generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// Core Entities (Company, Brand, User)
// ============================================

model Company {
  id        String   @id @default(uuid())
  name      String   @unique @db.VarChar(100)
  settings  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  brands           Brand[]
  categories       Category[]
  users            User[]
  locations        Location[]
  transactions     Transaction[]
  securityEvents   SecurityEvent[]
  defectThresholds DefectThreshold[]
  alertConfig      AlertConfig?
  forecastConfig   ForecastConfig?

  // Multi-company relations
  userCompanies UserCompany[] @relation("UserCompanies")
  components    Component[]   @relation("CompanyComponents")
  skus          SKU[]         @relation("CompanySKUs")

  // [V2-DEFERRED] Shopify integration relations
  shopifyConnection  ShopifyConnection?
  skuChannelMappings SkuChannelMapping[]
}

enum LocationType {
  warehouse
  threepl
  fba
  finished_goods
}

model Location {
  id        String       @id @default(uuid())
  companyId String
  company   Company      @relation(fields: [companyId], references: [id])
  name      String       @db.VarChar(100)
  type      LocationType @default(warehouse)
  isDefault Boolean      @default(false)
  isActive  Boolean      @default(true)
  notes     String?      @db.Text
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  transactions       Transaction[]       @relation("TransactionLocation")
  transfersFrom      Transaction[]       @relation("TransferFrom")
  transfersTo        Transaction[]       @relation("TransferTo")
  finishedGoodsLines FinishedGoodsLine[] @relation("FinishedGoodsAtLocation")

  @@unique([companyId, name])
  @@index([companyId, isActive])
}

model Brand {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  name      String   @db.VarChar(100)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  components Component[]
  skus       SKU[]

  @@unique([companyId, name])
  @@index([companyId, isActive])
}

model Category {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  name      String   @db.VarChar(50)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, name])
  @@index([companyId, isActive])
}

enum UserRole {
  admin
  ops
  viewer
}

model User {
  id           String    @id @default(uuid())
  companyId    String
  company      Company   @relation(fields: [companyId], references: [id])
  email        String    @unique @db.VarChar(255)
  passwordHash String    @db.VarChar(255)
  name         String    @db.VarChar(100)
  role         UserRole  @default(ops)
  isActive     Boolean   @default(true)
  lastLoginAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Audit relations
  componentsCreated Component[]     @relation("ComponentCreatedBy")
  componentsUpdated Component[]     @relation("ComponentUpdatedBy")
  skusCreated       SKU[]           @relation("SKUCreatedBy")
  skusUpdated       SKU[]           @relation("SKUUpdatedBy")
  bomVersions       BOMVersion[]
  transactions      Transaction[]
  securityEvents    SecurityEvent[]

  // Defect alert relations
  thresholdsCreated  DefectThreshold[] @relation("ThresholdCreatedBy")
  alertsAcknowledged DefectAlert[]     @relation("AlertAcknowledgedBy")

  // Draft transaction review relation
  transactionsReviewed Transaction[] @relation("TransactionReviewedBy")

  // Multi-company assignment
  userCompanies UserCompany[]

  // Feedback relations
  feedbacks Feedback[]

  @@index([companyId, isActive])
}

model UserCompany {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  companyId  String
  company    Company  @relation("UserCompanies", fields: [companyId], references: [id], onDelete: Cascade)
  role       UserRole @default(ops)
  assignedAt DateTime @default(now())

  @@unique([userId, companyId])
  @@index([userId])
  @@index([companyId])
}

model SecurityEvent {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  eventType String   @db.VarChar(50)
  ipAddress String?  @db.VarChar(45)
  userAgent String?  @db.VarChar(500)
  details   Json     @default("{}")
  createdAt DateTime @default(now())

  @@index([companyId, createdAt(sort: Desc)])
  @@index([userId])
}

// ============================================
// Inventory Entities (Component, Transaction)
// ============================================

model Component {
  id            String   @id @default(uuid())
  brandId       String
  brand         Brand    @relation(fields: [brandId], references: [id])
  companyId     String?
  company       Company? @relation("CompanyComponents", fields: [companyId], references: [id])
  name          String   @db.VarChar(100)
  skuCode       String   @db.VarChar(50)
  category      String?  @db.VarChar(50)
  unitOfMeasure String   @default("each") @db.VarChar(20)
  costPerUnit   Decimal  @default(0) @db.Decimal(10, 4)
  reorderPoint  Int      @default(0)
  leadTimeDays  Int      @default(0)
  notes         String?  @db.Text
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdById   String
  createdBy     User     @relation("ComponentCreatedBy", fields: [createdById], references: [id])
  updatedById   String
  updatedBy     User     @relation("ComponentUpdatedBy", fields: [updatedById], references: [id])

  bomLines         BOMLine[]
  transactionLines TransactionLine[]
  alertState       ComponentAlertState?
  lots             Lot[]

  @@unique([brandId, name])
  @@unique([brandId, skuCode])
  @@index([brandId, isActive])
  @@index([companyId, isActive])
}

model Lot {
  id               String    @id @default(uuid())
  componentId      String
  component        Component @relation(fields: [componentId], references: [id])
  lotNumber        String    @db.VarChar(100)
  expiryDate       DateTime? @db.Date
  receivedQuantity Decimal   @db.Decimal(10, 4)
  supplier         String?   @db.VarChar(100)
  notes            String?   @db.Text
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  balance          LotBalance?
  transactionLines TransactionLine[]

  @@unique([componentId, lotNumber])
  @@index([componentId])
  @@index([expiryDate])
}

model LotBalance {
  id               String  @id @default(uuid())
  lotId            String  @unique
  lot              Lot     @relation(fields: [lotId], references: [id])
  quantity         Decimal @db.Decimal(10, 4)
  reservedQuantity Decimal @default(0) @db.Decimal(10, 4)

  @@index([lotId])
}

enum TransactionType {
  receipt
  build
  adjustment
  initial
  transfer
  outbound
}

enum TransactionStatus {
  draft
  approved
  rejected
}

enum ShopifyOrderStatus {
  pending // Newly synced, awaiting review
  approved // Ready for transaction posting
  posted // Transaction created
  skipped // Manually skipped
  error // Processing error
}

model Transaction {
  id             String          @id @default(uuid())
  companyId      String
  company        Company         @relation(fields: [companyId], references: [id])
  type           TransactionType
  date           DateTime        @db.Date
  skuId          String?
  sku            SKU?            @relation(fields: [skuId], references: [id])
  bomVersionId   String?
  bomVersion     BOMVersion?     @relation(fields: [bomVersionId], references: [id])
  locationId     String?
  location       Location?       @relation("TransactionLocation", fields: [locationId], references: [id])
  fromLocationId String?
  fromLocation   Location?       @relation("TransferFrom", fields: [fromLocationId], references: [id])
  toLocationId   String?
  toLocation     Location?       @relation("TransferTo", fields: [toLocationId], references: [id])
  salesChannel   String?         @db.VarChar(50)
  unitsBuild     Int?
  unitBomCost    Decimal?        @db.Decimal(10, 4)
  totalBomCost   Decimal?        @db.Decimal(10, 4)
  supplier       String?         @db.VarChar(100)
  reason         String?         @db.VarChar(200)
  notes          String?         @db.Text
  defectCount    Int?
  defectNotes    String?         @db.Text
  affectedUnits  Int?
  createdAt      DateTime        @default(now())
  createdById    String
  createdBy      User            @relation(fields: [createdById], references: [id])

  // Draft workflow fields
  status         TransactionStatus @default(approved)
  reviewedAt     DateTime?
  reviewedById   String?
  reviewedBy     User?             @relation("TransactionReviewedBy", fields: [reviewedById], references: [id])
  rejectReason   String?           @db.VarChar(500)

  lines              TransactionLine[]
  finishedGoodsLines FinishedGoodsLine[] @relation("FinishedGoodsLines")
  defectAlerts       DefectAlert[]

  // Source tracking for automated transactions (e.g., from Shopify orders)
  sourceType    String? @db.VarChar(20) // "shopify", "manual", etc.
  sourceOrderId String? // Reference to ShopifyOrder.id

  @@index([companyId, createdAt(sort: Desc)])
  @@index([skuId])
  @@index([type])
  @@index([locationId])
  @@index([fromLocationId])
  @@index([toLocationId])
  @@index([sourceType, sourceOrderId])
  @@index([companyId, status])
}

model TransactionLine {
  id             String      @id @default(uuid())
  transactionId  String
  transaction    Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  componentId    String
  component      Component   @relation(fields: [componentId], references: [id])
  quantityChange Decimal     @db.Decimal(10, 4)
  costPerUnit    Decimal?    @db.Decimal(10, 4)
  lotId          String?
  lot            Lot?        @relation(fields: [lotId], references: [id])

  @@index([componentId])
  @@index([lotId])
}

model FinishedGoodsLine {
  id             String      @id @default(uuid())
  transactionId  String
  transaction    Transaction @relation("FinishedGoodsLines", fields: [transactionId], references: [id], onDelete: Cascade)
  skuId          String
  sku            SKU         @relation("FinishedGoodsLines", fields: [skuId], references: [id])
  quantityChange Decimal     @db.Decimal(10, 4)
  costPerUnit    Decimal?    @db.Decimal(10, 4)
  locationId     String
  location       Location    @relation("FinishedGoodsAtLocation", fields: [locationId], references: [id])

  @@index([skuId])
  @@index([locationId])
  @@index([transactionId])
}

// ============================================
// SKU & BOM Entities
// ============================================

model SKU {
  id           String   @id @default(uuid())
  brandId      String
  brand        Brand    @relation(fields: [brandId], references: [id])
  companyId    String?
  company      Company? @relation("CompanySKUs", fields: [companyId], references: [id])
  name         String   @db.VarChar(100)
  internalCode String   @db.VarChar(50)
  salesChannel String   @db.VarChar(50)
  externalIds  Json     @default("{}")
  notes        String?  @db.Text
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  createdById  String
  createdBy    User     @relation("SKUCreatedBy", fields: [createdById], references: [id])
  updatedById  String
  updatedBy    User     @relation("SKUUpdatedBy", fields: [updatedById], references: [id])

  bomVersions        BOMVersion[]
  transactions       Transaction[]
  defectThresholds   DefectThreshold[]
  defectAlerts       DefectAlert[]
  finishedGoodsLines FinishedGoodsLine[] @relation("FinishedGoodsLines")

  // Channel mapping relations
  channelMappings SkuChannelMapping[]

  @@unique([brandId, internalCode])
  @@index([brandId, isActive])
  @@index([companyId, isActive])
}

// Note: Partial unique index "one_active_bom_per_sku" enforces one active BOM per SKU
// Created via raw SQL migration (Prisma doesn't support partial unique indexes in schema)
model BOMVersion {
  id                 String    @id @default(uuid())
  skuId              String
  sku                SKU       @relation(fields: [skuId], references: [id])
  versionName        String    @db.VarChar(50)
  effectiveStartDate DateTime  @db.Date
  effectiveEndDate   DateTime? @db.Date
  isActive           Boolean   @default(false)
  notes              String?   @db.Text
  defectNotes        String?   @db.Text
  qualityMetadata    Json      @default("{}")
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  createdById        String
  createdBy          User      @relation(fields: [createdById], references: [id])

  lines        BOMLine[]
  transactions Transaction[]

  @@index([skuId, isActive])
}

model BOMLine {
  id              String     @id @default(uuid())
  bomVersionId    String
  bomVersion      BOMVersion @relation(fields: [bomVersionId], references: [id], onDelete: Cascade)
  componentId     String
  component       Component  @relation(fields: [componentId], references: [id])
  quantityPerUnit Decimal    @db.Decimal(10, 4)
  notes           String?    @db.Text

  @@unique([bomVersionId, componentId])
}

// ============================================
// Defect Threshold & Alert Entities
// ============================================

model DefectThreshold {
  id                String   @id @default(uuid())
  companyId         String
  company           Company  @relation(fields: [companyId], references: [id])
  skuId             String? // null = global threshold for company
  sku               SKU?     @relation(fields: [skuId], references: [id])
  defectRateLimit   Decimal  @db.Decimal(5, 2) // e.g., 5.00 = 5%
  affectedRateLimit Decimal? @db.Decimal(5, 2) // optional secondary threshold
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  createdById       String
  createdBy         User     @relation("ThresholdCreatedBy", fields: [createdById], references: [id])

  alerts DefectAlert[]

  @@unique([companyId, skuId])
  @@index([companyId, isActive])
}

model DefectAlert {
  id               String          @id @default(uuid())
  thresholdId      String
  threshold        DefectThreshold @relation(fields: [thresholdId], references: [id])
  transactionId    String
  transaction      Transaction     @relation(fields: [transactionId], references: [id])
  skuId            String
  sku              SKU             @relation(fields: [skuId], references: [id])
  defectRate       Decimal         @db.Decimal(5, 2)
  thresholdValue   Decimal         @db.Decimal(5, 2)
  severity         String          @db.VarChar(20) // 'warning' | 'critical'
  acknowledgedAt   DateTime?
  acknowledgedById String?
  acknowledgedBy   User?           @relation("AlertAcknowledgedBy", fields: [acknowledgedById], references: [id])
  createdAt        DateTime        @default(now())

  @@index([thresholdId, createdAt(sort: Desc)])
  @@index([skuId, createdAt(sort: Desc)])
  @@index([acknowledgedAt])
}

// ============================================
// Low-Stock Alert Configuration
// ============================================

model AlertConfig {
  id        String  @id @default(uuid())
  companyId String  @unique
  company   Company @relation(fields: [companyId], references: [id])

  // Channel configuration
  slackWebhookUrl String?  @db.VarChar(500)
  emailAddresses  String[] // PostgreSQL array type

  // Toggles
  enableSlack Boolean @default(false)
  enableEmail Boolean @default(false)

  // Throttle settings
  alertMode      String    @default("daily_digest") @db.VarChar(20) // 'daily_digest' | 'per_transition'
  lastDigestSent DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ComponentAlertState {
  id            String    @id @default(uuid())
  componentId   String    @unique
  component     Component @relation(fields: [componentId], references: [id], onDelete: Cascade)
  lastStatus    String    @db.VarChar(20) // 'ok' | 'warning' | 'critical'
  lastAlertSent DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ============================================
// Forecast Configuration
// ============================================

model ForecastConfig {
  id        String  @id @default(uuid())
  companyId String  @unique
  company   Company @relation(fields: [companyId], references: [id])

  // Forecast parameters
  lookbackDays             Int      @default(30)
  safetyDays               Int      @default(7)
  excludedTransactionTypes String[] @default(["initial", "adjustment"])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ============================================
// [V2-DEFERRED] Shopify Integration Entities
// These models are preserved for V2 but not actively used in V1.
// Do not remove - this avoids migration complexity.
// See /src/_deferred/shopify/ for related code.
// ============================================

model ShopifyConnection {
  id          String    @id @default(uuid())
  companyId   String
  company     Company   @relation(fields: [companyId], references: [id])
  shopName    String    @db.VarChar(100) // e.g., "mystore.myshopify.com"
  accessToken String    @db.VarChar(255) // encrypted API token
  isActive    Boolean   @default(true)
  lastSyncAt  DateTime?
  syncStatus  String?   @db.VarChar(50) // "idle", "syncing", "error"
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  orders ShopifyOrder[]

  @@unique([companyId]) // One connection per company initially
  @@index([companyId, isActive])
}

model ShopifyOrder {
  id                 String             @id @default(uuid())
  connectionId       String
  connection         ShopifyConnection  @relation(fields: [connectionId], references: [id])
  shopifyOrderId     String // Shopify's order ID
  shopifyOrderNumber String // Human-readable order number
  orderDate          DateTime
  fulfillmentStatus  String?            @db.VarChar(50)
  financialStatus    String?            @db.VarChar(50)
  status             ShopifyOrderStatus @default(pending)
  transactionId      String? // Link to created Transaction
  errorMessage       String?            @db.Text
  rawData            Json               @default("{}") // Store raw order JSON
  syncedAt           DateTime           @default(now())
  processedAt        DateTime?

  lines ShopifyOrderLine[]

  @@unique([connectionId, shopifyOrderId])
  @@index([connectionId, status])
  @@index([syncedAt])
}

model ShopifyOrderLine {
  id               String       @id @default(uuid())
  orderId          String
  order            ShopifyOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  shopifyLineId    String
  shopifyVariantId String? // May be null for custom items
  shopifySku       String?      @db.VarChar(100)
  title            String       @db.VarChar(255)
  quantity         Int
  price            Decimal      @db.Decimal(10, 2)
  mappedSkuId      String? // Internal SKU if mapped (not a FK - may be unmapped)
  mappingStatus    String       @default("unmapped") @db.VarChar(20) // "mapped", "unmapped", "not_found"

  @@index([orderId])
  @@index([shopifyVariantId])
}

model SkuChannelMapping {
  id          String   @id @default(uuid())
  companyId   String
  company     Company  @relation(fields: [companyId], references: [id])
  channelType String   @default("shopify") @db.VarChar(20) // Future: amazon, tiktok, etc.
  externalId  String   @db.VarChar(100) // Shopify variant ID
  externalSku String?  @db.VarChar(100) // Shopify SKU for reference
  skuId       String
  sku         SKU      @relation(fields: [skuId], references: [id])
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([companyId, channelType, externalId])
  @@index([companyId, channelType])
  @@index([skuId])
}

// ============================================
// Feedback Tracking
// ============================================

enum FeedbackStatus {
  pending      // Issue created, awaiting resolution
  in_progress  // Developer working on it
  resolved     // Issue closed, awaiting user verification
  verified     // User confirmed fix works
  reopened     // User requested changes, follow-up created
}

model Feedback {
  id                String         @id @default(uuid())
  userId            String
  user              User           @relation(fields: [userId], references: [id])
  type              String         @db.VarChar(20) // 'bug' | 'feature'
  description       String         @db.Text
  githubIssueNumber Int
  githubIssueUrl    String         @db.VarChar(500)
  status            FeedbackStatus @default(pending)
  emailMessageId    String?        @db.VarChar(255) // For tracking notification emails
  resolvedAt        DateTime?
  verifiedAt        DateTime?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  replies FeedbackReply[]

  @@index([userId])
  @@index([githubIssueNumber])
  @@index([status])
}

model FeedbackReply {
  id                  String   @id @default(uuid())
  feedbackId          String
  feedback            Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  emailMessageId      String?  @db.VarChar(255) // Email message ID for tracking
  content             String   @db.Text
  action              String   @db.VarChar(20) // 'verified' | 'changes_requested'
  followUpIssueNumber Int?     // If changes requested, the new issue number
  followUpIssueUrl    String?  @db.VarChar(500)
  createdAt           DateTime @default(now())

  @@index([feedbackId])
}
