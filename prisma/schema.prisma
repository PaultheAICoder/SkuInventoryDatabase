generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// Core Entities (Company, Brand, User)
// ============================================

model Company {
  id        String   @id @default(uuid())
  name      String   @unique @db.VarChar(100)
  settings  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  brands           Brand[]
  categories       Category[]
  locations        Location[]
  transactions     Transaction[]
  securityEvents   SecurityEvent[]
  defectThresholds DefectThreshold[]
  alertConfig      AlertConfig?
  forecastConfig   ForecastConfig?

  // Multi-company relations
  userCompanies UserCompany[] @relation("UserCompanies")
  components    Component[]   @relation("CompanyComponents")
  skus          SKU[]         @relation("CompanySKUs")

  // [V2-DEFERRED] Shopify integration relations
  shopifyConnection  ShopifyConnection?
  skuChannelMappings SkuChannelMapping[]

  // V2: Integration credentials and sync logs
  integrationCredentials IntegrationCredential[]
  syncLogs               SyncLog[]               @relation("CompanySyncLogs")
}

enum LocationType {
  warehouse
  threepl
  fba
  finished_goods
}

model Location {
  id        String       @id @default(uuid())
  companyId String
  company   Company      @relation(fields: [companyId], references: [id])
  name      String       @db.VarChar(100)
  type      LocationType @default(warehouse)
  isDefault Boolean      @default(false)
  isActive  Boolean      @default(true)
  notes     String?      @db.Text
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  transactions          Transaction[]          @relation("TransactionLocation")
  transfersFrom         Transaction[]          @relation("TransferFrom")
  transfersTo           Transaction[]          @relation("TransferTo")
  finishedGoodsLines    FinishedGoodsLine[]    @relation("FinishedGoodsAtLocation")
  inventoryBalances     InventoryBalance[]
  finishedGoodsBalances FinishedGoodsBalance[]

  @@unique([companyId, name])
  @@index([companyId, isActive])
}

model Brand {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  name      String   @db.VarChar(100)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  components Component[]
  skus       SKU[]

  // V2: Integration relations
  integrationCredentials IntegrationCredential[]
  salesDaily             SalesDaily[]
  asinSkuMappings        AsinSkuMapping[]

  @@unique([companyId, name])
  @@index([companyId, isActive])
}

model Category {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  name      String   @db.VarChar(50)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, name])
  @@index([companyId, isActive])
}

enum UserRole {
  admin
  ops
  viewer
}

model User {
  id           String    @id @default(uuid())
  email        String    @unique @db.VarChar(255)
  passwordHash String    @db.VarChar(255)
  name         String    @db.VarChar(100)
  role         UserRole  @default(ops)
  isActive     Boolean   @default(true)
  lastLoginAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Audit relations
  componentsCreated Component[]     @relation("ComponentCreatedBy")
  componentsUpdated Component[]     @relation("ComponentUpdatedBy")
  skusCreated       SKU[]           @relation("SKUCreatedBy")
  skusUpdated       SKU[]           @relation("SKUUpdatedBy")
  bomVersions       BOMVersion[]
  transactions      Transaction[]
  securityEvents    SecurityEvent[]

  // Defect alert relations
  thresholdsCreated  DefectThreshold[] @relation("ThresholdCreatedBy")
  alertsAcknowledged DefectAlert[]     @relation("AlertAcknowledgedBy")

  // Draft transaction review relation
  transactionsReviewed Transaction[] @relation("TransactionReviewedBy")

  // Soft delete audit relation
  transactionsDeleted  Transaction[] @relation("TransactionDeletedBy")

  // Multi-company assignment (SINGLE SOURCE OF TRUTH)
  userCompanies UserCompany[]

  // Feedback relation
  feedbacks Feedback[]

  // V2: Integration relations
  asinMappingsCreated AsinSkuMapping[] @relation("AsinMappingCreatedBy")
  syncLogsTriggered   SyncLog[]        @relation("SyncLogTriggeredBy")
  notifications       Notification[]
}

// Note: Partial unique index "one_primary_company_per_user" enforces one isPrimary=true per userId
// Created via raw SQL migration (Prisma doesn't support partial unique indexes in schema)
model UserCompany {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  companyId  String
  company    Company  @relation("UserCompanies", fields: [companyId], references: [id], onDelete: Cascade)
  role       UserRole @default(ops)
  isPrimary  Boolean  @default(false) // Designates user's default company (enforced by DB constraint)
  assignedAt DateTime @default(now())

  @@unique([userId, companyId])
  @@index([userId])
  @@index([companyId])
}

model SecurityEvent {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  eventType String   @db.VarChar(50)
  ipAddress String?  @db.VarChar(45)
  userAgent String?  @db.VarChar(500)
  details   Json     @default("{}")
  createdAt DateTime @default(now())

  @@index([companyId, createdAt(sort: Desc)])
  @@index([userId])
}

// ============================================
// Inventory Entities (Component, Transaction)
// ============================================

model Component {
  id            String   @id @default(uuid())
  brandId       String
  brand         Brand    @relation(fields: [brandId], references: [id])
  companyId     String
  company       Company  @relation("CompanyComponents", fields: [companyId], references: [id])
  name          String   @db.VarChar(100)
  skuCode       String   @db.VarChar(50)
  category      String?  @db.VarChar(50)
  unitOfMeasure String   @default("each") @db.VarChar(20)
  costPerUnit   Decimal  @default(0) @db.Decimal(10, 4)
  reorderPoint  Int      @default(0)
  leadTimeDays  Int      @default(0)
  notes         String?  @db.Text
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdById   String
  createdBy     User     @relation("ComponentCreatedBy", fields: [createdById], references: [id])
  updatedById   String
  updatedBy     User     @relation("ComponentUpdatedBy", fields: [updatedById], references: [id])

  bomLines          BOMLine[]
  transactionLines  TransactionLine[]
  alertState        ComponentAlertState?
  lots              Lot[]
  inventoryBalances InventoryBalance[]

  @@unique([brandId, name])
  @@unique([brandId, skuCode])
  @@index([brandId, isActive])
  @@index([companyId, isActive])
}

model InventoryBalance {
  id          String    @id @default(uuid())
  componentId String
  component   Component @relation(fields: [componentId], references: [id], onDelete: Cascade)
  locationId  String
  location    Location  @relation(fields: [locationId], references: [id])
  quantity    Decimal   @db.Decimal(10, 4)

  @@unique([componentId, locationId])
  @@index([componentId])
  @@index([locationId])
}

model Lot {
  id               String    @id @default(uuid())
  componentId      String
  component        Component @relation(fields: [componentId], references: [id])
  lotNumber        String    @db.VarChar(100)
  expiryDate       DateTime? @db.Date
  receivedQuantity Decimal   @db.Decimal(10, 4)
  supplier         String?   @db.VarChar(100)
  notes            String?   @db.Text
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  balance          LotBalance?
  transactionLines TransactionLine[]

  @@unique([componentId, lotNumber])
  @@index([componentId])
  @@index([expiryDate])
}

model LotBalance {
  id               String  @id @default(uuid())
  lotId            String  @unique
  lot              Lot     @relation(fields: [lotId], references: [id])
  quantity         Decimal @db.Decimal(10, 4)
  reservedQuantity Decimal @default(0) @db.Decimal(10, 4)

  @@index([lotId])
}

enum TransactionType {
  receipt
  build
  adjustment
  initial
  transfer
  outbound
}

enum TransactionStatus {
  draft
  approved
  rejected
}

enum ShopifyOrderStatus {
  pending // Newly synced, awaiting review
  approved // Ready for transaction posting
  posted // Transaction created
  skipped // Manually skipped
  error // Processing error
}

model Transaction {
  id             String          @id @default(uuid())
  companyId      String
  company        Company         @relation(fields: [companyId], references: [id])
  type           TransactionType
  date           DateTime        @db.Date
  skuId          String?
  sku            SKU?            @relation(fields: [skuId], references: [id])
  bomVersionId   String?
  bomVersion     BOMVersion?     @relation(fields: [bomVersionId], references: [id])
  locationId     String?
  location       Location?       @relation("TransactionLocation", fields: [locationId], references: [id])
  fromLocationId String?
  fromLocation   Location?       @relation("TransferFrom", fields: [fromLocationId], references: [id])
  toLocationId   String?
  toLocation     Location?       @relation("TransferTo", fields: [toLocationId], references: [id])
  salesChannel   String?         @db.VarChar(50)
  unitsBuild     Int?
  unitBomCost    Decimal?        @db.Decimal(10, 4)
  totalBomCost   Decimal?        @db.Decimal(10, 4)
  supplier       String?         @db.VarChar(100)
  reason         String?         @db.VarChar(200)
  notes          String?         @db.Text
  defectCount    Int?
  defectNotes    String?         @db.Text
  affectedUnits  Int?
  createdAt      DateTime        @default(now())
  createdById    String
  createdBy      User            @relation(fields: [createdById], references: [id])

  // Draft workflow fields
  status       TransactionStatus @default(approved)
  reviewedAt   DateTime?
  reviewedById String?
  reviewedBy   User?             @relation("TransactionReviewedBy", fields: [reviewedById], references: [id])
  rejectReason String?           @db.VarChar(500)

  // BOM snapshot for draft build transactions (frozen at draft creation)
  bomSnapshot Json?

  // Soft delete fields for audit trail
  deletedAt    DateTime?
  deletedById  String?
  deletedBy    User?             @relation("TransactionDeletedBy", fields: [deletedById], references: [id])

  lines              TransactionLine[]
  finishedGoodsLines FinishedGoodsLine[] @relation("FinishedGoodsLines")
  defectAlerts       DefectAlert[]

  // Source tracking for automated transactions (e.g., from Shopify orders)
  sourceType    String? @db.VarChar(20) // "shopify", "manual", etc.
  sourceOrderId String? // Reference to ShopifyOrder.id

  @@index([companyId, createdAt(sort: Desc)])
  @@index([skuId])
  @@index([type])
  @@index([locationId])
  @@index([fromLocationId])
  @@index([toLocationId])
  @@index([sourceType, sourceOrderId])
  @@index([companyId, status])
  @@index([companyId, status, deletedAt])
}

model TransactionLine {
  id             String      @id @default(uuid())
  transactionId  String
  transaction    Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  componentId    String
  component      Component   @relation(fields: [componentId], references: [id])
  quantityChange Decimal     @db.Decimal(10, 4)
  costPerUnit    Decimal?    @db.Decimal(10, 4)
  lotId          String?
  lot            Lot?        @relation(fields: [lotId], references: [id])

  @@index([componentId])
  @@index([lotId])
}

model FinishedGoodsLine {
  id             String      @id @default(uuid())
  transactionId  String
  transaction    Transaction @relation("FinishedGoodsLines", fields: [transactionId], references: [id], onDelete: Cascade)
  skuId          String
  sku            SKU         @relation("FinishedGoodsLines", fields: [skuId], references: [id])
  quantityChange Decimal     @db.Decimal(10, 4)
  costPerUnit    Decimal?    @db.Decimal(10, 4)
  locationId     String
  location       Location    @relation("FinishedGoodsAtLocation", fields: [locationId], references: [id])

  @@index([skuId])
  @@index([locationId])
  @@index([transactionId])
}

// ============================================
// SKU & BOM Entities
// ============================================

model SKU {
  id           String   @id @default(uuid())
  brandId      String
  brand        Brand    @relation(fields: [brandId], references: [id])
  companyId    String?
  company      Company? @relation("CompanySKUs", fields: [companyId], references: [id])
  name         String   @db.VarChar(100)
  internalCode String   @db.VarChar(50)
  salesChannel String   @db.VarChar(50)
  externalIds  Json     @default("{}")
  notes        String?  @db.Text
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  createdById  String
  createdBy    User     @relation("SKUCreatedBy", fields: [createdById], references: [id])
  updatedById  String
  updatedBy    User     @relation("SKUUpdatedBy", fields: [updatedById], references: [id])

  bomVersions           BOMVersion[]
  transactions          Transaction[]
  defectThresholds      DefectThreshold[]
  defectAlerts          DefectAlert[]
  finishedGoodsLines    FinishedGoodsLine[]    @relation("FinishedGoodsLines")
  finishedGoodsBalances FinishedGoodsBalance[]

  // Channel mapping relations
  channelMappings SkuChannelMapping[]

  // V2: ASIN mapping relation
  asinMappings AsinSkuMapping[]

  @@unique([brandId, internalCode])
  @@index([brandId, isActive])
  @@index([companyId, isActive])
}

model FinishedGoodsBalance {
  id         String   @id @default(uuid())
  skuId      String
  sku        SKU      @relation(fields: [skuId], references: [id], onDelete: Cascade)
  locationId String
  location   Location @relation(fields: [locationId], references: [id])
  quantity   Decimal  @db.Decimal(10, 4)

  @@unique([skuId, locationId])
  @@index([skuId])
  @@index([locationId])
}

// Note: Partial unique index "one_active_bom_per_sku" enforces one active BOM per SKU
// Created via raw SQL migration (Prisma doesn't support partial unique indexes in schema)
model BOMVersion {
  id                 String    @id @default(uuid())
  skuId              String
  sku                SKU       @relation(fields: [skuId], references: [id])
  versionName        String    @db.VarChar(50)
  effectiveStartDate DateTime  @db.Date
  effectiveEndDate   DateTime? @db.Date
  isActive           Boolean   @default(false)
  notes              String?   @db.Text
  defectNotes        String?   @db.Text
  qualityMetadata    Json      @default("{}")
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  createdById        String
  createdBy          User      @relation(fields: [createdById], references: [id])

  lines        BOMLine[]
  transactions Transaction[]

  @@index([skuId, isActive])
}

model BOMLine {
  id              String     @id @default(uuid())
  bomVersionId    String
  bomVersion      BOMVersion @relation(fields: [bomVersionId], references: [id], onDelete: Cascade)
  componentId     String
  component       Component  @relation(fields: [componentId], references: [id])
  quantityPerUnit Decimal    @db.Decimal(10, 4)
  notes           String?    @db.Text

  @@unique([bomVersionId, componentId])
}

// ============================================
// Defect Threshold & Alert Entities
// ============================================

model DefectThreshold {
  id                String   @id @default(uuid())
  companyId         String
  company           Company  @relation(fields: [companyId], references: [id])
  skuId             String? // null = global threshold for company
  sku               SKU?     @relation(fields: [skuId], references: [id])
  defectRateLimit   Decimal  @db.Decimal(5, 2) // e.g., 5.00 = 5%
  affectedRateLimit Decimal? @db.Decimal(5, 2) // optional secondary threshold
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  createdById       String
  createdBy         User     @relation("ThresholdCreatedBy", fields: [createdById], references: [id])

  alerts DefectAlert[]

  @@unique([companyId, skuId])
  @@index([companyId, isActive])
}

model DefectAlert {
  id               String          @id @default(uuid())
  thresholdId      String
  threshold        DefectThreshold @relation(fields: [thresholdId], references: [id])
  transactionId    String
  transaction      Transaction     @relation(fields: [transactionId], references: [id])
  skuId            String
  sku              SKU             @relation(fields: [skuId], references: [id])
  defectRate       Decimal         @db.Decimal(5, 2)
  thresholdValue   Decimal         @db.Decimal(5, 2)
  severity         String          @db.VarChar(20) // 'warning' | 'critical'
  acknowledgedAt   DateTime?
  acknowledgedById String?
  acknowledgedBy   User?           @relation("AlertAcknowledgedBy", fields: [acknowledgedById], references: [id])
  createdAt        DateTime        @default(now())

  @@index([thresholdId, createdAt(sort: Desc)])
  @@index([skuId, createdAt(sort: Desc)])
  @@index([acknowledgedAt])
}

// ============================================
// Low-Stock Alert Configuration
// ============================================

model AlertConfig {
  id        String  @id @default(uuid())
  companyId String  @unique
  company   Company @relation(fields: [companyId], references: [id])

  // Channel configuration
  slackWebhookUrl String?  @db.VarChar(500)
  emailAddresses  String[] // PostgreSQL array type

  // Toggles
  enableSlack Boolean @default(false)
  enableEmail Boolean @default(false)

  // Throttle settings
  alertMode      String    @default("daily_digest") @db.VarChar(20) // 'daily_digest' | 'per_transition'
  lastDigestSent DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ComponentAlertState {
  id            String    @id @default(uuid())
  componentId   String    @unique
  component     Component @relation(fields: [componentId], references: [id], onDelete: Cascade)
  lastStatus    String    @db.VarChar(20) // 'ok' | 'warning' | 'critical'
  lastAlertSent DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ============================================
// Forecast Configuration
// ============================================

model ForecastConfig {
  id        String  @id @default(uuid())
  companyId String  @unique
  company   Company @relation(fields: [companyId], references: [id])

  // Forecast parameters
  lookbackDays             Int      @default(30)
  safetyDays               Int      @default(7)
  excludedTransactionTypes String[] @default(["initial", "adjustment"])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ============================================
// [V2-DEFERRED] Shopify Integration Entities
// These models are preserved for V2 but not actively used in V1.
// Do not remove - this avoids migration complexity.
// See /src/_deferred/shopify/ for related code.
// ============================================

model ShopifyConnection {
  id          String    @id @default(uuid())
  companyId   String
  company     Company   @relation(fields: [companyId], references: [id])
  shopName    String    @db.VarChar(100) // e.g., "mystore.myshopify.com"
  accessToken String    @db.VarChar(255) // encrypted API token
  isActive    Boolean   @default(true)
  lastSyncAt  DateTime?
  syncStatus  String?   @db.VarChar(50) // "idle", "syncing", "error"
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  orders ShopifyOrder[]

  @@unique([companyId]) // One connection per company initially
  @@index([companyId, isActive])
}

model ShopifyOrder {
  id                 String             @id @default(uuid())
  connectionId       String
  connection         ShopifyConnection  @relation(fields: [connectionId], references: [id])
  shopifyOrderId     String // Shopify's order ID
  shopifyOrderNumber String // Human-readable order number
  orderDate          DateTime
  fulfillmentStatus  String?            @db.VarChar(50)
  financialStatus    String?            @db.VarChar(50)
  status             ShopifyOrderStatus @default(pending)
  transactionId      String? // Link to created Transaction
  errorMessage       String?            @db.Text
  rawData            Json               @default("{}") // Store raw order JSON
  syncedAt           DateTime           @default(now())
  processedAt        DateTime?

  lines ShopifyOrderLine[]

  @@unique([connectionId, shopifyOrderId])
  @@index([connectionId, status])
  @@index([syncedAt])
}

model ShopifyOrderLine {
  id               String       @id @default(uuid())
  orderId          String
  order            ShopifyOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  shopifyLineId    String
  shopifyVariantId String? // May be null for custom items
  shopifySku       String?      @db.VarChar(100)
  title            String       @db.VarChar(255)
  quantity         Int
  price            Decimal      @db.Decimal(10, 2)
  mappedSkuId      String? // Internal SKU if mapped (not a FK - may be unmapped)
  mappingStatus    String       @default("unmapped") @db.VarChar(20) // "mapped", "unmapped", "not_found"

  @@index([orderId])
  @@index([shopifyVariantId])
}

model SkuChannelMapping {
  id          String   @id @default(uuid())
  companyId   String
  company     Company  @relation(fields: [companyId], references: [id])
  channelType String   @default("shopify") @db.VarChar(20) // Future: amazon, tiktok, etc.
  externalId  String   @db.VarChar(100) // Shopify variant ID
  externalSku String?  @db.VarChar(100) // Shopify SKU for reference
  skuId       String
  sku         SKU      @relation(fields: [skuId], references: [id])
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([companyId, channelType, externalId])
  @@index([companyId, channelType])
  @@index([skuId])
}

// ============================================
// Feedback Tracking Entities
// ============================================

enum FeedbackStatus {
  pending // Issue created
  resolved // Issue closed, notification sent
  clarification_requested // Clarification questions sent to user
  verified // User confirmed fix
  changes_requested // User needs more work
}

model Feedback {
  id        String @id @default(uuid())
  userId    String
  user      User   @relation(fields: [userId], references: [id])
  projectId String @default("SkuInventoryDatabase") @db.VarChar(100)

  // GitHub link
  githubIssueNumber Int    @unique
  githubIssueUrl    String @db.VarChar(500)

  // Status tracking
  status FeedbackStatus @default(pending)

  // Notification tracking
  notificationSentAt    DateTime?
  notificationMessageId String?   @db.VarChar(255)

  // Response tracking
  responseReceivedAt  DateTime?
  responseEmailId     String?   @db.VarChar(255)
  responseContent     String?   @db.Text
  followUpIssueNumber Int?
  followUpIssueUrl    String?   @db.VarChar(500)

  // Clarification tracking
  clarificationSentAt    DateTime?
  clarificationMessageId String?   @db.VarChar(255)
  clarificationQuestions String?   @db.Text // JSON array of questions
  clarificationAnswers   String?   @db.Text // User's response text
  clarificationContext   String?   @db.Text // JSON: completion report summary, files changed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([githubIssueNumber])
  @@index([userId])
}

model EmailMonitorState {
  id            String   @id @default("singleton")
  lastCheckTime DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// ============================================
// V2: Amazon Ads Integration Entities
// ============================================

model IntegrationCredential {
  id              String  @id @default(uuid())
  companyId       String
  company         Company @relation(fields: [companyId], references: [id])
  brandId         String?
  brand           Brand?  @relation(fields: [brandId], references: [id])
  integrationType String  @db.VarChar(50) // "amazon_ads", "shopify", etc.

  // Encrypted credentials (format: iv:encrypted:authTag)
  encryptedAccessToken  String  @db.Text
  encryptedRefreshToken String? @db.Text

  // OAuth metadata
  scopes    String[] // PostgreSQL array
  expiresAt DateTime?

  // Connection status
  status      String    @default("active") @db.VarChar(20) // "active", "expired", "revoked", "error"
  lastUsedAt  DateTime?
  lastErrorAt DateTime?
  lastError   String?   @db.Text

  // External account info
  externalAccountId   String? @db.VarChar(100)
  externalAccountName String? @db.VarChar(200)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  adPortfolios AdPortfolio[]
  syncLogs     SyncLog[]

  @@unique([companyId, brandId, integrationType])
  @@index([companyId, integrationType])
  @@index([status])
}

model AdPortfolio {
  id           String                @id @default(uuid())
  credentialId String
  credential   IntegrationCredential @relation(fields: [credentialId], references: [id])

  externalId String @db.VarChar(100) // Amazon portfolio ID
  name       String @db.VarChar(200)
  state      String @default("enabled") @db.VarChar(20) // "enabled", "paused", "archived"

  // Budget info (optional)
  budgetAmount       Decimal? @db.Decimal(10, 2)
  budgetCurrencyCode String?  @db.VarChar(3) // "USD"
  budgetPolicy       String?  @db.VarChar(20) // "dateRange", "monthlyRecurring"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  campaigns      AdCampaign[]
  keywordMetrics KeywordMetric[]

  @@unique([credentialId, externalId])
  @@index([credentialId])
}

model AdCampaign {
  id           String       @id @default(uuid())
  portfolioId  String?
  portfolio    AdPortfolio? @relation(fields: [portfolioId], references: [id])
  credentialId String // Denormalized for queries without portfolio

  externalId    String  @db.VarChar(100) // Amazon campaign ID
  name          String  @db.VarChar(200)
  campaignType  String  @db.VarChar(50) // "sponsoredProducts", "sponsoredBrands", "sponsoredDisplay"
  targetingType String? @db.VarChar(50) // "manual", "auto"
  state         String  @default("enabled") @db.VarChar(20)

  // Budget
  dailyBudget Decimal? @db.Decimal(10, 2)

  // Dates
  startDate DateTime? @db.Date
  endDate   DateTime? @db.Date

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  adGroups       AdGroup[]
  keywordMetrics KeywordMetric[]

  @@unique([credentialId, externalId])
  @@index([portfolioId])
  @@index([credentialId])
}

model AdGroup {
  id         String     @id @default(uuid())
  campaignId String
  campaign   AdCampaign @relation(fields: [campaignId], references: [id])

  externalId String   @db.VarChar(100) // Amazon ad group ID
  name       String   @db.VarChar(200)
  state      String   @default("enabled") @db.VarChar(20)
  defaultBid Decimal? @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  keywordMetrics KeywordMetric[]

  @@unique([campaignId, externalId])
  @@index([campaignId])
}

model KeywordMetric {
  id String @id @default(uuid())

  // Hierarchy (nullable for CSV imports without full context)
  portfolioId String?
  portfolio   AdPortfolio? @relation(fields: [portfolioId], references: [id])
  campaignId  String?
  campaign    AdCampaign?  @relation(fields: [campaignId], references: [id])
  adGroupId   String?
  adGroup     AdGroup?     @relation(fields: [adGroupId], references: [id])

  // Keyword identification
  keyword   String @db.VarChar(500)
  matchType String @db.VarChar(20) // "exact", "phrase", "broad", "auto"

  // Time dimension
  date DateTime @db.Date

  // Performance metrics
  impressions    Int      @default(0)
  clicks         Int      @default(0)
  ctr            Decimal? @db.Decimal(8, 4) // Click-through rate
  spend          Decimal  @default(0) @db.Decimal(10, 2)
  cpc            Decimal? @db.Decimal(10, 2) // Cost per click
  orders         Int      @default(0)
  sales          Decimal  @default(0) @db.Decimal(10, 2)
  roas           Decimal? @db.Decimal(10, 2) // Return on ad spend
  conversionRate Decimal? @db.Decimal(8, 4)
  acos           Decimal? @db.Decimal(8, 4) // Advertising cost of sales

  // Source tracking
  source         String  @db.VarChar(50) // "api", "csv_amazon", "csv_zonguru", "csv_helium10"
  sourceFileName String? @db.VarChar(255)

  // Extra data from CSV (for columns we don't have dedicated fields for)
  metadata Json @default("{}")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([portfolioId, campaignId, adGroupId, keyword, matchType, date, source])
  @@index([portfolioId, date])
  @@index([campaignId, date])
  @@index([keyword])
  @@index([date])
}

model SalesDaily {
  id      String @id @default(uuid())
  brandId String
  brand   Brand  @relation(fields: [brandId], references: [id])

  // Product identification
  asin  String? @db.VarChar(20) // Amazon ASIN
  skuId String? // FK to internal SKU (via AsinSkuMapping)

  // Time dimension
  date DateTime @db.Date

  // Sales breakdown
  totalSales        Decimal @db.Decimal(10, 2)
  adAttributedSales Decimal @db.Decimal(10, 2)
  organicSales      Decimal @db.Decimal(10, 2) // Calculated: total - adAttributed

  // Source channel
  channel String @db.VarChar(50) // "amazon", "shopify"

  // Metadata
  unitsTotal        Int?
  unitsAdAttributed Int?
  unitsOrganic      Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([brandId, asin, date, channel])
  @@index([brandId, date])
  @@index([asin])
  @@index([date])
}

model AsinSkuMapping {
  id      String @id @default(uuid())
  brandId String
  brand   Brand  @relation(fields: [brandId], references: [id])

  asin  String @db.VarChar(20)
  skuId String
  sku   SKU    @relation(fields: [skuId], references: [id])

  // Optional metadata
  productName String? @db.VarChar(500) // Amazon product name for reference

  createdAt   DateTime @default(now())
  createdById String
  createdBy   User     @relation("AsinMappingCreatedBy", fields: [createdById], references: [id])

  @@unique([brandId, asin])
  @@index([brandId])
  @@index([skuId])
}

model SyncLog {
  id           String                 @id @default(uuid())
  credentialId String?
  credential   IntegrationCredential? @relation(fields: [credentialId], references: [id])
  companyId    String?
  company      Company?               @relation("CompanySyncLogs", fields: [companyId], references: [id])

  integrationType String @db.VarChar(50) // "amazon_ads", "shopify", "csv_amazon", "csv_zonguru", "csv_helium10"
  syncType        String @db.VarChar(50) // "full", "incremental", "manual"
  status          String @db.VarChar(20) // "running", "completed", "failed", "partial"

  startedAt   DateTime  @default(now())
  completedAt DateTime?
  initiatedBy String? // userId who triggered the sync

  // Metrics
  recordsProcessed Int @default(0)
  recordsCreated   Int @default(0)
  recordsUpdated   Int @default(0)
  recordsDeleted   Int @default(0)
  recordsFailed    Int @default(0)

  // Error details
  errorMessage String? @db.Text
  errorDetails Json    @default("{}")

  // For file uploads (CSV/XLSX)
  fileName String? @db.VarChar(255)
  fileSize Int? // bytes
  metadata Json    @default("{}") // Additional context (dateRange, brandId, etc.)

  triggeredById String?
  triggeredBy   User?   @relation("SyncLogTriggeredBy", fields: [triggeredById], references: [id])

  @@index([credentialId, startedAt(sort: Desc)])
  @@index([companyId, startedAt(sort: Desc)])
  @@index([integrationType, status])
  @@index([syncType, status])
  @@index([startedAt(sort: Desc)])
}

model Notification {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  type    String @db.VarChar(50) // "sync_failure", "credential_expired", "info"
  title   String @db.VarChar(200)
  message String @db.Text

  // Link to related entity
  relatedType String? @db.VarChar(50) // "sync_log", "credential"
  relatedId   String?

  read        Boolean   @default(false)
  readAt      DateTime?
  dismissedAt DateTime?

  createdAt DateTime @default(now())

  @@index([userId, read])
  @@index([userId, createdAt(sort: Desc)])
}
