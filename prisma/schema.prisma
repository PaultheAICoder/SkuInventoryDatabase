generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// Core Entities (Company, Brand, User)
// ============================================

model Company {
  id        String   @id @default(uuid())
  name      String   @unique @db.VarChar(100)
  settings  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  brands           Brand[]
  users            User[]
  locations        Location[]
  transactions     Transaction[]
  securityEvents   SecurityEvent[]
  defectThresholds DefectThreshold[]
  alertConfig      AlertConfig?

  // Multi-company relations
  userCompanies    UserCompany[] @relation("UserCompanies")
  components       Component[] @relation("CompanyComponents")
  skus             SKU[] @relation("CompanySKUs")
}

enum LocationType {
  warehouse
  threepl
  fba
  finished_goods
}

model Location {
  id        String       @id @default(uuid())
  companyId String
  company   Company      @relation(fields: [companyId], references: [id])
  name      String       @db.VarChar(100)
  type      LocationType @default(warehouse)
  isDefault Boolean      @default(false)
  isActive  Boolean      @default(true)
  notes     String?      @db.Text
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  transactions Transaction[]

  @@unique([companyId, name])
  @@index([companyId, isActive])
}

model Brand {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  name      String   @db.VarChar(100)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  components Component[]
  skus       SKU[]

  @@unique([companyId, name])
  @@index([companyId, isActive])
}

enum UserRole {
  admin
  ops
  viewer
}

model User {
  id           String    @id @default(uuid())
  companyId    String
  company      Company   @relation(fields: [companyId], references: [id])
  email        String    @unique @db.VarChar(255)
  passwordHash String    @db.VarChar(255)
  name         String    @db.VarChar(100)
  role         UserRole  @default(ops)
  isActive     Boolean   @default(true)
  lastLoginAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Audit relations
  componentsCreated Component[]     @relation("ComponentCreatedBy")
  componentsUpdated Component[]     @relation("ComponentUpdatedBy")
  skusCreated       SKU[]           @relation("SKUCreatedBy")
  skusUpdated       SKU[]           @relation("SKUUpdatedBy")
  bomVersions       BOMVersion[]
  transactions      Transaction[]
  securityEvents    SecurityEvent[]

  // Defect alert relations
  thresholdsCreated  DefectThreshold[] @relation("ThresholdCreatedBy")
  alertsAcknowledged DefectAlert[]     @relation("AlertAcknowledgedBy")

  // Multi-company assignment
  userCompanies     UserCompany[]

  @@index([companyId, isActive])
}

model UserCompany {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  companyId  String
  company    Company  @relation("UserCompanies", fields: [companyId], references: [id], onDelete: Cascade)
  role       UserRole @default(ops)
  assignedAt DateTime @default(now())

  @@unique([userId, companyId])
  @@index([userId])
  @@index([companyId])
}

model SecurityEvent {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  eventType String   @db.VarChar(50)
  ipAddress String?  @db.VarChar(45)
  userAgent String?  @db.VarChar(500)
  details   Json     @default("{}")
  createdAt DateTime @default(now())

  @@index([companyId, createdAt(sort: Desc)])
  @@index([userId])
}

// ============================================
// Inventory Entities (Component, Transaction)
// ============================================

model Component {
  id            String   @id @default(uuid())
  brandId       String
  brand         Brand    @relation(fields: [brandId], references: [id])
  companyId     String?
  company       Company?  @relation("CompanyComponents", fields: [companyId], references: [id])
  name          String   @db.VarChar(100)
  skuCode       String   @db.VarChar(50)
  category      String?  @db.VarChar(50)
  unitOfMeasure String   @default("each") @db.VarChar(20)
  costPerUnit   Decimal  @default(0) @db.Decimal(10, 4)
  reorderPoint  Int      @default(0)
  leadTimeDays  Int      @default(0)
  notes         String?  @db.Text
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  createdById   String
  createdBy     User     @relation("ComponentCreatedBy", fields: [createdById], references: [id])
  updatedById   String
  updatedBy     User     @relation("ComponentUpdatedBy", fields: [updatedById], references: [id])

  bomLines         BOMLine[]
  transactionLines TransactionLine[]
  alertState       ComponentAlertState?

  @@unique([brandId, name])
  @@unique([brandId, skuCode])
  @@index([brandId, isActive])
  @@index([companyId, isActive])
}

enum TransactionType {
  receipt
  build
  adjustment
  initial
}

model Transaction {
  id            String          @id @default(uuid())
  companyId     String
  company       Company         @relation(fields: [companyId], references: [id])
  type          TransactionType
  date          DateTime        @db.Date
  skuId         String?
  sku           SKU?            @relation(fields: [skuId], references: [id])
  bomVersionId  String?
  bomVersion    BOMVersion?     @relation(fields: [bomVersionId], references: [id])
  locationId    String?
  location      Location?       @relation(fields: [locationId], references: [id])
  salesChannel  String?         @db.VarChar(50)
  unitsBuild    Int?
  unitBomCost   Decimal?        @db.Decimal(10, 4)
  totalBomCost  Decimal?        @db.Decimal(10, 4)
  supplier      String?         @db.VarChar(100)
  reason        String?         @db.VarChar(200)
  notes         String?         @db.Text
  defectCount   Int?
  defectNotes   String?         @db.Text
  affectedUnits Int?
  createdAt     DateTime        @default(now())
  createdById   String
  createdBy     User            @relation(fields: [createdById], references: [id])

  lines        TransactionLine[]
  defectAlerts DefectAlert[]

  @@index([companyId, createdAt(sort: Desc)])
  @@index([skuId])
  @@index([type])
  @@index([locationId])
}

model TransactionLine {
  id             String      @id @default(uuid())
  transactionId  String
  transaction    Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  componentId    String
  component      Component   @relation(fields: [componentId], references: [id])
  quantityChange Decimal     @db.Decimal(10, 4)
  costPerUnit    Decimal?    @db.Decimal(10, 4)

  @@index([componentId])
}

// ============================================
// SKU & BOM Entities
// ============================================

model SKU {
  id           String   @id @default(uuid())
  brandId      String
  brand        Brand    @relation(fields: [brandId], references: [id])
  companyId    String?
  company      Company?  @relation("CompanySKUs", fields: [companyId], references: [id])
  name         String   @db.VarChar(100)
  internalCode String   @db.VarChar(50)
  salesChannel String   @db.VarChar(50)
  externalIds  Json     @default("{}")
  notes        String?  @db.Text
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  createdById  String
  createdBy    User     @relation("SKUCreatedBy", fields: [createdById], references: [id])
  updatedById  String
  updatedBy    User     @relation("SKUUpdatedBy", fields: [updatedById], references: [id])

  bomVersions      BOMVersion[]
  transactions     Transaction[]
  defectThresholds DefectThreshold[]
  defectAlerts     DefectAlert[]

  @@unique([brandId, internalCode])
  @@index([brandId, isActive])
  @@index([companyId, isActive])
}

model BOMVersion {
  id                 String    @id @default(uuid())
  skuId              String
  sku                SKU       @relation(fields: [skuId], references: [id])
  versionName        String    @db.VarChar(50)
  effectiveStartDate DateTime  @db.Date
  effectiveEndDate   DateTime? @db.Date
  isActive           Boolean   @default(false)
  notes              String?   @db.Text
  defectNotes        String?   @db.Text
  qualityMetadata    Json      @default("{}")
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  createdById        String
  createdBy          User      @relation(fields: [createdById], references: [id])

  lines        BOMLine[]
  transactions Transaction[]

  @@index([skuId, isActive])
}

model BOMLine {
  id              String     @id @default(uuid())
  bomVersionId    String
  bomVersion      BOMVersion @relation(fields: [bomVersionId], references: [id], onDelete: Cascade)
  componentId     String
  component       Component  @relation(fields: [componentId], references: [id])
  quantityPerUnit Decimal    @db.Decimal(10, 4)
  notes           String?    @db.Text

  @@unique([bomVersionId, componentId])
}

// ============================================
// Defect Threshold & Alert Entities
// ============================================

model DefectThreshold {
  id                String   @id @default(uuid())
  companyId         String
  company           Company  @relation(fields: [companyId], references: [id])
  skuId             String? // null = global threshold for company
  sku               SKU?     @relation(fields: [skuId], references: [id])
  defectRateLimit   Decimal  @db.Decimal(5, 2) // e.g., 5.00 = 5%
  affectedRateLimit Decimal? @db.Decimal(5, 2) // optional secondary threshold
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  createdById       String
  createdBy         User     @relation("ThresholdCreatedBy", fields: [createdById], references: [id])

  alerts DefectAlert[]

  @@unique([companyId, skuId])
  @@index([companyId, isActive])
}

model DefectAlert {
  id               String          @id @default(uuid())
  thresholdId      String
  threshold        DefectThreshold @relation(fields: [thresholdId], references: [id])
  transactionId    String
  transaction      Transaction     @relation(fields: [transactionId], references: [id])
  skuId            String
  sku              SKU             @relation(fields: [skuId], references: [id])
  defectRate       Decimal         @db.Decimal(5, 2)
  thresholdValue   Decimal         @db.Decimal(5, 2)
  severity         String          @db.VarChar(20) // 'warning' | 'critical'
  acknowledgedAt   DateTime?
  acknowledgedById String?
  acknowledgedBy   User?           @relation("AlertAcknowledgedBy", fields: [acknowledgedById], references: [id])
  createdAt        DateTime        @default(now())

  @@index([thresholdId, createdAt(sort: Desc)])
  @@index([skuId, createdAt(sort: Desc)])
  @@index([acknowledgedAt])
}

// ============================================
// Low-Stock Alert Configuration
// ============================================

model AlertConfig {
  id              String    @id @default(uuid())
  companyId       String    @unique
  company         Company   @relation(fields: [companyId], references: [id])

  // Channel configuration
  slackWebhookUrl String?   @db.VarChar(500)
  emailAddresses  String[]  // PostgreSQL array type

  // Toggles
  enableSlack     Boolean   @default(false)
  enableEmail     Boolean   @default(false)

  // Throttle settings
  alertMode       String    @default("daily_digest") @db.VarChar(20) // 'daily_digest' | 'per_transition'
  lastDigestSent  DateTime?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model ComponentAlertState {
  id            String    @id @default(uuid())
  componentId   String    @unique
  component     Component @relation(fields: [componentId], references: [id], onDelete: Cascade)
  lastStatus    String    @db.VarChar(20) // 'ok' | 'warning' | 'critical'
  lastAlertSent DateTime?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}
