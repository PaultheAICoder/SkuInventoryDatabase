# Implementation Plan
**Generated**: 2025-12-04T16:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #80 - Shopify API client service
**Estimated Build Time**: 4-6 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature (New Service)
**Source**: GitHub Issue #80
**Priority**: High (blocks downstream integration work)
**Parent Issue**: #10 - Shopify order integration to auto-create consumption/build transactions

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="shopify"` for future test runs

### Issue Validation
**Status**: Valid
**Recent Changes**: Issue #76 (database schema) was CLOSED - Shopify schema models already exist in `prisma/schema.prisma`
**Dependency Check**:
- #76 (Database schema) - CLOSED/COMPLETED (ShopifyConnection, ShopifyOrder, ShopifyOrderLine, SkuChannelMapping models exist)
- #93 (Order sync endpoint) - OPEN (will use this client)

### Current State Assessment
- **Existing components**:
  - Prisma schema: ShopifyConnection, ShopifyOrder, ShopifyOrderLine, SkuChannelMapping models exist
  - No `src/services/shopify.ts` exists (needs creation)
  - No `src/types/shopify.ts` exists (needs creation)
  - No encryption/crypto utilities exist in codebase (needs creation)
- **Database**: Schema complete via #76, no migrations needed
- **API Routes**: None for Shopify yet (handled in subsequent issues)
- **Types**: No Shopify types exist

### Dependencies & Blockers
1. **SHOPIFY_ENCRYPTION_KEY environment variable**: Optional - can fall back to NEXTAUTH_SECRET
2. **No external packages needed**: Node.js `crypto` module available natively
3. **Shopify API version**: Use `2024-01` stable version per issue spec

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 4-6 hours
**Risk**: Low (isolated service layer, no database changes, well-defined patterns)

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/lib/claude.ts` - External API client pattern with:
- Lazy client initialization
- Graceful fallback when API unavailable
- Error handling with console logging
- TypeScript interfaces for params/results

**Secondary**: `/home/pbrown/SkuInventory/src/services/alert.ts` - Service pattern with:
- Prisma integration
- Type exports from separate type file
- Async/await patterns
- Error handling

### Ripple Effect Analysis
**Files Identified**: 0 existing files affected
- This is a new feature creating new files
- No existing code depends on these files yet
- Downstream issue #93 will import from these new files

---

## Executive Summary
Create a type-safe Shopify API client service (`src/services/shopify.ts`) and TypeScript types (`src/types/shopify.ts`) that handle authentication, order fetching with pagination, rate limiting awareness, error handling with retries, and token encryption/decryption utilities. Also add a crypto utility library (`src/lib/crypto.ts`) for reusable AES encryption. The client will be used by downstream sync services (#93) to fetch orders from Shopify.

---

## Phase 1: Types Layer

### Subtask 1.1: Create Shopify Types
**File**: `/home/pbrown/SkuInventory/src/types/shopify.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/types/alert.ts` structure

**Instructions**:
1. Create TypeScript interfaces for Shopify API responses:
   - `ShopifyOrderResponse` - Order data from Shopify API
   - `ShopifyLineItem` - Line item within an order
   - `ShopifyOrdersListParams` - Query parameters for fetching orders
   - `ShopifyApiError` - Error response structure
   - `ShopifyRateLimitInfo` - Rate limit header data
2. Add Zod schemas if needed for runtime validation
3. Export all types for use by service and future API routes

**Code Snippet**:
```typescript
// Core types from issue spec
export interface ShopifyOrderResponse {
  id: number
  order_number: number
  created_at: string
  fulfillment_status: string | null
  financial_status: string
  line_items: ShopifyLineItem[]
  // Additional fields as needed
}

export interface ShopifyLineItem {
  id: number
  variant_id: number | null
  sku: string | null
  title: string
  quantity: number
  price: string
}

export interface ShopifyOrdersListParams {
  status?: 'open' | 'closed' | 'cancelled' | 'any'
  fulfillment_status?: 'shipped' | 'partial' | 'unshipped' | 'any' | 'unfulfilled'
  financial_status?: 'paid' | 'pending' | 'any' | 'authorized' | 'partially_paid' | 'refunded'
  created_at_min?: string
  created_at_max?: string
  limit?: number
  since_id?: number
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] All interfaces defined per issue spec
- [ ] File exports all types correctly
- [ ] No TypeScript errors

---

### Subtask 1.2: Create Crypto Utility Library
**File**: `/home/pbrown/SkuInventory/src/lib/crypto.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/lib/utils.ts` utility pattern

**Instructions**:
1. Create AES-256-GCM encryption/decryption functions using Node.js `crypto` module
2. Functions should accept a plaintext and return base64-encoded ciphertext (and vice versa)
3. Use NEXTAUTH_SECRET as fallback encryption key if SHOPIFY_ENCRYPTION_KEY not set
4. Include IV (initialization vector) in the encrypted output for proper decryption
5. Add proper error handling for malformed input

**Code Snippet**:
```typescript
import { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'crypto'

const ALGORITHM = 'aes-256-gcm'
const IV_LENGTH = 16
const SALT_LENGTH = 16
const TAG_LENGTH = 16
const KEY_LENGTH = 32

function getEncryptionKey(): Buffer {
  const secret = process.env.SHOPIFY_ENCRYPTION_KEY || process.env.NEXTAUTH_SECRET
  if (!secret) {
    throw new Error('No encryption key available (SHOPIFY_ENCRYPTION_KEY or NEXTAUTH_SECRET required)')
  }
  // Derive a 256-bit key from the secret using scrypt
  return scryptSync(secret, 'shopify-token-salt', KEY_LENGTH)
}

export function encryptToken(plaintext: string): string {
  // Implementation with IV prepended
}

export function decryptToken(ciphertext: string): string {
  // Implementation extracting IV from ciphertext
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] `encryptToken` function implemented
- [ ] `decryptToken` function implemented
- [ ] Uses NEXTAUTH_SECRET fallback
- [ ] No TypeScript errors
- [ ] Handles edge cases (empty string, malformed input)

---

## Phase 2: Service Layer

### Subtask 2.1: Create ShopifyClient Class
**File**: `/home/pbrown/SkuInventory/src/services/shopify.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/lib/claude.ts` client pattern

**Instructions**:
1. Create `ShopifyClient` class with constructor accepting `shopName` and `accessToken`
2. Set API version to `2024-01` as constant
3. Implement base URL construction: `https://{shop}.myshopify.com/admin/api/{version}/`
4. Implement `testConnection()` method to verify credentials
5. Implement `fetchOrder(orderId: number)` method for single order
6. Implement `fetchOrders(params: ShopifyOrdersListParams)` method with pagination support
7. Implement private `rateLimitedFetch<T>(url: string)` method that:
   - Checks `X-Shopify-Shop-Api-Call-Limit` header
   - Implements exponential backoff for 429 responses
   - Handles pagination via `Link` header
8. Add proper error handling for network failures, auth failures, rate limits

**Code Structure**:
```typescript
import {
  ShopifyOrderResponse,
  ShopifyOrdersListParams,
  ShopifyApiError
} from '@/types/shopify'

export class ShopifyClient {
  private shopName: string
  private accessToken: string
  private readonly apiVersion = '2024-01'

  constructor(shopName: string, accessToken: string) {
    this.shopName = shopName
    this.accessToken = accessToken
  }

  private get baseUrl(): string {
    return `https://${this.shopName}/admin/api/${this.apiVersion}`
  }

  async testConnection(): Promise<boolean> {
    // GET /shop.json to verify connection
  }

  async fetchOrder(orderId: number): Promise<ShopifyOrderResponse> {
    // GET /orders/{orderId}.json
  }

  async fetchOrders(params: ShopifyOrdersListParams): Promise<ShopifyOrderResponse[]> {
    // GET /orders.json with pagination
  }

  private async rateLimitedFetch<T>(url: string): Promise<T> {
    // Handle rate limiting and retries
  }
}

// Re-export encryption utilities for convenience
export { encryptToken, decryptToken } from '@/lib/crypto'
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] ShopifyClient class implemented
- [ ] Constructor accepts shopName and accessToken
- [ ] `testConnection()` method works
- [ ] `fetchOrder()` method works
- [ ] `fetchOrders()` method with pagination
- [ ] Rate limiting handled
- [ ] Error handling implemented
- [ ] No TypeScript errors
- [ ] Build passes

---

## Phase 3: Environment Configuration

### Subtask 3.1: Update Environment Schema (Optional Enhancement)
**File**: `/home/pbrown/SkuInventory/src/lib/env.ts`
**Pattern**: Follow existing env schema pattern

**Instructions**:
1. Add optional `SHOPIFY_ENCRYPTION_KEY` to environment schema
2. This is optional - the crypto utility will fall back to NEXTAUTH_SECRET
3. Document the environment variable in comments

**Code Snippet**:
```typescript
const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  NEXTAUTH_SECRET: z.string().min(1),
  NEXTAUTH_URL: z.string().url().optional(),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  ANTHROPIC_API_KEY: z.string().min(1).optional(),
  CLAUDE_CODE_PATH: z.string().optional(),
  SHOPIFY_ENCRYPTION_KEY: z.string().min(32).optional(), // Optional, falls back to NEXTAUTH_SECRET
})
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] SHOPIFY_ENCRYPTION_KEY added to schema (optional)
- [ ] No TypeScript errors
- [ ] Build passes

---

## Phase 4: Unit Tests

### Subtask 4.1: Create Shopify Client Tests
**File**: `/home/pbrown/SkuInventory/tests/unit/shopify-client.test.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/tests/unit/claude-client.test.ts` test pattern

**Instructions**:
1. Mock fetch API responses for Shopify endpoints
2. Test `testConnection()` method with success and failure cases
3. Test `fetchOrder()` with valid order ID and not found case
4. Test `fetchOrders()` with various parameter combinations
5. Test pagination handling (multiple pages)
6. Test rate limiting (429 response with Retry-After)
7. Test error handling (network errors, auth errors)

**Test Structure**:
```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'

// Mock global fetch
global.fetch = vi.fn()

import { ShopifyClient } from '@/services/shopify'

describe('ShopifyClient', () => {
  let client: ShopifyClient

  beforeEach(() => {
    client = new ShopifyClient('test-store.myshopify.com', 'test-token')
    vi.clearAllMocks()
  })

  describe('testConnection', () => {
    it('returns true for valid credentials', async () => { /* ... */ })
    it('returns false for invalid credentials', async () => { /* ... */ })
  })

  describe('fetchOrder', () => {
    it('fetches a single order by ID', async () => { /* ... */ })
    it('throws error for non-existent order', async () => { /* ... */ })
  })

  describe('fetchOrders', () => {
    it('fetches orders with default params', async () => { /* ... */ })
    it('handles pagination correctly', async () => { /* ... */ })
    it('applies filter parameters', async () => { /* ... */ })
  })

  describe('rate limiting', () => {
    it('retries on 429 response', async () => { /* ... */ })
    it('respects Retry-After header', async () => { /* ... */ })
  })
})
```

**Validation Commands**:
```bash
npm test -- --filter="shopify"
```

**Completion Criteria**:
- [ ] All test cases pass
- [ ] Coverage for happy path and error cases
- [ ] Rate limiting tested
- [ ] Pagination tested

---

### Subtask 4.2: Create Crypto Utility Tests
**File**: `/home/pbrown/SkuInventory/tests/unit/crypto.test.ts`
**Pattern**: Follow existing unit test patterns

**Instructions**:
1. Test `encryptToken` produces different output for same input (due to random IV)
2. Test `decryptToken` correctly reverses encryption
3. Test roundtrip: encrypt then decrypt returns original
4. Test error handling for malformed input
5. Test with various token lengths

**Test Structure**:
```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'

describe('Crypto Utilities', () => {
  const originalEnv = process.env

  beforeEach(() => {
    process.env = { ...originalEnv, NEXTAUTH_SECRET: 'test-secret-at-least-32-chars-long' }
  })

  afterEach(() => {
    process.env = originalEnv
  })

  describe('encryptToken', () => {
    it('encrypts a token string', async () => { /* ... */ })
    it('produces different output each time (random IV)', async () => { /* ... */ })
  })

  describe('decryptToken', () => {
    it('decrypts an encrypted token', async () => { /* ... */ })
    it('throws error for malformed input', async () => { /* ... */ })
  })

  describe('roundtrip', () => {
    it('encrypt then decrypt returns original', async () => { /* ... */ })
    it('works with various token lengths', async () => { /* ... */ })
  })
})
```

**Validation Commands**:
```bash
npm test -- --filter="crypto"
```

**Completion Criteria**:
- [ ] All test cases pass
- [ ] Roundtrip encryption works
- [ ] Error cases handled

---

## Phase 5: Final Verification

### Subtask 5.1: Run Full Build and Tests
**Instructions**:
1. Run TypeScript compilation
2. Run Next.js build
3. Run linter
4. Run unit tests

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
npm run lint
npm test
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` passes
- [ ] `npm run lint` passes (no warnings)
- [ ] `npm test` passes

---

## Summary of Deliverables

**Files Created**: 4
- `/home/pbrown/SkuInventory/src/types/shopify.ts` - TypeScript types for Shopify data
- `/home/pbrown/SkuInventory/src/lib/crypto.ts` - Encryption/decryption utilities
- `/home/pbrown/SkuInventory/src/services/shopify.ts` - ShopifyClient class
- `/home/pbrown/SkuInventory/tests/unit/shopify-client.test.ts` - Client unit tests
- `/home/pbrown/SkuInventory/tests/unit/crypto.test.ts` - Crypto utility tests

**Files Modified**: 1 (optional)
- `/home/pbrown/SkuInventory/src/lib/env.ts` - Add SHOPIFY_ENCRYPTION_KEY to schema

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5)
2. Complete each subtask fully before moving to the next
3. Run validation commands after each subtask
4. If tests fail, debug and fix before proceeding
5. Follow reference patterns exactly

---

## Test Strategy Note
- Use Vitest for unit tests (project standard)
- Mock `fetch` API for Shopify client tests
- Test environment variables should be set in test setup
- No integration tests needed for this service-only issue

---

## Acceptance Criteria Mapping (from Issue)
- [x] `ShopifyClient` class created with order fetching capabilities -> Subtask 2.1
- [x] Type definitions complete for orders and line items -> Subtask 1.1
- [x] Error handling for network failures, auth failures, rate limits -> Subtask 2.1
- [x] `testConnection()` method works correctly -> Subtask 2.1
- [x] Pagination support for large order sets -> Subtask 2.1
- [x] Token encryption/decryption utilities implemented -> Subtask 1.2
- [x] Unit tests for client methods (mock API responses) -> Subtask 4.1, 4.2
- [x] `npm run build` passes -> Subtask 5.1
- [x] `npx tsc --noEmit` passes -> Subtask 5.1

---

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 10m |
| **Total** | **30m** |
