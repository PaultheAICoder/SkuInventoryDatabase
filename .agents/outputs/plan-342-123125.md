# Implementation Plan
**Generated**: 2025-12-31T17:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #342
**Estimated Build Time**: 3-4 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Bug Fix (follow-up to #330)
**Source**: GitHub Issue #342
**Priority**: High

### Task Classification
**Category**: BUG_FIX
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="bom"` or None

### Issue Validation
**Status**: Valid - Root cause identified (different from assumed cause)
**Recent Changes**: Commit 26fb6ad added floating-point tolerance (working correctly)

### Current State Assessment

#### Original Issue #330 Fix
The fix from issue #330 is **technically correct and working**. It added `floorWithTolerance()` with epsilon = 1e-9 to handle floating-point precision errors.

**Locations Updated**:
1. `src/services/bom.ts` - lines 11-19, 131, 197, 254
2. `src/app/api/components/[id]/route.ts` - lines 30-33, 207

#### Actual Root Cause of #342
The issue is NOT floating-point precision in calculations. The issue is **precision loss in data storage**.

**Evidence from Production Database**:
```sql
-- Component: 24x9x9 Casepack
quantityPerUnit = 0.0167  -- Stored with 4 decimal places
total_inventory = 4.0000
buildable = 4 / 0.0167 = 239.52... -> floors to 239 (CORRECT!)
```

**The BOMLine schema**:
```prisma
model BOMLine {
  quantityPerUnit Decimal @db.Decimal(10, 4)  -- Only 4 decimal places!
}
```

**What happened**:
1. User entered `1/60` (0.016666...) as the BOM quantity
2. Database stored it as `0.0167` (rounded to 4 decimal places)
3. 4 / 0.0167 = 239.52, which correctly floors to 239
4. User expected 240 because 4 / (1/60) = 240 exactly

**Why #330 fix doesn't help**:
- The epsilon tolerance helps when result is like `239.9999997` (rounds to 240)
- But `4 / 0.0167 = 239.52` is nowhere near 240
- The fix is correct but the stored data is already imprecise

### Dependencies & Blockers
1. **Schema Change**: Requires increasing Decimal precision in Prisma schema
2. **Data Migration**: Existing data may need recalculation from original input
3. **UI Changes**: Users should be able to enter fractions like "1/60"

**Can Proceed?**: YES (but solution options need consideration)

### Complexity Assessment
**Complexity**: Medium
**Effort**: 3-4 hours
**Risk**: Medium (schema changes affect existing data)

### Patterns Identified
**Primary**: Prisma migrations in `prisma/migrations/`
**Secondary**: BOM line handling in `src/app/api/skus/[id]/bom-versions/route.ts`

### Ripple Effect Analysis
**Files Identified**: 8-12 files

Schema change affects:
- `prisma/schema.prisma` - BOMLine model
- `src/app/api/skus/[id]/bom-versions/route.ts` - BOM creation
- `src/app/api/skus/[id]/bom-versions/[versionId]/lines/route.ts` - Line updates
- `src/services/bom.ts` - BOM calculations
- `src/types/bom.ts` - Type definitions
- `tests/unit/bom-calculations.test.ts` - Tests
- Frontend components displaying BOM quantities

---

## Executive Summary

Issue #342 is NOT a continuation of the floating-point precision bug from #330. The real issue is that `BOMLine.quantityPerUnit` is stored as `Decimal(10,4)`, limiting precision to 4 decimal places. When users enter fractions like "1/60" (0.0166666...), they get stored as "0.0167", causing buildable unit calculations to be slightly off.

**Two solution options**:
1. **Option A (Recommended)**: Increase Decimal precision to 10 decimal places
2. **Option B**: Store fractions as a string and convert at runtime

---

## Phase 0: Verify Current State (Investigation Complete)

### Already Verified During Investigation

**Database State** (Production):
- `quantityPerUnit` = 0.0167 (24x9x9 Casepack)
- `inventory` = 4.0000
- `buildable` = 239.52 -> 239 (mathematically correct with stored data)

**Code State**:
- `floorWithTolerance()` is correctly implemented in all 4 locations
- Docker containers are rebuilt and running version 0.7.87
- The #330 fix is deployed and working as designed

---

## Phase 1: Schema Update (Option A - Recommended)

### Subtask 1.1: Increase BOMLine quantityPerUnit Precision
**File**: `prisma/schema.prisma`
**Pattern**: Follow existing Decimal field definitions
**Instructions**:

1. Update the BOMLine model to increase precision from 4 to 10 decimal places:

```prisma
model BOMLine {
  id              String     @id @default(uuid())
  bomVersionId    String
  bomVersion      BOMVersion @relation(fields: [bomVersionId], references: [id], onDelete: Cascade)
  componentId     String
  component       Component  @relation(fields: [componentId], references: [id])
  quantityPerUnit Decimal    @db.Decimal(18, 10)  // Changed from (10, 4) to (18, 10)
  notes           String?    @db.Text

  @@unique([bomVersionId, componentId])
}
```

**Rationale**:
- `Decimal(18, 10)` allows storing 1/65 as 0.0153846154 (10 decimal places)
- This eliminates rounding errors for common fractions

**Completion Criteria**:
- [ ] Schema updated
- [ ] Change reviewed for impacts

---

### Subtask 1.2: Create and Run Migration
**File**: `prisma/migrations/[timestamp]_increase_bom_quantity_precision/migration.sql`
**Pattern**: Follow existing migrations in `prisma/migrations/`
**Instructions**:

1. Generate migration:
```bash
cd /home/pbrown/SkuInventory
npx prisma migrate dev --name increase_bom_quantity_precision
```

2. The migration SQL should look like:
```sql
-- AlterTable
ALTER TABLE "BOMLine" ALTER COLUMN "quantityPerUnit" TYPE DECIMAL(18,10);
```

3. Verify migration runs successfully:
```bash
npx prisma migrate deploy
```

**Completion Criteria**:
- [ ] Migration file created
- [ ] Migration applied to test database
- [ ] No data loss confirmed

---

### Subtask 1.3: Regenerate Prisma Client
**File**: Generated Prisma client
**Instructions**:

```bash
npx prisma generate
```

**Completion Criteria**:
- [ ] Prisma client regenerated
- [ ] TypeScript compilation passes

---

## Phase 2: Fix Existing Data (Manual Step)

### Subtask 2.1: Document Data Correction Needed
**Instructions**:

The existing `0.0167` value cannot be automatically corrected because we don't know the original intended value. The user must manually update the BOM line with the correct fraction.

**Recommended Values**:
- If intended as 1/60: Update to `0.0166666667`
- If intended as 1/65: Update to `0.0153846154`

**SQL to update (user must run after confirming correct value)**:
```sql
-- Example: Update to 1/60 precision
UPDATE "BOMLine" bl
SET "quantityPerUnit" = 0.0166666667
FROM "BOMVersion" bv
JOIN "SKU" s ON bv."skuId" = s.id
WHERE bl."bomVersionId" = bv.id
  AND s."internalCode" = 'AMZ_1pk'
  AND bl."quantityPerUnit" = 0.0167;
```

**Completion Criteria**:
- [ ] Documentation added for user to correct data
- [ ] User notified of manual step required

---

## Phase 3: Improve Fraction Input (Enhancement)

### Subtask 3.1: Add Fraction Parsing to BOM Line Input
**File**: `src/lib/utils.ts`
**Pattern**: Follow existing `parseFractionOrNumber()` function
**Instructions**:

The codebase already has `parseFractionOrNumber()` in `src/lib/utils.ts`. Verify it preserves full precision:

```typescript
// Existing function - verify it returns full precision
export function parseFractionOrNumber(input: string): number | null {
  if (!input || typeof input !== 'string') return null
  const trimmed = input.trim()

  // Handle fractions like "1/60"
  const fractionMatch = trimmed.match(/^(\d+)\s*\/\s*(\d+)$/)
  if (fractionMatch) {
    const numerator = parseInt(fractionMatch[1], 10)
    const denominator = parseInt(fractionMatch[2], 10)
    if (denominator === 0) return null
    return numerator / denominator  // Full precision
  }

  const num = parseFloat(trimmed)
  return isNaN(num) ? null : num
}
```

**Completion Criteria**:
- [ ] Function preserves full precision for fractions
- [ ] Function is used in BOM line creation

---

### Subtask 3.2: Verify BOM Line Creation Uses Fraction Parser
**File**: `src/services/sku.ts`
**Pattern**: Line 314
**Instructions**:

Verify the BOM line creation uses full precision:

```typescript
// In createSku function, around line 314
lines: {
  create: input.bomLines!.map((line) => ({
    componentId: line.componentId,
    quantityPerUnit: parseFractionOrNumber(line.quantityPerUnit) ?? 1,  // Full precision
  })),
},
```

**Completion Criteria**:
- [ ] Fraction parsing preserves full precision
- [ ] BOM lines store high-precision values

---

## Phase 4: Validation

### Subtask 4.1: Add Test for High-Precision BOM Quantities
**File**: `tests/unit/bom-calculations.test.ts`
**Pattern**: Follow existing test at line 323
**Instructions**:

Add test to verify high-precision quantities work correctly:

```typescript
it('handles high-precision BOM quantities (1/60)', async () => {
  // 1/60 stored with full precision
  const quantityPerUnit = 1/60  // 0.016666666666666666

  vi.mocked(prisma.bOMVersion.findFirst).mockResolvedValue({
    id: 'bom-1',
    skuId: 'sku-1',
    versionName: 'v1',
    isActive: true,
    lines: [
      {
        componentId: 'comp-1',
        quantityPerUnit: new Prisma.Decimal(quantityPerUnit.toString()),
        component: { id: 'comp-1' }
      },
    ],
  } as never)

  vi.mocked(prisma.component.findMany).mockResolvedValue([
    { id: 'comp-1' },
  ] as never)

  // 4 / (1/60) = 240 exactly
  vi.mocked(prisma.inventoryBalance.groupBy).mockResolvedValue([
    { componentId: 'comp-1', _sum: { quantity: new Prisma.Decimal('4') } },
  ] as never)

  const result = await calculateMaxBuildableUnits('sku-1', 'company-1')
  expect(result).toBe(240)  // Not 239!
})
```

**Completion Criteria**:
- [ ] Test added
- [ ] Test passes with schema update

---

### Subtask 4.2: Run Full Validation Suite
**Instructions**:

```bash
cd /home/pbrown/SkuInventory

# TypeScript check
npx tsc --noEmit

# Build check
npm run build

# Lint check
npm run lint

# Run tests
npm test
```

**Completion Criteria**:
- [ ] TypeScript: No errors
- [ ] Build: Passes
- [ ] Lint: No errors
- [ ] Tests: All passing

---

### Subtask 4.3: Rebuild Docker and Verify Fix
**Instructions**:

```bash
cd /home/pbrown/SkuInventory/docker
docker compose up -d --build

# Wait for healthy
docker compose ps

# Verify database migration applied
docker exec inventory-db-prod psql -U postgres -d inventory -c "
  SELECT column_name, data_type, numeric_precision, numeric_scale
  FROM information_schema.columns
  WHERE table_name = 'BOMLine' AND column_name = 'quantityPerUnit';
"
```

**Completion Criteria**:
- [ ] Docker containers rebuilt
- [ ] Migration applied
- [ ] Column shows Decimal(18,10)

---

## Summary of Deliverables

**Files Modified**: 3-4
- `prisma/schema.prisma` - BOMLine precision update
- `prisma/migrations/*/migration.sql` - Auto-generated
- `tests/unit/bom-calculations.test.ts` - New test case

**User Action Required**:
- Update AMZ_1pk BOM line with correct fraction value after schema migration

---

## Handoff to Build Agent

1. Execute subtasks in exact order
2. Phase 1 (schema) must complete before Phase 4 (validation)
3. Document the manual data correction step for user
4. The #330 floating-point fix is correct and should NOT be modified
5. This is a DATA PRECISION issue, not a CALCULATION issue

---

## Test Strategy Note

- Use Vitest for unit tests
- Test with actual fraction values (1/60, 1/65)
- Verify Prisma Decimal preserves precision

---

## Alternative Approach (If Schema Change Not Desired)

If increasing precision is not feasible, an alternative is to:

1. Store the original fraction as a string (e.g., "1/60") in a new column
2. Calculate at runtime using the stored fraction
3. More complex but preserves exact user intent

This approach requires more extensive changes and is NOT recommended.

---

## Key Insight for User

The issue is that "0.0167" in the database is NOT equal to "1/60":
- 1/60 = 0.016666666... (repeating)
- Stored: 0.0167 (rounded to 4 decimal places)
- 4 / 0.0167 = 239.52 (correctly floors to 239)
- 4 / (1/60) = 240 (what user expected)

**The fix is to store more decimal places so 1/60 is stored as 0.0166666667, not 0.0167.**

---

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 10m |
| **Total** | **45m** |
