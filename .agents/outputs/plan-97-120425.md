# Implementation Plan
**Generated**: 2025-12-04T11:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: Issue #97
**Estimated Build Time**: 6-8 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #97
**Priority**: High (Final piece of Shopify order integration MVP)
**Parent Issue**: #10 (Shopify order integration to auto-create consumption/build transactions)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--testPathPattern="order-posting"` or run integration tests

### Issue Validation
**Status**: Valid
**Recent Changes**:
- Issue #95 (CLOSED) added order review queue UI with approve/skip workflows
- Issue #93 (CLOSED) added order sync service and endpoint
- Issue #76 (CLOSED) added Shopify integration database schema
- The ShopifyOrder model already has a `transactionId` field for linking to created transactions
- The approval workflow is already implemented in `/api/shopify/orders/[id]/approve/route.ts`

### Current State Assessment
- **Existing Components**:
  - `ShopifyOrder` model with status enum (pending, approved, posted, skipped, error) - EXISTS
  - `ShopifyOrderLine` model with mapping info - EXISTS
  - Approval API route at `/api/shopify/orders/[id]/approve/route.ts` - EXISTS
  - `createBuildTransaction` service function in `src/services/inventory.ts` - EXISTS (with FEFO lot selection, insufficient inventory handling)
  - BOM version selection by effective date logic in `src/app/api/transactions/build/route.ts` - EXISTS

- **Database**:
  - Transaction model - EXISTS (no sourceType/sourceOrderId fields yet - need to add per issue spec)
  - ShopifyOrder.transactionId field - EXISTS
  - ShopifyOrderStatus enum includes 'posted' - EXISTS

- **API Routes**:
  - `/api/shopify/orders/[id]/post` - NEEDS CREATION
  - `/api/shopify/orders/post-batch` - NEEDS CREATION

- **Services**:
  - `src/services/order-posting.ts` - NEEDS CREATION

### Dependencies & Blockers
1. **Dependency on #95** (Review queue UI) - CLOSED, already merged
2. **Dependency on #93** (Order sync) - CLOSED, already merged
3. **Dependency on #76** (Schema) - CLOSED, already merged

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 6-8 hours
**Risk**: Medium (integrating with existing build transaction logic, need careful transaction handling)

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts` - BOM version selection by effective date, createBuildTransaction usage
**Secondary**: `/home/pbrown/SkuInventory/src/app/api/shopify/orders/[id]/approve/route.ts` - Order validation and status update patterns

### Ripple Effect Analysis
**Files Identified**: 6 files to create/modify

Files to CREATE:
- `/home/pbrown/SkuInventory/src/app/api/shopify/orders/[id]/post/route.ts` (new)
- `/home/pbrown/SkuInventory/src/app/api/shopify/orders/post-batch/route.ts` (new)
- `/home/pbrown/SkuInventory/src/services/order-posting.ts` (new)
- `/home/pbrown/SkuInventory/src/types/order-posting.ts` (new)

Files to MODIFY:
- `/home/pbrown/SkuInventory/prisma/schema.prisma` - Add sourceType/sourceOrderId to Transaction
- `/home/pbrown/SkuInventory/src/types/transaction.ts` - Update types if needed

---

## Executive Summary
Create the transaction posting system for approved Shopify orders. When a user "posts" an approved order, the system will:
1. Validate the order is in "approved" status
2. Aggregate line items by SKU (grouping quantities)
3. Find the effective BOM version for each SKU at the order date
4. Create build transactions to consume components and produce finished goods
5. Link transactions back to the source Shopify order
6. Update order status to "posted"

The implementation leverages the existing `createBuildTransaction` service function which already handles FEFO lot selection, insufficient inventory checks, and finished goods output.

---

## Phase 1: Database Schema Updates

### Subtask 1.1: Add Source Reference Fields to Transaction Model
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing optional field patterns in Transaction model
**Instructions**:
1. Add new fields to the Transaction model:
```prisma
model Transaction {
  // ... existing fields ...

  // Source tracking for automated transactions (e.g., from Shopify orders)
  sourceType     String?  @db.VarChar(20)  // "shopify", "manual", etc.
  sourceOrderId  String?  // Reference to ShopifyOrder.id

  @@index([sourceType, sourceOrderId])
}
```
2. Place the new fields after `defectAlerts` relation and before the existing `@@index` statements
3. Run migration: `npx prisma migrate dev --name add-transaction-source-reference`
4. Generate client: `npx prisma generate`

**Validation**:
```bash
npx prisma migrate dev --name add-transaction-source-reference
npx prisma generate
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] New fields added to Transaction model
- [ ] New index created for sourceType + sourceOrderId
- [ ] Migration runs successfully
- [ ] Prisma client generated without errors
- [ ] TypeScript compilation passes

---

## Phase 2: Types Layer

### Subtask 2.1: Create Order Posting Types
**File**: `/home/pbrown/SkuInventory/src/types/order-posting.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/types/transaction.ts` and `/home/pbrown/SkuInventory/src/types/order-review.ts`
**Instructions**:
1. Create the new types file with the following content:

```typescript
/**
 * Order posting types and Zod schemas
 * Used for posting approved orders to create inventory transactions
 */

import { z } from 'zod'
import type { InsufficientInventoryItem } from '@/services/inventory'

// =============================================================================
// Request Schemas
// =============================================================================

/**
 * Schema for posting a single order
 */
export const postOrderSchema = z.object({
  allowInsufficientInventory: z.boolean().optional().default(false),
})

export type PostOrderInput = z.infer<typeof postOrderSchema>

/**
 * Schema for batch posting orders
 */
export const postOrderBatchSchema = z.object({
  orderIds: z.array(z.string().uuid()).min(1, 'At least one order ID required'),
  allowInsufficientInventory: z.boolean().optional().default(false),
})

export type PostOrderBatchInput = z.infer<typeof postOrderBatchSchema>

// =============================================================================
// Response Types
// =============================================================================

/**
 * Error during posting
 */
export interface PostingError {
  skuId?: string
  skuName?: string
  message: string
  code: 'NO_BOM' | 'INSUFFICIENT_INVENTORY' | 'TRANSACTION_FAILED' | 'VALIDATION_ERROR'
}

/**
 * Result of posting a single order
 */
export interface PostOrderResult {
  success: boolean
  orderId: string
  transactionIds: string[]
  errors: PostingError[]
  insufficientInventory: InsufficientInventoryItem[]
  warnings: string[]
  skusSummary: Array<{
    skuId: string
    skuName: string
    internalCode: string
    totalUnits: number
    transactionId: string
  }>
}

/**
 * Result of batch posting
 */
export interface PostOrderBatchResult {
  totalOrders: number
  successCount: number
  failureCount: number
  results: Array<{
    orderId: string
    shopifyOrderNumber: string
    result: PostOrderResult
  }>
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with all types
- [ ] Zod schemas export correctly
- [ ] TypeScript compilation passes

---

## Phase 3: Service Layer

### Subtask 3.1: Create Order Posting Service
**File**: `/home/pbrown/SkuInventory/src/services/order-posting.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/inventory.ts` (createBuildTransaction) and `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts` (BOM version selection)
**Instructions**:
1. Create the new service file with the following implementation:

```typescript
/**
 * Order Posting Service
 * Handles converting approved Shopify orders into inventory transactions
 */

import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'
import { createBuildTransaction, getCompanySettings, checkInsufficientInventory } from './inventory'
import type { PostOrderResult, PostingError } from '@/types/order-posting'
import type { InsufficientInventoryItem } from './inventory'

/**
 * Aggregated SKU line item from order
 */
interface AggregatedSku {
  skuId: string
  skuName: string
  internalCode: string
  totalQuantity: number
  lineIds: string[]
}

/**
 * Get effective BOM version for a SKU at a specific date
 * Returns the BOM version that was active on that date
 */
async function getEffectiveBomVersion(skuId: string, orderDate: Date): Promise<{
  id: string
  versionName: string
} | null> {
  const bomVersion = await prisma.bOMVersion.findFirst({
    where: {
      skuId,
      effectiveStartDate: { lte: orderDate },
      OR: [
        { effectiveEndDate: null },
        { effectiveEndDate: { gte: orderDate } }
      ]
    },
    orderBy: { effectiveStartDate: 'desc' },
    select: {
      id: true,
      versionName: true,
    },
  })

  return bomVersion
}

/**
 * Aggregate order lines by SKU
 * Groups quantities for the same SKU across multiple lines
 */
function aggregateLinesBySku(
  lines: Array<{
    id: string
    mappedSkuId: string | null
    mappingStatus: string
    quantity: number
  }>,
  skuMap: Map<string, { name: string; internalCode: string }>
): AggregatedSku[] {
  const aggregated = new Map<string, AggregatedSku>()

  for (const line of lines) {
    // Skip unmapped or ignored lines
    if (!line.mappedSkuId || line.mappingStatus !== 'mapped') {
      continue
    }

    const existing = aggregated.get(line.mappedSkuId)
    const skuInfo = skuMap.get(line.mappedSkuId)

    if (existing) {
      existing.totalQuantity += line.quantity
      existing.lineIds.push(line.id)
    } else {
      aggregated.set(line.mappedSkuId, {
        skuId: line.mappedSkuId,
        skuName: skuInfo?.name ?? 'Unknown',
        internalCode: skuInfo?.internalCode ?? 'Unknown',
        totalQuantity: line.quantity,
        lineIds: [line.id],
      })
    }
  }

  return Array.from(aggregated.values())
}

/**
 * Post a single approved Shopify order to create inventory transactions
 *
 * Flow:
 * 1. Validate order exists and is in "approved" status
 * 2. Get all mapped line items
 * 3. Aggregate quantities by SKU
 * 4. For each SKU, find effective BOM and create build transaction
 * 5. Update order status to "posted"
 */
export async function postShopifyOrder(params: {
  orderId: string
  userId: string
  companyId: string
  allowInsufficientInventory?: boolean
}): Promise<PostOrderResult> {
  const { orderId, userId, companyId, allowInsufficientInventory = false } = params

  const result: PostOrderResult = {
    success: false,
    orderId,
    transactionIds: [],
    errors: [],
    insufficientInventory: [],
    warnings: [],
    skusSummary: [],
  }

  // Get order with lines and validate
  const order = await prisma.shopifyOrder.findFirst({
    where: {
      id: orderId,
      connection: { companyId },
    },
    include: {
      lines: {
        select: {
          id: true,
          mappedSkuId: true,
          mappingStatus: true,
          quantity: true,
        },
      },
    },
  })

  if (!order) {
    result.errors.push({
      message: 'Order not found',
      code: 'VALIDATION_ERROR',
    })
    return result
  }

  // Check idempotency - if already posted, return existing state
  if (order.status === 'posted') {
    result.errors.push({
      message: 'Order already posted',
      code: 'VALIDATION_ERROR',
    })
    return result
  }

  // Validate order is approved
  if (order.status !== 'approved') {
    result.errors.push({
      message: `Order must be approved before posting (current status: ${order.status})`,
      code: 'VALIDATION_ERROR',
    })
    return result
  }

  // Get SKU details for mapped lines
  const mappedSkuIds = order.lines
    .filter((l) => l.mappedSkuId && l.mappingStatus === 'mapped')
    .map((l) => l.mappedSkuId!)

  if (mappedSkuIds.length === 0) {
    result.errors.push({
      message: 'No mapped SKUs found in order',
      code: 'VALIDATION_ERROR',
    })
    return result
  }

  const skus = await prisma.sKU.findMany({
    where: { id: { in: mappedSkuIds } },
    select: { id: true, name: true, internalCode: true },
  })

  const skuMap = new Map(skus.map((s) => [s.id, { name: s.name, internalCode: s.internalCode }]))

  // Aggregate lines by SKU
  const aggregatedSkus = aggregateLinesBySku(order.lines, skuMap)

  if (aggregatedSkus.length === 0) {
    result.errors.push({
      message: 'No mapped lines to process',
      code: 'VALIDATION_ERROR',
    })
    return result
  }

  // Get company settings
  const settings = await getCompanySettings(companyId)
  const allowInsufficient = settings.allowNegativeInventory || allowInsufficientInventory

  // Pre-check all SKUs for BOM availability and inventory
  const preCheckErrors: PostingError[] = []
  const allInsufficientItems: InsufficientInventoryItem[] = []

  for (const sku of aggregatedSkus) {
    const bomVersion = await getEffectiveBomVersion(sku.skuId, order.orderDate)

    if (!bomVersion) {
      preCheckErrors.push({
        skuId: sku.skuId,
        skuName: sku.skuName,
        message: `No BOM version effective on ${order.orderDate.toISOString().split('T')[0]}`,
        code: 'NO_BOM',
      })
      continue
    }

    // Check inventory if not allowing insufficient
    if (!allowInsufficient) {
      const insufficientItems = await checkInsufficientInventory({
        bomVersionId: bomVersion.id,
        unitsToBuild: sku.totalQuantity,
      })

      if (insufficientItems.length > 0) {
        allInsufficientItems.push(...insufficientItems)
        preCheckErrors.push({
          skuId: sku.skuId,
          skuName: sku.skuName,
          message: `Insufficient inventory for ${insufficientItems.length} component(s)`,
          code: 'INSUFFICIENT_INVENTORY',
        })
      }
    }
  }

  // If pre-check found errors and we're not allowing insufficient inventory, return early
  if (preCheckErrors.length > 0 && !allowInsufficient) {
    result.errors = preCheckErrors
    result.insufficientInventory = allInsufficientItems
    return result
  }

  // Process all SKUs in a database transaction
  try {
    await prisma.$transaction(async (tx) => {
      for (const sku of aggregatedSkus) {
        const bomVersion = await getEffectiveBomVersion(sku.skuId, order.orderDate)

        if (!bomVersion) {
          // Skip SKUs without BOM (already warned in pre-check)
          result.warnings.push(`Skipped ${sku.skuName}: No effective BOM`)
          continue
        }

        try {
          // Create build transaction with source reference
          const buildResult = await createBuildTransaction({
            companyId,
            skuId: sku.skuId,
            bomVersionId: bomVersion.id,
            unitsToBuild: sku.totalQuantity,
            salesChannel: 'shopify',
            date: order.orderDate,
            notes: `Shopify Order #${order.shopifyOrderNumber}`,
            createdById: userId,
            allowInsufficientInventory: allowInsufficient,
          })

          // Update the transaction with source reference
          await tx.transaction.update({
            where: { id: buildResult.transaction.id },
            data: {
              sourceType: 'shopify',
              sourceOrderId: orderId,
            },
          })

          result.transactionIds.push(buildResult.transaction.id)
          result.skusSummary.push({
            skuId: sku.skuId,
            skuName: sku.skuName,
            internalCode: sku.internalCode,
            totalUnits: sku.totalQuantity,
            transactionId: buildResult.transaction.id,
          })

          if (buildResult.warning) {
            result.warnings.push(`${sku.skuName}: Built with insufficient inventory warning`)
            result.insufficientInventory.push(...buildResult.insufficientItems)
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Unknown error'
          result.errors.push({
            skuId: sku.skuId,
            skuName: sku.skuName,
            message: errorMessage,
            code: 'TRANSACTION_FAILED',
          })
        }
      }

      // Only update order status if at least one transaction succeeded
      if (result.transactionIds.length > 0) {
        await tx.shopifyOrder.update({
          where: { id: orderId },
          data: {
            status: 'posted',
            processedAt: new Date(),
            transactionId: result.transactionIds[0], // Store primary transaction ID
          },
        })
      }
    })

    result.success = result.transactionIds.length > 0 && result.errors.length === 0
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Transaction rollback'
    result.errors.push({
      message: errorMessage,
      code: 'TRANSACTION_FAILED',
    })
  }

  return result
}

/**
 * Post multiple approved orders in batch
 */
export async function postShopifyOrderBatch(params: {
  orderIds: string[]
  userId: string
  companyId: string
  allowInsufficientInventory?: boolean
}): Promise<{
  totalOrders: number
  successCount: number
  failureCount: number
  results: Array<{
    orderId: string
    shopifyOrderNumber: string
    result: PostOrderResult
  }>
}> {
  const { orderIds, userId, companyId, allowInsufficientInventory } = params

  // Get order numbers for response
  const orders = await prisma.shopifyOrder.findMany({
    where: {
      id: { in: orderIds },
      connection: { companyId },
    },
    select: {
      id: true,
      shopifyOrderNumber: true,
    },
  })

  const orderNumberMap = new Map(orders.map((o) => [o.id, o.shopifyOrderNumber]))

  const results: Array<{
    orderId: string
    shopifyOrderNumber: string
    result: PostOrderResult
  }> = []

  let successCount = 0
  let failureCount = 0

  // Process orders sequentially to avoid race conditions
  for (const orderId of orderIds) {
    const result = await postShopifyOrder({
      orderId,
      userId,
      companyId,
      allowInsufficientInventory,
    })

    results.push({
      orderId,
      shopifyOrderNumber: orderNumberMap.get(orderId) ?? 'Unknown',
      result,
    })

    if (result.success) {
      successCount++
    } else {
      failureCount++
    }
  }

  return {
    totalOrders: orderIds.length,
    successCount,
    failureCount,
    results,
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Service file created with all functions
- [ ] `postShopifyOrder` function handles all cases (validation, BOM lookup, transaction creation)
- [ ] `postShopifyOrderBatch` function for batch processing
- [ ] Source reference (sourceType, sourceOrderId) set on created transactions
- [ ] TypeScript compilation passes
- [ ] Lint passes

---

## Phase 4: API Routes

### Subtask 4.1: Create Single Order Post Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/shopify/orders/[id]/post/route.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/shopify/orders/[id]/approve/route.ts`
**Instructions**:
1. Create the new route file:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { postShopifyOrder } from '@/services/order-posting'
import { postOrderSchema } from '@/types/order-posting'

// =============================================================================
// POST /api/shopify/orders/[id]/post - Post approved order to create transactions
// =============================================================================

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Only admin and ops can post orders
    if (session.user.role === 'viewer') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id } = await params
    const selectedCompanyId = session.user.selectedCompanyId

    // Parse request body
    const body = await request.json().catch(() => ({}))
    const validation = postOrderSchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    // Verify order belongs to company's connection
    const connection = await prisma.shopifyConnection.findUnique({
      where: { companyId: selectedCompanyId },
      select: { id: true },
    })

    if (!connection) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 })
    }

    // Verify order exists and belongs to this connection
    const order = await prisma.shopifyOrder.findFirst({
      where: {
        id,
        connectionId: connection.id,
      },
      select: { id: true, status: true },
    })

    if (!order) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 })
    }

    // Post the order
    const result = await postShopifyOrder({
      orderId: id,
      userId: session.user.id,
      companyId: selectedCompanyId,
      allowInsufficientInventory: validation.data.allowInsufficientInventory,
    })

    // Determine response status based on result
    if (result.success) {
      return NextResponse.json({
        data: result,
        message: `Order posted successfully. Created ${result.transactionIds.length} transaction(s).`,
      })
    } else if (result.insufficientInventory.length > 0) {
      return NextResponse.json(
        {
          error: 'Insufficient inventory',
          data: result,
          canRetryWithOverride: true,
        },
        { status: 400 }
      )
    } else {
      return NextResponse.json(
        {
          error: result.errors[0]?.message || 'Failed to post order',
          data: result,
        },
        { status: 400 }
      )
    }
  } catch (error) {
    console.error('Error posting order:', error)
    return NextResponse.json({ error: 'Failed to post order' }, { status: 500 })
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Route file created
- [ ] Authentication and authorization implemented
- [ ] Request body validated with Zod
- [ ] Proper error handling for all cases
- [ ] Returns appropriate status codes

### Subtask 4.2: Create Batch Order Post Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/shopify/orders/post-batch/route.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/shopify/orders/route.ts` for auth patterns
**Instructions**:
1. Create the new route file:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { postShopifyOrderBatch } from '@/services/order-posting'
import { postOrderBatchSchema } from '@/types/order-posting'

// =============================================================================
// POST /api/shopify/orders/post-batch - Batch post multiple approved orders
// =============================================================================

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Only admin and ops can post orders
    if (session.user.role === 'viewer') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const selectedCompanyId = session.user.selectedCompanyId

    // Parse and validate request body
    const body = await request.json().catch(() => ({}))
    const validation = postOrderBatchSchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    const { orderIds, allowInsufficientInventory } = validation.data

    // Verify connection exists for company
    const connection = await prisma.shopifyConnection.findUnique({
      where: { companyId: selectedCompanyId },
      select: { id: true },
    })

    if (!connection) {
      return NextResponse.json(
        { error: 'No Shopify connection found for company' },
        { status: 404 }
      )
    }

    // Verify all orders belong to this connection
    const validOrders = await prisma.shopifyOrder.findMany({
      where: {
        id: { in: orderIds },
        connectionId: connection.id,
      },
      select: { id: true },
    })

    const validOrderIds = new Set(validOrders.map((o) => o.id))
    const invalidOrderIds = orderIds.filter((id) => !validOrderIds.has(id))

    if (invalidOrderIds.length > 0) {
      return NextResponse.json(
        {
          error: 'Some orders not found',
          invalidOrderIds,
        },
        { status: 400 }
      )
    }

    // Process batch
    const result = await postShopifyOrderBatch({
      orderIds,
      userId: session.user.id,
      companyId: selectedCompanyId,
      allowInsufficientInventory,
    })

    return NextResponse.json({
      data: result,
      message: `Batch complete: ${result.successCount} succeeded, ${result.failureCount} failed`,
    })
  } catch (error) {
    console.error('Error batch posting orders:', error)
    return NextResponse.json({ error: 'Failed to batch post orders' }, { status: 500 })
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Route file created
- [ ] Validates all order IDs belong to company
- [ ] Returns comprehensive batch results
- [ ] Handles partial failures gracefully

---

## Phase 5: Build Verification

### Subtask 5.1: Run Full Build and Type Check
**Instructions**:
1. Run TypeScript compilation check
2. Run build process
3. Fix any errors

**Validation**:
```bash
npx tsc --noEmit
npm run build
npm run lint
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` passes with no errors
- [ ] `npm run lint` passes with no warnings

### Subtask 5.2: Create Integration Test File (Optional but Recommended)
**File**: `/home/pbrown/SkuInventory/tests/integration/order-posting.test.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`
**Instructions**:
1. Create test file with comprehensive tests:
   - Test posting an approved order creates transactions
   - Test posting creates transactions for each unique SKU
   - Test order status updates to "posted"
   - Test idempotency (double-posting returns error)
   - Test insufficient inventory handling
   - Test BOM version selection by order date

**Note**: This subtask is optional for the initial implementation but recommended for robust testing.

---

## Summary of Deliverables

**Files Created**: 4 new files
1. `/home/pbrown/SkuInventory/src/app/api/shopify/orders/[id]/post/route.ts` - Single order post API
2. `/home/pbrown/SkuInventory/src/app/api/shopify/orders/post-batch/route.ts` - Batch post API
3. `/home/pbrown/SkuInventory/src/services/order-posting.ts` - Core posting service
4. `/home/pbrown/SkuInventory/src/types/order-posting.ts` - Type definitions

**Files Modified**: 1 file
1. `/home/pbrown/SkuInventory/prisma/schema.prisma` - Add sourceType/sourceOrderId fields

**Database Changes**: 1 migration
- Add `sourceType` and `sourceOrderId` columns to Transaction table
- Add index on `sourceType` and `sourceOrderId`

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 5)
2. Phase 1 (Schema) must complete before Phase 2-4 can start
3. Test completion criteria before moving to next subtask
4. Follow reference patterns exactly
5. Run `npx tsc --noEmit` after each file creation
6. Run `npm run build` and `npm run lint` after all phases complete

## Test Strategy Note
- Use TARGETED testing approach
- Focus on integration tests for order posting flow
- Verify with manual API testing using curl or Postman:
  ```bash
  # Test single order post
  curl -X POST http://172.16.20.50:4545/api/shopify/orders/{orderId}/post \
    -H "Content-Type: application/json" \
    -d '{"allowInsufficientInventory": false}'

  # Test batch post
  curl -X POST http://172.16.20.50:4545/api/shopify/orders/post-batch \
    -H "Content-Type: application/json" \
    -d '{"orderIds": ["id1", "id2"], "allowInsufficientInventory": false}'
  ```

## Performance Metrics
| Phase | Estimated Duration |
|-------|----------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 20m |
| **Total** | **55m** |

---

## Acceptance Criteria Checklist (from Issue #97)
- [ ] Post endpoint creates build transactions for approved orders
- [ ] Transactions correctly reference source Shopify order (sourceType, sourceOrderId)
- [ ] BOM version selected based on order date (not current date)
- [ ] Quantities aggregated per SKU across order lines
- [ ] Order status updated to "posted" on success
- [ ] Batch posting works for multiple orders
- [ ] Insufficient inventory handled per company settings
- [ ] Idempotent - cannot double-post same order
- [ ] Transaction notes include Shopify order reference
- [ ] `npm run build` passes
- [ ] `npx tsc --noEmit` passes
