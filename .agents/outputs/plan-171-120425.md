# Implementation Plan
**Generated**: 2025-12-04T22:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #171
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #171
**Priority**: Medium

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="import|csv|bom"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- Issue #169 (commit 06c1f6b) added Company/Brand/Location columns to import templates
- This builds on that foundation by adding BOM/component reference data

### Current State Assessment
- **SKU Template Generation**: `src/services/import.ts:generateSKUTemplate()` - currently generates basic columns (Name, Internal Code, Company, Brand, Sales Channel, Notes) with reference section for companies/brands
- **SKU Import Processing**: `src/services/import.ts:processSKUImport()` - parses CSV into `SKUImportWithLookups` objects
- **SKU Import API**: `src/app/api/import/skus/route.ts` - creates SKUs but does NOT create BOM versions
- **BOM Creation Service**: `src/services/bom.ts:createBOMVersion()` - creates BOM with lines in transaction
- **Template Route**: `src/app/api/import/template/[type]/route.ts` - fetches reference data for templates

### Dependencies & Blockers
1. **Component lookup**: Need to fetch available components for reference section
2. **BOM structure complexity**: SKU can have multiple BOM lines (component + quantity pairs)
3. **CSV format limitation**: Need to design a flat CSV format that can represent multiple BOM lines per SKU

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 6-8 hours
**Risk**: Low

### Patterns Identified
**Primary**: `src/services/import.ts:generateComponentTemplate()` - pattern for including reference sections
**Secondary**: `src/services/bom.ts:createBOMVersion()` - pattern for creating BOMs with lines

### Ripple Effect Analysis
**Files Identified**: 6 files
- `src/services/import.ts` - Add BOM columns to SKU template, add component reference, extend SKUImportWithLookups
- `src/app/api/import/template/[type]/route.ts` - Fetch components for reference data
- `src/app/api/import/skus/route.ts` - Create BOM version during SKU import
- `tests/unit/csv-import.test.ts` - Add tests for new template/import functionality
- `tests/integration/import-export.test.ts` - Add integration tests for SKU+BOM import

---

## Executive Summary
This feature enhances the SKU import template to include BOM (Bill of Materials) component columns, allowing users to create complete SKUs with their component requirements in a single CSV upload. The template will list available components in the reference section (similar to how companies/brands are listed), and the import process will create both the SKU and an initial BOM version with the specified components.

## Design Decisions

### CSV Format for BOM Components
Since a SKU can have multiple BOM components, we need a flat CSV format. The recommended approach is to use paired columns:
- `BOM Component 1`, `BOM Qty 1`, `BOM Component 2`, `BOM Qty 2`, ... (up to 10 components)

Example template:
```csv
Name,Internal Code,Company,Brand,Sales Channel,BOM Component 1,BOM Qty 1,BOM Component 2,BOM Qty 2,Notes
Example SKU,SKU-001,Acme Corp,Main Brand,Amazon,BOX-001,1,LABEL-001,2,Sample
```

### Reference Section Enhancement
Add a COMPONENTS section to the reference area:
```
# COMPONENTS (SKU Code -> Name [Cost]):
#   BOX-001 -> Small Box [$1.50]
#   LABEL-001 -> Shipping Label [$0.10]
```

---

## Phase 1: Template & Types Enhancement

### Subtask 1.1: Extend TemplateReferenceData Interface
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing interface at line 18-23
**Instructions**:
1. Add `components` field to `TemplateReferenceData` interface:
   ```typescript
   export interface TemplateReferenceData {
     companies: { name: string }[]
     brands: { name: string; companyName: string }[]
     locations: { name: string; companyName: string }[]
     categories: { name: string }[]
     components?: { skuCode: string; name: string; costPerUnit: string }[]
   }
   ```
2. Make components optional to maintain backward compatibility with component template

**Completion Criteria**:
- [ ] Interface extended with optional components field
- [ ] `npx tsc --noEmit` passes

### Subtask 1.2: Extend SKUImportWithLookups Interface
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing interface at line 44-52
**Instructions**:
1. Add BOM-related fields to `SKUImportWithLookups` interface:
   ```typescript
   export interface SKUImportWithLookups {
     name: string
     internalCode: string
     company?: string
     brand?: string
     salesChannel: 'Amazon' | 'Shopify' | 'TikTok' | 'Generic'
     notes: string | null
     // BOM component pairs (up to 10)
     bomComponents?: Array<{
       componentSkuCode: string
       quantity: number
     }>
   }
   ```

**Completion Criteria**:
- [ ] Interface extended with bomComponents array
- [ ] `npx tsc --noEmit` passes

### Subtask 1.3: Update skuImportSchema for BOM Columns
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing schema at line 173-189
**Instructions**:
1. Add BOM column parsing to `skuImportSchema`:
   ```typescript
   const skuImportSchema = z.object({
     name: z.string().min(1, 'Name is required'),
     internal_code: z.string().min(1, 'Internal code is required'),
     company: z.string().optional().transform((v) => v || undefined),
     brand: z.string().optional().transform((v) => v || undefined),
     sales_channel: z.enum(['Amazon', 'Shopify', 'TikTok', 'Generic']),
     notes: z.string().optional().transform((v) => v || null),
     // BOM columns (1-10)
     bom_component_1: z.string().optional().transform((v) => v || undefined),
     bom_qty_1: z.string().optional().transform((v) => v ? parseFloat(v) : undefined),
     bom_component_2: z.string().optional().transform((v) => v || undefined),
     bom_qty_2: z.string().optional().transform((v) => v ? parseFloat(v) : undefined),
     // ... repeat for 3-10
   })
   ```
2. Use a helper function to avoid repetition:
   ```typescript
   function createBomColumnSchemas(): Record<string, z.ZodTypeAny> {
     const schemas: Record<string, z.ZodTypeAny> = {}
     for (let i = 1; i <= 10; i++) {
       schemas[`bom_component_${i}`] = z.string().optional().transform((v) => v || undefined)
       schemas[`bom_qty_${i}`] = z.string().optional().transform((v) => v ? parseFloat(v) : undefined)
     }
     return schemas
   }
   ```

**Completion Criteria**:
- [ ] Schema extended with BOM columns
- [ ] `npx tsc --noEmit` passes

### Subtask 1.4: Update importSKURow to Parse BOM Components
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing function at line 275-315
**Instructions**:
1. Modify `importSKURow` function to extract BOM components from parsed CSV:
   ```typescript
   // After parsing with skuImportSchema
   // Extract BOM components
   const bomComponents: Array<{ componentSkuCode: string; quantity: number }> = []
   for (let i = 1; i <= 10; i++) {
     const skuCode = csvParsed[`bom_component_${i}` as keyof typeof csvParsed]
     const qty = csvParsed[`bom_qty_${i}` as keyof typeof csvParsed]
     if (skuCode && qty && !isNaN(qty as number)) {
       bomComponents.push({
         componentSkuCode: skuCode as string,
         quantity: qty as number,
       })
     }
   }

   // Add to skuData
   const skuData: SKUImportWithLookups = {
     // ... existing fields
     bomComponents: bomComponents.length > 0 ? bomComponents : undefined,
   }
   ```

**Completion Criteria**:
- [ ] Function extracts and validates BOM components
- [ ] `npx tsc --noEmit` passes

### Subtask 1.5: Update generateSKUTemplate to Include BOM Columns
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing function at line 535-570
**Instructions**:
1. Add BOM columns to headers:
   ```typescript
   const headers = [
     'Name', 'Internal Code', 'Company', 'Brand', 'Sales Channel',
     'BOM Component 1', 'BOM Qty 1',
     'BOM Component 2', 'BOM Qty 2',
     'BOM Component 3', 'BOM Qty 3',
     'BOM Component 4', 'BOM Qty 4',
     'BOM Component 5', 'BOM Qty 5',
     'Notes'
   ]
   ```
2. Update example row to include sample BOM data:
   ```typescript
   const exampleRow = [
     'Example SKU',
     'SKU-001',
     referenceData?.companies[0]?.name || 'Company Name',
     referenceData?.brands[0]?.name || 'Brand Name',
     'Amazon',
     referenceData?.components?.[0]?.skuCode || '',  // BOM Component 1
     referenceData?.components?.[0] ? '1' : '',       // BOM Qty 1
     '', '', '', '', '', '', '', '',                  // Remaining BOM slots
     'Sample SKU for import',
   ]
   ```
3. Add COMPONENTS section to reference data:
   ```typescript
   if (referenceData?.components && referenceData.components.length > 0) {
     lines.push('#')
     lines.push('# COMPONENTS (SKU Code -> Name [Cost]):')
     for (const component of referenceData.components) {
       lines.push(`#   ${component.skuCode} -> ${component.name} [$${component.costPerUnit}]`)
     }
   }
   ```

**Completion Criteria**:
- [ ] Template includes BOM columns
- [ ] Template includes COMPONENTS reference section
- [ ] Example row includes sample BOM data
- [ ] `npx tsc --noEmit` passes

---

## Phase 2: API Route Enhancement

### Subtask 2.1: Extend fetchReferenceData to Include Components
**File**: `/home/pbrown/SkuInventory/src/app/api/import/template/[type]/route.ts`
**Pattern**: Follow existing function at line 22-66
**Instructions**:
1. Add components fetch to the parallel queries (only for SKU template):
   ```typescript
   async function fetchReferenceData(
     userId: string,
     selectedCompanyId: string,
     includeComponents: boolean = false
   ): Promise<TemplateReferenceData> {
     // ... existing company/brand/location/category fetches

     // Only fetch components for SKU template
     const componentQuery = includeComponents
       ? prisma.component.findMany({
           where: { companyId: { in: uniqueCompanyIds }, isActive: true },
           select: { skuCode: true, name: true, costPerUnit: true },
           orderBy: [{ name: 'asc' }],
         })
       : Promise.resolve([])

     const [companies, brands, locations, categories, components] = await Promise.all([
       // ... existing queries
       componentQuery,
     ])

     return {
       // ... existing fields
       components: components.map((c) => ({
         skuCode: c.skuCode,
         name: c.name,
         costPerUnit: c.costPerUnit.toString(),
       })),
     }
   }
   ```
2. Update the call in GET handler to pass `includeComponents: true` for SKU template

**Completion Criteria**:
- [ ] Components included in reference data for SKU template
- [ ] Components NOT included for component template (avoid confusion)
- [ ] `npx tsc --noEmit` passes

### Subtask 2.2: Update SKU Import Route to Create BOM Version
**File**: `/home/pbrown/SkuInventory/src/app/api/import/skus/route.ts`
**Pattern**: Follow existing import logic at line 131-236
**Instructions**:
1. Add component lookup map building (extend `buildLookupMaps`):
   ```typescript
   interface LookupMaps {
     companies: Map<string, string>
     companyNames: Map<string, string>
     brands: Map<string, { id: string; companyId: string }>
     components: Map<string, { id: string; costPerUnit: number }> // Add this
   }
   ```
2. Fetch components in `buildLookupMaps`:
   ```typescript
   const [companies, brands, components] = await Promise.all([
     // ... existing queries
     prisma.component.findMany({
       where: { companyId: { in: uniqueCompanyIds }, isActive: true },
       select: { id: true, skuCode: true, costPerUnit: true, companyId: true },
     }),
   ])

   return {
     // ... existing maps
     components: new Map(
       components.map((c) => [
         c.skuCode.toLowerCase(),
         { id: c.id, costPerUnit: c.costPerUnit.toNumber() },
       ])
     ),
   }
   ```
3. After creating SKU, if `bomComponents` exists, create BOM version:
   ```typescript
   import { createBOMVersion } from '@/services/bom'

   // After SKU creation...
   if (skuData.bomComponents && skuData.bomComponents.length > 0) {
     // Validate and resolve components
     const bomLines: Array<{ componentId: string; quantityPerUnit: number }> = []
     let bomValid = true

     for (const bomComp of skuData.bomComponents) {
       const component = lookupMaps.components.get(bomComp.componentSkuCode.toLowerCase())
       if (!component) {
         result.errors.push({
           rowNumber: row.rowNumber,
           name: skuData.name,
           errors: [`BOM component "${bomComp.componentSkuCode}" not found`],
         })
         bomValid = false
         break
       }
       bomLines.push({
         componentId: component.id,
         quantityPerUnit: bomComp.quantity,
       })
     }

     if (bomValid && bomLines.length > 0) {
       // Use try-catch to not fail the whole import if BOM creation fails
       try {
         await createBOMVersion({
           skuId: newSku.id,
           versionName: 'v1-import',
           effectiveStartDate: new Date(),
           isActive: true,
           notes: 'Created via CSV import',
           lines: bomLines,
           createdById: session.user.id,
         })
       } catch (bomError) {
         console.error('Failed to create BOM during import:', bomError)
         // SKU was created, just note the BOM failure in results
         result.errors.push({
           rowNumber: row.rowNumber,
           name: skuData.name,
           errors: ['SKU created but BOM creation failed: ' + (bomError instanceof Error ? bomError.message : 'Unknown error')],
         })
       }
     }
   }
   ```
4. Import the createBOMVersion function at the top of the file

**Completion Criteria**:
- [ ] SKU import creates BOM version when BOM columns provided
- [ ] Invalid component references result in clear error messages
- [ ] BOM creation failures don't prevent SKU creation
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` passes

---

## Phase 3: Unit Tests

### Subtask 3.1: Add Template Generation Tests for BOM Columns
**File**: `/home/pbrown/SkuInventory/tests/unit/csv-import.test.ts`
**Pattern**: Follow existing tests at line 500-574
**Instructions**:
1. Add test for SKU template with component reference:
   ```typescript
   describe('SKU template with BOM reference data', () => {
     it('generates SKU template with BOM columns', () => {
       const referenceData = {
         companies: [{ name: 'Acme Corp' }],
         brands: [{ name: 'Main Brand', companyName: 'Acme Corp' }],
         locations: [],
         categories: [],
         components: [
           { skuCode: 'BOX-001', name: 'Small Box', costPerUnit: '1.50' },
           { skuCode: 'LABEL-001', name: 'Shipping Label', costPerUnit: '0.10' },
         ],
       }

       const template = generateSKUTemplate(referenceData)

       expect(template).toContain('BOM Component 1')
       expect(template).toContain('BOM Qty 1')
       expect(template).toContain('BOM Component 5')
       expect(template).toContain('# COMPONENTS (SKU Code -> Name [Cost]):')
       expect(template).toContain('BOX-001 -> Small Box [$1.50]')
       expect(template).toContain('LABEL-001 -> Shipping Label [$0.10]')
     })

     it('generates SKU template without component reference when none provided', () => {
       const referenceData = {
         companies: [{ name: 'Acme Corp' }],
         brands: [{ name: 'Main Brand', companyName: 'Acme Corp' }],
         locations: [],
         categories: [],
       }

       const template = generateSKUTemplate(referenceData)

       expect(template).toContain('BOM Component 1')
       expect(template).not.toContain('# COMPONENTS (SKU Code')
     })
   })
   ```

**Completion Criteria**:
- [ ] Tests verify BOM columns in template
- [ ] Tests verify component reference section
- [ ] All tests pass: `npm test -- --filter="csv-import"`

### Subtask 3.2: Add SKU Import Tests for BOM Parsing
**File**: `/home/pbrown/SkuInventory/tests/unit/csv-import.test.ts`
**Instructions**:
1. Add test for SKU import with BOM components:
   ```typescript
   describe('processSKUImport with BOM columns', () => {
     it('parses CSV with BOM components', () => {
       const csv = `Name,Internal Code,Sales Channel,BOM Component 1,BOM Qty 1,BOM Component 2,BOM Qty 2
   Product X,PROD-X,Amazon,BOX-001,2,LABEL-001,1`

       const result = processSKUImport(csv)

       expect(result.successful).toBe(1)
       expect(result.results[0].data?.bomComponents).toHaveLength(2)
       expect(result.results[0].data?.bomComponents?.[0]).toEqual({
         componentSkuCode: 'BOX-001',
         quantity: 2,
       })
       expect(result.results[0].data?.bomComponents?.[1]).toEqual({
         componentSkuCode: 'LABEL-001',
         quantity: 1,
       })
     })

     it('handles empty BOM columns gracefully', () => {
       const csv = `Name,Internal Code,Sales Channel,BOM Component 1,BOM Qty 1
   Product Y,PROD-Y,Shopify,,`

       const result = processSKUImport(csv)

       expect(result.successful).toBe(1)
       expect(result.results[0].data?.bomComponents).toBeUndefined()
     })

     it('ignores BOM component without quantity', () => {
       const csv = `Name,Internal Code,Sales Channel,BOM Component 1,BOM Qty 1
   Product Z,PROD-Z,Generic,BOX-001,`

       const result = processSKUImport(csv)

       expect(result.successful).toBe(1)
       expect(result.results[0].data?.bomComponents).toBeUndefined()
     })
   })
   ```

**Completion Criteria**:
- [ ] Tests verify BOM component parsing
- [ ] Tests verify empty/partial BOM handling
- [ ] All tests pass: `npm test -- --filter="csv-import"`

---

## Phase 4: Integration Tests

### Subtask 4.1: Add Integration Tests for SKU Import with BOM
**File**: `/home/pbrown/SkuInventory/tests/integration/import-export.test.ts`
**Pattern**: Follow existing SKU import tests at line 344-400
**Instructions**:
1. Add test for SKU import that creates BOM:
   ```typescript
   describe('POST /api/import/skus with BOM', () => {
     it('imports SKU and creates BOM version with components', async () => {
       setTestSession(TEST_SESSIONS.admin!)
       const prisma = getIntegrationPrisma()

       // Create test components first
       const component1 = await createTestComponentInDb(
         TEST_SESSIONS.admin!.user.companyId,
         { name: 'Box Component', skuCode: 'BOX-INT-001' }
       )
       const component2 = await createTestComponentInDb(
         TEST_SESSIONS.admin!.user.companyId,
         { name: 'Label Component', skuCode: 'LABEL-INT-001' }
       )

       const csv = `Name,Internal Code,Sales Channel,BOM Component 1,BOM Qty 1,BOM Component 2,BOM Qty 2
   SKU With BOM,SKU-BOM-001,Amazon,BOX-INT-001,2,LABEL-INT-001,1`

       const request = new Request('http://localhost/api/import/skus', {
         method: 'POST',
         headers: { 'Content-Type': 'text/plain' },
         body: csv,
       })

       const response = await importSKUs(request as never)
       const result = await response.json()

       expect(response.status).toBe(200)
       expect(result.data.imported).toBe(1)

       // Verify SKU and BOM were created
       const sku = await prisma.sKU.findFirst({
         where: { internalCode: 'SKU-BOM-001' },
       })
       expect(sku).not.toBeNull()

       const bomVersion = await prisma.bOMVersion.findFirst({
         where: { skuId: sku!.id, isActive: true },
         include: { lines: true },
       })
       expect(bomVersion).not.toBeNull()
       expect(bomVersion!.lines).toHaveLength(2)

       // Verify component quantities
       const boxLine = bomVersion!.lines.find(l => l.componentId === component1.id)
       const labelLine = bomVersion!.lines.find(l => l.componentId === component2.id)
       expect(Number(boxLine!.quantityPerUnit)).toBe(2)
       expect(Number(labelLine!.quantityPerUnit)).toBe(1)
     })

     it('imports SKU but reports error for invalid BOM component', async () => {
       setTestSession(TEST_SESSIONS.admin!)

       const csv = `Name,Internal Code,Sales Channel,BOM Component 1,BOM Qty 1
   SKU Bad BOM,SKU-BADBOM-001,Amazon,NONEXISTENT-COMP,1`

       const request = new Request('http://localhost/api/import/skus', {
         method: 'POST',
         headers: { 'Content-Type': 'text/plain' },
         body: csv,
       })

       const response = await importSKUs(request as never)
       const result = await response.json()

       expect(response.status).toBe(200)
       // SKU should still be created, but with an error note about BOM
       expect(result.data.imported).toBe(1)
       expect(result.data.errors[0].errors[0]).toContain('BOM component "NONEXISTENT-COMP" not found')
     })

     it('template includes component reference for SKUs', async () => {
       setTestSession(TEST_SESSIONS.admin!)

       // Create test component
       await createTestComponentInDb(
         TEST_SESSIONS.admin!.user.companyId,
         { name: 'Ref Component', skuCode: 'REF-COMP-001' }
       )

       const request = createTestRequest('/api/import/template/skus')
       const response = await getTemplate(request, { params: Promise.resolve({ type: 'skus' }) })

       expect(response.status).toBe(200)
       const csv = await response.text()

       expect(csv).toContain('BOM Component 1')
       expect(csv).toContain('BOM Qty 1')
       expect(csv).toContain('# COMPONENTS (SKU Code -> Name [Cost])')
       expect(csv).toContain('REF-COMP-001')
     })
   })
   ```

**Completion Criteria**:
- [ ] Tests verify SKU + BOM creation via import
- [ ] Tests verify error handling for invalid components
- [ ] Tests verify template includes component reference
- [ ] All tests pass: `npm test -- --filter="import-export"`

---

## Phase 5: Final Validation

### Subtask 5.1: Verify Build and Type Checks
**Instructions**:
1. Run TypeScript check: `npx tsc --noEmit`
2. Run build: `npm run build`
3. Run lint: `npm run lint`
4. Fix any errors or warnings

**Completion Criteria**:
- [ ] TypeScript check passes with no errors
- [ ] Build completes successfully
- [ ] No lint warnings

### Subtask 5.2: Run Full Test Suite
**Instructions**:
1. Run affected tests: `npm test -- --filter="import|csv|bom"`
2. Run full test suite if time permits: `npm test`

**Completion Criteria**:
- [ ] All import/csv/bom tests pass
- [ ] No regressions in other tests

---

## Summary of Deliverables
**Files Created**: 0
**Files Modified**:
1. `/home/pbrown/SkuInventory/src/services/import.ts` - Extended interfaces, schemas, template generation
2. `/home/pbrown/SkuInventory/src/app/api/import/template/[type]/route.ts` - Fetch components for reference
3. `/home/pbrown/SkuInventory/src/app/api/import/skus/route.ts` - Create BOM during SKU import
4. `/home/pbrown/SkuInventory/tests/unit/csv-import.test.ts` - Unit tests for BOM parsing
5. `/home/pbrown/SkuInventory/tests/integration/import-export.test.ts` - Integration tests

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 1 before Phase 2, etc.)
2. Run validation commands after each phase
3. Follow reference patterns exactly - especially the existing template/import patterns
4. Test completion criteria before moving to next subtask

## Test Strategy Note
- Use Vitest for unit and integration tests
- Unit tests: `npm test -- --filter="csv-import"`
- Integration tests: `npm test -- --filter="import-export"`

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 10m |
| **Total** | **30m** |
