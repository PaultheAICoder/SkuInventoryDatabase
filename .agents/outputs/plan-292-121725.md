# Implementation Plan
**Generated**: 2025-12-17T06:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: Issue #292 - Move reorder-status filtering to the DB and avoid full-set loads
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

---

## Investigation Summary

### Request Analysis
**Type**: Enhancement / Performance Optimization
**Source**: GitHub Issue #292
**Priority**: Medium (impacts scalability for large tenants)

### Task Classification
**Category**: REFACTORING
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="component|inventory"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- Issue #5 (commit bf9d383) previously added client-side filtering by reorderStatus before pagination
- Issue #6 (commit 09688ad) integrated company settings with reorderWarningMultiplier
- Issue #96 added company scoping to data queries

The current code works correctly but loads ALL matching components when filtering by reorderStatus, which will degrade with large data sets.

### Current State Assessment

**Problem Analysis:**
The current implementation at `src/app/api/components/route.ts` (lines 57-108) and `src/app/(dashboard)/components/page.tsx` (lines 56-110) performs the following when filtering by `reorderStatus`:
1. Fetches ALL components matching base filters (no pagination)
2. Gets quantities for ALL components via `getComponentQuantities()`
3. Calculates reorderStatus for each in application code
4. Filters by reorderStatus in JavaScript
5. Applies pagination to the filtered result

**Impact**: For a tenant with 10,000 components, a reorderStatus filter loads all 10,000 rows into memory before pagination.

**Current Files Affected**:
| File | Status | Role |
|------|--------|------|
| `src/app/api/components/route.ts` | MODIFY | API endpoint - has duplicated filtering logic |
| `src/app/(dashboard)/components/page.tsx` | MODIFY | SSR page - has duplicated filtering logic |
| `src/services/inventory.ts` | MODIFY | Add new DB-level query function |
| `src/types/component.ts` | NO CHANGE | Types are already correct |

### Dependencies & Blockers
1. **Database Layer**: TransactionLine sums by componentId already handled by `getComponentQuantities()` - need to adapt this for DB-side computation
2. **Company Settings**: `reorderWarningMultiplier` is fetched per-company - must be available in SQL query
3. **Location Filtering**: Optional `locationId` filter adds complexity to quantity calculation

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 6-8 hours
**Risk**: Medium - SQL complexity for location-aware transfers, but well-defined logic

### Patterns Identified

**Primary Pattern**: `src/services/inventory.ts:142-266` - `getComponentQuantities()` function
- Uses Prisma `groupBy` with aggregation
- Handles transfer transactions with from/to locations
- Returns Map<componentId, quantity>

**Secondary Pattern**: Similar DB-side pagination exists in:
- `src/app/api/skus/route.ts` - SKU listing with pagination
- `src/app/api/transactions/route.ts` - Transaction listing with filters

### Ripple Effect Analysis

**Files Identified**: 4 primary files

1. **`src/app/api/components/route.ts`** (lines 57-108)
   - Current reorderStatus filtering block - will be refactored
   - Affects GET handler only

2. **`src/app/(dashboard)/components/page.tsx`** (lines 56-110)
   - `getComponents()` function has same duplication
   - Will call new service function

3. **`src/services/inventory.ts`**
   - Add new `getComponentsWithReorderStatus()` function
   - Keep existing `getComponentQuantities()` for backward compatibility

4. **`src/app/api/export/components/route.ts`**
   - Currently loads all components for export (acceptable for export use case)
   - No change needed - export always needs full data

**Secondary Files (no changes needed)**:
- `src/app/api/dashboard/route.ts` - Uses different pattern (loads all active components for stats)
- `src/components/features/ComponentTable.tsx` - Client-side, consumes API response

---

## Executive Summary

This implementation moves the reorder status calculation and filtering from application code into the database layer. A new service function will use SQL to compute on-hand quantities via TransactionLine aggregation, calculate reorder status using the company's `reorderWarningMultiplier` setting, and return only the filtered, paginated results. This eliminates loading all components into memory when filtering by status.

---

## Phase 1: Service Layer - New DB-Side Query Function

### Subtask 1.1: Add `getComponentsWithReorderStatus()` to Inventory Service
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Follow existing `getComponentQuantities()` function (lines 142-266)
**Instructions**:

1. Add a new exported function after `getComponentQuantities()`:

```typescript
/**
 * Fetch components with computed reorderStatus at the DB level.
 * Supports filtering by status, pagination, and sorting.
 * Optionally filters quantities by location.
 *
 * This function pushes the status computation to SQL to avoid
 * loading all components when filtering by reorderStatus.
 */
export async function getComponentsWithReorderStatus(params: {
  companyId: string
  brandId?: string
  page: number
  pageSize: number
  sortBy: string
  sortOrder: 'asc' | 'desc'
  search?: string
  category?: string
  isActive?: boolean
  reorderStatus?: 'critical' | 'warning' | 'ok'
  locationId?: string
  reorderWarningMultiplier: number
}): Promise<{ data: ComponentWithStatus[]; total: number }>
```

2. The function should:
   - Use Prisma `$queryRaw` with a CTE (Common Table Expression) or subquery to:
     a. Join Component with TransactionLine aggregation
     b. Handle location-specific quantity calculation (transfers need special handling)
     c. Compute reorderStatus using CASE WHEN in SQL
   - Apply the WHERE filter for reorderStatus at DB level
   - Apply pagination (LIMIT/OFFSET) and sorting at DB level
   - Return both data and total count

3. Add supporting type:

```typescript
interface ComponentWithStatus {
  id: string
  name: string
  skuCode: string
  category: string | null
  unitOfMeasure: string
  costPerUnit: string
  reorderPoint: number
  leadTimeDays: number
  notes: string | null
  isActive: boolean
  quantityOnHand: number
  reorderStatus: 'critical' | 'warning' | 'ok'
  createdAt: string
  updatedAt: string
  createdBy: { id: string; name: string }
}
```

4. SQL Logic for reorderStatus:
```sql
CASE
  WHEN c."reorderPoint" = 0 THEN 'ok'
  WHEN COALESCE(qty_sum, 0) <= c."reorderPoint" THEN 'critical'
  WHEN COALESCE(qty_sum, 0) <= c."reorderPoint" * $multiplier THEN 'warning'
  ELSE 'ok'
END AS "reorderStatus"
```

5. For global quantity (no locationId):
```sql
SELECT tl."componentId", SUM(tl."quantityChange") as qty_sum
FROM "TransactionLine" tl
JOIN "Transaction" t ON tl."transactionId" = t.id
WHERE t."companyId" = $companyId AND t."status" = 'approved'
GROUP BY tl."componentId"
```

6. For location-specific quantity, adapt the three-query pattern from `getComponentQuantities()`:
   - Non-transfer transactions at this location
   - Transfer lines where this is fromLocationId (negative)
   - Transfer lines where this is toLocationId (positive)

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] New function added to inventory.ts
- [ ] Type definitions in place
- [ ] TypeScript compiles without errors
- [ ] Handles both global and location-filtered queries

### Subtask 1.2: Export New Function
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Instructions**:
1. Ensure `getComponentsWithReorderStatus` is exported
2. Add any new types to the exports if needed

**Completion Criteria**:
- [ ] Function is importable from `@/services/inventory`

---

## Phase 2: API Route Refactoring

### Subtask 2.1: Update Components API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/components/route.ts`
**Pattern**: Keep non-reorderStatus path unchanged, refactor reorderStatus path
**Instructions**:

1. Import the new function:
```typescript
import {
  getComponentQuantities,
  calculateReorderStatus,
  getCompanySettings,
  getComponentsWithReorderStatus  // Add this
} from '@/services/inventory'
```

2. Replace lines 57-108 (the `if (reorderStatus)` block) with:

```typescript
// When filtering by reorderStatus, use DB-side computation
if (reorderStatus) {
  const result = await getComponentsWithReorderStatus({
    companyId: selectedCompanyId,
    brandId: selectedBrandId || undefined,
    page,
    pageSize,
    sortBy,
    sortOrder,
    search,
    category,
    isActive,
    reorderStatus,
    locationId,
    reorderWarningMultiplier: settings.reorderWarningMultiplier,
  })

  return paginated(result.data, result.total, page, pageSize)
}
```

3. Keep the existing non-reorderStatus logic (lines 110-151) unchanged

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
curl -s "http://172.16.20.50:2345/api/components?reorderStatus=critical" | jq .
```

**Completion Criteria**:
- [ ] API route compiles without errors
- [ ] ReorderStatus filtering works correctly
- [ ] Pagination returns correct total count
- [ ] Non-reorderStatus queries still work

---

## Phase 3: Page Component Refactoring

### Subtask 3.1: Update Components Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/components/page.tsx`
**Pattern**: Follow same pattern as API route
**Instructions**:

1. Import the new function:
```typescript
import {
  getComponentQuantities,
  calculateReorderStatus,
  getCompanySettings,
  getComponentsWithReorderStatus  // Add this
} from '@/services/inventory'
```

2. Refactor the `getComponents()` function (lines 27-158):
   - Replace the `if (params.reorderStatus)` block (lines 61-110) with call to `getComponentsWithReorderStatus()`
   - Keep the non-reorderStatus path unchanged

3. The refactored reorderStatus block:
```typescript
if (params.reorderStatus) {
  const result = await getComponentsWithReorderStatus({
    companyId: selectedCompanyId,
    page: params.page,
    pageSize: params.pageSize,
    sortBy: params.sortBy,
    sortOrder: params.sortOrder,
    search: params.search,
    category: params.category,
    isActive: true, // Page hardcodes isActive: true
    reorderStatus: params.reorderStatus as 'critical' | 'warning' | 'ok',
    locationId: params.locationId,
    reorderWarningMultiplier: settings.reorderWarningMultiplier,
  })

  return {
    components: result.data,
    total: result.total,
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Page compiles without errors
- [ ] Server-side rendering works
- [ ] ReorderStatus filter works on the UI

---

## Phase 4: Testing

### Subtask 4.1: Add Unit Tests for New Service Function
**File**: `/home/pbrown/SkuInventory/tests/unit/inventory-reorder-status.test.ts` (NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/tests/unit/inventory-service.test.ts`
**Instructions**:

1. Create new test file with tests for:
   - `getComponentsWithReorderStatus()` returns correct status values
   - Filtering by 'critical' returns only critical items
   - Filtering by 'warning' returns only warning items
   - Filtering by 'ok' returns only ok items
   - Pagination works correctly with reorderStatus filter
   - Location filtering works with reorderStatus

2. Test cases:
```typescript
describe('getComponentsWithReorderStatus', () => {
  it('calculates critical status when quantity <= reorderPoint')
  it('calculates warning status when quantity <= reorderPoint * multiplier')
  it('calculates ok status when quantity > reorderPoint * multiplier')
  it('filters to only critical components when requested')
  it('returns correct total count for pagination')
  it('applies location filter correctly')
})
```

**Validation Commands**:
```bash
npm test -- --filter="reorder-status"
```

**Completion Criteria**:
- [ ] Tests cover all status cases
- [ ] Tests pass
- [ ] Edge cases covered (zero reorderPoint, negative quantities)

### Subtask 4.2: Integration Test for API Endpoint
**File**: Extend existing test or add to `/home/pbrown/SkuInventory/tests/integration/component-api.test.ts` (if exists) or create new
**Instructions**:

1. Add integration test that:
   - Seeds test data with known quantities and reorder points
   - Calls `/api/components?reorderStatus=critical&page=1&pageSize=10`
   - Verifies only critical components are returned
   - Verifies total count is accurate

**Validation Commands**:
```bash
npm test -- --filter="component"
```

**Completion Criteria**:
- [ ] Integration test passes
- [ ] API returns correct filtered data

---

## Phase 5: Verification

### Subtask 5.1: End-to-End Verification
**Instructions**:

1. Build the application:
```bash
npm run build
```

2. Start test server and verify:
```bash
# Test API with reorderStatus filter
curl -s "http://172.16.20.50:2345/api/components?reorderStatus=critical&page=1&pageSize=10" | jq '.meta'

# Verify total count matches filtered count, not total component count
```

3. Verify UI:
   - Navigate to `/components`
   - Select "Critical" from status filter
   - Verify pagination shows correct total
   - Verify only critical items are displayed

**Completion Criteria**:
- [ ] Build passes without errors
- [ ] API returns correct paginated data
- [ ] UI filtering works correctly
- [ ] Performance is improved (no full-set load)

---

## Summary of Deliverables

**Files Created**: 1
- `/home/pbrown/SkuInventory/tests/unit/inventory-reorder-status.test.ts`

**Files Modified**: 3
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Add `getComponentsWithReorderStatus()`
- `/home/pbrown/SkuInventory/src/app/api/components/route.ts` - Refactor reorderStatus handling
- `/home/pbrown/SkuInventory/src/app/(dashboard)/components/page.tsx` - Refactor reorderStatus handling

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> 5)
2. Complete Phase 1 fully before Phase 2 (service layer must exist first)
3. Test completion criteria before next subtask
4. Follow existing patterns in `getComponentQuantities()` for the SQL structure
5. Handle transfer transactions carefully in location-specific queries

## Test Strategy Note
- Use Vitest for unit tests
- Run `npm test` to execute all tests
- Focus on testing the SQL logic correctness through the service function

## Technical Notes

### SQL Complexity Warning
The location-aware quantity calculation requires handling transfer transactions specially:
- Non-transfers: use `transaction.locationId`
- Transfers: negative line -> `fromLocationId`, positive line -> `toLocationId`

This is currently implemented as three separate queries in `getComponentQuantities()`. The new function can either:
1. Use three CTEs combined with UNION
2. Use conditional aggregation with CASE expressions

Recommend Option 1 (three CTEs) for clarity and maintainability.

### Performance Considerations
- Add index hint: The existing index `@@index([companyId, isActive])` on Component should be sufficient
- TransactionLine already has `@@index([componentId])`
- Consider adding `@@index([transactionId, componentId])` if performance testing shows issues

---

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 15m |
| **Total Scout-and-Plan** | **50m** |
