# Implementation Plan
**Generated**: 2025-12-09T20:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #236
**Estimated Build Time**: 4-6 hours
**Complexity**: Low

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #236 - "Phase 2: Restore feedback service with simplified CRUD operations"
**Priority**: Medium
**Dependency**: Issue #235 (Phase 1 - CLOSED - database migration complete)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED (unit tests for service + optional integration tests)
**Suggested Filter**: `--filter="feedback"` or `npm test -- --testPathPattern="feedback"`

### Issue Validation
**Status**: Valid - Phase 1 (#235) confirmed CLOSED, database models exist
**Recent Changes**: Commit 20b0d42 deleted original feedback.ts, schema has new simplified Feedback model

### Current State Assessment

**Existing Components:**
- `prisma/schema.prisma` - Feedback and EmailMonitorState models exist (lines 599-645)
- `src/types/feedback.ts` - Exists but contains only UI/API types (dialog steps, zod schemas)
- `src/services/feedback.ts` - DELETED in commit 20b0d42, needs recreation
- `src/app/api/cron/email-monitor/route.ts` - Uses in-memory `lastCheckTime` variable (not persisted)

**Database Models Available:**
```prisma
enum FeedbackStatus {
  pending           // Issue created
  resolved          // Issue closed, notification sent
  verified          // User confirmed fix
  changes_requested // User needs more work
}

model Feedback {
  id                    String         @id @default(uuid())
  userId                String
  user                  User           @relation(...)
  githubIssueNumber     Int            @unique
  githubIssueUrl        String         @db.VarChar(500)
  status                FeedbackStatus @default(pending)
  notificationSentAt    DateTime?
  notificationMessageId String?        @db.VarChar(255)
  responseReceivedAt    DateTime?
  responseEmailId       String?        @db.VarChar(255)
  responseContent       String?        @db.Text
  followUpIssueNumber   Int?
  followUpIssueUrl      String?        @db.VarChar(500)
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
}

model EmailMonitorState {
  id            String   @id @default("singleton")
  lastCheckTime DateTime @default(now())
  updatedAt     DateTime @updatedAt
}
```

**Patterns Identified:**
- **Primary**: `/home/pbrown/SkuInventory/src/services/inventory.ts` - service pattern with Prisma queries
- **Secondary**: Original deleted service from git history (`git show 7c78d8a:src/services/feedback.ts`)

### Dependencies & Blockers
1. Phase 1 (#235) MUST be complete - VERIFIED CLOSED
2. Prisma client needs to be generated after Phase 1 migration

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Simple
**Effort**: 4-6 hours
**Risk**: Low - straightforward CRUD operations with existing schema

### Ripple Effect Analysis
**Files Identified**: 4 files to create/modify

1. `/home/pbrown/SkuInventory/src/services/feedback.ts` - CREATE (new file)
2. `/home/pbrown/SkuInventory/src/types/feedback.ts` - MODIFY (add database types)
3. `/home/pbrown/SkuInventory/tests/unit/feedback-service.test.ts` - CREATE (new test file)
4. Future: `/home/pbrown/SkuInventory/src/app/api/cron/email-monitor/route.ts` - candidate for update in Phase 3 to use persisted lastCheckTime

**NO IMPORTS CURRENTLY EXIST** - The old feedback service was deleted and nothing imports from `@/services/feedback`. This is a clean new implementation.

---

## Executive Summary

This issue creates a new feedback service (`src/services/feedback.ts`) with CRUD operations for the Feedback database model created in Phase 1. The service provides functions to create, retrieve, and update feedback records, plus utilities for querying pending/resolved feedback and managing email monitor state. Unit tests will validate the service functions.

---

## Phase 1: Update Types

### Subtask 1.1: Add FeedbackStatus Type and Database Record Types

**File**: `/home/pbrown/SkuInventory/src/types/feedback.ts`
**Pattern**: Follow existing type definitions at top of file
**Action**: APPEND new types after existing exports (do NOT modify existing types)

**Instructions**:
1. Add FeedbackStatus type alias matching Prisma enum
2. Add FeedbackRecord interface for database records (with user name/email from relation)
3. Add CreateFeedbackInput interface
4. Add UpdateFeedbackInput interface

**Code to Add** (append after line 63):
```typescript
// ============================================
// Database Types (for Phase 2 feedback service)
// ============================================

// Feedback status enum (matches Prisma FeedbackStatus)
export type FeedbackStatus = 'pending' | 'resolved' | 'verified' | 'changes_requested'

// Database record type (returned from service functions)
export interface FeedbackRecord {
  id: string
  userId: string
  userName?: string
  userEmail?: string
  githubIssueNumber: number
  githubIssueUrl: string
  status: FeedbackStatus
  notificationSentAt: string | null
  notificationMessageId: string | null
  responseReceivedAt: string | null
  responseEmailId: string | null
  responseContent: string | null
  followUpIssueNumber: number | null
  followUpIssueUrl: string | null
  createdAt: string
  updatedAt: string
}

// Input type for creating feedback records
export interface CreateFeedbackInput {
  userId: string
  githubIssueNumber: number
  githubIssueUrl: string
}

// Input type for updating feedback records
export interface UpdateFeedbackInput {
  status?: FeedbackStatus
  notificationSentAt?: Date
  notificationMessageId?: string
  responseReceivedAt?: Date
  responseEmailId?: string
  responseContent?: string
  followUpIssueNumber?: number
  followUpIssueUrl?: string
}
```

**Completion Criteria**:
- [ ] FeedbackStatus type matches Prisma enum values
- [ ] FeedbackRecord interface has all fields from schema
- [ ] CreateFeedbackInput has minimal required fields
- [ ] UpdateFeedbackInput has optional fields for partial updates
- [ ] `npx tsc --noEmit` passes

---

## Phase 2: Create Feedback Service

### Subtask 2.1: Create Feedback Service File

**File**: `/home/pbrown/SkuInventory/src/services/feedback.ts` (CREATE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/inventory.ts` structure

**Instructions**:
1. Create new file at specified path
2. Import prisma from `@/lib/db`
3. Import types from `@/types/feedback`
4. Implement all required functions per issue specification

**Complete File Content**:
```typescript
/**
 * Feedback Service
 *
 * Provides CRUD operations for feedback tracking:
 * - Creating feedback records linked to GitHub issues
 * - Retrieving feedback by ID or issue number
 * - Updating feedback status through resolution workflow
 * - Managing email monitor state persistence
 */

import { prisma } from '@/lib/db'
import type {
  FeedbackRecord,
  FeedbackStatus,
  CreateFeedbackInput,
  UpdateFeedbackInput,
} from '@/types/feedback'

/**
 * Helper to transform Prisma Feedback to FeedbackRecord
 */
function toFeedbackRecord(
  feedback: {
    id: string
    userId: string
    githubIssueNumber: number
    githubIssueUrl: string
    status: string
    notificationSentAt: Date | null
    notificationMessageId: string | null
    responseReceivedAt: Date | null
    responseEmailId: string | null
    responseContent: string | null
    followUpIssueNumber: number | null
    followUpIssueUrl: string | null
    createdAt: Date
    updatedAt: Date
    user?: { name: string; email: string }
  }
): FeedbackRecord {
  return {
    id: feedback.id,
    userId: feedback.userId,
    userName: feedback.user?.name,
    userEmail: feedback.user?.email,
    githubIssueNumber: feedback.githubIssueNumber,
    githubIssueUrl: feedback.githubIssueUrl,
    status: feedback.status as FeedbackStatus,
    notificationSentAt: feedback.notificationSentAt?.toISOString() ?? null,
    notificationMessageId: feedback.notificationMessageId,
    responseReceivedAt: feedback.responseReceivedAt?.toISOString() ?? null,
    responseEmailId: feedback.responseEmailId,
    responseContent: feedback.responseContent,
    followUpIssueNumber: feedback.followUpIssueNumber,
    followUpIssueUrl: feedback.followUpIssueUrl,
    createdAt: feedback.createdAt.toISOString(),
    updatedAt: feedback.updatedAt.toISOString(),
  }
}

/**
 * Create a new feedback record
 */
export async function createFeedback(input: CreateFeedbackInput): Promise<FeedbackRecord> {
  const feedback = await prisma.feedback.create({
    data: {
      userId: input.userId,
      githubIssueNumber: input.githubIssueNumber,
      githubIssueUrl: input.githubIssueUrl,
      status: 'pending',
    },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
  })

  return toFeedbackRecord(feedback)
}

/**
 * Get feedback by GitHub issue number
 */
export async function getFeedbackByIssueNumber(
  issueNumber: number
): Promise<FeedbackRecord | null> {
  const feedback = await prisma.feedback.findUnique({
    where: { githubIssueNumber: issueNumber },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
  })

  if (!feedback) return null
  return toFeedbackRecord(feedback)
}

/**
 * Get feedback by ID
 */
export async function getFeedbackById(id: string): Promise<FeedbackRecord | null> {
  const feedback = await prisma.feedback.findUnique({
    where: { id },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
  })

  if (!feedback) return null
  return toFeedbackRecord(feedback)
}

/**
 * Update feedback status and related fields
 */
export async function updateFeedbackStatus(
  id: string,
  input: UpdateFeedbackInput
): Promise<FeedbackRecord> {
  const feedback = await prisma.feedback.update({
    where: { id },
    data: {
      ...(input.status && { status: input.status }),
      ...(input.notificationSentAt && { notificationSentAt: input.notificationSentAt }),
      ...(input.notificationMessageId && { notificationMessageId: input.notificationMessageId }),
      ...(input.responseReceivedAt && { responseReceivedAt: input.responseReceivedAt }),
      ...(input.responseEmailId && { responseEmailId: input.responseEmailId }),
      ...(input.responseContent !== undefined && { responseContent: input.responseContent }),
      ...(input.followUpIssueNumber && { followUpIssueNumber: input.followUpIssueNumber }),
      ...(input.followUpIssueUrl && { followUpIssueUrl: input.followUpIssueUrl }),
    },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
  })

  return toFeedbackRecord(feedback)
}

/**
 * Get all feedback in 'pending' status
 * Used for verification reminder workflows
 */
export async function getPendingFeedback(): Promise<FeedbackRecord[]> {
  const feedbacks = await prisma.feedback.findMany({
    where: { status: 'pending' },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
    orderBy: { createdAt: 'desc' },
  })

  return feedbacks.map(toFeedbackRecord)
}

/**
 * Get all feedback in 'resolved' status
 * Used by email monitoring to match incoming replies
 */
export async function getResolvedFeedback(): Promise<FeedbackRecord[]> {
  const feedbacks = await prisma.feedback.findMany({
    where: { status: 'resolved' },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
    orderBy: { updatedAt: 'desc' },
  })

  return feedbacks.map(toFeedbackRecord)
}

// ============================================
// Email Monitor State Management
// ============================================

const SINGLETON_ID = 'singleton'

/**
 * Get the last email check time
 * Returns the current time if no state exists (first run)
 */
export async function getLastCheckTime(): Promise<Date> {
  const state = await prisma.emailMonitorState.findUnique({
    where: { id: SINGLETON_ID },
  })

  if (!state) {
    // First run - return 15 minutes ago as default
    return new Date(Date.now() - 15 * 60 * 1000)
  }

  return state.lastCheckTime
}

/**
 * Update the last email check time
 * Creates the singleton record if it doesn't exist
 */
export async function updateLastCheckTime(time: Date): Promise<void> {
  await prisma.emailMonitorState.upsert({
    where: { id: SINGLETON_ID },
    create: {
      id: SINGLETON_ID,
      lastCheckTime: time,
    },
    update: {
      lastCheckTime: time,
    },
  })
}
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] All 8 functions exported: createFeedback, getFeedbackByIssueNumber, getFeedbackById, updateFeedbackStatus, getPendingFeedback, getResolvedFeedback, getLastCheckTime, updateLastCheckTime
- [ ] Helper function toFeedbackRecord properly transforms Prisma types
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` passes

---

## Phase 3: Create Unit Tests

### Subtask 3.1: Create Feedback Service Unit Tests

**File**: `/home/pbrown/SkuInventory/tests/unit/feedback-service.test.ts` (CREATE)
**Pattern**: Follow `/home/pbrown/SkuInventory/tests/unit/inventory-service.test.ts` structure

**Instructions**:
1. Create new test file
2. Mock prisma client for unit tests (no database required)
3. Test all exported functions
4. Focus on testing business logic and data transformations

**Complete Test File Content**:
```typescript
/**
 * Unit tests for the feedback service
 *
 * Tests CRUD operations and data transformations.
 * Uses mocked Prisma client - no database required.
 */
import { describe, it, expect, vi, beforeEach } from 'vitest'

// Mock prisma before importing service
vi.mock('@/lib/db', () => ({
  prisma: {
    feedback: {
      create: vi.fn(),
      findUnique: vi.fn(),
      findMany: vi.fn(),
      update: vi.fn(),
    },
    emailMonitorState: {
      findUnique: vi.fn(),
      upsert: vi.fn(),
    },
  },
}))

import { prisma } from '@/lib/db'
import {
  createFeedback,
  getFeedbackByIssueNumber,
  getFeedbackById,
  updateFeedbackStatus,
  getPendingFeedback,
  getResolvedFeedback,
  getLastCheckTime,
  updateLastCheckTime,
} from '@/services/feedback'
import type { FeedbackStatus } from '@/types/feedback'

// Type assertion for mocked prisma
const mockPrisma = prisma as unknown as {
  feedback: {
    create: ReturnType<typeof vi.fn>
    findUnique: ReturnType<typeof vi.fn>
    findMany: ReturnType<typeof vi.fn>
    update: ReturnType<typeof vi.fn>
  }
  emailMonitorState: {
    findUnique: ReturnType<typeof vi.fn>
    upsert: ReturnType<typeof vi.fn>
  }
}

// Test fixtures
const mockDate = new Date('2025-12-09T12:00:00Z')
const mockUser = { name: 'Test User', email: 'test@example.com' }

const mockFeedbackDb = {
  id: 'feedback-123',
  userId: 'user-456',
  githubIssueNumber: 100,
  githubIssueUrl: 'https://github.com/org/repo/issues/100',
  status: 'pending' as const,
  notificationSentAt: null,
  notificationMessageId: null,
  responseReceivedAt: null,
  responseEmailId: null,
  responseContent: null,
  followUpIssueNumber: null,
  followUpIssueUrl: null,
  createdAt: mockDate,
  updatedAt: mockDate,
  user: mockUser,
}

describe('Feedback Service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('createFeedback', () => {
    it('creates a feedback record with pending status', async () => {
      mockPrisma.feedback.create.mockResolvedValue(mockFeedbackDb)

      const result = await createFeedback({
        userId: 'user-456',
        githubIssueNumber: 100,
        githubIssueUrl: 'https://github.com/org/repo/issues/100',
      })

      expect(mockPrisma.feedback.create).toHaveBeenCalledWith({
        data: {
          userId: 'user-456',
          githubIssueNumber: 100,
          githubIssueUrl: 'https://github.com/org/repo/issues/100',
          status: 'pending',
        },
        include: {
          user: {
            select: { name: true, email: true },
          },
        },
      })

      expect(result.id).toBe('feedback-123')
      expect(result.status).toBe('pending')
      expect(result.userName).toBe('Test User')
      expect(result.userEmail).toBe('test@example.com')
    })

    it('converts Date fields to ISO strings', async () => {
      mockPrisma.feedback.create.mockResolvedValue(mockFeedbackDb)

      const result = await createFeedback({
        userId: 'user-456',
        githubIssueNumber: 100,
        githubIssueUrl: 'https://github.com/org/repo/issues/100',
      })

      expect(result.createdAt).toBe('2025-12-09T12:00:00.000Z')
      expect(result.updatedAt).toBe('2025-12-09T12:00:00.000Z')
    })
  })

  describe('getFeedbackByIssueNumber', () => {
    it('returns feedback record when found', async () => {
      mockPrisma.feedback.findUnique.mockResolvedValue(mockFeedbackDb)

      const result = await getFeedbackByIssueNumber(100)

      expect(mockPrisma.feedback.findUnique).toHaveBeenCalledWith({
        where: { githubIssueNumber: 100 },
        include: {
          user: {
            select: { name: true, email: true },
          },
        },
      })

      expect(result).not.toBeNull()
      expect(result?.githubIssueNumber).toBe(100)
    })

    it('returns null when not found', async () => {
      mockPrisma.feedback.findUnique.mockResolvedValue(null)

      const result = await getFeedbackByIssueNumber(999)

      expect(result).toBeNull()
    })
  })

  describe('getFeedbackById', () => {
    it('returns feedback record when found', async () => {
      mockPrisma.feedback.findUnique.mockResolvedValue(mockFeedbackDb)

      const result = await getFeedbackById('feedback-123')

      expect(mockPrisma.feedback.findUnique).toHaveBeenCalledWith({
        where: { id: 'feedback-123' },
        include: {
          user: {
            select: { name: true, email: true },
          },
        },
      })

      expect(result).not.toBeNull()
      expect(result?.id).toBe('feedback-123')
    })

    it('returns null when not found', async () => {
      mockPrisma.feedback.findUnique.mockResolvedValue(null)

      const result = await getFeedbackById('nonexistent')

      expect(result).toBeNull()
    })
  })

  describe('updateFeedbackStatus', () => {
    it('updates status field', async () => {
      const updatedFeedback = { ...mockFeedbackDb, status: 'resolved' as const }
      mockPrisma.feedback.update.mockResolvedValue(updatedFeedback)

      const result = await updateFeedbackStatus('feedback-123', { status: 'resolved' })

      expect(mockPrisma.feedback.update).toHaveBeenCalledWith({
        where: { id: 'feedback-123' },
        data: { status: 'resolved' },
        include: {
          user: {
            select: { name: true, email: true },
          },
        },
      })

      expect(result.status).toBe('resolved')
    })

    it('updates notification fields', async () => {
      const notificationDate = new Date('2025-12-09T13:00:00Z')
      const updatedFeedback = {
        ...mockFeedbackDb,
        notificationSentAt: notificationDate,
        notificationMessageId: 'msg-789',
      }
      mockPrisma.feedback.update.mockResolvedValue(updatedFeedback)

      const result = await updateFeedbackStatus('feedback-123', {
        notificationSentAt: notificationDate,
        notificationMessageId: 'msg-789',
      })

      expect(result.notificationSentAt).toBe('2025-12-09T13:00:00.000Z')
      expect(result.notificationMessageId).toBe('msg-789')
    })

    it('updates follow-up issue fields', async () => {
      const updatedFeedback = {
        ...mockFeedbackDb,
        status: 'changes_requested' as const,
        followUpIssueNumber: 101,
        followUpIssueUrl: 'https://github.com/org/repo/issues/101',
      }
      mockPrisma.feedback.update.mockResolvedValue(updatedFeedback)

      const result = await updateFeedbackStatus('feedback-123', {
        status: 'changes_requested',
        followUpIssueNumber: 101,
        followUpIssueUrl: 'https://github.com/org/repo/issues/101',
      })

      expect(result.status).toBe('changes_requested')
      expect(result.followUpIssueNumber).toBe(101)
      expect(result.followUpIssueUrl).toBe('https://github.com/org/repo/issues/101')
    })
  })

  describe('getPendingFeedback', () => {
    it('returns array of pending feedback records', async () => {
      mockPrisma.feedback.findMany.mockResolvedValue([mockFeedbackDb])

      const result = await getPendingFeedback()

      expect(mockPrisma.feedback.findMany).toHaveBeenCalledWith({
        where: { status: 'pending' },
        include: {
          user: {
            select: { name: true, email: true },
          },
        },
        orderBy: { createdAt: 'desc' },
      })

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('pending')
    })

    it('returns empty array when no pending feedback', async () => {
      mockPrisma.feedback.findMany.mockResolvedValue([])

      const result = await getPendingFeedback()

      expect(result).toHaveLength(0)
    })
  })

  describe('getResolvedFeedback', () => {
    it('returns array of resolved feedback records', async () => {
      const resolvedFeedback = { ...mockFeedbackDb, status: 'resolved' as const }
      mockPrisma.feedback.findMany.mockResolvedValue([resolvedFeedback])

      const result = await getResolvedFeedback()

      expect(mockPrisma.feedback.findMany).toHaveBeenCalledWith({
        where: { status: 'resolved' },
        include: {
          user: {
            select: { name: true, email: true },
          },
        },
        orderBy: { updatedAt: 'desc' },
      })

      expect(result).toHaveLength(1)
      expect(result[0].status).toBe('resolved')
    })
  })

  describe('Email Monitor State', () => {
    describe('getLastCheckTime', () => {
      it('returns stored time when state exists', async () => {
        const storedTime = new Date('2025-12-09T11:00:00Z')
        mockPrisma.emailMonitorState.findUnique.mockResolvedValue({
          id: 'singleton',
          lastCheckTime: storedTime,
          updatedAt: storedTime,
        })

        const result = await getLastCheckTime()

        expect(mockPrisma.emailMonitorState.findUnique).toHaveBeenCalledWith({
          where: { id: 'singleton' },
        })
        expect(result).toEqual(storedTime)
      })

      it('returns default time (15 min ago) when no state exists', async () => {
        mockPrisma.emailMonitorState.findUnique.mockResolvedValue(null)

        const before = Date.now()
        const result = await getLastCheckTime()
        const after = Date.now()

        // Should be approximately 15 minutes before now
        const fifteenMinMs = 15 * 60 * 1000
        expect(result.getTime()).toBeGreaterThanOrEqual(before - fifteenMinMs - 1000)
        expect(result.getTime()).toBeLessThanOrEqual(after - fifteenMinMs + 1000)
      })
    })

    describe('updateLastCheckTime', () => {
      it('upserts the singleton state record', async () => {
        const newTime = new Date('2025-12-09T12:30:00Z')
        mockPrisma.emailMonitorState.upsert.mockResolvedValue({
          id: 'singleton',
          lastCheckTime: newTime,
          updatedAt: newTime,
        })

        await updateLastCheckTime(newTime)

        expect(mockPrisma.emailMonitorState.upsert).toHaveBeenCalledWith({
          where: { id: 'singleton' },
          create: {
            id: 'singleton',
            lastCheckTime: newTime,
          },
          update: {
            lastCheckTime: newTime,
          },
        })
      })
    })
  })

  describe('Status Transitions', () => {
    it.each([
      ['pending', 'resolved'],
      ['resolved', 'verified'],
      ['resolved', 'changes_requested'],
    ] as const)('allows transition from %s to %s', async (from, to) => {
      const feedbackWithStatus = { ...mockFeedbackDb, status: to }
      mockPrisma.feedback.update.mockResolvedValue(feedbackWithStatus)

      const result = await updateFeedbackStatus('feedback-123', { status: to as FeedbackStatus })

      expect(result.status).toBe(to)
    })
  })
})
```

**Completion Criteria**:
- [ ] Test file created at correct path
- [ ] All 8 service functions have test coverage
- [ ] Prisma is properly mocked
- [ ] Tests cover success cases and edge cases
- [ ] `npm test -- --testPathPattern="feedback-service"` passes
- [ ] All tests pass with `npm test`

---

## Summary of Deliverables

**Files Created**: 2
- `/home/pbrown/SkuInventory/src/services/feedback.ts` (new service file)
- `/home/pbrown/SkuInventory/tests/unit/feedback-service.test.ts` (new test file)

**Files Modified**: 1
- `/home/pbrown/SkuInventory/src/types/feedback.ts` (add database types)

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3)
2. Types must be added BEFORE creating the service (compile dependency)
3. Run `npx tsc --noEmit` after each phase to verify compilation
4. Run `npm run build` after Phase 2 to verify full build
5. Run `npm test -- --testPathPattern="feedback-service"` after Phase 3
6. Follow reference patterns exactly for consistency

---

## Test Strategy Note

- Use Vitest for unit tests
- Tests mock Prisma client (no database connection needed for unit tests)
- Integration tests not required for this issue (could be added in Phase 4 if desired)
- Run full test suite before completing: `npm test`

---

## Post-Implementation Notes

**Future Phase 3 Work** (not part of this issue):
The email-monitor route (`/home/pbrown/SkuInventory/src/app/api/cron/email-monitor/route.ts`) currently uses an in-memory `lastCheckTime` variable (line 25). Phase 3 could update it to use the new `getLastCheckTime()` and `updateLastCheckTime()` functions from the feedback service for persistence across server restarts.

---

## Performance Metrics

| Phase | Estimated Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 20m |
| **Total Scout-Plan** | **40m** |
| **Estimated Build** | **3-4h** |
