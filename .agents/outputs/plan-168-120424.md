# Implementation Plan
**Generated**: 2024-12-04 20:05 UTC
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #168
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #168 - Add Category management to Settings (CRUD for component categories)
**Priority**: Medium

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="category|Category"`

### Issue Validation
**Status**: Valid
**Recent Changes**: None affecting categories - category is currently hardcoded

### Current State Assessment

#### How Categories Work Today
1. **Database**: `Component.category` is a free-text `VARCHAR(50)` field (line 166 in `prisma/schema.prisma`)
2. **Frontend**: Categories are hardcoded in `src/components/features/ComponentForm.tsx` (lines 23-29):
   ```typescript
   const CATEGORIES = [
     { value: 'packaging', label: 'Packaging' },
     { value: 'tool', label: 'Tool' },
     { value: 'documentation', label: 'Documentation' },
     { value: 'accessory', label: 'Accessory' },
     { value: 'other', label: 'Other' },
   ]
   ```
3. **No Category table exists** - needs to be created
4. **No Category API routes exist** - needs to be created

#### Related Existing Implementations (Patterns to Follow)
- **Brand Management** (PRIMARY PATTERN):
  - Page: `src/app/(dashboard)/settings/brands/page.tsx`
  - API: `src/app/api/brands/route.ts` and `src/app/api/brands/[id]/route.ts`
  - Table: `src/components/features/BrandTable.tsx`
  - Form: `src/components/features/BrandForm.tsx`
  - Types: `src/types/brand.ts`
- **Navigation**: `src/app/(dashboard)/layout.tsx` (line 33-48 for nav array)

### Dependencies & Blockers

1. **Decision Required**: Should we migrate existing category strings to FK references?
   - **Recommendation**: NO - Keep `Component.category` as string initially
   - Add `Category` table for management
   - Update `ComponentForm` to fetch categories from API
   - Migration to FK can be a future enhancement (avoids breaking changes)

2. **No External Dependencies**: No new packages required

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 6-8 hours
**Risk**: Low (follows established patterns, no breaking changes)

### Patterns Identified
**Primary**: Brand CRUD implementation
- `src/app/api/brands/route.ts` - API pattern for list/create
- `src/app/api/brands/[id]/route.ts` - API pattern for get/update/delete
- `src/types/brand.ts` - Type definitions with Zod schemas
- `src/components/features/BrandForm.tsx` - Form component pattern
- `src/components/features/BrandTable.tsx` - Table component pattern
- `src/app/(dashboard)/settings/brands/page.tsx` - Page layout pattern

**Secondary**: Location management (for soft-delete pattern)
- `src/app/(dashboard)/settings/locations/page.tsx`

### Ripple Effect Analysis
**Files Identified**: 3 files need modification, 9 new files to create

**Files to Modify**:
1. `prisma/schema.prisma` - Add Category model
2. `src/app/(dashboard)/layout.tsx` - Add Categories nav link
3. `src/components/features/ComponentForm.tsx` - Fetch categories from API instead of hardcoded

**Files to Create**:
1. `src/types/category.ts` - Type definitions
2. `src/app/api/categories/route.ts` - GET (list) and POST (create)
3. `src/app/api/categories/[id]/route.ts` - GET, PATCH, DELETE
4. `src/components/features/CategoryTable.tsx` - Table component
5. `src/components/features/CategoryForm.tsx` - Form component
6. `src/app/(dashboard)/settings/categories/page.tsx` - List page
7. `src/app/(dashboard)/settings/categories/new/page.tsx` - Create page
8. `src/app/(dashboard)/settings/categories/[id]/edit/page.tsx` - Edit page

---

## Executive Summary

Add a Category management page under Settings allowing admins to CRUD categories. This involves:
1. Creating a new `Category` model in Prisma (company-scoped, with isActive flag)
2. Building API routes following the Brand pattern
3. Creating frontend components (table, form, pages)
4. Updating ComponentForm to fetch categories dynamically
5. Adding Categories link to navigation sidebar

---

## Phase 1: Database/Types Layer

### Subtask 1.1: Add Category Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow `Brand` model structure (lines 67-81)
**Instructions**:

1. Add the Category model after the Brand model (around line 82):
```prisma
model Category {
  id        String   @id @default(uuid())
  companyId String
  company   Company  @relation(fields: [companyId], references: [id])
  name      String   @db.VarChar(50)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, name])
  @@index([companyId, isActive])
}
```

2. Add the `categories` relation to the `Company` model (after line 21, with other relations):
```prisma
  categories       Category[]
```

3. Run migration:
```bash
npx prisma migrate dev --name add_category_model
```

4. Generate client:
```bash
npx prisma generate
```

**Validation**:
```bash
npx prisma validate
npx prisma generate
```

**Completion Criteria**:
- [ ] Category model added to schema
- [ ] Company relation added
- [ ] Migration runs successfully
- [ ] Prisma client generates without errors

### Subtask 1.2: Create Category Type Definitions
**File**: `/home/pbrown/SkuInventory/src/types/category.ts` (NEW FILE)
**Pattern**: Follow `src/types/brand.ts` exactly
**Instructions**:

Create the file with these contents:
```typescript
import { z } from 'zod'

// Category create schema (admin only)
export const createCategorySchema = z.object({
  name: z.string().min(1, 'Name is required').max(50, 'Name must be 50 characters or less'),
})

export type CreateCategoryInput = z.infer<typeof createCategorySchema>

// Category update schema (admin only)
export const updateCategorySchema = z.object({
  name: z.string().min(1, 'Name is required').max(50).optional(),
  isActive: z.boolean().optional(),
})

export type UpdateCategoryInput = z.infer<typeof updateCategorySchema>

// Category list query schema
export const categoryListQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  pageSize: z.coerce.number().int().positive().max(100).default(50),
  search: z.string().optional(),
  isActive: z
    .string()
    .transform((val) => val === 'true')
    .optional(),
  sortBy: z.enum(['name', 'createdAt']).default('name'),
  sortOrder: z.enum(['asc', 'desc']).default('asc'),
})

export type CategoryListQuery = z.infer<typeof categoryListQuerySchema>

// Category response type (what API returns)
export interface CategoryResponse {
  id: string
  name: string
  isActive: boolean
  companyId?: string
  companyName?: string
  componentCount: number
  createdAt: string
  updatedAt: string
}

// Category list response type
export interface CategoryListResponse {
  data: CategoryResponse[]
  meta: {
    page: number
    pageSize: number
    total: number
    totalPages: number
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with all schemas and types
- [ ] TypeScript compiles without errors

---

## Phase 2: API Routes

### Subtask 2.1: Create Categories List/Create API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/categories/route.ts` (NEW FILE)
**Pattern**: Follow `src/app/api/brands/route.ts` exactly
**Instructions**:

Create the file with these contents:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'
import { createCategorySchema, categoryListQuerySchema } from '@/types/category'

// GET /api/categories - List categories (admin only)
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const searchParams = Object.fromEntries(request.nextUrl.searchParams)
    const validation = categoryListQuerySchema.safeParse(searchParams)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Invalid query parameters', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    const { page, pageSize, search, isActive, sortBy, sortOrder } = validation.data

    // Use selected company for scoping
    const selectedCompanyId = session.user.selectedCompanyId

    // Build where clause
    const where: Prisma.CategoryWhereInput = {
      companyId: selectedCompanyId,
    }

    if (search) {
      where.name = { contains: search, mode: 'insensitive' }
    }

    if (isActive !== undefined) {
      where.isActive = isActive
    }

    // Get total count
    const total = await prisma.category.count({ where })

    // Get categories with component counts
    const categories = await prisma.category.findMany({
      where,
      select: {
        id: true,
        name: true,
        isActive: true,
        companyId: true,
        company: {
          select: {
            id: true,
            name: true,
          },
        },
        createdAt: true,
        updatedAt: true,
      },
      orderBy: {
        [sortBy]: sortOrder,
      },
      skip: (page - 1) * pageSize,
      take: pageSize,
    })

    // Count components using each category (by name match)
    const categoryNames = categories.map(c => c.name)
    const componentCounts = await prisma.component.groupBy({
      by: ['category'],
      where: {
        companyId: selectedCompanyId,
        category: { in: categoryNames },
      },
      _count: { category: true },
    })

    const countMap = new Map(componentCounts.map(c => [c.category, c._count.category]))

    return NextResponse.json({
      data: categories.map((category) => ({
        id: category.id,
        name: category.name,
        isActive: category.isActive,
        companyId: category.companyId,
        companyName: category.company?.name,
        componentCount: countMap.get(category.name) || 0,
        createdAt: category.createdAt.toISOString(),
        updatedAt: category.updatedAt.toISOString(),
      })),
      meta: {
        page,
        pageSize,
        total,
        totalPages: Math.ceil(total / pageSize),
      },
    })
  } catch (error) {
    console.error('Error listing categories:', error)
    return NextResponse.json({ error: 'Failed to list categories' }, { status: 500 })
  }
}

// POST /api/categories - Create category (admin only)
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const body = await request.json()
    const validation = createCategorySchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    const { name } = validation.data

    // Use selected company for scoping
    const selectedCompanyId = session.user.selectedCompanyId

    // Check if name already exists for this company
    const existingCategory = await prisma.category.findFirst({
      where: {
        companyId: selectedCompanyId,
        name,
      },
    })

    if (existingCategory) {
      return NextResponse.json(
        { error: 'A category with this name already exists' },
        { status: 409 }
      )
    }

    // Create category in the selected company
    const category = await prisma.category.create({
      data: {
        companyId: selectedCompanyId,
        name,
      },
      select: {
        id: true,
        name: true,
        isActive: true,
        createdAt: true,
        updatedAt: true,
      },
    })

    return NextResponse.json(
      {
        data: {
          id: category.id,
          name: category.name,
          isActive: category.isActive,
          componentCount: 0,
          createdAt: category.createdAt.toISOString(),
          updatedAt: category.updatedAt.toISOString(),
        },
        message: 'Category created successfully',
      },
      { status: 201 }
    )
  } catch (error) {
    console.error('Error creating category:', error)
    return NextResponse.json({ error: 'Failed to create category' }, { status: 500 })
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] GET endpoint lists categories with pagination
- [ ] POST endpoint creates new category
- [ ] Admin-only access enforced
- [ ] Company scoping works correctly
- [ ] TypeScript compiles

### Subtask 2.2: Create Category Detail API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/categories/[id]/route.ts` (NEW FILE)
**Pattern**: Follow `src/app/api/brands/[id]/route.ts` exactly
**Instructions**:

Create the file with these contents:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { updateCategorySchema } from '@/types/category'

// GET /api/categories/[id] - Get category details (admin only)
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id } = await params

    // Use selected company for scoping
    const selectedCompanyId = session.user.selectedCompanyId

    const category = await prisma.category.findUnique({
      where: {
        id,
        companyId: selectedCompanyId,
      },
      select: {
        id: true,
        name: true,
        isActive: true,
        createdAt: true,
        updatedAt: true,
      },
    })

    if (!category) {
      return NextResponse.json({ error: 'Category not found' }, { status: 404 })
    }

    // Count components using this category
    const componentCount = await prisma.component.count({
      where: {
        companyId: selectedCompanyId,
        category: category.name,
      },
    })

    return NextResponse.json({
      data: {
        id: category.id,
        name: category.name,
        isActive: category.isActive,
        componentCount,
        createdAt: category.createdAt.toISOString(),
        updatedAt: category.updatedAt.toISOString(),
      },
    })
  } catch (error) {
    console.error('Error fetching category:', error)
    return NextResponse.json({ error: 'Failed to fetch category' }, { status: 500 })
  }
}

// PATCH /api/categories/[id] - Update category (admin only)
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id } = await params
    const body = await request.json()

    // Use selected company for scoping
    const selectedCompanyId = session.user.selectedCompanyId

    const validation = updateCategorySchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    // Check if category exists and belongs to the selected company
    const existingCategory = await prisma.category.findUnique({
      where: {
        id,
        companyId: selectedCompanyId,
      },
      select: {
        id: true,
        name: true,
        isActive: true,
      },
    })

    if (!existingCategory) {
      return NextResponse.json({ error: 'Category not found' }, { status: 404 })
    }

    const oldName = existingCategory.name

    // Check name uniqueness if being changed
    if (validation.data.name && validation.data.name !== existingCategory.name) {
      const nameExists = await prisma.category.findFirst({
        where: {
          companyId: selectedCompanyId,
          name: validation.data.name,
          id: { not: id },
        },
      })

      if (nameExists) {
        return NextResponse.json(
          { error: 'A category with this name already exists' },
          { status: 409 }
        )
      }
    }

    // Prepare update data
    const updateData: Parameters<typeof prisma.category.update>[0]['data'] = {}

    if (validation.data.name) updateData.name = validation.data.name
    if (validation.data.isActive !== undefined) updateData.isActive = validation.data.isActive

    // Update category
    const category = await prisma.category.update({
      where: { id },
      data: updateData,
      select: {
        id: true,
        name: true,
        isActive: true,
        createdAt: true,
        updatedAt: true,
      },
    })

    // If name changed, update all components using the old category name
    if (validation.data.name && validation.data.name !== oldName) {
      await prisma.component.updateMany({
        where: {
          companyId: selectedCompanyId,
          category: oldName,
        },
        data: {
          category: validation.data.name,
        },
      })
    }

    // Count components
    const componentCount = await prisma.component.count({
      where: {
        companyId: selectedCompanyId,
        category: category.name,
      },
    })

    return NextResponse.json({
      data: {
        id: category.id,
        name: category.name,
        isActive: category.isActive,
        componentCount,
        createdAt: category.createdAt.toISOString(),
        updatedAt: category.updatedAt.toISOString(),
      },
      message: 'Category updated successfully',
    })
  } catch (error) {
    console.error('Error updating category:', error)
    return NextResponse.json({ error: 'Failed to update category' }, { status: 500 })
  }
}

// DELETE /api/categories/[id] - Delete category (admin only, soft delete)
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id } = await params

    // Use selected company for scoping
    const selectedCompanyId = session.user.selectedCompanyId

    // Check if category exists and belongs to the selected company
    const existingCategory = await prisma.category.findUnique({
      where: {
        id,
        companyId: selectedCompanyId,
      },
      select: {
        id: true,
        name: true,
      },
    })

    if (!existingCategory) {
      return NextResponse.json({ error: 'Category not found' }, { status: 404 })
    }

    // Check for associated components
    const componentCount = await prisma.component.count({
      where: {
        companyId: selectedCompanyId,
        category: existingCategory.name,
      },
    })

    if (componentCount > 0) {
      return NextResponse.json(
        {
          error: `Cannot delete category with ${componentCount} component(s). Consider deactivating instead.`,
        },
        { status: 400 }
      )
    }

    // Soft delete by setting isActive=false
    await prisma.category.update({
      where: { id },
      data: { isActive: false },
    })

    return NextResponse.json({ message: 'Category deleted successfully' })
  } catch (error) {
    console.error('Error deleting category:', error)
    return NextResponse.json({ error: 'Failed to delete category' }, { status: 500 })
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] GET endpoint returns category details
- [ ] PATCH endpoint updates category (and cascades name changes to components)
- [ ] DELETE endpoint soft-deletes (prevents if components exist)
- [ ] TypeScript compiles

---

## Phase 3: Frontend Components

### Subtask 3.1: Create CategoryTable Component
**File**: `/home/pbrown/SkuInventory/src/components/features/CategoryTable.tsx` (NEW FILE)
**Pattern**: Follow `src/components/features/BrandTable.tsx` exactly
**Instructions**:

Create the file with these contents:
```typescript
'use client'

import { useState } from 'react'
import Link from 'next/link'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import { MoreHorizontal, Edit, Trash2, Power, PowerOff } from 'lucide-react'
import type { CategoryResponse } from '@/types/category'

interface CategoryTableProps {
  categories: CategoryResponse[]
  onRefresh: () => void
}

export function CategoryTable({ categories, onRefresh }: CategoryTableProps) {
  const [categoryToDelete, setCategoryToDelete] = useState<CategoryResponse | null>(null)
  const [isDeleting, setIsDeleting] = useState(false)
  const [actionError, setActionError] = useState<string | null>(null)

  const handleToggleActive = async (category: CategoryResponse) => {
    setActionError(null)
    try {
      const res = await fetch(`/api/categories/${category.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ isActive: !category.isActive }),
      })

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.error || 'Failed to toggle category status')
      }

      onRefresh()
    } catch (error) {
      setActionError(error instanceof Error ? error.message : 'Failed to toggle category status')
    }
  }

  const handleDelete = async () => {
    if (!categoryToDelete) return

    setIsDeleting(true)
    setActionError(null)
    try {
      const res = await fetch(`/api/categories/${categoryToDelete.id}`, {
        method: 'DELETE',
      })

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.error || 'Failed to delete category')
      }

      onRefresh()
    } catch (error) {
      setActionError(error instanceof Error ? error.message : 'Failed to delete category')
    } finally {
      setIsDeleting(false)
      setCategoryToDelete(null)
    }
  }

  if (categories.length === 0) {
    return (
      <div className="py-10 text-center text-muted-foreground">
        No categories found.
      </div>
    )
  }

  return (
    <>
      {actionError && (
        <div className="mb-4 rounded-md bg-destructive/10 p-3 text-sm text-destructive">
          {actionError}
        </div>
      )}

      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Name</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Components</TableHead>
              <TableHead className="w-[70px]" />
            </TableRow>
          </TableHeader>
          <TableBody>
            {categories.map((category) => (
              <TableRow key={category.id}>
                <TableCell className="font-medium">
                  {category.name}
                </TableCell>
                <TableCell>
                  <Badge variant={category.isActive ? 'success' : 'secondary'}>
                    {category.isActive ? 'Active' : 'Inactive'}
                  </Badge>
                </TableCell>
                <TableCell>{category.componentCount}</TableCell>
                <TableCell>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="icon">
                        <MoreHorizontal className="h-4 w-4" />
                        <span className="sr-only">Open menu</span>
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem asChild>
                        <Link href={`/settings/categories/${category.id}/edit`}>
                          <Edit className="mr-2 h-4 w-4" />
                          Edit
                        </Link>
                      </DropdownMenuItem>
                      <DropdownMenuItem onClick={() => handleToggleActive(category)}>
                        {category.isActive ? (
                          <>
                            <PowerOff className="mr-2 h-4 w-4" />
                            Deactivate
                          </>
                        ) : (
                          <>
                            <Power className="mr-2 h-4 w-4" />
                            Activate
                          </>
                        )}
                      </DropdownMenuItem>
                      <DropdownMenuItem
                        className="text-destructive"
                        onClick={() => setCategoryToDelete(category)}
                      >
                        <Trash2 className="mr-2 h-4 w-4" />
                        Delete
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>

      <AlertDialog open={!!categoryToDelete} onOpenChange={() => setCategoryToDelete(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Category</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete <strong>{categoryToDelete?.name}</strong>?
              {categoryToDelete && categoryToDelete.componentCount > 0 ? (
                <span className="block mt-2 text-destructive">
                  This category has {categoryToDelete.componentCount} component(s).
                  You must remove or reassign them before deleting.
                </span>
              ) : (
                <span className="block mt-2">
                  This will deactivate the category and it will no longer be available for new items.
                </span>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              disabled={isDeleting}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Component renders category list in table
- [ ] Edit, Delete, Activate/Deactivate actions work
- [ ] TypeScript compiles

### Subtask 3.2: Create CategoryForm Component
**File**: `/home/pbrown/SkuInventory/src/components/features/CategoryForm.tsx` (NEW FILE)
**Pattern**: Follow `src/components/features/BrandForm.tsx` exactly
**Instructions**:

Create the file with these contents:
```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import type { CategoryResponse } from '@/types/category'

interface CategoryFormProps {
  category?: CategoryResponse
  onSuccess?: () => void
}

export function CategoryForm({ category, onSuccess }: CategoryFormProps) {
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const [formData, setFormData] = useState({
    name: category?.name ?? '',
    isActive: category?.isActive ?? true,
  })

  const isEditing = !!category

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError(null)

    try {
      const url = isEditing ? `/api/categories/${category.id}` : '/api/categories'
      const method = isEditing ? 'PATCH' : 'POST'

      // Build request body
      const body: Record<string, unknown> = {
        name: formData.name,
      }

      if (isEditing) {
        body.isActive = formData.isActive
      }

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      })

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.error || 'Failed to save category')
      }

      if (onSuccess) {
        onSuccess()
      } else {
        router.push('/settings/categories')
        router.refresh()
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <Card>
        <CardHeader>
          <CardTitle>{isEditing ? 'Edit Category' : 'Create Category'}</CardTitle>
          <CardDescription>
            {isEditing
              ? 'Update category information'
              : 'Add a new category for your components'}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && (
            <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
              {error}
            </div>
          )}

          <div className="space-y-2">
            <Label htmlFor="name">Name *</Label>
            <Input
              id="name"
              placeholder="Category Name"
              value={formData.name}
              onChange={(e) => setFormData((prev) => ({ ...prev, name: e.target.value }))}
              required
              maxLength={50}
            />
          </div>

          {isEditing && (
            <div className="flex items-center space-x-2">
              <input
                id="isActive"
                type="checkbox"
                className="h-4 w-4 rounded border-gray-300"
                checked={formData.isActive}
                onChange={(e) =>
                  setFormData((prev) => ({ ...prev, isActive: e.target.checked }))
                }
              />
              <Label htmlFor="isActive" className="font-normal">
                Active (inactive categories cannot be used for new items)
              </Label>
            </div>
          )}

          <div className="flex justify-end gap-2 pt-4">
            <Button type="button" variant="outline" onClick={() => router.back()}>
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? 'Saving...' : isEditing ? 'Save Changes' : 'Create Category'}
            </Button>
          </div>
        </CardContent>
      </Card>
    </form>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Form handles create and edit modes
- [ ] Validation and error handling work
- [ ] TypeScript compiles

---

## Phase 4: Frontend Pages

### Subtask 4.1: Create Categories List Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/categories/page.tsx` (NEW FILE)
**Pattern**: Follow `src/app/(dashboard)/settings/brands/page.tsx` exactly
**Instructions**:

Create the directory and file:
```bash
mkdir -p src/app/\(dashboard\)/settings/categories
```

Then create the file with these contents:
```typescript
'use client'

import { useState, useEffect, useCallback } from 'react'
import Link from 'next/link'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { CategoryTable } from '@/components/features/CategoryTable'
import { FolderTree, Search } from 'lucide-react'
import type { CategoryResponse } from '@/types/category'

export default function CategoriesPage() {
  const [categories, setCategories] = useState<CategoryResponse[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [search, setSearch] = useState('')
  const [activeFilter, setActiveFilter] = useState<string>('')

  const fetchCategories = useCallback(async () => {
    setIsLoading(true)
    setError(null)

    try {
      const params = new URLSearchParams()
      if (search) params.set('search', search)
      if (activeFilter) params.set('isActive', activeFilter)

      const res = await fetch(`/api/categories?${params.toString()}`)
      if (!res.ok) {
        throw new Error('Failed to load categories')
      }
      const data = await res.json().catch(() => ({}))
      setCategories(data?.data || [])
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }, [search, activeFilter])

  useEffect(() => {
    fetchCategories()
  }, [fetchCategories])

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault()
    fetchCategories()
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">Category Management</h1>
          <p className="text-muted-foreground">Manage component categories</p>
        </div>
        <Button asChild>
          <Link href="/settings/categories/new">
            <FolderTree className="mr-2 h-4 w-4" />
            Add Category
          </Link>
        </Button>
      </div>

      {/* Filters */}
      <div className="flex flex-wrap items-center gap-4">
        <form onSubmit={handleSearch} className="flex gap-2">
          <div className="relative">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              type="search"
              placeholder="Search categories..."
              className="pl-8 w-[250px]"
              value={search}
              onChange={(e) => setSearch(e.target.value)}
            />
          </div>
          <Button type="submit" variant="secondary">
            Search
          </Button>
        </form>

        <Select value={activeFilter || 'all'} onValueChange={(v) => setActiveFilter(v === 'all' ? '' : v)}>
          <SelectTrigger className="w-[150px]">
            <SelectValue placeholder="All Status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Status</SelectItem>
            <SelectItem value="true">Active</SelectItem>
            <SelectItem value="false">Inactive</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Error State */}
      {error && (
        <div className="rounded-md bg-destructive/10 p-4 text-destructive">{error}</div>
      )}

      {/* Loading State */}
      {isLoading && (
        <div className="py-10 text-center text-muted-foreground">Loading categories...</div>
      )}

      {/* Category Table */}
      {!isLoading && !error && (
        <CategoryTable categories={categories} onRefresh={fetchCategories} />
      )}
    </div>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Page renders with search and filter
- [ ] Category list displays correctly
- [ ] TypeScript compiles

### Subtask 4.2: Create New Category Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/categories/new/page.tsx` (NEW FILE)
**Pattern**: Follow `src/app/(dashboard)/settings/brands/new/page.tsx` exactly
**Instructions**:

Create the directory and file:
```bash
mkdir -p src/app/\(dashboard\)/settings/categories/new
```

Then create the file with these contents:
```typescript
'use client'

import Link from 'next/link'
import { Button } from '@/components/ui/button'
import { ArrowLeft } from 'lucide-react'
import { CategoryForm } from '@/components/features/CategoryForm'

export default function NewCategoryPage() {
  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Link href="/settings/categories">
          <Button variant="ghost" size="sm">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Categories
          </Button>
        </Link>
        <h1 className="text-3xl font-bold">Create Category</h1>
      </div>

      <div className="max-w-2xl">
        <CategoryForm />
      </div>
    </div>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Page renders with form
- [ ] Navigation back to list works
- [ ] TypeScript compiles

### Subtask 4.3: Create Edit Category Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/categories/[id]/edit/page.tsx` (NEW FILE)
**Pattern**: Follow `src/app/(dashboard)/settings/brands/[id]/edit/page.tsx` exactly
**Instructions**:

Create the directory structure and file:
```bash
mkdir -p src/app/\(dashboard\)/settings/categories/\[id\]/edit
```

Then create the file with these contents:
```typescript
'use client'

import { useState, useEffect } from 'react'
import Link from 'next/link'
import { useParams } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { ArrowLeft } from 'lucide-react'
import { CategoryForm } from '@/components/features/CategoryForm'
import type { CategoryResponse } from '@/types/category'

export default function EditCategoryPage() {
  const params = useParams()
  const id = params.id as string
  const [category, setCategory] = useState<CategoryResponse | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    async function fetchCategory() {
      try {
        const res = await fetch(`/api/categories/${id}`)
        if (!res.ok) {
          throw new Error('Category not found')
        }
        const data = await res.json().catch(() => ({}))
        setCategory(data?.data)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred')
      } finally {
        setIsLoading(false)
      }
    }

    fetchCategory()
  }, [id])

  if (isLoading) {
    return (
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Link href="/settings/categories">
            <Button variant="ghost" size="sm">
              <ArrowLeft className="h-4 w-4 mr-2" />
              Back to Categories
            </Button>
          </Link>
        </div>
        <div className="py-10 text-center text-muted-foreground">Loading category...</div>
      </div>
    )
  }

  if (error || !category) {
    return (
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Link href="/settings/categories">
            <Button variant="ghost" size="sm">
              <ArrowLeft className="h-4 w-4 mr-2" />
              Back to Categories
            </Button>
          </Link>
        </div>
        <div className="rounded-md bg-destructive/10 p-4 text-destructive">
          {error || 'Category not found'}
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Link href="/settings/categories">
          <Button variant="ghost" size="sm">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Categories
          </Button>
        </Link>
        <h1 className="text-3xl font-bold">Edit Category</h1>
      </div>

      <div className="max-w-2xl">
        <CategoryForm category={category} />
      </div>
    </div>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Page loads category data
- [ ] Form pre-populates with existing data
- [ ] Navigation and error handling work
- [ ] TypeScript compiles

---

## Phase 5: Navigation & Integration

### Subtask 5.1: Add Categories Link to Sidebar Navigation
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx`
**Pattern**: Follow existing navigation items (lines 33-48)
**Instructions**:

1. Add `FolderTree` to the import from lucide-react (around line 23):
```typescript
import {
  LayoutDashboard,
  Package,
  Boxes,
  ArrowLeftRight,
  Upload,
  BarChart3,
  Settings,
  Users,
  MapPin,
  LogOut,
  Menu,
  X,
  Layers,
  Building2,
  ShoppingCart,
  TrendingDown,
  Tag,
  FolderTree,
} from 'lucide-react'
```

2. Add the Categories navigation item after Brands (around line 45), following the same pattern:
```typescript
  { name: 'Categories', href: '/settings/categories', icon: FolderTree, adminOnly: true },
```

The navigation array should now include:
```typescript
const navigation = [
  { name: 'Dashboard', href: '/', icon: LayoutDashboard },
  { name: 'Components', href: '/components', icon: Package },
  { name: 'SKUs', href: '/skus', icon: Boxes },
  { name: 'Transactions', href: '/transactions', icon: ArrowLeftRight },
  { name: 'Orders', href: '/orders', icon: ShoppingCart },
  { name: 'Lots', href: '/lots', icon: Layers },
  { name: 'Import', href: '/import', icon: Upload },
  { name: 'Analytics', href: '/analytics/defects', icon: BarChart3 },
  { name: 'Forecasts', href: '/forecasts', icon: TrendingDown },
  { name: 'Users', href: '/settings/users', icon: Users, adminOnly: true },
  { name: 'Locations', href: '/settings/locations', icon: MapPin, adminOnly: true },
  { name: 'Brands', href: '/settings/brands', icon: Tag, adminOnly: true },
  { name: 'Categories', href: '/settings/categories', icon: FolderTree, adminOnly: true },
  { name: 'Companies', href: '/settings/companies', icon: Building2, adminOnly: true },
  { name: 'Settings', href: '/settings', icon: Settings, adminOnly: true },
]
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Categories link appears in sidebar for admin users
- [ ] Link navigates to categories page
- [ ] TypeScript compiles
- [ ] Build succeeds

### Subtask 5.2: Update ComponentForm to Fetch Categories from API
**File**: `/home/pbrown/SkuInventory/src/components/features/ComponentForm.tsx`
**Pattern**: Dynamic data fetching similar to other selectors
**Instructions**:

1. Remove the hardcoded CATEGORIES constant (lines 23-29)

2. Add state and useEffect to fetch categories dynamically:

Replace the current implementation with:
```typescript
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import type { ComponentResponse } from '@/types/component'

interface CategoryOption {
  value: string
  label: string
}

interface ComponentFormProps {
  component?: ComponentResponse
  onSuccess?: () => void
}

const UNITS_OF_MEASURE = [
  { value: 'each', label: 'Each' },
  { value: 'box', label: 'Box' },
  { value: 'pack', label: 'Pack' },
  { value: 'roll', label: 'Roll' },
  { value: 'sheet', label: 'Sheet' },
]

export function ComponentForm({ component, onSuccess }: ComponentFormProps) {
  const router = useRouter()
  const isEditing = !!component

  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [categories, setCategories] = useState<CategoryOption[]>([])
  const [categoriesLoading, setCategoriesLoading] = useState(true)

  const [formData, setFormData] = useState({
    name: component?.name ?? '',
    skuCode: component?.skuCode ?? '',
    category: component?.category ?? '',
    unitOfMeasure: component?.unitOfMeasure ?? 'each',
    costPerUnit: component?.costPerUnit ?? '0',
    reorderPoint: component?.reorderPoint?.toString() ?? '0',
    leadTimeDays: component?.leadTimeDays?.toString() ?? '0',
    notes: component?.notes ?? '',
  })

  // Fetch categories on mount
  useEffect(() => {
    async function fetchCategories() {
      try {
        const res = await fetch('/api/categories?isActive=true&pageSize=100')
        if (res.ok) {
          const data = await res.json()
          const categoryOptions = (data?.data || []).map((cat: { name: string }) => ({
            value: cat.name,
            label: cat.name,
          }))
          setCategories(categoryOptions)
        }
      } catch (err) {
        console.error('Failed to fetch categories:', err)
      } finally {
        setCategoriesLoading(false)
      }
    }

    fetchCategories()
  }, [])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError(null)

    try {
      const url = isEditing ? `/api/components/${component.id}` : '/api/components'
      const method = isEditing ? 'PATCH' : 'POST'

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...formData,
          costPerUnit: parseFloat(formData.costPerUnit),
          reorderPoint: parseInt(formData.reorderPoint, 10),
          leadTimeDays: parseInt(formData.leadTimeDays, 10),
          category: formData.category || null,
          notes: formData.notes || null,
        }),
      })

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.message || 'Failed to save component')
      }

      if (onSuccess) {
        onSuccess()
      } else {
        router.push('/components')
        router.refresh()
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <Card>
        <CardHeader>
          <CardTitle>{isEditing ? 'Edit Component' : 'New Component'}</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && (
            <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
              {error}
            </div>
          )}

          <div className="grid gap-4 sm:grid-cols-2">
            <div className="space-y-2">
              <Label htmlFor="name">Name *</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData((prev) => ({ ...prev, name: e.target.value }))}
                placeholder="e.g., Medium Tool"
                required
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="skuCode">SKU Code *</Label>
              <Input
                id="skuCode"
                value={formData.skuCode}
                onChange={(e) => setFormData((prev) => ({ ...prev, skuCode: e.target.value }))}
                placeholder="e.g., TT-MED-TOOL"
                required
                disabled={isEditing}
              />
            </div>
          </div>

          <div className="grid gap-4 sm:grid-cols-2">
            <div className="space-y-2">
              <Label htmlFor="category">Category</Label>
              <Select
                value={formData.category}
                onValueChange={(value) => setFormData((prev) => ({ ...prev, category: value }))}
                disabled={categoriesLoading}
              >
                <SelectTrigger id="category">
                  <SelectValue placeholder={categoriesLoading ? 'Loading...' : 'Select a category'} />
                </SelectTrigger>
                <SelectContent>
                  {categories.map((cat) => (
                    <SelectItem key={cat.value} value={cat.value}>
                      {cat.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="unitOfMeasure">Unit of Measure</Label>
              <Select
                value={formData.unitOfMeasure}
                onValueChange={(value) =>
                  setFormData((prev) => ({ ...prev, unitOfMeasure: value }))
                }
              >
                <SelectTrigger id="unitOfMeasure">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {UNITS_OF_MEASURE.map((unit) => (
                    <SelectItem key={unit.value} value={unit.value}>
                      {unit.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          <div className="grid gap-4 sm:grid-cols-3">
            <div className="space-y-2">
              <Label htmlFor="costPerUnit">Cost per Unit ($)</Label>
              <Input
                id="costPerUnit"
                type="number"
                step="0.0001"
                min="0"
                value={formData.costPerUnit}
                onChange={(e) => setFormData((prev) => ({ ...prev, costPerUnit: e.target.value }))}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="reorderPoint">Reorder Point</Label>
              <Input
                id="reorderPoint"
                type="number"
                min="0"
                value={formData.reorderPoint}
                onChange={(e) =>
                  setFormData((prev) => ({ ...prev, reorderPoint: e.target.value }))
                }
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="leadTimeDays">Lead Time (days)</Label>
              <Input
                id="leadTimeDays"
                type="number"
                min="0"
                value={formData.leadTimeDays}
                onChange={(e) =>
                  setFormData((prev) => ({ ...prev, leadTimeDays: e.target.value }))
                }
              />
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="notes">Notes</Label>
            <textarea
              id="notes"
              className="flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
              value={formData.notes}
              onChange={(e) => setFormData((prev) => ({ ...prev, notes: e.target.value }))}
              placeholder="Additional notes about this component..."
            />
          </div>
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button type="button" variant="outline" onClick={() => router.back()}>
            Cancel
          </Button>
          <Button type="submit" disabled={isLoading}>
            {isLoading ? 'Saving...' : isEditing ? 'Save Changes' : 'Create Component'}
          </Button>
        </CardFooter>
      </Card>
    </form>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Categories are fetched from API
- [ ] Select shows active categories only
- [ ] Loading state displays while fetching
- [ ] Backward compatible (existing categories still work)
- [ ] TypeScript compiles
- [ ] Build succeeds

---

## Phase 6: Data Seeding (Optional)

### Subtask 6.1: Seed Initial Categories from Existing Data
**Instructions**: This can be done manually or via a migration script after deployment.

To seed the initial categories based on the hardcoded values, run this in Prisma Studio or a migration:

```sql
-- Insert default categories for each company
INSERT INTO "Category" (id, "companyId", name, "isActive", "createdAt", "updatedAt")
SELECT
  gen_random_uuid(),
  c.id,
  category_name,
  true,
  NOW(),
  NOW()
FROM "Company" c
CROSS JOIN (
  VALUES ('packaging'), ('tool'), ('documentation'), ('accessory'), ('other')
) AS categories(category_name)
ON CONFLICT ("companyId", name) DO NOTHING;
```

**Completion Criteria**:
- [ ] Default categories exist for each company
- [ ] Existing component categories still work

---

## Summary of Deliverables

**Files Created**: 9
- `src/types/category.ts`
- `src/app/api/categories/route.ts`
- `src/app/api/categories/[id]/route.ts`
- `src/components/features/CategoryTable.tsx`
- `src/components/features/CategoryForm.tsx`
- `src/app/(dashboard)/settings/categories/page.tsx`
- `src/app/(dashboard)/settings/categories/new/page.tsx`
- `src/app/(dashboard)/settings/categories/[id]/edit/page.tsx`
- `prisma/migrations/[timestamp]_add_category_model/migration.sql` (auto-generated)

**Files Modified**: 3
- `prisma/schema.prisma` - Add Category model
- `src/app/(dashboard)/layout.tsx` - Add Categories nav link
- `src/components/features/ComponentForm.tsx` - Fetch categories dynamically

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 6)
2. Complete Phase 1 (database) fully before Phase 2 (API)
3. Run validation commands after each subtask
4. Test completion criteria before moving to next subtask
5. Follow reference patterns exactly (Brand implementation)

---

## Test Strategy Note

- Use Vitest for unit tests (if adding)
- Manual testing via browser for UI components
- Test admin-only access by logging in as non-admin
- Test company scoping by switching companies

---

## UI Acceptance Criteria

- [ ] Categories link visible in sidebar for admin users
- [ ] Categories link NOT visible for non-admin users
- [ ] Categories page lists all categories with search/filter
- [ ] Can create new category via form
- [ ] Can edit existing category
- [ ] Can activate/deactivate category
- [ ] Delete blocked if category has components
- [ ] Component form shows categories from API (not hardcoded)

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Investigation | 8m |
| Validation | 3m |
| Planning | 12m |
| **Total** | **23m** |
