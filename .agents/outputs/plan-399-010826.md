# Implementation Plan

**Issue**: #399 - Add Build as transaction type option
**Tier**: 2 (Standard)
**Type**: Feature Enhancement
**Est. Time**: 4-6 hours
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED

**Generated**: 2026-01-08
**Generated By**: Scout-and-Plan Agent (combined workflow)

## Summary

Add "Build" as a fourth transaction type option (alongside Inbound, Outbound, Adjustment) in the Transactions Quick Entry page. This allows users to initiate builds directly from the Transactions page instead of navigating to SKUs. The implementation will reuse existing BuildDialog component for the form UI and leverage the existing `/api/transactions/build` endpoint. Natural language parsing already partially supports "build" keywords but needs refinement.

## Investigation Summary

### Request Analysis
**Type**: Feature Enhancement
**Source**: GitHub Issue #399
**Priority**: P2 (Enhancement)

### Issue Validation
**Status**: Valid - No recent commits touch this feature area
**Recent Changes**: Natural language parser improvements in issues #395, #392, #340, but none address build transaction type in UI

### Current State Assessment

#### Transaction Type Selector
- **File**: `/home/pbrown/SkuInventory/src/components/features/TransactionTypeSelector.tsx`
- **Current Options**: `inbound`, `outbound`, `adjustment`
- **Grid Layout**: `grid-cols-3` (needs change to `grid-cols-4`)
- **Type Export**: `TransactionTypeValue` = `'inbound' | 'outbound' | 'adjustment'`

#### QuickEntryForm
- **File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
- **Form State**: Has `inboundFormData`, `outboundFormData`, `adjustmentFormData` - needs `buildFormData`
- **SKU Loading**: Already fetches SKUs with `hasActiveBom` filter (line 223-236)
- **Submit Logic**: Maps types to endpoints in `handleSubmit` function
- **Initial Values Interface**: `QuickEntryFormInitialValues` needs `build` type support

#### Build API Endpoint
- **File**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
- **Status**: Fully functional, reusable
- **Validation**: Uses `createBuildSchema` from `src/types/transaction.ts`

#### BuildDialog Component
- **File**: `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx`
- **Status**: Full-featured build form (722 lines)
- **Features**: BOM validation, insufficient inventory handling, expired lot warnings, location settings, defect tracking
- **Can be reused**: Yes, as reference pattern for QuickEntryForm build fields

#### Natural Language Parser
- **File**: `/home/pbrown/SkuInventory/src/lib/transaction-parser.ts`
- **Current Support**: Already parses "built", "made", "assembled" keywords (line 61)
- **Issue**: `mapActionToType` function maps `build` to `outbound` (line 160-171) - needs fix
- **Parser Types**: `ParsedTransactionType` in `src/types/parser.ts` only has `'receipt' | 'outbound' | 'adjustment'`

#### QuickEntryWrapper (Natural Language Flow)
- **File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx`
- **Issue**: `handleEditManually` only maps `receipt`, `outbound`, `adjustment` (line 37-58)
- **Issue**: `submitParsedTransaction` only handles `receipt`, `outbound`, `adjustment` (line 72-142)

#### ParsedTransactionPreview
- **File**: `/home/pbrown/SkuInventory/src/components/features/ParsedTransactionPreview.tsx`
- **Issue**: Transaction type labels/icons only have `receipt`, `build`, `adjustment` - note: `build` label exists but not `outbound`

### Dependencies & Blockers
1. **None** - All required components and APIs already exist

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 4-6 hours
**Risk**: Low (primarily UI changes with existing backend)

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx` - Build form fields and validation
**Secondary**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx` - Transaction type form pattern

### Ripple Effect Analysis
**Files Identified**: 7

| File | Change Type | Description |
|------|-------------|-------------|
| `src/components/features/TransactionTypeSelector.tsx` | Modify | Add 'build' option, update grid cols, add Hammer icon |
| `src/components/features/QuickEntryForm.tsx` | Modify | Add build form state, fields, submit logic |
| `src/types/parser.ts` | Modify | Add 'build' to ParsedTransactionType, RawClaudeParseResponse |
| `src/lib/transaction-parser.ts` | Modify | Fix mapActionToType, update inferItemType |
| `src/components/features/QuickEntryWrapper.tsx` | Modify | Handle 'build' in edit/submit flows |
| `src/components/features/ParsedTransactionPreview.tsx` | Modify | Update labels/icons for build |
| `src/app/api/transactions/parse/route.ts` | Verify | Ensure parser response includes build type |

---

## Changes Required

### Phase 1: Type Updates

| Subtask | File | Change | Completion Criteria |
|---------|------|--------|---------------------|
| 1.1 | `src/types/parser.ts` | Add 'build' to ParsedTransactionType union, add 'build' to RawClaudeParseResponse action union | [ ] Type compiles |
| 1.2 | `src/components/features/TransactionTypeSelector.tsx` | Add 'build' to TransactionTypeValue type | [ ] Type compiles |

### Phase 2: Transaction Type Selector

| Subtask | File | Change | Completion Criteria |
|---------|------|--------|---------------------|
| 2.1 | `src/components/features/TransactionTypeSelector.tsx` | Add Hammer icon import, add build option to TRANSACTION_TYPES array, change grid-cols-3 to grid-cols-4 | [ ] Build shows as 4th option, [ ] Consistent styling |

### Phase 3: Parser Updates

| Subtask | File | Change | Completion Criteria |
|---------|------|--------|---------------------|
| 3.1 | `src/lib/transaction-parser.ts` | Update mapActionToType to return 'build' for 'build' action, update inferItemType to handle 'build' same as 'ship' | [ ] Parser returns 'build' type for build inputs |

### Phase 4: QuickEntryForm Build Fields

| Subtask | File | Change | Completion Criteria |
|---------|------|--------|---------------------|
| 4.1 | `src/components/features/QuickEntryForm.tsx` | Add buildFormData state (mirroring BuildDialog), add initial values handling for build type, add SKU filtering for BOMs | [ ] Form state initialized |
| 4.2 | `src/components/features/QuickEntryForm.tsx` | Add build form fields section (SKU select, unitsToBuild, salesChannel, date, location, notes) | [ ] Build form renders when selected |
| 4.3 | `src/components/features/QuickEntryForm.tsx` | Add build submit logic (POST to /api/transactions/build), handle insufficient inventory warning | [ ] Build transactions save successfully |
| 4.4 | `src/components/features/QuickEntryForm.tsx` | Update submit disabled logic for build type validation | [ ] Button disabled when required fields missing |
| 4.5 | `src/components/features/QuickEntryForm.tsx` | Add draft save support for build type | [ ] Can save build as draft |
| 4.6 | `src/components/features/QuickEntryForm.tsx` | Add handleRecordAnother reset for build form | [ ] Form resets properly after build |

### Phase 5: Natural Language Flow

| Subtask | File | Change | Completion Criteria |
|---------|------|--------|---------------------|
| 5.1 | `src/components/features/QuickEntryWrapper.tsx` | Update handleEditManually to map 'build' type to form values (skuId, unitsToBuild, salesChannel) | [ ] Parsed build can switch to manual form |
| 5.2 | `src/components/features/QuickEntryWrapper.tsx` | Update submitParsedTransaction to handle 'build' type (POST to /api/transactions/build endpoint) | [ ] Natural language build submits correctly |
| 5.3 | `src/components/features/ParsedTransactionPreview.tsx` | Add 'outbound' to transactionTypeLabels (currently only has receipt/build/adjustment), add correct icons | [ ] Preview shows correct build label |

### Phase 6: Validation

| Subtask | File | Change | Completion Criteria |
|---------|------|--------|---------------------|
| 6.1 | N/A | Run `npm run build` | [ ] No build errors |
| 6.2 | N/A | Run `npx tsc --noEmit` | [ ] No type errors |
| 6.3 | N/A | Manual test: Select Build in Quick Entry, enter data, submit | [ ] Build created |
| 6.4 | N/A | Manual test: Natural language "today I built 10 Amazon 3-packs" | [ ] Parses as build |

---

## Detailed Subtask Instructions

### Subtask 1.1: Update ParsedTransactionType

**File**: `/home/pbrown/SkuInventory/src/types/parser.ts`
**Pattern**: Follow existing union type pattern

**Instructions**:
1. Line 4: Change `ParsedTransactionType = 'receipt' | 'outbound' | 'adjustment'` to `'receipt' | 'outbound' | 'adjustment' | 'build'`
2. Line 83: In `RawClaudeParseResponse`, update action union from `'ship' | 'receive' | 'adjust' | 'outbound'` to `'ship' | 'receive' | 'adjust' | 'outbound' | 'build'`

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes

---

### Subtask 1.2: Update TransactionTypeValue

**File**: `/home/pbrown/SkuInventory/src/components/features/TransactionTypeSelector.tsx`
**Pattern**: Follow existing type definition

**Instructions**:
1. Line 7: Change `TransactionTypeValue = 'inbound' | 'outbound' | 'adjustment'` to `'inbound' | 'outbound' | 'adjustment' | 'build'`

**Completion Criteria**:
- [ ] Type compiles without errors

---

### Subtask 2.1: Add Build Option to Selector

**File**: `/home/pbrown/SkuInventory/src/components/features/TransactionTypeSelector.tsx`
**Pattern**: Follow existing TRANSACTION_TYPES array entries

**Instructions**:
1. Line 5: Add `Hammer` to the lucide-react import (alongside PackagePlus, PackageMinus, Scale)
2. Lines 15-19: Add fourth item to TRANSACTION_TYPES array:
   ```typescript
   { value: 'build' as const, label: 'Build', icon: Hammer, description: 'Build SKUs' },
   ```
3. Line 27: Change `grid-cols-3` to `grid-cols-4`

**Completion Criteria**:
- [ ] Build button appears as 4th option
- [ ] Consistent styling with other buttons
- [ ] Hammer icon displays correctly

---

### Subtask 3.1: Fix Parser Action Mapping

**File**: `/home/pbrown/SkuInventory/src/lib/transaction-parser.ts`
**Pattern**: Follow existing switch case pattern

**Instructions**:
1. Lines 160-172: Update `mapActionToType` function to handle 'build':
   ```typescript
   function mapActionToType(action: string): 'receipt' | 'outbound' | 'adjustment' | 'build' {
     switch (action) {
       case 'receive':
         return 'receipt'
       case 'ship':
       case 'outbound':
         return 'outbound'
       case 'build':
         return 'build'
       case 'adjust':
         return 'adjustment'
       default:
         return 'outbound' // Default to outbound for unknown actions
     }
   }
   ```
2. Lines 177-217: In `inferItemType`, already handles 'build' correctly (returns 'sku') - verify no changes needed

**Completion Criteria**:
- [ ] "built 10 widgets" parses as type 'build' not 'outbound'
- [ ] Item type correctly inferred as 'sku' for builds

---

### Subtask 4.1: Add Build Form State

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Pattern**: Follow existing form state patterns (lines 100-132)

**Instructions**:
1. After line 132 (adjustmentFormData), add buildFormData state:
   ```typescript
   // Build form data (building SKUs from components)
   const [buildFormData, setBuildFormData] = useState({
     date: toLocalDateString(new Date()),
     skuId: '',
     unitsToBuild: '',
     salesChannel: '',
     locationId: '',
     notes: '',
   })
   ```
2. Update `QuickEntryFormInitialValues` interface (lines 44-60) to add build-specific fields:
   ```typescript
   // Build fields
   unitsToBuild?: number
   ```
3. In the useEffect for initialValues (around line 146), add handling for build type:
   ```typescript
   // Pre-fill build form
   if (initialValues.skuId || initialValues.unitsToBuild !== undefined || initialValues.salesChannel) {
     setBuildFormData((prev) => ({
       ...prev,
       skuId: initialValues.skuId || prev.skuId,
       unitsToBuild: initialValues.unitsToBuild !== undefined ? initialValues.unitsToBuild.toString() : prev.unitsToBuild,
       salesChannel: initialValues.salesChannel || prev.salesChannel,
       date: initialValues.date || prev.date,
       locationId: initialValues.locationId || prev.locationId,
       notes: initialValues.notes || prev.notes,
     }))
   }
   ```
4. Add state for build-specific UI:
   ```typescript
   const [insufficientItems, setInsufficientItems] = useState<Array<{
     componentId: string
     componentName: string
     required: number
     available: number
     shortage: number
   }>>([])
   const [showBuildWarning, setShowBuildWarning] = useState(false)
   ```
5. Import `InsufficientInventoryItem` type from `@/types/transaction`

**Completion Criteria**:
- [ ] Build form state initializes correctly
- [ ] Initial values populate form

---

### Subtask 4.2: Add Build Form Fields

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Pattern**: Follow BuildDialog.tsx lines 436-530 for field structure, but simplified

**Instructions**:
1. Filter SKUs to only show those with active BOMs:
   ```typescript
   // Get buildable SKUs (only those with active BOMs)
   const buildableSkus = skus.filter((s) => s.hasActiveBom)
   const selectedBuildSku = buildableSkus.find((s) => s.id === buildFormData.skuId)
   const unitsToBuildNum = parseInt(buildFormData.unitsToBuild) || 0
   const exceedsBuildable = selectedBuildSku?.maxBuildableUnits != null && unitsToBuildNum > selectedBuildSku.maxBuildableUnits
   ```

2. After the adjustment form fields section (around line 918), add build form fields:
   ```typescript
   {/* Build Form Fields */}
   {transactionType === 'build' && (
     <div className="space-y-4">
       {/* Warning for insufficient inventory */}
       {showBuildWarning && insufficientItems.length > 0 && (
         <div className="rounded-md bg-yellow-50 border border-yellow-200 p-4">
           {/* Similar to BuildDialog warning pattern */}
         </div>
       )}

       <div className="grid grid-cols-4 items-center gap-4">
         <Label htmlFor="build-date" className="text-right">Date *</Label>
         <Input
           id="build-date"
           type="date"
           className="col-span-3"
           value={buildFormData.date}
           onChange={(e) => setBuildFormData((prev) => ({ ...prev, date: e.target.value }))}
           required
         />
       </div>

       <div className="grid grid-cols-4 items-center gap-4">
         <Label htmlFor="build-sku" className="text-right">SKU *</Label>
         <Select
           value={buildFormData.skuId}
           onValueChange={(value) => setBuildFormData((prev) => ({ ...prev, skuId: value }))}
           disabled={isLoadingSkus}
         >
           <SelectTrigger className="col-span-3">
             <SelectValue placeholder={isLoadingSkus ? 'Loading SKUs...' : 'Select SKU to build'} />
           </SelectTrigger>
           <SelectContent>
             {buildableSkus.length === 0 && !isLoadingSkus && (
               <div className="px-3 py-4 text-sm text-muted-foreground text-center">
                 No SKUs with active BOMs found.<br />Create a BOM for your SKUs first.
               </div>
             )}
             {buildableSkus.map((sku) => (
               <SelectItem key={sku.id} value={sku.id}>
                 <span suppressHydrationWarning>
                   {sku.name} ({sku.maxBuildableUnits?.toLocaleString() ?? '0'} buildable)
                 </span>
               </SelectItem>
             ))}
           </SelectContent>
         </Select>
       </div>
       {selectedBuildSku && (
         <div className="grid grid-cols-4 items-center gap-4">
           <div className="col-span-1" />
           <div className="col-span-3 text-xs text-muted-foreground" suppressHydrationWarning>
             Max buildable: {selectedBuildSku.maxBuildableUnits?.toLocaleString() ?? '0'} units
           </div>
         </div>
       )}

       <div className="grid grid-cols-4 items-center gap-4">
         <Label htmlFor="build-units" className="text-right">Units to Build *</Label>
         <Input
           id="build-units"
           type="number"
           step="1"
           min="1"
           className={cn("col-span-3", exceedsBuildable && "border-yellow-500")}
           placeholder="e.g., 10"
           value={buildFormData.unitsToBuild}
           onChange={(e) => setBuildFormData((prev) => ({ ...prev, unitsToBuild: e.target.value }))}
           required
         />
       </div>
       {exceedsBuildable && (
         <div className="grid grid-cols-4 items-center gap-4">
           <div className="col-span-1" />
           <div className="col-span-3 text-xs text-yellow-600" suppressHydrationWarning>
             Exceeds max buildable ({selectedBuildSku?.maxBuildableUnits?.toLocaleString()})
           </div>
         </div>
       )}

       <div className="grid grid-cols-4 items-center gap-4">
         <Label htmlFor="build-channel" className="text-right">Sales Channel</Label>
         <Input
           id="build-channel"
           className="col-span-3"
           placeholder="e.g., Amazon, Shopify"
           value={buildFormData.salesChannel}
           onChange={(e) => setBuildFormData((prev) => ({ ...prev, salesChannel: e.target.value }))}
         />
       </div>

       <div className="grid grid-cols-4 items-center gap-4">
         <Label htmlFor="build-location" className="text-right">Location</Label>
         <Select
           value={buildFormData.locationId}
           onValueChange={(value) => setBuildFormData((prev) => ({ ...prev, locationId: value }))}
           disabled={isLoadingLocations}
         >
           <SelectTrigger className="col-span-3">
             <SelectValue placeholder={isLoadingLocations ? 'Loading...' : 'Default location'} />
           </SelectTrigger>
           <SelectContent>
             {locations.map((loc) => (
               <SelectItem key={loc.id} value={loc.id}>{loc.name}</SelectItem>
             ))}
           </SelectContent>
         </Select>
       </div>

       <div className="grid grid-cols-4 items-start gap-4">
         <Label htmlFor="build-notes" className="text-right pt-2">Notes</Label>
         <Textarea
           id="build-notes"
           className="col-span-3"
           placeholder="e.g., Order batch #123"
           value={buildFormData.notes}
           onChange={(e) => setBuildFormData((prev) => ({ ...prev, notes: e.target.value }))}
         />
       </div>
     </div>
   )}
   ```

**Completion Criteria**:
- [ ] Build form fields render when Build selected
- [ ] SKU dropdown shows only SKUs with active BOMs
- [ ] Max buildable units shown for selected SKU
- [ ] Warning shown when exceeding max buildable

---

### Subtask 4.3: Add Build Submit Logic

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Pattern**: Follow existing handleSubmit pattern, reference BuildDialog lines 199-314

**Instructions**:
1. In handleSubmit function, add build handling (after adjustment section, around line 356):

For draft save (`if (saveAsDraft)`):
```typescript
} else if (transactionType === 'build') {
  payload = {
    type: 'build',
    skuId: buildFormData.skuId,
    date: buildFormData.date,
    unitsToBuild: parseInt(buildFormData.unitsToBuild),
    salesChannel: buildFormData.salesChannel || undefined,
    locationId: buildFormData.locationId || undefined,
    notes: buildFormData.notes || null,
  }
}
```

For regular submit (after line 358):
```typescript
} else if (transactionType === 'build') {
  endpoint = '/api/transactions/build'
  payload = {
    skuId: buildFormData.skuId,
    date: buildFormData.date,
    unitsToBuild: parseInt(buildFormData.unitsToBuild),
    salesChannel: buildFormData.salesChannel || undefined,
    locationId: buildFormData.locationId || undefined,
    notes: buildFormData.notes || null,
  }
}
```

2. Handle build-specific response (insufficient inventory):
```typescript
// After const data = await res.json()...
if (!res.ok) {
  // Handle insufficient inventory for build transactions
  if (transactionType === 'build' && data?.insufficientItems && data.insufficientItems.length > 0) {
    setInsufficientItems(data.insufficientItems)
    setShowBuildWarning(true)
    return
  }
  throw new Error(data?.message || data?.error || 'Failed to record transaction')
}
```

3. Add success message for build:
```typescript
} else if (transactionType === 'build') {
  const sku = buildableSkus.find((s) => s.id === buildFormData.skuId)
  successText = isDraft
    ? `Draft saved: Build ${buildFormData.unitsToBuild} x ${sku?.name || 'SKU'}`
    : `Build recorded: ${buildFormData.unitsToBuild} x ${sku?.name || 'SKU'}`
}
```

**Completion Criteria**:
- [ ] Build transactions submit to `/api/transactions/build`
- [ ] Insufficient inventory warning shows and allows force submit
- [ ] Success message displays correctly

---

### Subtask 4.4: Update Submit Disabled Logic

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Pattern**: Follow existing disabled logic pattern (line 949-953)

**Instructions**:
1. Update the submit button disabled condition to include build validation:
```typescript
disabled={
  isLoading ||
  (transactionType === 'inbound' && (!inboundFormData.componentId || !inboundFormData.quantity || !inboundFormData.supplier)) ||
  (transactionType === 'outbound' && (!outboundFormData.skuId || !outboundFormData.quantity || !outboundFormData.salesChannel)) ||
  (transactionType === 'adjustment' && (!adjustmentFormData.componentId || !adjustmentFormData.quantity || !adjustmentFormData.reason)) ||
  (transactionType === 'build' && (!buildFormData.skuId || !buildFormData.unitsToBuild))
}
```

**Completion Criteria**:
- [ ] Submit button disabled when build fields missing
- [ ] Submit enabled when required build fields filled

---

### Subtask 4.5: Add Build Draft Save Support

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`

**Instructions**:
Already handled in Subtask 4.3 within the draft payload section.

**Completion Criteria**:
- [ ] Save as Draft checkbox works for build type
- [ ] Draft saved with correct type='build'

---

### Subtask 4.6: Update Record Another for Build

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Pattern**: Follow existing handleRecordAnother pattern (lines 402-439)

**Instructions**:
1. Add build form reset in handleRecordAnother:
```typescript
} else if (transactionType === 'build') {
  setBuildFormData({
    date: today,
    skuId: '',
    unitsToBuild: '',
    salesChannel: '',
    locationId: '',
    notes: '',
  })
  setInsufficientItems([])
  setShowBuildWarning(false)
}
```

**Completion Criteria**:
- [ ] Build form resets when "Record Another" clicked
- [ ] Warning state clears

---

### Subtask 5.1: Update handleEditManually for Build

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx`
**Pattern**: Follow existing type handling (lines 31-62)

**Instructions**:
1. Update `handleEditManually` function to handle 'build' type:
```typescript
const handleEditManually = () => {
  if (parsedResult) {
    const parsed = parsedResult.parsed

    // Map transaction types
    let transactionType: 'inbound' | 'outbound' | 'adjustment' | 'build'
    if (parsed.transactionType.value === 'receipt') {
      transactionType = 'inbound'
    } else if (parsed.transactionType.value === 'build') {
      transactionType = 'build'
    } else {
      transactionType = parsed.transactionType.value as 'outbound' | 'adjustment'
    }

    const values: QuickEntryFormInitialValues = {
      transactionType,
      quantity: parsed.quantity.value,
      date: toLocalDateString(parsed.date.value instanceof Date ? parsed.date.value : new Date(parsed.date.value)),
      notes: parsed.notes?.value || undefined,
    }

    // Add type-specific fields
    if (parsed.transactionType.value === 'receipt') {
      values.componentId = parsed.itemId.value || undefined
      values.supplier = parsed.supplier?.value || undefined
    } else if (parsed.transactionType.value === 'build') {
      values.skuId = parsed.itemId.value || undefined
      values.unitsToBuild = parsed.quantity.value
      values.salesChannel = parsed.salesChannel?.value || undefined
    } else if (parsed.transactionType.value === 'outbound') {
      values.skuId = parsed.itemId.value || undefined
      values.salesChannel = parsed.salesChannel?.value || undefined
    } else if (parsed.transactionType.value === 'adjustment') {
      values.componentId = parsed.itemId.value || undefined
      values.reason = parsed.reason?.value || undefined
      values.adjustmentType = 'subtract'
    }

    setFormInitialValues(values)
    setMode('form')
  }
}
```

2. Update `QuickEntryFormInitialValues` import to include the new type (if not already)

**Completion Criteria**:
- [ ] Parsed build transaction can switch to manual form
- [ ] Build-specific fields (skuId, unitsToBuild, salesChannel) populate

---

### Subtask 5.2: Update submitParsedTransaction for Build

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx`
**Pattern**: Follow existing endpoint/payload pattern (lines 72-142)

**Instructions**:
1. Add build case in `submitParsedTransaction`:
```typescript
} else if (transactionType === 'build') {
  endpoint = '/api/transactions/build'
  payload = {
    skuId: parsed.itemId.value,
    date,
    unitsToBuild: parsed.quantity.value,
    salesChannel: parsed.salesChannel?.value || undefined,
    locationId: overrides?.locationId || undefined,
    notes: parsed.notes?.value || `Parsed from: "${parsed.originalInput}"`,
  }
}
```

**Completion Criteria**:
- [ ] Natural language build submits to correct endpoint
- [ ] Build payload includes correct fields

---

### Subtask 5.3: Update ParsedTransactionPreview Labels

**File**: `/home/pbrown/SkuInventory/src/components/features/ParsedTransactionPreview.tsx`
**Pattern**: Follow existing labels/icons pattern (lines 197-207)

**Instructions**:
1. Verify/update `transactionTypeLabels`:
```typescript
const transactionTypeLabels: Record<string, string> = {
  receipt: 'Receipt (Receive Components)',
  build: 'Build (Create SKU Units)',
  adjustment: 'Adjustment',
  outbound: 'Outbound (Ship SKUs)',
}
```

2. Add Hammer icon import and update `transactionTypeIcons`:
```typescript
import { ..., Hammer } from 'lucide-react'

const transactionTypeIcons: Record<string, React.ReactNode> = {
  receipt: <Truck className="h-4 w-4" />,
  build: <Hammer className="h-4 w-4" />,
  adjustment: <Edit2 className="h-4 w-4" />,
  outbound: <Package className="h-4 w-4" />,
}
```

**Completion Criteria**:
- [ ] Build type shows correct label "Build (Create SKU Units)"
- [ ] Hammer icon displays for build type
- [ ] Outbound type also has proper label

---

## Summary of Deliverables

**Files Created**: 0
**Files Modified**: 6

| File | Type | Est. Lines |
|------|------|------------|
| `src/types/parser.ts` | Modify | ~5 |
| `src/components/features/TransactionTypeSelector.tsx` | Modify | ~10 |
| `src/lib/transaction-parser.ts` | Modify | ~15 |
| `src/components/features/QuickEntryForm.tsx` | Modify | ~200 |
| `src/components/features/QuickEntryWrapper.tsx` | Modify | ~50 |
| `src/components/features/ParsedTransactionPreview.tsx` | Modify | ~15 |

## Validation Commands

```bash
# TypeScript check
npx tsc --noEmit

# Build check
npm run build

# Lint check
npm run lint
```

## Test Strategy Note
- Manual testing required for UI changes
- Test Quick Entry form with Build selected
- Test natural language: "today I built 10 Amazon 3-packs"
- Test insufficient inventory warning flow
- Test save as draft for build
- Test "Edit manually" from parsed build

## Acceptance Criteria from Issue
- [ ] Build appears as transaction type option
- [ ] Can select SKU to build, enter quantity and date
- [ ] BOM validation occurs (sufficient component inventory warning)
- [ ] Natural language "today I built 10 [SKU name]" works
- [ ] Build transaction recorded with proper component deductions

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 20m |
| **Total** | **40m** |
