# Implementation Plan: Defect Rate Analytics Dashboard

**Generated**: 2025-12-03T14:30:00Z
**Task ID**: Issue #46
**Estimated Build Time**: 12-15 hours
**Complexity**: Medium

## Executive Summary

This plan implements a comprehensive Defect Rate Analytics Dashboard that visualizes defect trends over time, compares defect rates across BOM versions, and provides correlation analysis between BOM changes and quality outcomes. The implementation leverages existing defect tracking fields from Issue #15 (Transaction.defectCount, Transaction.defectNotes, Transaction.affectedUnits, BOMVersion.defectNotes, BOMVersion.qualityMetadata) and adds new analytics services, API endpoints, and React components with recharts visualizations.

## Schema Verification

**Verified column names via grep analysis**:

| Model | Field | Type | Source |
|-------|-------|------|--------|
| Transaction | defectCount | Int? | prisma/schema.prisma:145 |
| Transaction | defectNotes | String? @db.Text | prisma/schema.prisma:146 |
| Transaction | affectedUnits | Int? | prisma/schema.prisma:147 |
| Transaction | unitsBuild | Int? | prisma/schema.prisma:139 |
| Transaction | type | TransactionType (enum: receipt, build, adjustment, initial) | prisma/schema.prisma:132 |
| Transaction | date | DateTime @db.Date | prisma/schema.prisma:133 |
| Transaction | bomVersionId | String? | prisma/schema.prisma:136 |
| Transaction | skuId | String? | prisma/schema.prisma:134 |
| Transaction | companyId | String | prisma/schema.prisma:130 |
| BOMVersion | defectNotes | String? @db.Text | prisma/schema.prisma:208 |
| BOMVersion | qualityMetadata | Json | prisma/schema.prisma:209 |
| BOMVersion | effectiveStartDate | DateTime @db.Date | prisma/schema.prisma:204 |

**Defect Rate Calculation Formula**:
```
defectRate = (defectCount / unitsBuild) * 100
```

Only `build` type transactions have meaningful defect data.

## Ripple Effect Analysis

**Scout's Assessment**: VALIDATED - No existing files need modification for core functionality

**Files Using Defect Fields** (read-only, no changes needed):
- `/home/pbrown/SkuInventory/src/app/api/transactions/route.ts` - Lists transactions with defects
- `/home/pbrown/SkuInventory/src/app/api/transactions/[id]/route.ts` - Returns defect data
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Build transaction with defects
- `/home/pbrown/SkuInventory/src/types/transaction.ts` - Transaction defect types
- `/home/pbrown/SkuInventory/src/types/bom.ts` - BOM defect types

**New Files (9 files to create)**:
1. `/home/pbrown/SkuInventory/src/types/analytics.ts` - Analytics types
2. `/home/pbrown/SkuInventory/src/services/analytics.ts` - Analytics service
3. `/home/pbrown/SkuInventory/src/app/api/analytics/defects/route.ts` - API endpoint
4. `/home/pbrown/SkuInventory/src/app/(dashboard)/analytics/defects/page.tsx` - Dashboard page
5. `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsDashboard.tsx` - Main component
6. `/home/pbrown/SkuInventory/src/components/features/DefectTrendChart.tsx` - Trend line chart
7. `/home/pbrown/SkuInventory/src/components/features/DefectBOMComparisonChart.tsx` - BOM bar chart
8. `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsFilters.tsx` - Filters component
9. `/home/pbrown/SkuInventory/src/services/analytics-export.ts` - Export functionality

**Files to Modify (2 files)**:
1. `/home/pbrown/SkuInventory/package.json` - Add recharts dependency
2. `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx` - Add Analytics navigation item

## UI Visibility Requirements

**Analytics Navigation Item**:
- Location: Sidebar navigation (between "Import" and "Users")
- Visibility: ALL devices (desktop, tablet, mobile)
- Icon: `BarChart3` from lucide-react
- NO conditional hiding - visible to all roles

**Dashboard Page Responsiveness**:
- Charts use `ResponsiveContainer` from recharts (adapts to screen width)
- Filters stack vertically on mobile (`grid md:grid-cols-4 grid-cols-1`)
- Stats cards use responsive grid (`grid-cols-2 md:grid-cols-4`)

---

## Phase 1: Dependencies & Types Setup

### Subtask 1.1: Install recharts Library

**Instructions**:
1. Install recharts package via npm

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npm install recharts
npm ls recharts
```

**Completion Criteria**:
- [ ] recharts appears in package.json dependencies
- [ ] npm install completes without errors

---

### Subtask 1.2: Create Analytics Types

**File**: `/home/pbrown/SkuInventory/src/types/analytics.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/types/transaction.ts` (Zod schemas + TypeScript interfaces)

**Instructions**:
Create a new file with the following content:

```typescript
import { z } from 'zod'

// Query parameters for analytics endpoint
export const defectAnalyticsQuerySchema = z.object({
  dateFrom: z.coerce.date().optional(),
  dateTo: z.coerce.date().optional(),
  skuId: z.string().uuid().optional(),
  bomVersionId: z.string().uuid().optional(),
  salesChannel: z.string().optional(),
  groupBy: z.enum(['day', 'week', 'month']).default('day'),
})

export type DefectAnalyticsQuery = z.infer<typeof defectAnalyticsQuerySchema>

// Defect rate trend data point (time series)
export interface DefectRateTrendPoint {
  date: string // ISO date string (YYYY-MM-DD)
  totalBuilds: number
  totalUnitsBuilt: number
  totalDefects: number
  totalAffectedUnits: number
  defectRate: number // (totalDefects / totalUnitsBuilt) * 100
  affectedRate: number // (totalAffectedUnits / totalUnitsBuilt) * 100
}

// Defect rate by BOM version
export interface DefectRateByBOM {
  bomVersionId: string
  bomVersionName: string
  skuId: string
  skuName: string
  skuCode: string
  effectiveStartDate: string
  totalBuilds: number
  totalUnitsBuilt: number
  totalDefects: number
  totalAffectedUnits: number
  defectRate: number
  affectedRate: number
}

// Defect rate by SKU
export interface DefectRateBySKU {
  skuId: string
  skuName: string
  skuCode: string
  totalBuilds: number
  totalUnitsBuilt: number
  totalDefects: number
  totalAffectedUnits: number
  defectRate: number
  affectedRate: number
}

// Summary statistics
export interface DefectAnalyticsSummary {
  totalBuilds: number
  totalUnitsBuilt: number
  totalDefects: number
  totalAffectedUnits: number
  overallDefectRate: number
  overallAffectedRate: number
  avgDefectRate: number
  maxDefectRate: number
  minDefectRate: number
}

// Full analytics response
export interface DefectAnalyticsResponse {
  summary: DefectAnalyticsSummary
  trends: DefectRateTrendPoint[]
  byBOMVersion: DefectRateByBOM[]
  bySKU: DefectRateBySKU[]
  filters: {
    dateFrom: string | null
    dateTo: string | null
    skuId: string | null
    bomVersionId: string | null
    salesChannel: string | null
    groupBy: 'day' | 'week' | 'month'
  }
}

// Export data types
export interface DefectAnalyticsExportRow {
  date: string
  skuName: string
  skuCode: string
  bomVersionName: string
  salesChannel: string | null
  unitsBuilt: number
  defectCount: number
  affectedUnits: number
  defectRate: string
  defectNotes: string | null
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with all interfaces
- [ ] TypeScript compilation succeeds
- [ ] Zod schema exports DefectAnalyticsQuery type

---

## Phase 2: Analytics Service Layer

### Subtask 2.1: Create Analytics Service

**File**: `/home/pbrown/SkuInventory/src/services/analytics.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/inventory.ts` (Prisma queries with tenant scoping)

**Instructions**:
Create a new file with the following content:

```typescript
import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'
import type {
  DefectAnalyticsQuery,
  DefectAnalyticsResponse,
  DefectRateTrendPoint,
  DefectRateByBOM,
  DefectRateBySKU,
  DefectAnalyticsSummary,
} from '@/types/analytics'

/**
 * Get defect analytics for a company
 * Aggregates build transaction data with defect information
 */
export async function getDefectAnalytics(
  companyId: string,
  query: DefectAnalyticsQuery
): Promise<DefectAnalyticsResponse> {
  const { dateFrom, dateTo, skuId, bomVersionId, salesChannel, groupBy } = query

  // Build where clause for build transactions only
  const where: Prisma.TransactionWhereInput = {
    companyId,
    type: 'build',
    unitsBuild: { gt: 0 },
    ...(dateFrom || dateTo
      ? {
          date: {
            ...(dateFrom && { gte: dateFrom }),
            ...(dateTo && { lte: dateTo }),
          },
        }
      : {}),
    ...(skuId && { skuId }),
    ...(bomVersionId && { bomVersionId }),
    ...(salesChannel && { salesChannel }),
  }

  // Get raw transaction data for aggregations
  const transactions = await prisma.transaction.findMany({
    where,
    select: {
      id: true,
      date: true,
      unitsBuild: true,
      defectCount: true,
      affectedUnits: true,
      defectNotes: true,
      salesChannel: true,
      sku: {
        select: {
          id: true,
          name: true,
          internalCode: true,
        },
      },
      bomVersion: {
        select: {
          id: true,
          versionName: true,
          effectiveStartDate: true,
        },
      },
    },
    orderBy: { date: 'asc' },
  })

  // Calculate summary
  const summary = calculateSummary(transactions)

  // Calculate trends by time period
  const trends = calculateTrends(transactions, groupBy)

  // Calculate by BOM version
  const byBOMVersion = calculateByBOMVersion(transactions)

  // Calculate by SKU
  const bySKU = calculateBySKU(transactions)

  return {
    summary,
    trends,
    byBOMVersion,
    bySKU,
    filters: {
      dateFrom: dateFrom?.toISOString().split('T')[0] ?? null,
      dateTo: dateTo?.toISOString().split('T')[0] ?? null,
      skuId: skuId ?? null,
      bomVersionId: bomVersionId ?? null,
      salesChannel: salesChannel ?? null,
      groupBy,
    },
  }
}

interface TransactionData {
  id: string
  date: Date
  unitsBuild: number | null
  defectCount: number | null
  affectedUnits: number | null
  defectNotes: string | null
  salesChannel: string | null
  sku: { id: string; name: string; internalCode: string } | null
  bomVersion: { id: string; versionName: string; effectiveStartDate: Date } | null
}

function calculateSummary(transactions: TransactionData[]): DefectAnalyticsSummary {
  let totalBuilds = 0
  let totalUnitsBuilt = 0
  let totalDefects = 0
  let totalAffectedUnits = 0
  const rates: number[] = []

  for (const tx of transactions) {
    const units = tx.unitsBuild ?? 0
    const defects = tx.defectCount ?? 0
    const affected = tx.affectedUnits ?? 0

    totalBuilds++
    totalUnitsBuilt += units
    totalDefects += defects
    totalAffectedUnits += affected

    if (units > 0) {
      rates.push((defects / units) * 100)
    }
  }

  const overallDefectRate = totalUnitsBuilt > 0 ? (totalDefects / totalUnitsBuilt) * 100 : 0
  const overallAffectedRate = totalUnitsBuilt > 0 ? (totalAffectedUnits / totalUnitsBuilt) * 100 : 0
  const avgDefectRate = rates.length > 0 ? rates.reduce((a, b) => a + b, 0) / rates.length : 0
  const maxDefectRate = rates.length > 0 ? Math.max(...rates) : 0
  const minDefectRate = rates.length > 0 ? Math.min(...rates) : 0

  return {
    totalBuilds,
    totalUnitsBuilt,
    totalDefects,
    totalAffectedUnits,
    overallDefectRate: Math.round(overallDefectRate * 100) / 100,
    overallAffectedRate: Math.round(overallAffectedRate * 100) / 100,
    avgDefectRate: Math.round(avgDefectRate * 100) / 100,
    maxDefectRate: Math.round(maxDefectRate * 100) / 100,
    minDefectRate: Math.round(minDefectRate * 100) / 100,
  }
}

function calculateTrends(
  transactions: TransactionData[],
  groupBy: 'day' | 'week' | 'month'
): DefectRateTrendPoint[] {
  const groups = new Map<
    string,
    { totalBuilds: number; totalUnits: number; totalDefects: number; totalAffected: number }
  >()

  for (const tx of transactions) {
    const dateKey = getDateKey(tx.date, groupBy)
    const existing = groups.get(dateKey) || {
      totalBuilds: 0,
      totalUnits: 0,
      totalDefects: 0,
      totalAffected: 0,
    }

    existing.totalBuilds++
    existing.totalUnits += tx.unitsBuild ?? 0
    existing.totalDefects += tx.defectCount ?? 0
    existing.totalAffected += tx.affectedUnits ?? 0

    groups.set(dateKey, existing)
  }

  const trends: DefectRateTrendPoint[] = []
  for (const [date, data] of groups.entries()) {
    const defectRate = data.totalUnits > 0 ? (data.totalDefects / data.totalUnits) * 100 : 0
    const affectedRate = data.totalUnits > 0 ? (data.totalAffected / data.totalUnits) * 100 : 0

    trends.push({
      date,
      totalBuilds: data.totalBuilds,
      totalUnitsBuilt: data.totalUnits,
      totalDefects: data.totalDefects,
      totalAffectedUnits: data.totalAffected,
      defectRate: Math.round(defectRate * 100) / 100,
      affectedRate: Math.round(affectedRate * 100) / 100,
    })
  }

  return trends.sort((a, b) => a.date.localeCompare(b.date))
}

function getDateKey(date: Date, groupBy: 'day' | 'week' | 'month'): string {
  const d = new Date(date)
  const year = d.getFullYear()
  const month = String(d.getMonth() + 1).padStart(2, '0')
  const day = String(d.getDate()).padStart(2, '0')

  switch (groupBy) {
    case 'day':
      return `${year}-${month}-${day}`
    case 'week': {
      // Get Monday of the week
      const dayOfWeek = d.getDay()
      const diff = d.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1)
      const monday = new Date(d)
      monday.setDate(diff)
      const wYear = monday.getFullYear()
      const wMonth = String(monday.getMonth() + 1).padStart(2, '0')
      const wDay = String(monday.getDate()).padStart(2, '0')
      return `${wYear}-${wMonth}-${wDay}`
    }
    case 'month':
      return `${year}-${month}-01`
  }
}

function calculateByBOMVersion(transactions: TransactionData[]): DefectRateByBOM[] {
  const groups = new Map<
    string,
    {
      bomVersionId: string
      bomVersionName: string
      skuId: string
      skuName: string
      skuCode: string
      effectiveStartDate: string
      totalBuilds: number
      totalUnits: number
      totalDefects: number
      totalAffected: number
    }
  >()

  for (const tx of transactions) {
    if (!tx.bomVersion || !tx.sku) continue

    const key = tx.bomVersion.id
    const existing = groups.get(key) || {
      bomVersionId: tx.bomVersion.id,
      bomVersionName: tx.bomVersion.versionName,
      skuId: tx.sku.id,
      skuName: tx.sku.name,
      skuCode: tx.sku.internalCode,
      effectiveStartDate: tx.bomVersion.effectiveStartDate.toISOString().split('T')[0],
      totalBuilds: 0,
      totalUnits: 0,
      totalDefects: 0,
      totalAffected: 0,
    }

    existing.totalBuilds++
    existing.totalUnits += tx.unitsBuild ?? 0
    existing.totalDefects += tx.defectCount ?? 0
    existing.totalAffected += tx.affectedUnits ?? 0

    groups.set(key, existing)
  }

  const results: DefectRateByBOM[] = []
  for (const data of groups.values()) {
    const defectRate = data.totalUnits > 0 ? (data.totalDefects / data.totalUnits) * 100 : 0
    const affectedRate = data.totalUnits > 0 ? (data.totalAffected / data.totalUnits) * 100 : 0

    results.push({
      bomVersionId: data.bomVersionId,
      bomVersionName: data.bomVersionName,
      skuId: data.skuId,
      skuName: data.skuName,
      skuCode: data.skuCode,
      effectiveStartDate: data.effectiveStartDate,
      totalBuilds: data.totalBuilds,
      totalUnitsBuilt: data.totalUnits,
      totalDefects: data.totalDefects,
      totalAffectedUnits: data.totalAffected,
      defectRate: Math.round(defectRate * 100) / 100,
      affectedRate: Math.round(affectedRate * 100) / 100,
    })
  }

  // Sort by effective start date (newest first)
  return results.sort((a, b) => b.effectiveStartDate.localeCompare(a.effectiveStartDate))
}

function calculateBySKU(transactions: TransactionData[]): DefectRateBySKU[] {
  const groups = new Map<
    string,
    {
      skuId: string
      skuName: string
      skuCode: string
      totalBuilds: number
      totalUnits: number
      totalDefects: number
      totalAffected: number
    }
  >()

  for (const tx of transactions) {
    if (!tx.sku) continue

    const key = tx.sku.id
    const existing = groups.get(key) || {
      skuId: tx.sku.id,
      skuName: tx.sku.name,
      skuCode: tx.sku.internalCode,
      totalBuilds: 0,
      totalUnits: 0,
      totalDefects: 0,
      totalAffected: 0,
    }

    existing.totalBuilds++
    existing.totalUnits += tx.unitsBuild ?? 0
    existing.totalDefects += tx.defectCount ?? 0
    existing.totalAffected += tx.affectedUnits ?? 0

    groups.set(key, existing)
  }

  const results: DefectRateBySKU[] = []
  for (const data of groups.values()) {
    const defectRate = data.totalUnits > 0 ? (data.totalDefects / data.totalUnits) * 100 : 0
    const affectedRate = data.totalUnits > 0 ? (data.totalAffected / data.totalUnits) * 100 : 0

    results.push({
      skuId: data.skuId,
      skuName: data.skuName,
      skuCode: data.skuCode,
      totalBuilds: data.totalBuilds,
      totalUnitsBuilt: data.totalUnits,
      totalDefects: data.totalDefects,
      totalAffectedUnits: data.totalAffected,
      defectRate: Math.round(defectRate * 100) / 100,
      affectedRate: Math.round(affectedRate * 100) / 100,
    })
  }

  // Sort by defect rate (highest first)
  return results.sort((a, b) => b.defectRate - a.defectRate)
}

/**
 * Get list of SKUs for filter dropdown (only SKUs with build transactions)
 */
export async function getSKUsWithBuilds(companyId: string): Promise<
  Array<{ id: string; name: string; internalCode: string }>
> {
  // Get user's brand first
  const company = await prisma.company.findUnique({
    where: { id: companyId },
    include: { brands: { where: { isActive: true }, take: 1 } },
  })

  if (!company?.brands[0]) {
    return []
  }

  const brandId = company.brands[0].id

  // Get SKUs that have build transactions
  const skus = await prisma.sKU.findMany({
    where: {
      brandId,
      isActive: true,
      transactions: {
        some: {
          type: 'build',
          companyId,
        },
      },
    },
    select: {
      id: true,
      name: true,
      internalCode: true,
    },
    orderBy: { name: 'asc' },
  })

  return skus
}

/**
 * Get list of BOM versions for filter dropdown
 */
export async function getBOMVersionsForFilter(
  companyId: string,
  skuId?: string
): Promise<Array<{ id: string; versionName: string; skuName: string }>> {
  // Get user's brand first
  const company = await prisma.company.findUnique({
    where: { id: companyId },
    include: { brands: { where: { isActive: true }, take: 1 } },
  })

  if (!company?.brands[0]) {
    return []
  }

  const brandId = company.brands[0].id

  const bomVersions = await prisma.bOMVersion.findMany({
    where: {
      sku: {
        brandId,
        ...(skuId && { id: skuId }),
      },
      transactions: {
        some: {
          type: 'build',
          companyId,
        },
      },
    },
    select: {
      id: true,
      versionName: true,
      sku: {
        select: { name: true },
      },
    },
    orderBy: { createdAt: 'desc' },
  })

  return bomVersions.map((bom) => ({
    id: bom.id,
    versionName: bom.versionName,
    skuName: bom.sku.name,
  }))
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with all functions
- [ ] TypeScript compilation succeeds
- [ ] getDefectAnalytics function properly filters by companyId
- [ ] Date grouping logic works for day/week/month

---

### Subtask 2.2: Create Analytics Export Service

**File**: `/home/pbrown/SkuInventory/src/services/analytics-export.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/export.ts` (CSV generation pattern)

**Instructions**:
Create a new file with the following content:

```typescript
import { toCSV, type CSVColumn } from './export'
import type { DefectAnalyticsExportRow } from '@/types/analytics'
import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'
import type { DefectAnalyticsQuery } from '@/types/analytics'

/**
 * Column definitions for defect analytics export
 */
export const defectAnalyticsExportColumns: CSVColumn<DefectAnalyticsExportRow>[] = [
  { header: 'Date', accessor: (r) => r.date },
  { header: 'SKU Name', accessor: (r) => r.skuName },
  { header: 'SKU Code', accessor: (r) => r.skuCode },
  { header: 'BOM Version', accessor: (r) => r.bomVersionName },
  { header: 'Sales Channel', accessor: (r) => r.salesChannel },
  { header: 'Units Built', accessor: (r) => r.unitsBuilt },
  { header: 'Defect Count', accessor: (r) => r.defectCount },
  { header: 'Affected Units', accessor: (r) => r.affectedUnits },
  { header: 'Defect Rate (%)', accessor: (r) => r.defectRate },
  { header: 'Defect Notes', accessor: (r) => r.defectNotes },
]

/**
 * Generate CSV data for defect analytics export
 */
export async function generateDefectAnalyticsExport(
  companyId: string,
  query: DefectAnalyticsQuery
): Promise<string> {
  const { dateFrom, dateTo, skuId, bomVersionId, salesChannel } = query

  // Build where clause
  const where: Prisma.TransactionWhereInput = {
    companyId,
    type: 'build',
    unitsBuild: { gt: 0 },
    ...(dateFrom || dateTo
      ? {
          date: {
            ...(dateFrom && { gte: dateFrom }),
            ...(dateTo && { lte: dateTo }),
          },
        }
      : {}),
    ...(skuId && { skuId }),
    ...(bomVersionId && { bomVersionId }),
    ...(salesChannel && { salesChannel }),
  }

  const transactions = await prisma.transaction.findMany({
    where,
    select: {
      date: true,
      unitsBuild: true,
      defectCount: true,
      affectedUnits: true,
      defectNotes: true,
      salesChannel: true,
      sku: {
        select: {
          name: true,
          internalCode: true,
        },
      },
      bomVersion: {
        select: {
          versionName: true,
        },
      },
    },
    orderBy: { date: 'desc' },
  })

  const rows: DefectAnalyticsExportRow[] = transactions.map((tx) => {
    const unitsBuilt = tx.unitsBuild ?? 0
    const defectCount = tx.defectCount ?? 0
    const defectRate = unitsBuilt > 0 ? (defectCount / unitsBuilt) * 100 : 0

    return {
      date: tx.date.toISOString().split('T')[0],
      skuName: tx.sku?.name ?? 'N/A',
      skuCode: tx.sku?.internalCode ?? 'N/A',
      bomVersionName: tx.bomVersion?.versionName ?? 'N/A',
      salesChannel: tx.salesChannel,
      unitsBuilt,
      defectCount,
      affectedUnits: tx.affectedUnits ?? 0,
      defectRate: defectRate.toFixed(2),
      defectNotes: tx.defectNotes,
    }
  })

  return toCSV(rows, defectAnalyticsExportColumns)
}

/**
 * Generate filename for defect analytics export
 */
export function generateDefectAnalyticsFilename(): string {
  const date = new Date().toISOString().split('T')[0]
  return `defect-analytics-${date}.csv`
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with export functions
- [ ] TypeScript compilation succeeds
- [ ] Uses existing toCSV function from export.ts

---

## Phase 3: API Route

### Subtask 3.1: Create Analytics API Route

**File**: `/home/pbrown/SkuInventory/src/app/api/analytics/defects/route.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts` (auth, tenant scoping, error handling)

**Instructions**:
1. Create directory structure: `/home/pbrown/SkuInventory/src/app/api/analytics/defects/`
2. Create route.ts with the following content:

```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { success, unauthorized, serverError, parseQuery } from '@/lib/api-response'
import { defectAnalyticsQuerySchema } from '@/types/analytics'
import {
  getDefectAnalytics,
  getSKUsWithBuilds,
  getBOMVersionsForFilter,
} from '@/services/analytics'
import {
  generateDefectAnalyticsExport,
  generateDefectAnalyticsFilename,
} from '@/services/analytics-export'

// GET /api/analytics/defects - Get defect analytics data
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    const { searchParams } = new URL(request.url)

    // Check if this is an export request
    const exportFormat = searchParams.get('export')
    if (exportFormat === 'csv') {
      const queryResult = parseQuery(searchParams, defectAnalyticsQuerySchema)
      if (queryResult.error) return queryResult.error

      const csv = await generateDefectAnalyticsExport(session.user.companyId, queryResult.data)
      const filename = generateDefectAnalyticsFilename()

      return new Response(csv, {
        status: 200,
        headers: {
          'Content-Type': 'text/csv',
          'Content-Disposition': `attachment; filename="${filename}"`,
        },
      })
    }

    // Check if this is a filter options request
    const getFilters = searchParams.get('filters')
    if (getFilters === 'true') {
      const skuId = searchParams.get('skuId') || undefined

      const [skus, bomVersions] = await Promise.all([
        getSKUsWithBuilds(session.user.companyId),
        getBOMVersionsForFilter(session.user.companyId, skuId),
      ])

      return success({
        skus,
        bomVersions,
        salesChannels: ['Amazon', 'Shopify', 'TikTok', 'Generic'],
      })
    }

    // Regular analytics request
    const queryResult = parseQuery(searchParams, defectAnalyticsQuerySchema)
    if (queryResult.error) return queryResult.error

    const analytics = await getDefectAnalytics(session.user.companyId, queryResult.data)
    return success(analytics)
  } catch (error) {
    console.error('Error fetching defect analytics:', error)
    return serverError()
  }
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
cd /home/pbrown/SkuInventory && npm run build
```

**Completion Criteria**:
- [ ] Directory structure created
- [ ] Route file created with GET handler
- [ ] Authentication enforced (getServerSession)
- [ ] Tenant scoping via companyId
- [ ] Query parameter parsing with Zod
- [ ] CSV export support
- [ ] Filter options endpoint

---

## Phase 4: Frontend Chart Components

### Subtask 4.1: Create Defect Trend Chart Component

**File**: `/home/pbrown/SkuInventory/src/components/features/DefectTrendChart.tsx`
**Pattern**: Use recharts with shadcn/ui Card wrapper

**Instructions**:
Create a new file with the following content:

```typescript
'use client'

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts'
import type { DefectRateTrendPoint } from '@/types/analytics'

interface DefectTrendChartProps {
  data: DefectRateTrendPoint[]
  groupBy: 'day' | 'week' | 'month'
}

export function DefectTrendChart({ data, groupBy }: DefectTrendChartProps) {
  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr)
    switch (groupBy) {
      case 'day':
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
      case 'week':
        return `Week of ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`
      case 'month':
        return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
    }
  }

  const chartData = data.map((d) => ({
    ...d,
    formattedDate: formatDate(d.date),
  }))

  return (
    <Card>
      <CardHeader>
        <CardTitle>Defect Rate Trend</CardTitle>
        <CardDescription>
          Defect and affected unit rates over time (grouped by {groupBy})
        </CardDescription>
      </CardHeader>
      <CardContent>
        {data.length === 0 ? (
          <div className="flex h-64 items-center justify-center text-muted-foreground">
            No data available for the selected filters
          </div>
        ) : (
          <div className="h-80">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={chartData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" className="stroke-muted" />
                <XAxis
                  dataKey="formattedDate"
                  tick={{ fontSize: 12 }}
                  tickLine={false}
                  axisLine={false}
                />
                <YAxis
                  tickFormatter={(value) => `${value}%`}
                  tick={{ fontSize: 12 }}
                  tickLine={false}
                  axisLine={false}
                />
                <Tooltip
                  content={({ active, payload, label }) => {
                    if (!active || !payload?.length) return null
                    const data = payload[0].payload as DefectRateTrendPoint & { formattedDate: string }
                    return (
                      <div className="rounded-lg border bg-background p-3 shadow-lg">
                        <p className="font-medium">{label}</p>
                        <div className="mt-2 space-y-1 text-sm">
                          <p>
                            <span className="text-red-500">Defect Rate:</span> {data.defectRate}%
                          </p>
                          <p>
                            <span className="text-orange-500">Affected Rate:</span>{' '}
                            {data.affectedRate}%
                          </p>
                          <p className="text-muted-foreground">
                            {data.totalDefects} defects / {data.totalUnitsBuilt} units
                          </p>
                          <p className="text-muted-foreground">{data.totalBuilds} builds</p>
                        </div>
                      </div>
                    )
                  }}
                />
                <Legend />
                <Line
                  type="monotone"
                  dataKey="defectRate"
                  name="Defect Rate (%)"
                  stroke="#ef4444"
                  strokeWidth={2}
                  dot={{ fill: '#ef4444', strokeWidth: 2 }}
                  activeDot={{ r: 6 }}
                />
                <Line
                  type="monotone"
                  dataKey="affectedRate"
                  name="Affected Rate (%)"
                  stroke="#f97316"
                  strokeWidth={2}
                  dot={{ fill: '#f97316', strokeWidth: 2 }}
                  activeDot={{ r: 6 }}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        )}
      </CardContent>
    </Card>
  )
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with DefectTrendChart component
- [ ] Uses ResponsiveContainer for mobile support
- [ ] Custom tooltip shows detailed info
- [ ] Handles empty data gracefully

---

### Subtask 4.2: Create Defect BOM Comparison Chart Component

**File**: `/home/pbrown/SkuInventory/src/components/features/DefectBOMComparisonChart.tsx`
**Pattern**: Use recharts BarChart with shadcn/ui Card wrapper

**Instructions**:
Create a new file with the following content:

```typescript
'use client'

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts'
import type { DefectRateByBOM } from '@/types/analytics'

interface DefectBOMComparisonChartProps {
  data: DefectRateByBOM[]
}

export function DefectBOMComparisonChart({ data }: DefectBOMComparisonChartProps) {
  // Limit to top 10 BOM versions and reverse for chronological order (oldest to newest)
  const chartData = data
    .slice(0, 10)
    .reverse()
    .map((d) => ({
      ...d,
      label: `${d.skuName} - ${d.bomVersionName}`,
      shortLabel: d.bomVersionName.length > 15 ? d.bomVersionName.slice(0, 15) + '...' : d.bomVersionName,
    }))

  return (
    <Card>
      <CardHeader>
        <CardTitle>Defect Rate by BOM Version</CardTitle>
        <CardDescription>
          Comparing defect rates across different BOM versions (chronological order)
        </CardDescription>
      </CardHeader>
      <CardContent>
        {data.length === 0 ? (
          <div className="flex h-64 items-center justify-center text-muted-foreground">
            No BOM version data available for the selected filters
          </div>
        ) : (
          <div className="h-80">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={chartData} margin={{ top: 5, right: 30, left: 20, bottom: 60 }}>
                <CartesianGrid strokeDasharray="3 3" className="stroke-muted" />
                <XAxis
                  dataKey="shortLabel"
                  tick={{ fontSize: 11 }}
                  tickLine={false}
                  axisLine={false}
                  angle={-45}
                  textAnchor="end"
                  height={80}
                />
                <YAxis
                  tickFormatter={(value) => `${value}%`}
                  tick={{ fontSize: 12 }}
                  tickLine={false}
                  axisLine={false}
                />
                <Tooltip
                  content={({ active, payload }) => {
                    if (!active || !payload?.length) return null
                    const data = payload[0].payload as DefectRateByBOM & { label: string }
                    return (
                      <div className="rounded-lg border bg-background p-3 shadow-lg">
                        <p className="font-medium">{data.label}</p>
                        <p className="text-sm text-muted-foreground">
                          Effective: {data.effectiveStartDate}
                        </p>
                        <div className="mt-2 space-y-1 text-sm">
                          <p>
                            <span className="text-red-500">Defect Rate:</span> {data.defectRate}%
                          </p>
                          <p>
                            <span className="text-orange-500">Affected Rate:</span>{' '}
                            {data.affectedRate}%
                          </p>
                          <p className="text-muted-foreground">
                            {data.totalDefects} defects / {data.totalUnitsBuilt} units
                          </p>
                          <p className="text-muted-foreground">{data.totalBuilds} builds</p>
                        </div>
                      </div>
                    )
                  }}
                />
                <Legend />
                <Bar
                  dataKey="defectRate"
                  name="Defect Rate (%)"
                  fill="#ef4444"
                  radius={[4, 4, 0, 0]}
                />
                <Bar
                  dataKey="affectedRate"
                  name="Affected Rate (%)"
                  fill="#f97316"
                  radius={[4, 4, 0, 0]}
                />
              </BarChart>
            </ResponsiveContainer>
          </div>
        )}
      </CardContent>
    </Card>
  )
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with DefectBOMComparisonChart component
- [ ] Shows chronological order (oldest to newest)
- [ ] Handles long version names with truncation
- [ ] Custom tooltip with full details

---

### Subtask 4.3: Create Analytics Filters Component

**File**: `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsFilters.tsx`
**Pattern**: Follow existing filter patterns, use shadcn/ui Select

**Instructions**:
Create a new file with the following content:

```typescript
'use client'

import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Card, CardContent } from '@/components/ui/card'
import { X } from 'lucide-react'

interface FilterOptions {
  skus: Array<{ id: string; name: string; internalCode: string }>
  bomVersions: Array<{ id: string; versionName: string; skuName: string }>
  salesChannels: string[]
}

interface FilterValues {
  dateFrom: string
  dateTo: string
  skuId: string
  bomVersionId: string
  salesChannel: string
  groupBy: 'day' | 'week' | 'month'
}

interface DefectAnalyticsFiltersProps {
  filters: FilterValues
  options: FilterOptions
  onFilterChange: (key: keyof FilterValues, value: string) => void
  onApply: () => void
  onClear: () => void
  isLoading?: boolean
}

export function DefectAnalyticsFilters({
  filters,
  options,
  onFilterChange,
  onApply,
  onClear,
  isLoading,
}: DefectAnalyticsFiltersProps) {
  const hasActiveFilters =
    filters.dateFrom ||
    filters.dateTo ||
    filters.skuId ||
    filters.bomVersionId ||
    filters.salesChannel

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-4">
          {/* Date From */}
          <div className="space-y-2">
            <Label htmlFor="dateFrom">From Date</Label>
            <Input
              id="dateFrom"
              type="date"
              value={filters.dateFrom}
              onChange={(e) => onFilterChange('dateFrom', e.target.value)}
            />
          </div>

          {/* Date To */}
          <div className="space-y-2">
            <Label htmlFor="dateTo">To Date</Label>
            <Input
              id="dateTo"
              type="date"
              value={filters.dateTo}
              onChange={(e) => onFilterChange('dateTo', e.target.value)}
            />
          </div>

          {/* SKU Filter */}
          <div className="space-y-2">
            <Label htmlFor="skuId">SKU</Label>
            <Select
              value={filters.skuId || 'all'}
              onValueChange={(value) => onFilterChange('skuId', value === 'all' ? '' : value)}
            >
              <SelectTrigger id="skuId">
                <SelectValue placeholder="All SKUs" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All SKUs</SelectItem>
                {options.skus.map((sku) => (
                  <SelectItem key={sku.id} value={sku.id}>
                    {sku.name} ({sku.internalCode})
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* BOM Version Filter */}
          <div className="space-y-2">
            <Label htmlFor="bomVersionId">BOM Version</Label>
            <Select
              value={filters.bomVersionId || 'all'}
              onValueChange={(value) => onFilterChange('bomVersionId', value === 'all' ? '' : value)}
            >
              <SelectTrigger id="bomVersionId">
                <SelectValue placeholder="All Versions" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Versions</SelectItem>
                {options.bomVersions.map((bom) => (
                  <SelectItem key={bom.id} value={bom.id}>
                    {bom.skuName} - {bom.versionName}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Sales Channel Filter */}
          <div className="space-y-2">
            <Label htmlFor="salesChannel">Sales Channel</Label>
            <Select
              value={filters.salesChannel || 'all'}
              onValueChange={(value) =>
                onFilterChange('salesChannel', value === 'all' ? '' : value)
              }
            >
              <SelectTrigger id="salesChannel">
                <SelectValue placeholder="All Channels" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Channels</SelectItem>
                {options.salesChannels.map((channel) => (
                  <SelectItem key={channel} value={channel}>
                    {channel}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Group By */}
          <div className="space-y-2">
            <Label htmlFor="groupBy">Group By</Label>
            <Select
              value={filters.groupBy}
              onValueChange={(value) =>
                onFilterChange('groupBy', value as 'day' | 'week' | 'month')
              }
            >
              <SelectTrigger id="groupBy">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="day">Day</SelectItem>
                <SelectItem value="week">Week</SelectItem>
                <SelectItem value="month">Month</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Action Buttons */}
          <div className="flex items-end gap-2 md:col-span-2 lg:col-span-2">
            <Button onClick={onApply} disabled={isLoading} className="flex-1">
              {isLoading ? 'Loading...' : 'Apply Filters'}
            </Button>
            {hasActiveFilters && (
              <Button variant="outline" onClick={onClear} disabled={isLoading}>
                <X className="mr-2 h-4 w-4" />
                Clear
              </Button>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with filter component
- [ ] Responsive grid layout (1 col mobile, 2 col tablet, 4 col desktop)
- [ ] All filter types supported (date, SKU, BOM, channel, groupBy)
- [ ] Clear button only shows when filters active

---

### Subtask 4.4: Create Analytics Summary Stats Component

**File**: `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsSummary.tsx`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/components/features/DashboardStats.tsx`

**Instructions**:
Create a new file with the following content:

```typescript
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Activity, AlertCircle, AlertTriangle, Package } from 'lucide-react'
import type { DefectAnalyticsSummary as SummaryType } from '@/types/analytics'

interface DefectAnalyticsSummaryProps {
  summary: SummaryType
}

export function DefectAnalyticsSummary({ summary }: DefectAnalyticsSummaryProps) {
  return (
    <div className="grid gap-4 grid-cols-2 lg:grid-cols-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Total Builds</CardTitle>
          <Package className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{summary.totalBuilds.toLocaleString()}</div>
          <p className="text-xs text-muted-foreground">
            {summary.totalUnitsBuilt.toLocaleString()} units built
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Overall Defect Rate</CardTitle>
          <AlertCircle className="h-4 w-4 text-red-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-red-600">{summary.overallDefectRate}%</div>
          <p className="text-xs text-muted-foreground">
            {summary.totalDefects.toLocaleString()} total defects
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Affected Rate</CardTitle>
          <AlertTriangle className="h-4 w-4 text-orange-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-orange-600">{summary.overallAffectedRate}%</div>
          <p className="text-xs text-muted-foreground">
            {summary.totalAffectedUnits.toLocaleString()} affected units
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Defect Rate Range</CardTitle>
          <Activity className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {summary.minDefectRate}% - {summary.maxDefectRate}%
          </div>
          <p className="text-xs text-muted-foreground">Avg: {summary.avgDefectRate}%</p>
        </CardContent>
      </Card>
    </div>
  )
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with summary component
- [ ] Responsive grid (2 cols mobile, 4 cols desktop)
- [ ] Color-coded metrics (red for defect, orange for affected)
- [ ] Proper number formatting

---

### Subtask 4.5: Create Main Analytics Dashboard Component

**File**: `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsDashboard.tsx`

**Instructions**:
Create a new file with the following content:

```typescript
'use client'

import { useState, useEffect, useCallback } from 'react'
import { Button } from '@/components/ui/button'
import { Download, Loader2 } from 'lucide-react'
import { toast } from 'sonner'
import { DefectAnalyticsFilters } from './DefectAnalyticsFilters'
import { DefectAnalyticsSummary } from './DefectAnalyticsSummary'
import { DefectTrendChart } from './DefectTrendChart'
import { DefectBOMComparisonChart } from './DefectBOMComparisonChart'
import type { DefectAnalyticsResponse } from '@/types/analytics'

interface FilterOptions {
  skus: Array<{ id: string; name: string; internalCode: string }>
  bomVersions: Array<{ id: string; versionName: string; skuName: string }>
  salesChannels: string[]
}

interface FilterValues {
  dateFrom: string
  dateTo: string
  skuId: string
  bomVersionId: string
  salesChannel: string
  groupBy: 'day' | 'week' | 'month'
}

const defaultFilters: FilterValues = {
  dateFrom: '',
  dateTo: '',
  skuId: '',
  bomVersionId: '',
  salesChannel: '',
  groupBy: 'day',
}

export function DefectAnalyticsDashboard() {
  const [data, setData] = useState<DefectAnalyticsResponse | null>(null)
  const [filterOptions, setFilterOptions] = useState<FilterOptions>({
    skus: [],
    bomVersions: [],
    salesChannels: [],
  })
  const [filters, setFilters] = useState<FilterValues>(defaultFilters)
  const [isLoading, setIsLoading] = useState(true)
  const [isExporting, setIsExporting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Fetch filter options
  const fetchFilterOptions = useCallback(async (skuId?: string) => {
    try {
      const url = new URL('/api/analytics/defects', window.location.origin)
      url.searchParams.set('filters', 'true')
      if (skuId) {
        url.searchParams.set('skuId', skuId)
      }

      const res = await fetch(url.toString())
      if (!res.ok) throw new Error('Failed to load filter options')

      const result = await res.json()
      setFilterOptions(result.data)
    } catch (err) {
      console.error('Error fetching filter options:', err)
    }
  }, [])

  // Fetch analytics data
  const fetchAnalytics = useCallback(async () => {
    setIsLoading(true)
    setError(null)

    try {
      const url = new URL('/api/analytics/defects', window.location.origin)

      if (filters.dateFrom) url.searchParams.set('dateFrom', filters.dateFrom)
      if (filters.dateTo) url.searchParams.set('dateTo', filters.dateTo)
      if (filters.skuId) url.searchParams.set('skuId', filters.skuId)
      if (filters.bomVersionId) url.searchParams.set('bomVersionId', filters.bomVersionId)
      if (filters.salesChannel) url.searchParams.set('salesChannel', filters.salesChannel)
      url.searchParams.set('groupBy', filters.groupBy)

      const res = await fetch(url.toString())
      if (!res.ok) throw new Error('Failed to load analytics')

      const result = await res.json()
      setData(result.data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }, [filters])

  // Initial load
  useEffect(() => {
    fetchFilterOptions()
    fetchAnalytics()
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  // Update BOM versions when SKU changes
  useEffect(() => {
    if (filters.skuId) {
      fetchFilterOptions(filters.skuId)
    }
  }, [filters.skuId, fetchFilterOptions])

  const handleFilterChange = (key: keyof FilterValues, value: string) => {
    setFilters((prev) => {
      const newFilters = { ...prev, [key]: value }
      // Clear BOM version if SKU changes
      if (key === 'skuId') {
        newFilters.bomVersionId = ''
      }
      return newFilters
    })
  }

  const handleApplyFilters = () => {
    fetchAnalytics()
  }

  const handleClearFilters = () => {
    setFilters(defaultFilters)
    fetchFilterOptions()
    // Fetch with default filters
    setTimeout(() => {
      fetchAnalytics()
    }, 0)
  }

  const handleExport = async () => {
    setIsExporting(true)
    try {
      const url = new URL('/api/analytics/defects', window.location.origin)
      url.searchParams.set('export', 'csv')

      if (filters.dateFrom) url.searchParams.set('dateFrom', filters.dateFrom)
      if (filters.dateTo) url.searchParams.set('dateTo', filters.dateTo)
      if (filters.skuId) url.searchParams.set('skuId', filters.skuId)
      if (filters.bomVersionId) url.searchParams.set('bomVersionId', filters.bomVersionId)
      if (filters.salesChannel) url.searchParams.set('salesChannel', filters.salesChannel)

      const res = await fetch(url.toString())
      if (!res.ok) throw new Error('Export failed')

      const blob = await res.blob()
      const contentDisposition = res.headers.get('Content-Disposition')
      let filename = 'defect-analytics.csv'
      if (contentDisposition) {
        const match = contentDisposition.match(/filename="(.+)"/)
        if (match) filename = match[1]
      }

      const downloadUrl = window.URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = downloadUrl
      link.download = filename
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      window.URL.revokeObjectURL(downloadUrl)

      toast.success('Export complete', {
        description: 'Your defect analytics data has been downloaded.',
      })
    } catch (err) {
      console.error('Export error:', err)
      toast.error('Export failed', {
        description: 'Please try again.',
      })
    } finally {
      setIsExporting(false)
    }
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Defect Analytics</h1>
          <p className="text-muted-foreground">
            Analyze defect rates and quality trends across builds
          </p>
        </div>
        <Button onClick={handleExport} disabled={isExporting || isLoading} variant="outline">
          {isExporting ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Exporting...
            </>
          ) : (
            <>
              <Download className="mr-2 h-4 w-4" />
              Export CSV
            </>
          )}
        </Button>
      </div>

      {/* Filters */}
      <DefectAnalyticsFilters
        filters={filters}
        options={filterOptions}
        onFilterChange={handleFilterChange}
        onApply={handleApplyFilters}
        onClear={handleClearFilters}
        isLoading={isLoading}
      />

      {/* Loading State */}
      {isLoading && (
        <div className="flex h-64 items-center justify-center">
          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        </div>
      )}

      {/* Error State */}
      {error && !isLoading && (
        <div className="flex h-64 items-center justify-center text-red-500">{error}</div>
      )}

      {/* Content */}
      {data && !isLoading && !error && (
        <>
          {/* Summary Stats */}
          <DefectAnalyticsSummary summary={data.summary} />

          {/* Charts Grid */}
          <div className="grid gap-6 lg:grid-cols-1">
            <DefectTrendChart data={data.trends} groupBy={data.filters.groupBy} />
          </div>

          <div className="grid gap-6 lg:grid-cols-1">
            <DefectBOMComparisonChart data={data.byBOMVersion} />
          </div>
        </>
      )}

      {/* No Data State */}
      {data && data.summary.totalBuilds === 0 && !isLoading && !error && (
        <div className="flex h-64 flex-col items-center justify-center text-muted-foreground">
          <p className="text-lg font-medium">No build transactions found</p>
          <p className="text-sm">
            Try adjusting your filters or record some build transactions with defect data
          </p>
        </div>
      )}
    </div>
  )
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with main dashboard component
- [ ] All child components integrated
- [ ] Loading, error, and empty states handled
- [ ] Export functionality works
- [ ] Filters update data dynamically

---

## Phase 5: Dashboard Page & Navigation

### Subtask 5.1: Create Analytics Dashboard Page

**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/analytics/defects/page.tsx`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/(dashboard)/page.tsx`

**Instructions**:
1. Create directory structure: `/home/pbrown/SkuInventory/src/app/(dashboard)/analytics/defects/`
2. Create page.tsx with the following content:

```typescript
import { DefectAnalyticsDashboard } from '@/components/features/DefectAnalyticsDashboard'

export const metadata = {
  title: 'Defect Analytics | Inventory Tracker',
  description: 'Analyze defect rates and quality trends across builds',
}

export default function DefectAnalyticsPage() {
  return <DefectAnalyticsDashboard />
}
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
cd /home/pbrown/SkuInventory && npm run build
```

**Completion Criteria**:
- [ ] Directory structure created
- [ ] Page file created with DefectAnalyticsDashboard component
- [ ] Metadata configured for SEO
- [ ] Page accessible at /analytics/defects

---

### Subtask 5.2: Add Analytics to Navigation

**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx`
**Line Reference**: Lines 25-33 (navigation array)

**Instructions**:
1. Add import for BarChart3 icon from lucide-react
2. Add Analytics navigation item after Import and before Users

**Current Code** (lines 9-10):
```typescript
import {
  LayoutDashboard,
```

**Replace with**:
```typescript
import {
  LayoutDashboard,
  BarChart3,
```

**Current Code** (lines 25-33):
```typescript
const navigation = [
  { name: 'Dashboard', href: '/', icon: LayoutDashboard },
  { name: 'Components', href: '/components', icon: Package },
  { name: 'SKUs', href: '/skus', icon: Boxes },
  { name: 'Transactions', href: '/transactions', icon: ArrowLeftRight },
  { name: 'Import', href: '/import', icon: Upload },
  { name: 'Users', href: '/settings/users', icon: Users, adminOnly: true },
  { name: 'Settings', href: '/settings', icon: Settings, adminOnly: true },
]
```

**Replace with**:
```typescript
const navigation = [
  { name: 'Dashboard', href: '/', icon: LayoutDashboard },
  { name: 'Components', href: '/components', icon: Package },
  { name: 'SKUs', href: '/skus', icon: Boxes },
  { name: 'Transactions', href: '/transactions', icon: ArrowLeftRight },
  { name: 'Import', href: '/import', icon: Upload },
  { name: 'Analytics', href: '/analytics/defects', icon: BarChart3 },
  { name: 'Users', href: '/settings/users', icon: Users, adminOnly: true },
  { name: 'Settings', href: '/settings', icon: Settings, adminOnly: true },
]
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
cd /home/pbrown/SkuInventory && npm run build
```

**Completion Criteria**:
- [ ] BarChart3 icon imported
- [ ] Analytics navigation item added
- [ ] Visible to ALL users (not adminOnly)
- [ ] Positioned after Import, before Users
- [ ] TypeScript compilation succeeds
- [ ] Build succeeds

---

## Phase 6: Testing

### Subtask 6.1: Create Analytics Service Unit Tests

**File**: `/home/pbrown/SkuInventory/tests/unit/analytics-service.test.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/tests/unit/defect-quality-fields.test.ts`

**Instructions**:
Create a new test file with the following content:

```typescript
import { describe, it, expect } from 'vitest'

// Test the analytics calculation logic
// These are pure function tests - no database required

describe('Analytics Calculations', () => {
  describe('Defect Rate Calculation', () => {
    it('should calculate defect rate correctly', () => {
      const defectCount = 5
      const unitsBuild = 100
      const defectRate = (defectCount / unitsBuild) * 100
      expect(defectRate).toBe(5)
    })

    it('should return 0 when no units built', () => {
      const defectCount = 5
      const unitsBuild = 0
      const defectRate = unitsBuild > 0 ? (defectCount / unitsBuild) * 100 : 0
      expect(defectRate).toBe(0)
    })

    it('should handle decimal rates', () => {
      const defectCount = 3
      const unitsBuild = 100
      const defectRate = (defectCount / unitsBuild) * 100
      expect(defectRate).toBe(3)
    })
  })

  describe('Affected Rate Calculation', () => {
    it('should calculate affected rate correctly', () => {
      const affectedUnits = 10
      const unitsBuild = 100
      const affectedRate = (affectedUnits / unitsBuild) * 100
      expect(affectedRate).toBe(10)
    })

    it('should handle zero affected units', () => {
      const affectedUnits = 0
      const unitsBuild = 100
      const affectedRate = (affectedUnits / unitsBuild) * 100
      expect(affectedRate).toBe(0)
    })
  })

  describe('Date Grouping', () => {
    it('should group by day correctly', () => {
      const date = new Date('2025-12-03')
      const year = date.getFullYear()
      const month = String(date.getMonth() + 1).padStart(2, '0')
      const day = String(date.getDate()).padStart(2, '0')
      const key = `${year}-${month}-${day}`
      expect(key).toBe('2025-12-03')
    })

    it('should group by month correctly', () => {
      const date = new Date('2025-12-15')
      const year = date.getFullYear()
      const month = String(date.getMonth() + 1).padStart(2, '0')
      const key = `${year}-${month}-01`
      expect(key).toBe('2025-12-01')
    })

    it('should get Monday for week grouping', () => {
      // Wednesday December 3, 2025
      const date = new Date('2025-12-03')
      const dayOfWeek = date.getDay()
      const diff = date.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1)
      const monday = new Date(date)
      monday.setDate(diff)
      const key = monday.toISOString().split('T')[0]
      expect(key).toBe('2025-12-01') // Monday of that week
    })
  })

  describe('Summary Statistics', () => {
    it('should calculate average correctly', () => {
      const rates = [1, 2, 3, 4, 5]
      const avg = rates.reduce((a, b) => a + b, 0) / rates.length
      expect(avg).toBe(3)
    })

    it('should find min/max correctly', () => {
      const rates = [1.5, 2.3, 0.5, 4.2, 3.1]
      expect(Math.min(...rates)).toBe(0.5)
      expect(Math.max(...rates)).toBe(4.2)
    })

    it('should handle empty rates array', () => {
      const rates: number[] = []
      const avg = rates.length > 0 ? rates.reduce((a, b) => a + b, 0) / rates.length : 0
      const min = rates.length > 0 ? Math.min(...rates) : 0
      const max = rates.length > 0 ? Math.max(...rates) : 0
      expect(avg).toBe(0)
      expect(min).toBe(0)
      expect(max).toBe(0)
    })
  })
})
```

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npm test -- --run tests/unit/analytics-service.test.ts
```

**Completion Criteria**:
- [ ] Test file created
- [ ] All tests pass
- [ ] Covers defect rate calculation
- [ ] Covers affected rate calculation
- [ ] Covers date grouping logic
- [ ] Covers summary statistics

---

## Phase 7: Final Validation

### Subtask 7.1: Full Build & Type Check

**Instructions**:
Run complete validation suite

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
cd /home/pbrown/SkuInventory && npm run lint
cd /home/pbrown/SkuInventory && npm run build
cd /home/pbrown/SkuInventory && npm test
```

**Completion Criteria**:
- [ ] TypeScript compilation succeeds with no errors
- [ ] ESLint passes with no errors or warnings
- [ ] Next.js build completes successfully
- [ ] All tests pass

---

## UI Acceptance Criteria

- [ ] Analytics navigation item visible in sidebar on desktop (1024px+)
- [ ] Analytics navigation item visible in sidebar on tablet (768px-1023px)
- [ ] Analytics navigation item visible in sidebar on mobile (<768px via menu)
- [ ] Charts resize responsively on all screen sizes
- [ ] Filter controls stack vertically on mobile
- [ ] Export button is functional and downloads CSV

---

## Summary of Deliverables

**Files Created (10 files)**:
| File | Type | Purpose |
|------|------|---------|
| `/home/pbrown/SkuInventory/src/types/analytics.ts` | Types | Analytics interfaces and Zod schemas |
| `/home/pbrown/SkuInventory/src/services/analytics.ts` | Service | Analytics calculations and aggregations |
| `/home/pbrown/SkuInventory/src/services/analytics-export.ts` | Service | CSV export for analytics |
| `/home/pbrown/SkuInventory/src/app/api/analytics/defects/route.ts` | API | REST endpoint |
| `/home/pbrown/SkuInventory/src/app/(dashboard)/analytics/defects/page.tsx` | Page | Dashboard page |
| `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsDashboard.tsx` | Component | Main dashboard |
| `/home/pbrown/SkuInventory/src/components/features/DefectTrendChart.tsx` | Component | Line chart |
| `/home/pbrown/SkuInventory/src/components/features/DefectBOMComparisonChart.tsx` | Component | Bar chart |
| `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsFilters.tsx` | Component | Filters |
| `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsSummary.tsx` | Component | Summary stats |

**Files Modified (2 files)**:
| File | Change |
|------|--------|
| `/home/pbrown/SkuInventory/package.json` | Add recharts dependency |
| `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx` | Add Analytics navigation |

**Test Files Created (1 file)**:
| File | Purpose |
|------|---------|
| `/home/pbrown/SkuInventory/tests/unit/analytics-service.test.ts` | Unit tests for analytics calculations |

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 7)
2. Run validation commands after each subtask
3. All completion criteria must be checked before proceeding
4. Follow reference patterns exactly as specified
5. Ensure tenant scoping (companyId) is enforced in all queries
6. Use ResponsiveContainer for all recharts components

## Performance Metrics

| Phase | Estimated Duration |
|-------|----------|
| Scout Review | 15m |
| Schema Verification | 10m |
| Pattern Research | 20m |
| Plan Writing | 45m |
| **Total** | **90m** |

---

AGENT_RETURN: plan-46-120325
