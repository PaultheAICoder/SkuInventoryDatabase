# Implementation Plan
**Generated**: 2025-12-03T15:45:00Z
**Task ID**: Issue #29
**Estimated Build Time**: 2-3 hours
**Complexity**: Low

## Executive Summary

FeedbackDialog.tsx has three unsafe property accesses that directly access nested `data.data` properties without validation. When the API returns an unexpected format (malformed JSON, missing properties, or non-object responses), the component crashes with "Cannot read property 'questions' of undefined" errors. This plan adds defensive programming with optional chaining, response validation, and new test cases for malformed responses.

---

## Phase 0: Not Required

The Scout report confirmed this is straightforward defensive programming with no complex code to untangle. The existing code structure is clear and the patterns are well-established in the codebase.

---

## Phase 1: Core Fix - Response Validation

### Subtask 1.1: Add Response Validation Helper Function

**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`

**Pattern**: Follow error handling pattern from `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx` (lines 88-91)

**Instructions**:

1. Add a type-safe validation helper function after the imports (around line 18):

```typescript
// Response validation helper
function isValidApiResponse<T>(data: unknown, validator: (d: unknown) => d is T): data is { data: T } {
  return (
    data !== null &&
    typeof data === 'object' &&
    'data' in data &&
    validator((data as { data: unknown }).data)
  )
}

// Type guards for API responses
function isClarifyData(data: unknown): data is { questions: string[] } {
  return (
    data !== null &&
    typeof data === 'object' &&
    'questions' in data &&
    Array.isArray((data as { questions: unknown }).questions)
  )
}

function isSubmitFeedbackData(data: unknown): data is { issueUrl: string; issueNumber: number } {
  return (
    data !== null &&
    typeof data === 'object' &&
    'issueUrl' in data &&
    typeof (data as { issueUrl: unknown }).issueUrl === 'string' &&
    'issueNumber' in data &&
    typeof (data as { issueNumber: unknown }).issueNumber === 'number'
  )
}
```

**Completion Criteria**:
- [ ] Helper functions compile without TypeScript errors
- [ ] Functions are placed before the component definition

---

### Subtask 1.2: Fix Unsafe Access at Line 82 (clarify API)

**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`

**Current Code** (lines 76-88):
```typescript
if (!res.ok) {
  const data = await res.json()
  throw new Error(data.message || 'Failed to get clarifying questions')
}

const data = await res.json()
setQuestions(data.data.questions)  // UNSAFE
setStep('clarify')
```

**Updated Code**:
```typescript
if (!res.ok) {
  const data = await res.json().catch(() => ({}))
  throw new Error(data?.message || 'Failed to get clarifying questions')
}

const data = await res.json()

// Validate response structure
if (!isValidApiResponse(data, isClarifyData)) {
  throw new Error('Invalid response from server. Please try again.')
}

setQuestions(data.data.questions)
setStep('clarify')
```

**Instructions**:
1. Add `.catch(() => ({}))` to the error response parsing (prevents crash if JSON parsing fails)
2. Add optional chaining `data?.message` for safety
3. Add response validation check before accessing `data.data.questions`
4. Throw user-friendly error if validation fails

**Completion Criteria**:
- [ ] Optional chaining added to error case
- [ ] Response validation added before accessing `data.data.questions`
- [ ] User-friendly error message for invalid response
- [ ] No TypeScript errors

---

### Subtask 1.3: Fix Unsafe Accesses at Lines 119 and 122 (submit API)

**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`

**Current Code** (lines 113-123):
```typescript
if (!res.ok) {
  const data = await res.json()
  throw new Error(data.message || 'Failed to submit feedback')
}

const data = await res.json()
setIssueUrl(data.data.issueUrl)  // UNSAFE (line 119)
setStep('success')
toast.success('Feedback submitted!', {
  description: `Issue #${data.data.issueNumber} created successfully.`,  // UNSAFE (line 122)
})
```

**Updated Code**:
```typescript
if (!res.ok) {
  const data = await res.json().catch(() => ({}))
  throw new Error(data?.message || 'Failed to submit feedback')
}

const data = await res.json()

// Validate response structure
if (!isValidApiResponse(data, isSubmitFeedbackData)) {
  throw new Error('Invalid response from server. Your feedback may have been submitted. Please check GitHub.')
}

setIssueUrl(data.data.issueUrl)
setStep('success')
toast.success('Feedback submitted!', {
  description: `Issue #${data.data.issueNumber} created successfully.`,
})
```

**Instructions**:
1. Add `.catch(() => ({}))` to the error response parsing
2. Add optional chaining `data?.message` for safety
3. Add response validation check before accessing `data.data.issueUrl` and `data.data.issueNumber`
4. Throw user-friendly error if validation fails (note: special message since feedback may have actually been submitted)

**Completion Criteria**:
- [ ] Optional chaining added to error case
- [ ] Response validation added before accessing nested properties
- [ ] User-friendly error message for invalid response
- [ ] Toast description only uses validated data
- [ ] No TypeScript errors

---

## Phase 2: Test Coverage

### Subtask 2.1: Add Test for Malformed Clarify Response (null data)

**File**: `/home/pbrown/SkuInventory/tests/unit/FeedbackDialog.test.tsx`

**Pattern**: Follow existing test patterns in same file (lines 926-967)

**Instructions**:

Add new test case in the `clarify API error handling` describe block (after line 967):

```typescript
it('handles malformed clarify response (null data)', async () => {
  const user = userEvent.setup()
  mockFetch.mockResolvedValueOnce({
    ok: true,
    json: () => Promise.resolve({ data: null })  // Malformed: data is null
  })

  render(<FeedbackDialog open={true} onOpenChange={() => {}} />)

  await user.click(screen.getByText('Report a Bug'))
  await user.type(screen.getByLabelText('Description *'), 'Testing malformed response')
  await user.click(screen.getByText('Continue'))

  await waitFor(() => {
    // Should show error and stay on describe step
    expect(screen.getByText(/Invalid response/i)).toBeInTheDocument()
    expect(screen.getByText('Describe the Bug')).toBeInTheDocument()
  })
})
```

**Completion Criteria**:
- [ ] Test added to test file
- [ ] Test passes when fix is implemented

---

### Subtask 2.2: Add Test for Malformed Clarify Response (missing questions)

**File**: `/home/pbrown/SkuInventory/tests/unit/FeedbackDialog.test.tsx`

**Instructions**:

Add new test case:

```typescript
it('handles malformed clarify response (missing questions property)', async () => {
  const user = userEvent.setup()
  mockFetch.mockResolvedValueOnce({
    ok: true,
    json: () => Promise.resolve({ data: { wrongProperty: 'value' } })  // Missing questions
  })

  render(<FeedbackDialog open={true} onOpenChange={() => {}} />)

  await user.click(screen.getByText('Report a Bug'))
  await user.type(screen.getByLabelText('Description *'), 'Testing missing questions')
  await user.click(screen.getByText('Continue'))

  await waitFor(() => {
    expect(screen.getByText(/Invalid response/i)).toBeInTheDocument()
    expect(screen.getByText('Describe the Bug')).toBeInTheDocument()
  })
})
```

**Completion Criteria**:
- [ ] Test added to test file
- [ ] Test passes when fix is implemented

---

### Subtask 2.3: Add Test for Malformed Clarify Response (questions not array)

**File**: `/home/pbrown/SkuInventory/tests/unit/FeedbackDialog.test.tsx`

**Instructions**:

Add new test case:

```typescript
it('handles malformed clarify response (questions is not array)', async () => {
  const user = userEvent.setup()
  mockFetch.mockResolvedValueOnce({
    ok: true,
    json: () => Promise.resolve({ data: { questions: 'not an array' } })  // Wrong type
  })

  render(<FeedbackDialog open={true} onOpenChange={() => {}} />)

  await user.click(screen.getByText('Report a Bug'))
  await user.type(screen.getByLabelText('Description *'), 'Testing wrong type')
  await user.click(screen.getByText('Continue'))

  await waitFor(() => {
    expect(screen.getByText(/Invalid response/i)).toBeInTheDocument()
    expect(screen.getByText('Describe the Bug')).toBeInTheDocument()
  })
})
```

**Completion Criteria**:
- [ ] Test added to test file
- [ ] Test passes when fix is implemented

---

### Subtask 2.4: Add Test for Malformed Submit Response (missing data)

**File**: `/home/pbrown/SkuInventory/tests/unit/FeedbackDialog.test.tsx`

**Instructions**:

Add new describe block for submit API error handling or add to success/error state tests:

```typescript
it('handles malformed submit response (missing data property)', async () => {
  const user = userEvent.setup()
  mockFetch
    .mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({
        data: { questions: ['Q1?', 'Q2?', 'Q3?'] }
      })
    })
    .mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ wrongShape: true })  // Missing data property
    })

  render(<FeedbackDialog open={true} onOpenChange={() => {}} />)

  await user.click(screen.getByText('Report a Bug'))
  await user.type(screen.getByLabelText('Description *'), 'Detailed description')
  await user.click(screen.getByText('Continue'))

  await waitFor(() => {
    expect(screen.getByText('A Few Quick Questions')).toBeInTheDocument()
  })

  const textareas = screen.getAllByPlaceholderText('Your answer...')
  await user.type(textareas[0], 'Answer 1')
  await user.type(textareas[1], 'Answer 2')
  await user.type(textareas[2], 'Answer 3')
  await user.click(screen.getByText('Submit Feedback'))

  await waitFor(() => {
    // Should show error state
    expect(screen.getByText('Submission Failed')).toBeInTheDocument()
    expect(screen.getByText(/Invalid response/i)).toBeInTheDocument()
  })
})
```

**Completion Criteria**:
- [ ] Test added to test file
- [ ] Test passes when fix is implemented

---

### Subtask 2.5: Add Test for Malformed Submit Response (missing issueUrl)

**File**: `/home/pbrown/SkuInventory/tests/unit/FeedbackDialog.test.tsx`

**Instructions**:

Add new test case:

```typescript
it('handles malformed submit response (missing issueUrl)', async () => {
  const user = userEvent.setup()
  mockFetch
    .mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({
        data: { questions: ['Q1?', 'Q2?', 'Q3?'] }
      })
    })
    .mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ data: { issueNumber: 123 } })  // Missing issueUrl
    })

  render(<FeedbackDialog open={true} onOpenChange={() => {}} />)

  await user.click(screen.getByText('Report a Bug'))
  await user.type(screen.getByLabelText('Description *'), 'Detailed description')
  await user.click(screen.getByText('Continue'))

  await waitFor(() => {
    expect(screen.getByText('A Few Quick Questions')).toBeInTheDocument()
  })

  const textareas = screen.getAllByPlaceholderText('Your answer...')
  await user.type(textareas[0], 'Answer 1')
  await user.type(textareas[1], 'Answer 2')
  await user.type(textareas[2], 'Answer 3')
  await user.click(screen.getByText('Submit Feedback'))

  await waitFor(() => {
    expect(screen.getByText('Submission Failed')).toBeInTheDocument()
  })
})
```

**Completion Criteria**:
- [ ] Test added to test file
- [ ] Test passes when fix is implemented

---

### Subtask 2.6: Add Test for JSON Parse Failure

**File**: `/home/pbrown/SkuInventory/tests/unit/FeedbackDialog.test.tsx`

**Instructions**:

Add new test case:

```typescript
it('handles JSON parse failure gracefully', async () => {
  const user = userEvent.setup()
  mockFetch.mockResolvedValueOnce({
    ok: false,
    json: () => Promise.reject(new Error('Invalid JSON'))  // JSON parse fails
  })

  render(<FeedbackDialog open={true} onOpenChange={() => {}} />)

  await user.click(screen.getByText('Report a Bug'))
  await user.type(screen.getByLabelText('Description *'), 'Testing JSON parse failure')
  await user.click(screen.getByText('Continue'))

  await waitFor(() => {
    // Should show default error message since JSON parsing failed
    expect(screen.getByText('Failed to get clarifying questions')).toBeInTheDocument()
  })
})
```

**Completion Criteria**:
- [ ] Test added to test file
- [ ] Test passes when fix is implemented

---

## Phase 3: Validation

### Subtask 3.1: Run Full Test Suite

**Instructions**:

```bash
# Run all FeedbackDialog tests
npm test -- --testPathPattern="FeedbackDialog"

# Run full test suite
npm test

# Run TypeScript check
npx tsc --noEmit

# Run linter
npm run lint

# Run build
npm run build
```

**Completion Criteria**:
- [ ] All FeedbackDialog tests pass
- [ ] Full test suite passes
- [ ] No TypeScript errors
- [ ] No linter warnings
- [ ] Build succeeds

---

### Subtask 3.2: Manual Testing Checklist

**Instructions**:

Test the following scenarios manually in the browser:

1. **Normal flow works**:
   - Select bug type
   - Enter valid description
   - Click Continue (should get clarifying questions)
   - Answer all questions
   - Submit (should show success)

2. **Simulated malformed response** (via browser DevTools network throttling/blocking):
   - Open browser DevTools
   - Go to Network tab
   - Block the clarify or feedback API endpoints
   - Verify error messages are user-friendly (not "Cannot read property...")

**Completion Criteria**:
- [ ] Normal flow still works
- [ ] Error messages are user-friendly
- [ ] No console errors for "Cannot read property"

---

## Summary of Deliverables

**Files Modified**: 2
- `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
- `/home/pbrown/SkuInventory/tests/unit/FeedbackDialog.test.tsx`

**Changes Summary**:
| File | Changes |
|------|---------|
| FeedbackDialog.tsx | Add 3 validation helper functions, fix 3 unsafe property accesses |
| FeedbackDialog.test.tsx | Add 6 new test cases for malformed responses |

---

## Acceptance Criteria

- [ ] Line 82: `setQuestions(data.data.questions)` validates response before access
- [ ] Line 119: `setIssueUrl(data.data.issueUrl)` validates response before access
- [ ] Line 122: `data.data.issueNumber` validates response before access
- [ ] Error case JSON parsing uses `.catch(() => ({}))` to prevent crashes
- [ ] Optional chaining used for `data?.message` in error handling
- [ ] User-friendly error messages displayed instead of crashes
- [ ] 6 new test cases added for malformed response scenarios
- [ ] All existing tests continue to pass
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` completes successfully
- [ ] `npm run lint` passes with no warnings

---

## Handoff to Build Agent

1. Execute subtasks in exact order: 1.1 -> 1.2 -> 1.3 -> 2.1 -> 2.2 -> 2.3 -> 2.4 -> 2.5 -> 2.6 -> 3.1 -> 3.2
2. Subtask 1.1 must be completed first as other subtasks depend on the helper functions
3. Run `npx tsc --noEmit` after each file modification to catch errors early
4. Run tests after all Phase 1 changes before starting Phase 2
5. All test cases should pass before moving to Phase 3 validation

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Scout Review | 5m |
| Pattern Research | 4m |
| File Analysis | 6m |
| Plan Writing | 10m |
| **Total** | **25m** |

---

**AGENT_RETURN**: plan-29-120325
