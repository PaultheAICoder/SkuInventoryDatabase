# Implementation Plan
**Generated**: 2025-12-06T10:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #183
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #183
**Priority**: Medium

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="transaction|QuickEntry"`

### Issue Validation
**Status**: Valid
**Recent Changes**: No recent commits specifically conflict with this task. Last relevant commits were for draft workflow and quick entry dropdown.

### Current State Assessment

**Existing Components**:
- `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx` - Main form with Receipt, Build, Adjustment tabs (983 lines)
- `/home/pbrown/SkuInventory/src/components/features/TransactionTypeSelector.tsx` - Tab selector component showing Receipt/Build/Adjustment buttons
- `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx` - Wrapper for Quick Entry with Natural Language parsing

**Database**:
- `Transaction` model in `prisma/schema.prisma` - Has `TransactionType` enum: `receipt`, `build`, `adjustment`, `initial`, `transfer`
- `FinishedGoodsLine` model - Tracks SKU inventory changes per location
- Need to add new `outbound` transaction type to enum

**API Routes**:
- `/api/transactions/receipt/route.ts` - Receipt endpoint (components inbound)
- `/api/transactions/build/route.ts` - Build endpoint (SKU assembly)
- No outbound endpoint exists - needs to be created

**Types**:
- `/home/pbrown/SkuInventory/src/types/transaction.ts` - Transaction schemas and types
- `/home/pbrown/SkuInventory/src/types/index.ts` - Contains `TransactionType` and `salesChannels`

**Services**:
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Transaction creation functions
- `/home/pbrown/SkuInventory/src/services/finished-goods.ts` - SKU inventory management

### Dependencies & Blockers
1. **Prisma Schema Migration**: Need to add `outbound` to `TransactionType` enum
2. **FinishedGoodsLine Integration**: Outbound decrements SKU inventory, similar to transfer

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 6-8 hours
**Risk**: Low - Follows established patterns for transaction types

### Patterns Identified

**Primary**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
- Pattern for SKU-based transaction API route
- Role-based access control (viewer cannot create)
- Session-based company scoping

**Secondary**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
- `adjustFinishedGoods()` function for SKU quantity changes
- Pattern for creating FinishedGoodsLine records

### Ripple Effect Analysis
**Files Identified**: 12

**Files to Modify**:
1. `/home/pbrown/SkuInventory/prisma/schema.prisma` - Add `outbound` to TransactionType enum
2. `/home/pbrown/SkuInventory/src/types/index.ts` - Update TransactionType type
3. `/home/pbrown/SkuInventory/src/types/transaction.ts` - Add outbound schema and types
4. `/home/pbrown/SkuInventory/src/components/features/TransactionTypeSelector.tsx` - Rename Receipt to Inbound, remove Build, add Outbound
5. `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx` - Update transaction types, rename receiptFormData to inboundFormData, add outbound form
6. `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx` - Update preview handling for outbound
7. `/home/pbrown/SkuInventory/src/lib/transaction-parser.ts` - Update parser for inbound/outbound terminology

**Files to Create**:
1. `/home/pbrown/SkuInventory/src/app/api/transactions/outbound/route.ts` - New API endpoint

**Test Files to Update**:
- `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts` - Add outbound tests
- E2E tests may need updates for renamed elements

---

## Executive Summary

This implementation updates the Transactions Quick Entry form to:
1. Remove the "Build SKU" transaction type from quick entry
2. Rename "Receipt" to "Inbound" (for component receipts to warehouse)
3. Add a new "Outbound" transaction type for shipping SKUs out of the warehouse

The outbound transaction will decrement finished goods inventory and record the sales channel for analytics.

---

## Phase 1: Database Schema

### Subtask 1.1: Add `outbound` to TransactionType enum
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing enum structure at line 238
**Instructions**:
1. Locate the `TransactionType` enum (around line 238)
2. Add `outbound` after `transfer`
3. Run migration: `npx prisma migrate dev --name add_outbound_transaction_type`
4. Generate client: `npx prisma generate`

**Current code** (lines 238-244):
```prisma
enum TransactionType {
  receipt
  build
  adjustment
  initial
  transfer
}
```

**New code**:
```prisma
enum TransactionType {
  receipt
  build
  adjustment
  initial
  transfer
  outbound
}
```

**Validation**:
```bash
npx prisma migrate dev --name add_outbound_transaction_type
npx prisma generate
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Migration creates and applies successfully
- [ ] Prisma client regenerates without errors
- [ ] TypeScript compiles without errors

---

## Phase 2: TypeScript Types

### Subtask 2.1: Update TransactionType in types/index.ts
**File**: `/home/pbrown/SkuInventory/src/types/index.ts`
**Pattern**: Line 31
**Instructions**:
1. Update the `TransactionType` type union to include `outbound`

**Current code** (line 31):
```typescript
export type TransactionType = 'receipt' | 'build' | 'adjustment' | 'initial' | 'transfer'
```

**New code**:
```typescript
export type TransactionType = 'receipt' | 'build' | 'adjustment' | 'initial' | 'transfer' | 'outbound'
```

**Completion Criteria**:
- [ ] Type updated
- [ ] No TypeScript errors

### Subtask 2.2: Add outbound schema to types/transaction.ts
**File**: `/home/pbrown/SkuInventory/src/types/transaction.ts`
**Pattern**: Follow `createBuildSchema` structure (lines 57-82)
**Instructions**:
1. Add `createOutboundSchema` after line 84 (after `CreateBuildInput`)
2. Add `CreateOutboundInput` type export
3. Update `transactionListQuerySchema` type enum to include `outbound` (line 119)

**Add after line 84**:
```typescript
// Outbound transaction schema (shipping SKUs out of warehouse)
export const createOutboundSchema = z.object({
  date: z.coerce.date(),
  skuId: z.string().uuid('Invalid SKU ID'),
  salesChannel: z.string().min(1, 'Sales channel is required'),
  quantity: z.coerce.number().int().positive('Quantity must be positive'),
  notes: z.string().optional().nullable(),
  locationId: z.string().uuid('Invalid location ID').optional(),
})

export type CreateOutboundInput = z.infer<typeof createOutboundSchema>
```

**Update line 119** (in `transactionListQuerySchema`):
```typescript
  type: z.enum(['receipt', 'build', 'adjustment', 'initial', 'transfer', 'outbound']).optional(),
```

**Completion Criteria**:
- [ ] Schema added with correct validation
- [ ] Type exported
- [ ] List query schema updated
- [ ] TypeScript compiles without errors

---

## Phase 3: Service Layer

### Subtask 3.1: Add outbound transaction service function
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Pattern**: Follow `adjustFinishedGoods` function (lines 114-149)
**Instructions**:
1. Add `createOutboundTransaction` function at the end of the file
2. This function should:
   - Create a Transaction with type `outbound`
   - Create a FinishedGoodsLine with negative quantity (decrement inventory)
   - Store salesChannel on the transaction
   - Check sufficient inventory at location

**Add after line 278**:
```typescript
/**
 * Create an outbound transaction (shipping SKUs out of warehouse)
 * Decrements finished goods inventory at the specified location
 */
export async function createOutboundTransaction(params: {
  companyId: string
  skuId: string
  locationId: string
  quantity: number
  salesChannel: string
  notes?: string | null
  date: Date
  createdById: string
}): Promise<{ id: string; newBalance: number }> {
  const { companyId, skuId, locationId, quantity, salesChannel, notes, date, createdById } = params

  return prisma.$transaction(async (tx) => {
    // Check sufficient inventory at location
    const currentQty = await getSkuQuantity(skuId, locationId)
    if (currentQty < quantity) {
      throw new Error(
        `Insufficient finished goods at location. Available: ${currentQty}, Required: ${quantity}`
      )
    }

    // Create outbound transaction with finished goods line
    const transaction = await tx.transaction.create({
      data: {
        companyId,
        type: 'outbound',
        date,
        skuId,
        salesChannel,
        notes,
        locationId,
        createdById,
        finishedGoodsLines: {
          create: {
            skuId,
            locationId,
            quantityChange: new Prisma.Decimal(-quantity), // Negative to decrement
            costPerUnit: null,
          },
        },
      },
      select: { id: true },
    })

    // Get new balance at this location
    const newBalance = await getSkuQuantity(skuId, locationId)

    return { id: transaction.id, newBalance }
  })
}
```

**Completion Criteria**:
- [ ] Function creates transaction with type `outbound`
- [ ] FinishedGoodsLine created with negative quantity
- [ ] Inventory check prevents overselling
- [ ] TypeScript compiles without errors

---

## Phase 4: API Route

### Subtask 4.1: Create outbound API route
**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/outbound/route.ts` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/transactions/receipt/route.ts`
**Instructions**:
1. Create new directory and file
2. Implement POST handler with:
   - Authentication check
   - Role check (viewer cannot create)
   - SKU validation (exists and belongs to company)
   - Location validation (if provided, use default otherwise)
   - Call `createOutboundTransaction` service

**Full file content**:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { created, unauthorized, notFound, serverError, parseBody, error } from '@/lib/api-response'
import { createOutboundSchema } from '@/types/transaction'
import { createOutboundTransaction } from '@/services/finished-goods'
import { getDefaultLocationId } from '@/services/location'

// POST /api/transactions/outbound - Create an outbound transaction (ship SKUs)
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    // Check role - Viewer cannot create transactions
    if (session.user.role === 'viewer') {
      return unauthorized('You do not have permission to create transactions')
    }

    const bodyResult = await parseBody(request, createOutboundSchema)
    if (bodyResult.error) return bodyResult.error

    const data = bodyResult.data

    // Use selected company for scoping
    const selectedCompanyId = session.user.selectedCompanyId

    // Verify SKU exists and belongs to user's selected company
    const sku = await prisma.sKU.findFirst({
      where: {
        id: data.skuId,
        companyId: selectedCompanyId,
      },
    })

    if (!sku) {
      return notFound('SKU')
    }

    // Get location - use provided or default
    let locationId = data.locationId
    if (!locationId) {
      // Get default finished goods location
      const defaultLocation = await prisma.location.findFirst({
        where: {
          companyId: selectedCompanyId,
          type: 'finished_goods',
          isActive: true,
        },
      })
      if (defaultLocation) {
        locationId = defaultLocation.id
      } else {
        locationId = await getDefaultLocationId(selectedCompanyId)
      }
    } else {
      // Validate provided location
      const location = await prisma.location.findFirst({
        where: {
          id: locationId,
          companyId: selectedCompanyId,
          isActive: true,
        },
      })
      if (!location) {
        return notFound('Location')
      }
    }

    try {
      // Create the outbound transaction
      const result = await createOutboundTransaction({
        companyId: selectedCompanyId,
        skuId: data.skuId,
        locationId,
        quantity: data.quantity,
        salesChannel: data.salesChannel,
        notes: data.notes,
        date: data.date,
        createdById: session.user.id,
      })

      return created({
        id: result.id,
        type: 'outbound',
        date: data.date.toISOString().split('T')[0],
        skuId: data.skuId,
        sku: { id: sku.id, name: sku.name },
        salesChannel: data.salesChannel,
        quantity: data.quantity,
        locationId,
        notes: data.notes,
        newBalance: result.newBalance,
        createdAt: new Date().toISOString(),
        createdBy: { id: session.user.id, name: session.user.name },
      })
    } catch (err) {
      if (err instanceof Error && err.message.includes('Insufficient')) {
        return error(err.message, 400)
      }
      throw err
    }
  } catch (err) {
    console.error('Error creating outbound transaction:', err)
    return serverError()
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Route file created at correct path
- [ ] POST handler implemented
- [ ] Auth check enforced
- [ ] Role check (viewer blocked)
- [ ] SKU and location validated
- [ ] TypeScript compiles without errors

---

## Phase 5: Frontend Components

### Subtask 5.1: Update TransactionTypeSelector component
**File**: `/home/pbrown/SkuInventory/src/components/features/TransactionTypeSelector.tsx`
**Instructions**:
1. Update `TransactionTypeValue` type to `'inbound' | 'outbound' | 'adjustment'` (remove 'receipt' and 'build')
2. Update `TRANSACTION_TYPES` array:
   - Change 'receipt' to 'inbound' with label 'Inbound' and description 'Receive components'
   - Remove 'build' entry entirely
   - Add 'outbound' with label 'Outbound', icon `PackageMinus`, and description 'Ship SKUs'
3. Change grid from 3 columns to 3 columns (Inbound, Outbound, Adjustment) OR 2 columns if desired

**Current code** (lines 7-19):
```typescript
export type TransactionTypeValue = 'receipt' | 'build' | 'adjustment'

interface TransactionTypeSelectorProps {
  value: TransactionTypeValue
  onValueChange: (value: TransactionTypeValue) => void
  disabled?: boolean
}

const TRANSACTION_TYPES = [
  { value: 'receipt' as const, label: 'Receipt', icon: PackagePlus, description: 'Receive components' },
  { value: 'build' as const, label: 'Build', icon: Hammer, description: 'Build SKUs' },
  { value: 'adjustment' as const, label: 'Adjustment', icon: Scale, description: 'Adjust inventory' },
]
```

**New code**:
```typescript
export type TransactionTypeValue = 'inbound' | 'outbound' | 'adjustment'

interface TransactionTypeSelectorProps {
  value: TransactionTypeValue
  onValueChange: (value: TransactionTypeValue) => void
  disabled?: boolean
}

const TRANSACTION_TYPES = [
  { value: 'inbound' as const, label: 'Inbound', icon: PackagePlus, description: 'Receive components' },
  { value: 'outbound' as const, label: 'Outbound', icon: PackageMinus, description: 'Ship SKUs' },
  { value: 'adjustment' as const, label: 'Adjustment', icon: Scale, description: 'Adjust inventory' },
]
```

**Also add import**:
```typescript
import { PackagePlus, PackageMinus, Scale } from 'lucide-react'
```
(Remove `Hammer` import)

**Completion Criteria**:
- [ ] Type updated to new values
- [ ] TRANSACTION_TYPES updated
- [ ] Icons imported correctly
- [ ] TypeScript compiles without errors

### Subtask 5.2: Update QuickEntryForm component - Part 1 (State and Types)
**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Instructions**:
1. Update default state for `transactionType` from `'receipt'` to `'inbound'`
2. Rename all `receipt` references in state to `inbound`:
   - `receiptFormData` -> `inboundFormData`
   - All occurrences of `receiptFormData` in the file
3. Remove `buildFormData` state and all build-related state
4. Add `outboundFormData` state similar to build but for SKUs with salesChannel

**State changes around lines 58-103**:
- Change `useState<TransactionTypeValue>('receipt')` to `useState<TransactionTypeValue>('inbound')`
- Rename `receiptFormData` to `inboundFormData`
- Remove `buildFormData` state entirely
- Add `outboundFormData` state

**New outboundFormData state** (add after inboundFormData):
```typescript
  // Outbound form data
  const [outboundFormData, setOutboundFormData] = useState({
    date: new Date().toISOString().split('T')[0],
    skuId: '',
    salesChannel: '',
    quantity: '',
    locationId: '',
    notes: '',
  })
```

### Subtask 5.3: Update QuickEntryForm component - Part 2 (URL param handling)
**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Instructions**:
1. Update useEffect for URL params (lines 117-138):
   - Change `receipt` to `inbound` in type check
   - Remove `build` from type check
   - Add `outbound` to type check
   - Update pre-fill logic for outbound

**Updated URL param handling**:
```typescript
  useEffect(() => {
    const typeParam = searchParams.get('type')
    if (typeParam && ['inbound', 'outbound', 'adjustment'].includes(typeParam)) {
      setTransactionType(typeParam as TransactionTypeValue)
    }
    // Pre-fill sales channel from URL (for outbound)
    const channelParam = searchParams.get('channel')
    if (channelParam) {
      setOutboundFormData((prev) => ({ ...prev, salesChannel: channelParam }))
    }
    // Pre-fill component ID from URL (for inbound/adjustment)
    const componentParam = searchParams.get('componentId')
    if (componentParam) {
      setInboundFormData((prev) => ({ ...prev, componentId: componentParam }))
      setAdjustmentFormData((prev) => ({ ...prev, componentId: componentParam }))
    }
    // Pre-fill SKU ID from URL (for outbound)
    const skuParam = searchParams.get('skuId')
    if (skuParam) {
      setOutboundFormData((prev) => ({ ...prev, skuId: skuParam }))
    }
  }, [searchParams])
```

### Subtask 5.4: Update QuickEntryForm component - Part 3 (Form submission)
**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Instructions**:
1. Update handleSubmit function to:
   - Change `receipt` conditions to `inbound`
   - Remove all `build` conditions
   - Add `outbound` conditions
2. Update endpoint from `/api/transactions/receipt` to same (it's still receipt in backend)
3. Add outbound endpoint call to `/api/transactions/outbound`

**Key changes in handleSubmit**:
- Replace `transactionType === 'receipt'` with `transactionType === 'inbound'`
- Remove all `transactionType === 'build'` blocks
- Add `transactionType === 'outbound'` blocks

**Outbound submission logic** (in handleSubmit, inside the draft/non-draft conditionals):
```typescript
      } else if (transactionType === 'outbound') {
        endpoint = '/api/transactions/outbound'
        payload = {
          skuId: outboundFormData.skuId,
          date: outboundFormData.date,
          quantity: parseInt(outboundFormData.quantity),
          salesChannel: outboundFormData.salesChannel,
          locationId: outboundFormData.locationId || undefined,
          notes: outboundFormData.notes || null,
        }
      }
```

### Subtask 5.5: Update QuickEntryForm component - Part 4 (Form UI)
**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Instructions**:
1. Rename the receipt form section condition from `transactionType === 'receipt'` to `transactionType === 'inbound'`
2. Remove the entire build form section (`{transactionType === 'build' && ...}`)
3. Add outbound form section with fields: Date, SKU dropdown, Sales Channel dropdown, Quantity, Notes

**Outbound form section** (add after adjustment form section, before CardFooter):
```tsx
          {/* Outbound Form Fields */}
          {transactionType === 'outbound' && (
            <div className="space-y-4">
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="outbound-date" className="text-right">
                  Date *
                </Label>
                <Input
                  id="outbound-date"
                  type="date"
                  className="col-span-3"
                  value={outboundFormData.date}
                  onChange={(e) => setOutboundFormData((prev) => ({ ...prev, date: e.target.value }))}
                  required
                />
              </div>

              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="outbound-sku" className="text-right">
                  SKU *
                </Label>
                <Select
                  value={outboundFormData.skuId}
                  onValueChange={(value) => setOutboundFormData((prev) => ({ ...prev, skuId: value }))}
                  disabled={isLoadingSkus}
                >
                  <SelectTrigger className="col-span-3">
                    <SelectValue placeholder={isLoadingSkus ? 'Loading SKUs...' : 'Select SKU'} />
                  </SelectTrigger>
                  <SelectContent>
                    {skus.map((sku) => (
                      <SelectItem key={sku.id} value={sku.id}>
                        <div className="flex items-center justify-between gap-2">
                          <span>{sku.name}</span>
                          <span className="text-xs text-muted-foreground">
                            ({sku.internalCode})
                          </span>
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="outbound-channel" className="text-right">
                  Sales Channel *
                </Label>
                <Select
                  value={outboundFormData.salesChannel}
                  onValueChange={(value) => setOutboundFormData((prev) => ({ ...prev, salesChannel: value }))}
                >
                  <SelectTrigger className="col-span-3">
                    <SelectValue placeholder="Select channel" />
                  </SelectTrigger>
                  <SelectContent>
                    {salesChannels.map((channel) => (
                      <SelectItem key={channel} value={channel}>
                        {channel}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="outbound-quantity" className="text-right">
                  Quantity *
                </Label>
                <Input
                  id="outbound-quantity"
                  type="number"
                  step="1"
                  min="1"
                  className="col-span-3"
                  placeholder="e.g., 10"
                  value={outboundFormData.quantity}
                  onChange={(e) => setOutboundFormData((prev) => ({ ...prev, quantity: e.target.value }))}
                  required
                />
              </div>

              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="outbound-location" className="text-right">
                  Location
                </Label>
                <Select
                  value={outboundFormData.locationId}
                  onValueChange={(value) => setOutboundFormData((prev) => ({ ...prev, locationId: value }))}
                  disabled={isLoadingLocations}
                >
                  <SelectTrigger className="col-span-3">
                    <SelectValue placeholder={isLoadingLocations ? 'Loading...' : 'Default location'} />
                  </SelectTrigger>
                  <SelectContent>
                    {locations.map((loc) => (
                      <SelectItem key={loc.id} value={loc.id}>
                        {loc.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="grid grid-cols-4 items-start gap-4">
                <Label htmlFor="outbound-notes" className="text-right pt-2">
                  Notes
                </Label>
                <Textarea
                  id="outbound-notes"
                  className="col-span-3"
                  placeholder="e.g., Order #12345"
                  value={outboundFormData.notes}
                  onChange={(e) => setOutboundFormData((prev) => ({ ...prev, notes: e.target.value }))}
                />
              </div>
            </div>
          )}
```

### Subtask 5.6: Update QuickEntryForm component - Part 5 (Success messages and reset)
**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Instructions**:
1. Update success message generation (around lines 327-345):
   - Change `receipt` to `inbound`
   - Remove `build` block
   - Add `outbound` block
2. Update handleRecordAnother function:
   - Change `receipt` to `inbound`
   - Remove `build` block
   - Add `outbound` block
3. Update disabled state on submit button (around line 969-973):
   - Change `receipt` to `inbound`
   - Remove `build` condition
   - Add `outbound` condition

### Subtask 5.7: Update QuickEntryForm - Remove build-related variables
**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
**Instructions**:
1. Remove `selectedBuildSku`, `unitsToBuildNum`, `exceedsBuildable` computed values (lines 205-208)
2. Remove insufficient inventory warning section for builds (lines 459-499)
3. Remove build SKU fetching logic update (keep fetchSkus for outbound but remove BOM filter)
4. Update fetchSkus to not filter by `activeBom` (outbound doesn't require BOM)

**Update fetchSkus** (around lines 156-172):
```typescript
  const fetchSkus = useCallback(async () => {
    setIsLoadingSkus(true)
    try {
      const res = await fetch('/api/skus?isActive=true&pageSize=100')
      if (res.ok) {
        const data = await res.json()
        // For outbound, show all active SKUs (no BOM filter needed)
        setSkus(data.data || [])
      }
    } catch (err) {
      console.error('Failed to fetch SKUs:', err)
    } finally {
      setIsLoadingSkus(false)
    }
  }, [])
```

**Completion Criteria**:
- [ ] All `receipt` references changed to `inbound`
- [ ] All `build` code removed
- [ ] Outbound form and logic added
- [ ] Success messages updated
- [ ] Submit button disabled state updated
- [ ] TypeScript compiles without errors

---

## Phase 6: Update Transaction Parser (Optional - Low Priority)

### Subtask 6.1: Update transaction parser for new terminology
**File**: `/home/pbrown/SkuInventory/src/lib/transaction-parser.ts`
**Instructions**:
1. Update `buildParsePrompt()` to recognize "inbound" and "outbound" terminology
2. Update `mapActionToType()` to handle new action types
3. This is optional as the conversational input is a secondary feature

**Note**: This can be deferred if time is limited. The form-based quick entry is the primary interface.

---

## Phase 7: Testing

### Subtask 7.1: Add outbound transaction tests
**File**: `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`
**Instructions**:
1. Add new describe block for 'Outbound Transaction'
2. Test cases:
   - Creates outbound with negative finished goods quantity change
   - Fails with insufficient inventory
   - Viewer cannot create outbound
   - Ops can create outbound

**Completion Criteria**:
- [ ] Tests pass
- [ ] Coverage for happy path and error cases

### Subtask 7.2: Run full test suite
**Instructions**:
```bash
npm test
npm run build
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] All tests pass
- [ ] Build completes successfully
- [ ] No TypeScript errors

---

## Summary of Deliverables

**Files Created**: 1
- `/home/pbrown/SkuInventory/src/app/api/transactions/outbound/route.ts`

**Files Modified**: 8
- `/home/pbrown/SkuInventory/prisma/schema.prisma`
- `/home/pbrown/SkuInventory/src/types/index.ts`
- `/home/pbrown/SkuInventory/src/types/transaction.ts`
- `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
- `/home/pbrown/SkuInventory/src/components/features/TransactionTypeSelector.tsx`
- `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`
- `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx` (minor update for type)
- `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7)
2. Run `npx prisma migrate dev` in Phase 1 before proceeding
3. After each phase, run `npx tsc --noEmit` to validate
4. Phase 5 is the largest - work through subtasks 5.1-5.7 sequentially
5. Phase 6 (parser) can be skipped if time constrained
6. Run full test suite in Phase 7

## Test Strategy Note
- Use Vitest for unit/integration tests
- Test transaction creation with positive and negative scenarios
- Verify role-based access (viewer cannot create, ops/admin can)

## Access Control Note
Per the user request: "admin and ops for now" - the implementation uses the existing role check pattern that blocks viewers. No changes needed to auth middleware.

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 20m |
| **Total** | **40m** |
