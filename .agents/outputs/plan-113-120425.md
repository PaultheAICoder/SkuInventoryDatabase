# Implementation Plan
**Generated**: 2025-12-04T16:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #113
**Estimated Build Time**: 10-14 hours
**Complexity**: High

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #113
**Priority**: High (Part of Parent #98 Transaction Entry Enhancements)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED - Focus on parsing logic and API endpoint
**Suggested Filter**: `--filter="ConversationalInput|transaction-parser|parse"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- Issue #111 (Quick Entry UI) completed on 2025-12-04 - provides integration target
- Claude SDK already integrated in `src/lib/claude.ts`
- Transaction API routes well-established

### Current State Assessment
- **Existing Claude Integration**: `src/lib/claude.ts` provides pattern for API calls (using `claude-sonnet-4-20250514`)
- **Quick Entry Form**: `src/components/features/QuickEntryForm.tsx` (916 lines) - integration target
- **Transaction Types**: receipt, build, adjustment, initial, transfer (enum in Prisma)
- **Sales Channels**: Amazon, Shopify, TikTok, Generic (from `src/types/index.ts`)
- **API Patterns**: Standard patterns in `src/lib/api-response.ts` (parseBody, success, error)

### Dependencies & Blockers
1. **ANTHROPIC_API_KEY**: Required for Claude API calls. Existing pattern in `src/lib/claude.ts` handles missing key gracefully with fallback.
2. **Issue #111 Complete**: Quick Entry UI completed, provides form target for parsed data.
3. **No fuzzy search library**: Will need to install `fuse.js` for fuzzy matching SKU/Component names.

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: High
**Effort**: 10-14 hours
**Risk**: Medium - Prompt engineering may require iteration for accuracy

### Patterns Identified
**Primary**: `src/lib/claude.ts` - Claude API integration pattern (lines 40-107 for API call structure)
**Secondary**: `src/components/features/QuickEntryForm.tsx` - Form state management and API calls
**Reference**: `src/app/api/transactions/build/route.ts` - Transaction API endpoint pattern

### Ripple Effect Analysis
**Files Identified**: 5 new files + 2 modified
**New Files**:
- `src/lib/transaction-parser.ts` - AI-powered parsing logic
- `src/app/api/transactions/parse/route.ts` - Parse API endpoint
- `src/components/features/ConversationalInput.tsx` - Chat-style input
- `src/components/features/ParsedTransactionPreview.tsx` - Preview parsed data
- `src/types/parser.ts` - Type definitions for parser

**Modified Files**:
- `src/app/(dashboard)/transactions/new/page.tsx` - Integrate conversational input
- `package.json` - Add fuse.js dependency

---

## Executive Summary
Implement a conversational AI transaction parser that allows users to input natural language commands like "Today I shipped 10 casepacks of 3pks to Amazon" and have them parsed into structured transaction data. The system will use Claude to extract transaction details, fuzzy match SKU/Component names against the database, and present a preview with confidence scores before submission to existing transaction endpoints.

## Phase 0: Environment Setup & Dependencies

### Subtask 0.1: Install Fuzzy Search Library
**Instructions**:
1. Install fuse.js for fuzzy matching:
   ```bash
   npm install fuse.js
   npm install --save-dev @types/fuse.js
   ```
2. Verify installation:
   ```bash
   npm list fuse.js
   ```
**Completion Criteria**:
- [ ] fuse.js appears in package.json dependencies
- [ ] @types/fuse.js in devDependencies (if needed)
- [ ] `npm run build` passes

### Subtask 0.2: Verify Environment Dependencies
**Instructions**:
1. Check ANTHROPIC_API_KEY availability (existing code handles gracefully)
2. Note: Parser will provide fallback behavior when API unavailable
**Completion Criteria**:
- [ ] Understand that existing `getClient()` in claude.ts handles missing key

---

## Phase 1: Types & Interfaces

### Subtask 1.1: Create Parser Types
**File**: `src/types/parser.ts`
**Pattern**: Follow `src/types/transaction.ts` structure
**Instructions**:
Create type definitions for the parser:

```typescript
import { z } from 'zod'

// Transaction action types that can be parsed
export type ParsedTransactionType = 'receipt' | 'build' | 'adjustment'

// Confidence level for parsed values
export type ConfidenceLevel = 'high' | 'medium' | 'low'

// Parsed field with confidence
export interface ParsedField<T> {
  value: T
  confidence: ConfidenceLevel
  rawText?: string
}

// Result of parsing natural language input
export interface ParsedTransaction {
  transactionType: ParsedField<ParsedTransactionType>
  itemType: ParsedField<'sku' | 'component'>
  itemId: ParsedField<string | null>
  itemName: ParsedField<string>
  quantity: ParsedField<number>
  salesChannel?: ParsedField<string | null>
  supplier?: ParsedField<string | null>
  date: ParsedField<Date>
  reason?: ParsedField<string | null>
  notes?: ParsedField<string | null>
  overallConfidence: ConfidenceLevel
  originalInput: string
}

// API request schema
export const parseTransactionInputSchema = z.object({
  text: z.string().min(1, 'Input text is required').max(500, 'Input too long'),
})

export type ParseTransactionInput = z.infer<typeof parseTransactionInputSchema>

// API response type
export interface ParseTransactionResponse {
  parsed: ParsedTransaction
  suggestions: Array<{
    field: string
    currentValue: string | number | null
    alternatives: Array<{ value: string; label: string }>
  }>
  error?: string
}

// Match result from fuzzy search
export interface FuzzyMatchResult {
  id: string
  name: string
  score: number
  type: 'sku' | 'component'
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] File created at `src/types/parser.ts`
- [ ] TypeScript compiles without errors
- [ ] Exports all necessary types

---

## Phase 2: Parser Core Logic

### Subtask 2.1: Create Transaction Parser Library
**File**: `src/lib/transaction-parser.ts`
**Pattern**: Follow `src/lib/claude.ts` structure for Claude API calls
**Instructions**:
Create the core parsing logic:

1. Import Anthropic SDK using existing pattern from claude.ts
2. Create `parseTransactionText()` function that:
   - Accepts natural language text
   - Calls Claude API with structured prompt
   - Parses JSON response into ParsedTransaction
   - Returns with confidence scores

3. Key functions to implement:
   - `parseTransactionText(text: string, context: ParserContext): Promise<ParsedTransaction>`
   - `buildParsePrompt(): string` - System prompt for Claude
   - `parseClaudeResponse(response: string): RawParsedData`
   - `calculateConfidence(field: string, value: unknown): ConfidenceLevel`

4. System prompt should understand:
   - Transaction verbs: "shipped", "received", "got in", "sent out", "built", "adjusted"
   - Unit terms: "casepacks", "units", "pieces", "packs"
   - Relative dates: "today", "yesterday", "last Monday"
   - Channel variations: "FBA", "Amazon FBA", "Shopify store", "TikTok"

5. Example prompt structure:
```
You are a transaction parser for an inventory management system.
Parse the following natural language input into structured transaction data.

Input: "${userInput}"

Extract:
- action: one of "ship" (build), "receive" (receipt), "adjust" (adjustment), "build" (build)
- item: the SKU or component name mentioned
- quantity: numeric quantity
- channel: sales channel if mentioned (Amazon, Shopify, TikTok, Generic)
- date: transaction date (default to today if not specified)
- supplier: supplier name if this is a receipt

Respond with JSON only:
{
  "action": "ship|receive|adjust|build",
  "item": "item name as mentioned",
  "quantity": 123,
  "channel": "Amazon|Shopify|TikTok|Generic|null",
  "date": "YYYY-MM-DD",
  "supplier": "supplier name or null",
  "notes": "any additional context"
}
```

6. Use `claude-sonnet-4-20250514` model (same as existing code)
7. Include fallback handling when API unavailable

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] File created at `src/lib/transaction-parser.ts`
- [ ] parseTransactionText function implemented
- [ ] Handles missing API key gracefully
- [ ] TypeScript compiles without errors

### Subtask 2.2: Create Fuzzy Matching Service
**File**: `src/lib/transaction-parser.ts` (add to same file)
**Instructions**:
Add fuzzy matching functions to match parsed item names to database records:

1. Create `fuzzyMatchItem()` function:
   - Accept item name string
   - Query components and SKUs from database
   - Use Fuse.js for fuzzy matching
   - Return best matches with scores

2. Create `resolveItemToRecord()` function:
   - Takes parsed item name and item type hint
   - Returns resolved database ID or null
   - Calculates match confidence based on score

3. Fuse.js configuration:
```typescript
const fuseOptions = {
  keys: ['name', 'skuCode', 'internalCode'],
  threshold: 0.4,
  includeScore: true,
}
```

4. Match scoring:
   - Score < 0.1: high confidence
   - Score < 0.3: medium confidence
   - Score >= 0.3: low confidence

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] fuzzyMatchItem function implemented
- [ ] resolveItemToRecord function implemented
- [ ] Uses Fuse.js with appropriate thresholds
- [ ] Returns confidence scores with matches

---

## Phase 3: API Route

### Subtask 3.1: Create Parse Endpoint
**File**: `src/app/api/transactions/parse/route.ts`
**Pattern**: Follow `src/app/api/transactions/build/route.ts`
**Instructions**:
Create the parse API endpoint:

```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { success, unauthorized, serverError, parseBody } from '@/lib/api-response'
import { parseTransactionInputSchema, type ParseTransactionResponse } from '@/types/parser'
import { parseTransactionText, resolveItemToRecord } from '@/lib/transaction-parser'

export async function POST(request: NextRequest) {
  try {
    // 1. Auth check
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    // 2. Check role - Viewer cannot create transactions
    if (session.user.role === 'viewer') {
      return unauthorized('You do not have permission to create transactions')
    }

    // 3. Parse and validate input
    const bodyResult = await parseBody(request, parseTransactionInputSchema)
    if (bodyResult.error) return bodyResult.error

    const { text } = bodyResult.data
    const selectedCompanyId = session.user.selectedCompanyId

    // 4. Fetch context data for fuzzy matching
    const [components, skus, locations] = await Promise.all([
      prisma.component.findMany({
        where: { companyId: selectedCompanyId, isActive: true },
        select: { id: true, name: true, skuCode: true },
      }),
      prisma.sKU.findMany({
        where: { companyId: selectedCompanyId, isActive: true },
        select: { id: true, name: true, internalCode: true, salesChannel: true },
      }),
      prisma.location.findMany({
        where: { companyId: selectedCompanyId, isActive: true },
        select: { id: true, name: true },
      }),
    ])

    // 5. Parse with Claude
    const parsed = await parseTransactionText(text, {
      components,
      skus,
      locations,
    })

    // 6. Resolve item name to database record
    const resolvedItem = await resolveItemToRecord(
      parsed.itemName.value,
      parsed.itemType.value,
      { components, skus }
    )

    // 7. Update parsed with resolved ID
    const finalParsed = {
      ...parsed,
      itemId: {
        value: resolvedItem?.id ?? null,
        confidence: resolvedItem?.confidence ?? 'low',
        rawText: parsed.itemName.value,
      },
    }

    // 8. Build suggestions for low-confidence fields
    const suggestions = buildSuggestions(finalParsed, { components, skus })

    return success<ParseTransactionResponse>({
      parsed: finalParsed,
      suggestions,
    })
  } catch (error) {
    console.error('Error parsing transaction:', error)
    return serverError()
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
curl -X POST http://localhost:4545/api/transactions/parse \
  -H "Content-Type: application/json" \
  -d '{"text": "Shipped 10 3pks to Amazon today"}'
```
**Completion Criteria**:
- [ ] File created at `src/app/api/transactions/parse/route.ts`
- [ ] Authentication enforced
- [ ] Returns ParseTransactionResponse
- [ ] Handles errors gracefully
- [ ] Build completes without errors

---

## Phase 4: Frontend Components

### Subtask 4.1: Create Conversational Input Component
**File**: `src/components/features/ConversationalInput.tsx`
**Pattern**: Follow `src/components/features/QuickEntryForm.tsx` for state management
**Instructions**:
Create a chat-style input component:

```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card'
import { MessageSquare, Send, Loader2 } from 'lucide-react'
import type { ParseTransactionResponse, ParsedTransaction } from '@/types/parser'

interface ConversationalInputProps {
  onParsed: (result: ParseTransactionResponse) => void
  disabled?: boolean
}

const EXAMPLE_PROMPTS = [
  "Today I shipped 10 casepacks of 3pks to Amazon",
  "Received 500 bottles from XYZ supplier yesterday",
  "We had 15 3pk Shopify orders today",
  "Built 20 units of the 6-pack for TikTok",
  "Got in 1000 labels from our vendor",
]

export function ConversationalInput({ onParsed, disabled }: ConversationalInputProps) {
  const [input, setInput] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const handleSubmit = async () => {
    if (!input.trim()) return

    setIsLoading(true)
    setError(null)

    try {
      const res = await fetch('/api/transactions/parse', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: input }),
      })

      const data = await res.json()

      if (!res.ok) {
        throw new Error(data.message || 'Failed to parse input')
      }

      onParsed(data.data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  const handleExampleClick = (example: string) => {
    setInput(example)
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <MessageSquare className="h-5 w-5" />
          Conversational Entry
        </CardTitle>
        <CardDescription>
          Describe your transaction in natural language
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <Textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="e.g., Today I shipped 10 casepacks of 3pks to Amazon"
          className="min-h-[100px]"
          disabled={disabled || isLoading}
        />

        {/* Example prompts */}
        <div className="space-y-2">
          <p className="text-xs text-muted-foreground">Examples:</p>
          <div className="flex flex-wrap gap-2">
            {EXAMPLE_PROMPTS.slice(0, 3).map((example, i) => (
              <Button
                key={i}
                type="button"
                variant="outline"
                size="sm"
                className="text-xs"
                onClick={() => handleExampleClick(example)}
                disabled={disabled || isLoading}
              >
                {example.substring(0, 30)}...
              </Button>
            ))}
          </div>
        </div>

        {error && (
          <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
            {error}
          </div>
        )}

        <Button
          onClick={handleSubmit}
          disabled={disabled || isLoading || !input.trim()}
          className="w-full"
        >
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Parsing...
            </>
          ) : (
            <>
              <Send className="mr-2 h-4 w-4" />
              Parse Transaction
            </>
          )}
        </Button>
      </CardContent>
    </Card>
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] File created at `src/components/features/ConversationalInput.tsx`
- [ ] Textarea for natural language input
- [ ] Example prompt buttons
- [ ] Loading state with spinner
- [ ] Error display
- [ ] Calls parse API and returns result via onParsed callback

### Subtask 4.2: Create Parsed Transaction Preview Component
**File**: `src/components/features/ParsedTransactionPreview.tsx`
**Pattern**: Follow `src/components/features/InsufficientInventoryWarning.tsx` for warning display
**Instructions**:
Create a preview component showing parsed transaction with confidence indicators:

```typescript
'use client'

import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle, CardFooter } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import {
  CheckCircle, AlertCircle, HelpCircle,
  Calendar, Package, Hash, Store, Edit2, Check
} from 'lucide-react'
import type { ParsedTransaction, ConfidenceLevel, ParseTransactionResponse } from '@/types/parser'

interface ParsedTransactionPreviewProps {
  result: ParseTransactionResponse
  onConfirm: () => void
  onEdit: () => void
  onCancel: () => void
  isSubmitting?: boolean
}

const ConfidenceIcon = ({ level }: { level: ConfidenceLevel }) => {
  switch (level) {
    case 'high':
      return <CheckCircle className="h-4 w-4 text-green-500" />
    case 'medium':
      return <AlertCircle className="h-4 w-4 text-yellow-500" />
    case 'low':
      return <HelpCircle className="h-4 w-4 text-red-500" />
  }
}

const ConfidenceBadge = ({ level }: { level: ConfidenceLevel }) => {
  const variants: Record<ConfidenceLevel, 'default' | 'secondary' | 'destructive'> = {
    high: 'default',
    medium: 'secondary',
    low: 'destructive',
  }
  return <Badge variant={variants[level]}>{level}</Badge>
}

export function ParsedTransactionPreview({
  result,
  onConfirm,
  onEdit,
  onCancel,
  isSubmitting = false,
}: ParsedTransactionPreviewProps) {
  const { parsed, suggestions } = result

  const formatDate = (date: Date) => {
    return new Date(date).toLocaleDateString('en-US', {
      weekday: 'short',
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    })
  }

  const transactionTypeLabels: Record<string, string> = {
    receipt: 'Receipt (Receive Components)',
    build: 'Build (Create SKU Units)',
    adjustment: 'Adjustment',
  }

  const hasLowConfidence = parsed.overallConfidence === 'low' ||
    !parsed.itemId.value ||
    parsed.itemId.confidence === 'low'

  return (
    <Card className={hasLowConfidence ? 'border-yellow-500' : ''}>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          <span>Parsed Transaction</span>
          <ConfidenceBadge level={parsed.overallConfidence} />
        </CardTitle>
        {hasLowConfidence && (
          <div className="rounded-md bg-yellow-50 border border-yellow-200 p-2 text-sm text-yellow-800">
            Some fields have low confidence. Please review carefully or switch to manual entry.
          </div>
        )}
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Transaction Type */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Package className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm font-medium">Type</span>
          </div>
          <div className="flex items-center gap-2">
            <span>{transactionTypeLabels[parsed.transactionType.value]}</span>
            <ConfidenceIcon level={parsed.transactionType.confidence} />
          </div>
        </div>

        {/* Item */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Hash className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm font-medium">
              {parsed.itemType.value === 'sku' ? 'SKU' : 'Component'}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <span>{parsed.itemName.value}</span>
            {parsed.itemId.value ? (
              <ConfidenceIcon level={parsed.itemId.confidence} />
            ) : (
              <Badge variant="destructive">Not Found</Badge>
            )}
          </div>
        </div>

        {/* Quantity */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <span className="text-sm font-medium">Quantity</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="font-mono">{parsed.quantity.value.toLocaleString()}</span>
            <ConfidenceIcon level={parsed.quantity.confidence} />
          </div>
        </div>

        {/* Sales Channel (for builds) */}
        {parsed.salesChannel && parsed.salesChannel.value && (
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Store className="h-4 w-4 text-muted-foreground" />
              <span className="text-sm font-medium">Sales Channel</span>
            </div>
            <div className="flex items-center gap-2">
              <span>{parsed.salesChannel.value}</span>
              <ConfidenceIcon level={parsed.salesChannel.confidence} />
            </div>
          </div>
        )}

        {/* Date */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Calendar className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm font-medium">Date</span>
          </div>
          <div className="flex items-center gap-2">
            <span>{formatDate(parsed.date.value)}</span>
            <ConfidenceIcon level={parsed.date.confidence} />
          </div>
        </div>

        {/* Supplier (for receipts) */}
        {parsed.supplier && parsed.supplier.value && (
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <span className="text-sm font-medium">Supplier</span>
            </div>
            <div className="flex items-center gap-2">
              <span>{parsed.supplier.value}</span>
              <ConfidenceIcon level={parsed.supplier.confidence} />
            </div>
          </div>
        )}

        {/* Original Input */}
        <div className="pt-2 border-t">
          <p className="text-xs text-muted-foreground">Original input:</p>
          <p className="text-sm italic">&quot;{parsed.originalInput}&quot;</p>
        </div>
      </CardContent>
      <CardFooter className="flex justify-between">
        <Button variant="outline" onClick={onCancel} disabled={isSubmitting}>
          Cancel
        </Button>
        <div className="flex gap-2">
          <Button variant="outline" onClick={onEdit} disabled={isSubmitting}>
            <Edit2 className="mr-2 h-4 w-4" />
            Edit Manually
          </Button>
          <Button
            onClick={onConfirm}
            disabled={isSubmitting || !parsed.itemId.value}
          >
            <Check className="mr-2 h-4 w-4" />
            {isSubmitting ? 'Submitting...' : 'Confirm & Submit'}
          </Button>
        </div>
      </CardFooter>
    </Card>
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] File created at `src/components/features/ParsedTransactionPreview.tsx`
- [ ] Shows all parsed fields with confidence indicators
- [ ] Highlights low-confidence fields
- [ ] Provides Edit and Confirm buttons
- [ ] Disables Confirm when item not resolved

---

## Phase 5: Integration

### Subtask 5.1: Integrate Conversational Input into Quick Entry Page
**File**: `src/app/(dashboard)/transactions/new/page.tsx`
**Pattern**: Follow existing page structure
**Instructions**:
Update the quick entry page to include the conversational input option:

1. Add state for:
   - Mode toggle: 'form' | 'conversational' | 'preview'
   - Parsed result storage

2. Add mode toggle UI (tabs or buttons)

3. When in conversational mode:
   - Show ConversationalInput component
   - On parse success, switch to preview mode

4. When in preview mode:
   - Show ParsedTransactionPreview
   - On edit, switch to form mode with pre-filled data
   - On confirm, submit to appropriate transaction endpoint

5. Handle form pre-fill from parsed data:
   - Map parsed transaction type to form state
   - Set appropriate fields based on transaction type

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Mode toggle between form and conversational input
- [ ] Conversational input triggers parse
- [ ] Preview shows parsed result
- [ ] Edit transitions to form with pre-filled data
- [ ] Confirm submits to transaction API

### Subtask 5.2: Add Submission Logic to Preview
**File**: `src/app/(dashboard)/transactions/new/page.tsx` (continue from 5.1)
**Instructions**:
Add logic to submit parsed transaction:

1. Create `submitParsedTransaction()` function:
   - Map ParsedTransaction to appropriate API payload
   - Build: POST to /api/transactions/build
   - Receipt: POST to /api/transactions/receipt
   - Adjustment: POST to /api/transactions/adjustment

2. Handle response and show success/error

3. Provide "Record Another" flow after success

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Confirm button submits to correct endpoint
- [ ] Success message displayed
- [ ] Error handling for failed submissions
- [ ] Record Another workflow supported

---

## Phase 6: Testing & Validation

### Subtask 6.1: Manual Testing Checklist
**Instructions**:
Verify the following test cases manually:

1. **Receipt parsing**:
   - Input: "Received 500 bottles from XYZ supplier yesterday"
   - Expected: type=receipt, quantity=500, supplier="XYZ supplier", date=yesterday

2. **Build parsing**:
   - Input: "Today I shipped 10 casepacks of 3pks to Amazon"
   - Expected: type=build, quantity=10, item matches "3pk", channel=Amazon

3. **Adjustment parsing**:
   - Input: "Adjusted inventory down by 5 bottles"
   - Expected: type=adjustment, quantity=-5

4. **Fuzzy matching**:
   - Input with typo or partial name should still match

5. **Low confidence handling**:
   - Unrecognized item name shows warning
   - Unable to resolve shows "Not Found"

6. **Edit flow**:
   - Edit button transitions to form
   - Form pre-populated with parsed values

7. **Error handling**:
   - Missing API key shows graceful message
   - Network error shows error message

**Completion Criteria**:
- [ ] All test cases pass
- [ ] No TypeScript errors
- [ ] Build completes without errors

---

## Summary of Deliverables

**Files Created**: 5
- `src/types/parser.ts`
- `src/lib/transaction-parser.ts`
- `src/app/api/transactions/parse/route.ts`
- `src/components/features/ConversationalInput.tsx`
- `src/components/features/ParsedTransactionPreview.tsx`

**Files Modified**: 2
- `src/app/(dashboard)/transactions/new/page.tsx`
- `package.json` (fuse.js dependency)

**Dependencies Added**: 1
- `fuse.js` - Fuzzy search library

---

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 0 -> Phase 6)
2. Complete Phase 0 dependencies before Phase 1
3. Test completion criteria before moving to next subtask
4. Follow reference patterns exactly (especially claude.ts for API calls)
5. Use existing UI components from `src/components/ui/`

## Test Strategy Note
- Use manual testing for this feature (no existing test framework for AI responses)
- Focus on TypeScript compilation and build passing
- Test edge cases for parsing accuracy

## Risk Mitigation
- **Prompt Engineering**: May need iteration on Claude prompts for accuracy
- **Fuzzy Matching Threshold**: May need tuning (start with 0.4)
- **API Key Availability**: Graceful fallback when unavailable

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 20m |
| **Total** | **55m** |
