# Implementation Plan
**Generated**: 2025-12-03T16:07:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #53 - test.yml fails on every checkin
**Estimated Build Time**: 2-3 hours
**Complexity**: Low

## Investigation Summary

### Request Analysis
**Type**: Bug Fix
**Source**: GitHub Issue #53
**Priority**: High (blocks all CI/CD)

### Task Classification
**Category**: BUG_FIX
**Test Strategy**: TARGETED - Run `npm test -- --run tests/unit/increment-version.test.ts` after fix
**Suggested Filter**: `--filter="increment-version"`

### Issue Validation
**Status**: Valid - Confirmed via workflow run history
**Recent Changes**: Tests pass locally but fail in CI - path mismatch issue

### Current State Assessment

#### Root Cause Analysis

The test file `tests/unit/increment-version.test.ts` has **hardcoded absolute paths** that only work on the developer's local machine:

```typescript
// Line 15-17 of tests/unit/increment-version.test.ts
const projectRoot = '/home/pbrown/SkuInventory'  // PROBLEM: Hardcoded local path
const versionFilePath = path.join(projectRoot, 'version.json')
const scriptPath = path.join(projectRoot, 'scripts', 'increment-version.js')
```

In GitHub Actions CI, the working directory is:
- `/home/runner/work/SkuInventoryDatabase/SkuInventoryDatabase/`

But the test tries to access:
- `/home/pbrown/SkuInventory/version.json` (does not exist in CI)

This causes all 10 test failures with `ENOENT: no such file or directory`.

#### Secondary Issue: Shell Execution

The error `spawnSync /bin/sh ENOENT` is a **cascade failure** - it only occurs because the `beforeEach` hook fails first (when trying to read the non-existent version.json), leaving the test in an inconsistent state.

### Files Affected

| File | Type | Action Required |
|------|------|-----------------|
| `tests/unit/increment-version.test.ts` | Test | Refactor to use dynamic paths |
| `scripts/increment-version.js` | Script | Already uses `__dirname` (correct) |
| `version.json` | Data | No changes needed |

### Dependencies & Blockers

1. **No external blockers** - This is a self-contained test refactoring
2. The script itself (`scripts/increment-version.js`) already uses `__dirname` correctly:
   ```javascript
   const VERSION_FILE = path.join(__dirname, '..', 'version.json');
   ```
3. Tests need to follow the same pattern

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Simple
**Effort**: 2-3 hours
**Risk**: Low - isolated to test file, no production code changes

### Patterns Identified

**Primary Pattern**: The script itself shows the correct approach:
- File: `/home/pbrown/SkuInventory/scripts/increment-version.js` (line 13)
- Pattern: `path.join(__dirname, '..', 'version.json')` - uses `__dirname` for portability

**Secondary Pattern**: Other unit tests use mocking instead of real file system:
- File: `/home/pbrown/SkuInventory/tests/unit/bom-calculations.test.ts`
- Pattern: `vi.mock('@/lib/db', ...)` for external dependencies

### Ripple Effect Analysis

**Files Identified**: 1 (the test file only)
- `tests/unit/increment-version.test.ts` - Primary change required

**No ripple effects** - This is an isolated test file fix.

---

## Executive Summary

The GitHub Actions CI workflow fails because `tests/unit/increment-version.test.ts` uses a hardcoded path (`/home/pbrown/SkuInventory`) instead of dynamically determining the project root. The fix requires refactoring the test to use relative paths via `__dirname` or `process.cwd()`, and properly setting up/tearing down test fixtures in a temp directory to avoid modifying the real `version.json` file.

---

## Phase 1: Refactor Test File for CI Compatibility

### Subtask 1.1: Replace Hardcoded Paths with Dynamic Resolution

**File**: `/home/pbrown/SkuInventory/tests/unit/increment-version.test.ts`
**Pattern**: Follow `scripts/increment-version.js` line 13 using `__dirname`

**Instructions**:

1. Replace the hardcoded `projectRoot` constant (line 15):
   ```typescript
   // OLD (line 15):
   const projectRoot = '/home/pbrown/SkuInventory'

   // NEW:
   const projectRoot = path.resolve(__dirname, '..', '..')
   ```

2. Verify the derived paths remain correct:
   - `versionFilePath` will resolve to `{projectRoot}/version.json`
   - `scriptPath` will resolve to `{projectRoot}/scripts/increment-version.js`

**Validation Commands**:
```bash
# Test that paths resolve correctly
node -e "const path = require('path'); console.log(path.resolve('tests/unit', '..', '..'))"

# Run the specific test
npm test -- --run tests/unit/increment-version.test.ts
```

**Completion Criteria**:
- [ ] `projectRoot` is defined using `path.resolve(__dirname, '..', '..')`
- [ ] No hardcoded `/home/pbrown/SkuInventory` paths remain
- [ ] Tests pass locally with `npm test -- --run tests/unit/increment-version.test.ts`

---

### Subtask 1.2: Add Temporary Directory Isolation for Version File

**File**: `/home/pbrown/SkuInventory/tests/unit/increment-version.test.ts`
**Rationale**: The current test modifies the real `version.json` file and relies on `afterEach` to restore it. This is fragile - if a test fails, the real file may be left in a modified state. Use a temp directory approach instead.

**Instructions**:

1. Import `os` and `fs/promises` (or use sync equivalents) for temp directory handling:
   ```typescript
   import * as os from 'os'
   ```

2. Create a temp directory in `beforeAll` or `beforeEach`:
   ```typescript
   let tempDir: string
   let tempVersionFile: string
   let tempScriptPath: string

   beforeEach(() => {
     // Create temp directory for this test
     tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'increment-version-test-'))
     tempVersionFile = path.join(tempDir, 'version.json')

     // Copy the script to temp or just reference it directly
     // The script reads VERSION_FILE relative to its own __dirname, so we need
     // to either: (a) mock the script, or (b) run tests differently
   })
   ```

3. **Key Decision Point**: The current approach runs the actual script via `execSync`. The script uses `__dirname` to find `version.json` in the project root, NOT the temp directory.

   **Recommended approach**: Keep testing against the real `version.json` but improve the save/restore logic to be more robust:

   ```typescript
   let originalVersionContent: string | null = null

   beforeEach(() => {
     // Save original content (handle missing file gracefully)
     try {
       originalVersionContent = fs.readFileSync(versionFilePath, 'utf8')
     } catch {
       originalVersionContent = null
     }
   })

   afterEach(() => {
     // Restore original content
     if (originalVersionContent !== null) {
       fs.writeFileSync(versionFilePath, originalVersionContent, 'utf8')
     } else {
       // If file didn't exist, remove it
       try {
         fs.unlinkSync(versionFilePath)
       } catch {
         // Ignore if doesn't exist
       }
     }
     // ... git restore logic ...
   })
   ```

**Validation Commands**:
```bash
# Run tests multiple times to ensure proper cleanup
npm test -- --run tests/unit/increment-version.test.ts
npm test -- --run tests/unit/increment-version.test.ts

# Check version.json wasn't modified
cat version.json
```

**Completion Criteria**:
- [ ] `beforeEach` saves original file content (as string, not parsed JSON)
- [ ] `afterEach` restores original content reliably
- [ ] Tests are idempotent - running twice produces same results
- [ ] Real `version.json` is unchanged after test run

---

### Subtask 1.3: Fix Type Handling in beforeEach/afterEach

**File**: `/home/pbrown/SkuInventory/tests/unit/increment-version.test.ts`

**Instructions**:

1. Current code stores `originalVersion` as a parsed object (`{ version: string; buildTimestamp: string }`). Change to store raw string to avoid parse/stringify cycle issues:

   ```typescript
   // OLD:
   let originalVersion: { version: string; buildTimestamp: string }

   // NEW:
   let originalVersionContent: string | null = null
   ```

2. Update `beforeEach` to save raw string:
   ```typescript
   beforeEach(() => {
     try {
       originalVersionContent = fs.readFileSync(versionFilePath, 'utf8')
     } catch {
       originalVersionContent = null
     }
   })
   ```

3. Update `afterEach` to restore raw string:
   ```typescript
   afterEach(() => {
     if (originalVersionContent !== null) {
       fs.writeFileSync(versionFilePath, originalVersionContent, 'utf8')
     } else {
       try {
         fs.unlinkSync(versionFilePath)
       } catch {
         // File didn't exist originally, ignore if can't delete
       }
     }
     // Keep existing git restore logic
     try {
       execSync('git restore --staged version.json', { cwd: projectRoot, stdio: 'pipe' })
     } catch {
       // Ignore if not staged
     }
   })
   ```

**Completion Criteria**:
- [ ] `originalVersionContent` is typed as `string | null`
- [ ] No JSON.parse/stringify in save/restore cycle
- [ ] Handles case where file doesn't exist initially

---

## Phase 2: Verification

### Subtask 2.1: Run Full Test Suite Locally

**Instructions**:

1. Run the specific test file:
   ```bash
   npm test -- --run tests/unit/increment-version.test.ts
   ```

2. Run all unit tests to ensure no regressions:
   ```bash
   npm test -- --run
   ```

3. Run TypeScript check:
   ```bash
   npx tsc --noEmit
   ```

4. Run linter:
   ```bash
   npm run lint
   ```

5. Run build:
   ```bash
   npm run build
   ```

**Completion Criteria**:
- [ ] `npm test -- --run tests/unit/increment-version.test.ts` passes (8 tests)
- [ ] `npm test -- --run` passes (all unit tests)
- [ ] `npx tsc --noEmit` completes with no errors
- [ ] `npm run lint` passes
- [ ] `npm run build` completes successfully

---

### Subtask 2.2: Verify CI Compatibility (Dry Run)

**Instructions**:

1. Check that no hardcoded paths remain:
   ```bash
   grep -n "pbrown" tests/unit/increment-version.test.ts
   # Should return nothing
   ```

2. Verify path resolution works from different directories:
   ```bash
   cd /tmp
   node -e "
     const path = require('path');
     const testFile = '/home/pbrown/SkuInventory/tests/unit/increment-version.test.ts';
     const testDir = path.dirname(testFile);
     const projectRoot = path.resolve(testDir, '..', '..');
     console.log('Project root:', projectRoot);
     console.log('Version file:', path.join(projectRoot, 'version.json'));
   "
   ```

**Completion Criteria**:
- [ ] No occurrences of `/home/pbrown` in test file
- [ ] Path resolution works from any working directory

---

## Summary of Deliverables

**Files Modified**: 1
- `/home/pbrown/SkuInventory/tests/unit/increment-version.test.ts` - Refactored for CI compatibility

**Files Created**: 0
**Files Deleted**: 0

## Handoff to Build Agent

1. Execute subtasks in exact order (1.1 -> 1.2 -> 1.3 -> 2.1 -> 2.2)
2. Subtask 1.1 is the critical fix - replace hardcoded path
3. Subtasks 1.2 and 1.3 improve robustness of save/restore logic
4. Subtask 2.1 verifies the fix works locally
5. Subtask 2.2 verifies no hardcoded paths remain
6. After all subtasks complete, commit with message referencing Issue #53

## Test Strategy Note

- Use Vitest for unit tests (`npm test -- --run`)
- Run targeted test first: `tests/unit/increment-version.test.ts`
- Then run full suite to catch regressions

## Code Reference - Complete Refactored Test File (Target State)

The key changes to `/home/pbrown/SkuInventory/tests/unit/increment-version.test.ts`:

```typescript
// Lines 15-18 - BEFORE:
const projectRoot = '/home/pbrown/SkuInventory'
const versionFilePath = path.join(projectRoot, 'version.json')
const scriptPath = path.join(projectRoot, 'scripts', 'increment-version.js')
let originalVersion: { version: string; buildTimestamp: string }

// Lines 15-18 - AFTER:
const projectRoot = path.resolve(__dirname, '..', '..')
const versionFilePath = path.join(projectRoot, 'version.json')
const scriptPath = path.join(projectRoot, 'scripts', 'increment-version.js')
let originalVersionContent: string | null = null

// beforeEach - BEFORE (lines 20-27):
beforeEach(() => {
  try {
    originalVersion = JSON.parse(fs.readFileSync(versionFilePath, 'utf8'))
  } catch {
    originalVersion = { version: '0.5.0', buildTimestamp: new Date().toISOString() }
  }
})

// beforeEach - AFTER:
beforeEach(() => {
  try {
    originalVersionContent = fs.readFileSync(versionFilePath, 'utf8')
  } catch {
    originalVersionContent = null
  }
})

// afterEach - BEFORE (lines 29-38):
afterEach(() => {
  fs.writeFileSync(versionFilePath, JSON.stringify(originalVersion, null, 2) + '\n', 'utf8')
  try {
    execSync('git restore --staged version.json', { cwd: projectRoot, stdio: 'pipe' })
  } catch {
    // Ignore if not staged
  }
})

// afterEach - AFTER:
afterEach(() => {
  if (originalVersionContent !== null) {
    fs.writeFileSync(versionFilePath, originalVersionContent, 'utf8')
  } else {
    try {
      fs.unlinkSync(versionFilePath)
    } catch {
      // File didn't exist originally
    }
  }
  try {
    execSync('git restore --staged version.json', { cwd: projectRoot, stdio: 'pipe' })
  } catch {
    // Ignore if not staged
  }
})
```

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Investigation | 8m |
| Validation | 2m |
| Planning | 5m |
| **Total** | **15m** |
