# Implementation Plan
**Generated**: 2025-12-17T14:45:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #299 - Optimize Inventory Calculation with Snapshotting
**Estimated Build Time**: 16-24 hours
**Complexity**: High

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #299
**Priority**: High (Performance optimization for scalability)

### Task Classification
**Category**: REFACTORING + NEW_FEATURE
**Test Strategy**: FULL (architectural change, affects all transaction workflows)
**Suggested Filter**: None - full test suite required

### Issue Validation
**Status**: Valid
**Recent Changes**: Issue #292 optimized reorder-status filtering to DB level (related optimization work)

### Current State Assessment

#### Current Architecture (O(N) reads)
The system currently calculates inventory quantities by summing all transaction history on every read:

- **Component quantities**: `src/services/inventory.ts` - `getComponentQuantity()` and `getComponentQuantities()` aggregate `TransactionLine.quantityChange` grouped by component
- **SKU/Finished Goods quantities**: `src/services/finished-goods.ts` - `getSkuQuantity()` and `getSkuQuantities()` aggregate `FinishedGoodsLine.quantityChange`
- **Location-aware calculations**: Complex queries with 3 aggregations for transfers (regular + fromLocation + toLocation)

#### Existing Patterns to Follow
The system already has a `LotBalance` model that maintains running balances for lot-tracked inventory:
- Created atomically during receipt transactions
- Updated during build consumption (FEFO algorithm)
- Updated during receipt edits

#### Components Affected
1. **Database**: New `InventoryBalance` table, new `FinishedGoodsBalance` table
2. **Services**:
   - `src/services/inventory.ts` (major refactor)
   - `src/services/finished-goods.ts` (major refactor)
   - `src/services/transfer.ts` (balance updates)
   - `src/services/draft-transaction.ts` (balance updates on approval)
   - `src/services/transaction-edit.ts` (balance recalculation on edit/delete)
   - `src/services/forecast.ts` (consumption rate calculation unchanged, quantity reads optimized)
   - `src/services/bom.ts` (quantity reads optimized)
   - `src/services/lowstock-alert.ts` (quantity reads optimized)
   - `src/services/chatbot-queries.ts` (quantity reads optimized)
3. **API Routes**: Multiple routes call quantity functions - all will benefit passively

### Dependencies & Blockers
1. Prisma schema update required before service changes
2. Migration script needed to populate initial balances from existing history
3. All transaction services must update atomically within Prisma transactions

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: High
**Effort**: 16-24 hours
**Risk**: Medium-High (affects core inventory calculations, requires careful atomicity)

### Patterns Identified
**Primary**: `LotBalance` model in `prisma/schema.prisma` lines 239-247 - exact pattern to follow
**Secondary**: `src/services/inventory.ts` `createReceiptTransaction()` lines 377-506 - atomic balance updates pattern

### Ripple Effect Analysis

**Files Requiring Direct Changes**: 10 files

| File | Change Type | Reason |
|------|-------------|--------|
| `prisma/schema.prisma` | ADD | New InventoryBalance and FinishedGoodsBalance models |
| `src/services/inventory.ts` | MAJOR REFACTOR | Update quantity functions to read from balance table, update all transaction creators |
| `src/services/finished-goods.ts` | MAJOR REFACTOR | Update quantity functions to read from balance table, update all transaction creators |
| `src/services/transfer.ts` | MODIFY | Add balance updates for component transfers |
| `src/services/draft-transaction.ts` | MODIFY | Add balance updates on draft approval |
| `src/services/transaction-edit.ts` | MODIFY | Add balance recalculation on edit/delete |
| `src/types/inventory.ts` (NEW) | CREATE | New types for InventoryBalance |
| Migration script | CREATE | One-time script to populate balances from history |

**Files Benefiting Passively (No Changes Needed)**: 11+ files
- All API routes and services that call `getComponentQuantity/ies` or `getSkuQuantity/ies` will automatically benefit from O(1) reads

---

## Executive Summary

This implementation introduces an `InventoryBalance` table (for components) and `FinishedGoodsBalance` table (for SKUs) that maintain running balances updated atomically with each transaction. Reads become O(1) lookups instead of O(N) aggregations. The existing `LotBalance` pattern demonstrates this approach already works well in the codebase.

---

## Phase 0: Pre-Implementation Analysis

### Subtask 0.1: Verify Current Query Performance
**File**: N/A (analysis only)
**Instructions**:
1. Document current query patterns in `getComponentQuantity` and `getSkuQuantity`
2. Identify all atomic transaction boundaries that must include balance updates
3. Map the complete flow for each transaction type (receipt, build, adjustment, initial, transfer, outbound)

**Completion Criteria**:
- [ ] Query patterns documented
- [ ] Transaction boundaries identified
- [ ] All transaction types mapped

---

## Phase 1: Database Schema Changes

### Subtask 1.1: Add InventoryBalance Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow `LotBalance` model at lines 239-247
**Instructions**:

Add after the `Component` model (around line 217):

```prisma
model InventoryBalance {
  id          String   @id @default(uuid())
  componentId String
  component   Component @relation(fields: [componentId], references: [id], onDelete: Cascade)
  locationId  String
  location    Location @relation(fields: [locationId], references: [id])
  quantity    Decimal  @db.Decimal(10, 4)

  @@unique([componentId, locationId])
  @@index([componentId])
  @@index([locationId])
}
```

Add relation to `Component` model:
```prisma
// In Component model, add:
inventoryBalances InventoryBalance[]
```

Add relation to `Location` model:
```prisma
// In Location model, add:
inventoryBalances InventoryBalance[]
```

**Validation**:
```bash
npx prisma validate
```

**Completion Criteria**:
- [ ] InventoryBalance model added
- [ ] Relations added to Component and Location
- [ ] Schema validates without errors

### Subtask 1.2: Add FinishedGoodsBalance Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow `LotBalance` model
**Instructions**:

Add after the `SKU` model (around line 400):

```prisma
model FinishedGoodsBalance {
  id         String   @id @default(uuid())
  skuId      String
  sku        SKU      @relation(fields: [skuId], references: [id], onDelete: Cascade)
  locationId String
  location   Location @relation(fields: [locationId], references: [id])
  quantity   Decimal  @db.Decimal(10, 4)

  @@unique([skuId, locationId])
  @@index([skuId])
  @@index([locationId])
}
```

Add relation to `SKU` model:
```prisma
// In SKU model, add:
finishedGoodsBalances FinishedGoodsBalance[]
```

Add relation to `Location` model:
```prisma
// In Location model, add (if not already from 1.1):
finishedGoodsBalances FinishedGoodsBalance[]
```

**Validation**:
```bash
npx prisma validate
```

**Completion Criteria**:
- [ ] FinishedGoodsBalance model added
- [ ] Relations added to SKU and Location
- [ ] Schema validates without errors

### Subtask 1.3: Create and Apply Database Migration
**File**: `/home/pbrown/SkuInventory/prisma/migrations/[timestamp]_add_inventory_balance_tables/migration.sql`
**Instructions**:

1. Generate migration:
```bash
DATABASE_URL="postgresql://inventory_test:inventory_test_2025@localhost:2346/inventory_test" npx prisma migrate dev --name add_inventory_balance_tables
```

2. Verify migration file was created
3. Generate Prisma client:
```bash
npx prisma generate
```

**Validation**:
```bash
docker exec inventory-db-test psql -U inventory_test -d inventory_test -c "\d \"InventoryBalance\""
docker exec inventory-db-test psql -U inventory_test -d inventory_test -c "\d \"FinishedGoodsBalance\""
```

**Completion Criteria**:
- [ ] Migration created successfully
- [ ] Migration applied to test database
- [ ] Tables exist with correct structure
- [ ] Prisma client regenerated

---

## Phase 2: Types Layer

### Subtask 2.1: Create Inventory Balance Types
**File**: `/home/pbrown/SkuInventory/src/types/inventory-balance.ts` (NEW)
**Pattern**: Follow `src/types/lot.ts`
**Instructions**:

Create new file with:

```typescript
import { z } from 'zod'

// Inventory balance for components
export interface InventoryBalanceRecord {
  id: string
  componentId: string
  locationId: string
  quantity: number
}

// Finished goods balance for SKUs
export interface FinishedGoodsBalanceRecord {
  id: string
  skuId: string
  locationId: string
  quantity: number
}

// Response type for balance updates
export interface BalanceUpdateResult {
  componentId?: string
  skuId?: string
  locationId: string
  previousQuantity: number
  newQuantity: number
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Types file created
- [ ] TypeScript compiles without errors

---

## Phase 3: Migration Script for Existing Data

### Subtask 3.1: Create Balance Population Script
**File**: `/home/pbrown/SkuInventory/scripts/populate-inventory-balances.ts` (NEW)
**Instructions**:

Create a script that:
1. For each component, calculate current quantity at each location from TransactionLine history
2. Upsert InventoryBalance records
3. For each SKU, calculate current quantity at each location from FinishedGoodsLine history
4. Upsert FinishedGoodsBalance records
5. Validate totals match between calculation methods

```typescript
import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'

async function populateInventoryBalances() {
  console.log('Populating InventoryBalance records...')

  // Get all components with their companies
  const components = await prisma.component.findMany({
    where: { isActive: true },
    select: { id: true, companyId: true },
  })

  // Get all locations
  const locations = await prisma.location.findMany({
    where: { isActive: true },
    select: { id: true, companyId: true },
  })

  let balancesCreated = 0

  for (const component of components) {
    if (!component.companyId) continue

    // Get locations for this company
    const companyLocations = locations.filter(l => l.companyId === component.companyId)

    for (const location of companyLocations) {
      // Calculate quantity using existing logic (copy from getComponentQuantity)
      // ... [full implementation in Build phase]

      // Upsert balance
      await prisma.inventoryBalance.upsert({
        where: {
          componentId_locationId: {
            componentId: component.id,
            locationId: location.id,
          },
        },
        create: {
          componentId: component.id,
          locationId: location.id,
          quantity: new Prisma.Decimal(calculatedQuantity),
        },
        update: {
          quantity: new Prisma.Decimal(calculatedQuantity),
        },
      })
      balancesCreated++
    }
  }

  console.log(`Created ${balancesCreated} InventoryBalance records`)

  // Similar for FinishedGoodsBalance...
}

populateInventoryBalances()
  .then(() => console.log('Done'))
  .catch(console.error)
  .finally(() => prisma.$disconnect())
```

**Validation**:
```bash
npx ts-node scripts/populate-inventory-balances.ts
```

**Completion Criteria**:
- [ ] Script created
- [ ] Script runs without errors on test database
- [ ] Balances populated correctly
- [ ] Verification query confirms totals match

---

## Phase 4: Service Layer - Inventory Service Refactor

### Subtask 4.1: Add Balance Update Helper Functions
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Instructions**:

Add new helper functions for atomic balance updates:

```typescript
/**
 * Update inventory balance atomically within a transaction
 * Creates the balance record if it doesn't exist
 */
export async function updateInventoryBalance(
  tx: Prisma.TransactionClient,
  componentId: string,
  locationId: string,
  quantityDelta: number
): Promise<void> {
  await tx.inventoryBalance.upsert({
    where: {
      componentId_locationId: {
        componentId,
        locationId,
      },
    },
    create: {
      componentId,
      locationId,
      quantity: new Prisma.Decimal(quantityDelta),
    },
    update: {
      quantity: {
        increment: new Prisma.Decimal(quantityDelta),
      },
    },
  })
}
```

**Completion Criteria**:
- [ ] Helper function added
- [ ] TypeScript compiles

### Subtask 4.2: Refactor getComponentQuantity to Read from Balance Table
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Current function at lines 46-130
**Instructions**:

Replace the existing O(N) aggregation with O(1) lookup:

```typescript
export async function getComponentQuantity(
  componentId: string,
  companyId: string,
  locationId?: string
): Promise<number> {
  // Verify component belongs to company
  const component = await prisma.component.findFirst({
    where: { id: componentId, companyId },
    select: { id: true }
  })
  if (!component) {
    throw new Error('Component not found or access denied')
  }

  if (!locationId) {
    // Global total - sum all location balances
    const result = await prisma.inventoryBalance.aggregate({
      where: { componentId },
      _sum: { quantity: true },
    })
    return result._sum.quantity?.toNumber() ?? 0
  }

  // Location-specific - direct lookup
  const balance = await prisma.inventoryBalance.findUnique({
    where: {
      componentId_locationId: {
        componentId,
        locationId,
      },
    },
    select: { quantity: true },
  })

  return balance?.quantity.toNumber() ?? 0
}
```

**Validation**:
```bash
npm test -- --testPathPattern="inventory-quantity"
```

**Completion Criteria**:
- [ ] Function refactored
- [ ] Existing tests pass
- [ ] O(1) query verified

### Subtask 4.3: Refactor getComponentQuantities (Batch Version)
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Current function at lines 142-266
**Instructions**:

Refactor to use balance table:

```typescript
export async function getComponentQuantities(
  componentIds: string[],
  companyId: string,
  locationId?: string
): Promise<Map<string, number>> {
  // Filter to only components the company owns
  if (componentIds.length === 0) {
    return new Map()
  }
  const validComponents = await prisma.component.findMany({
    where: { id: { in: componentIds }, companyId },
    select: { id: true }
  })
  const validIds = validComponents.map(c => c.id)

  const quantities = new Map<string, number>()

  // Initialize all to 0
  for (const id of componentIds) {
    quantities.set(id, 0)
  }

  if (validIds.length === 0) {
    return quantities
  }

  if (!locationId) {
    // Global totals - aggregate across all locations
    const results = await prisma.inventoryBalance.groupBy({
      by: ['componentId'],
      where: { componentId: { in: validIds } },
      _sum: { quantity: true },
    })

    for (const result of results) {
      quantities.set(result.componentId, result._sum.quantity?.toNumber() ?? 0)
    }
  } else {
    // Location-specific - direct lookups
    const balances = await prisma.inventoryBalance.findMany({
      where: {
        componentId: { in: validIds },
        locationId,
      },
      select: { componentId: true, quantity: true },
    })

    for (const balance of balances) {
      quantities.set(balance.componentId, balance.quantity.toNumber())
    }
  }

  return quantities
}
```

**Completion Criteria**:
- [ ] Function refactored
- [ ] TypeScript compiles
- [ ] Tests pass

### Subtask 4.4: Update createReceiptTransaction to Update Balance
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Current function at lines 346-507
**Instructions**:

Inside the `prisma.$transaction` block, after creating the transaction, add:

```typescript
// Update inventory balance atomically
await updateInventoryBalance(
  tx,
  componentId,
  locationIdToUse!,
  quantity
)
```

**Completion Criteria**:
- [ ] Balance update added to transaction
- [ ] Tests pass

### Subtask 4.5: Update createAdjustmentTransaction to Update Balance
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Current function at lines 512-568
**Instructions**:

Wrap in `prisma.$transaction` and add balance update:

```typescript
return prisma.$transaction(async (tx) => {
  // Existing component lookup...

  // Create transaction...
  const transaction = await tx.transaction.create({...})

  // Update inventory balance atomically
  await updateInventoryBalance(
    tx,
    componentId,
    locationIdToUse!,
    quantity
  )

  return transaction
})
```

**Completion Criteria**:
- [ ] Transaction wrapped in $transaction
- [ ] Balance update added
- [ ] Tests pass

### Subtask 4.6: Update createInitialTransaction to Update Balance
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Current function at lines 573-657
**Instructions**:

Add balance update inside existing `prisma.$transaction`:

```typescript
// After creating transaction, add:
await updateInventoryBalance(
  tx,
  componentId,
  locationIdToUse!,
  quantity
)
```

**Completion Criteria**:
- [ ] Balance update added
- [ ] Tests pass

### Subtask 4.7: Update createBuildTransaction to Update Balances
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Current function at lines 911-1241
**Instructions**:

Inside the `prisma.$transaction` block, after creating consumption lines, add balance decrements for each component consumed:

```typescript
// After creating transaction lines, add:
for (const consumptionLine of consumptionLines) {
  await updateInventoryBalance(
    tx,
    consumptionLine.componentId,
    locationIdToUse!,
    consumptionLine.quantityChange.toNumber() // negative value decrements
  )
}
```

**Completion Criteria**:
- [ ] Balance updates added for all consumed components
- [ ] Tests pass

### Subtask 4.8: Refactor getComponentQuantitiesByLocation
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Current function at lines 272-317
**Instructions**:

Refactor to query InventoryBalance directly:

```typescript
export async function getComponentQuantitiesByLocation(
  componentId: string,
  companyId: string
): Promise<Array<{ locationId: string; locationName: string; locationType: string; quantity: number }>> {
  // Verify component belongs to company
  const component = await prisma.component.findFirst({
    where: { id: componentId, companyId },
    select: { id: true }
  })
  if (!component) {
    throw new Error('Component not found or access denied')
  }

  // Get all balances for this component with location info
  const balances = await prisma.inventoryBalance.findMany({
    where: {
      componentId,
      quantity: { not: new Prisma.Decimal(0) },
    },
    include: {
      location: {
        select: { id: true, name: true, type: true },
      },
    },
  })

  return balances
    .map(b => ({
      locationId: b.location.id,
      locationName: b.location.name,
      locationType: b.location.type,
      quantity: b.quantity.toNumber(),
    }))
    .sort((a, b) => a.locationName.localeCompare(b.locationName))
}
```

**Completion Criteria**:
- [ ] Function refactored
- [ ] Tests pass

---

## Phase 5: Service Layer - Finished Goods Service Refactor

### Subtask 5.1: Add Finished Goods Balance Update Helper
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Instructions**:

Add helper function:

```typescript
/**
 * Update finished goods balance atomically within a transaction
 */
export async function updateFinishedGoodsBalance(
  tx: Prisma.TransactionClient,
  skuId: string,
  locationId: string,
  quantityDelta: number
): Promise<void> {
  await tx.finishedGoodsBalance.upsert({
    where: {
      skuId_locationId: {
        skuId,
        locationId,
      },
    },
    create: {
      skuId,
      locationId,
      quantity: new Prisma.Decimal(quantityDelta),
    },
    update: {
      quantity: {
        increment: new Prisma.Decimal(quantityDelta),
      },
    },
  })
}
```

**Completion Criteria**:
- [ ] Helper function added

### Subtask 5.2: Refactor getSkuQuantity to Read from Balance Table
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Pattern**: Current function at lines 11-36
**Instructions**:

Replace with O(1) lookup:

```typescript
export async function getSkuQuantity(
  skuId: string,
  companyId: string,
  locationId?: string
): Promise<number> {
  // Verify SKU belongs to company
  const sku = await prisma.sKU.findFirst({
    where: { id: skuId, companyId },
    select: { id: true },
  })
  if (!sku) {
    throw new Error('SKU not found or access denied')
  }

  if (!locationId) {
    // Global total
    const result = await prisma.finishedGoodsBalance.aggregate({
      where: { skuId },
      _sum: { quantity: true },
    })
    return result._sum.quantity?.toNumber() ?? 0
  }

  // Location-specific
  const balance = await prisma.finishedGoodsBalance.findUnique({
    where: {
      skuId_locationId: { skuId, locationId },
    },
    select: { quantity: true },
  })

  return balance?.quantity.toNumber() ?? 0
}
```

**Completion Criteria**:
- [ ] Function refactored
- [ ] Tests pass

### Subtask 5.3: Refactor getSkuQuantities (Batch Version)
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Pattern**: Current function at lines 44-95
**Instructions**:

Similar refactor to use balance table.

**Completion Criteria**:
- [ ] Function refactored
- [ ] Tests pass

### Subtask 5.4: Update adjustFinishedGoods to Update Balance
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Pattern**: Current function at lines 158-193
**Instructions**:

Wrap in transaction and add balance update.

**Completion Criteria**:
- [ ] Balance update added

### Subtask 5.5: Update receiveFinishedGoods to Update Balance
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Pattern**: Current function at lines 199-239
**Instructions**:

Wrap in transaction and add balance update.

**Completion Criteria**:
- [ ] Balance update added

### Subtask 5.6: Update transferFinishedGoods to Update Balances
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Pattern**: Current function at lines 244-322
**Instructions**:

Add balance updates for both source (decrement) and destination (increment).

**Completion Criteria**:
- [ ] Balance updates added for both locations

### Subtask 5.7: Update createOutboundTransaction to Update Balance
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Pattern**: Current function at lines 328-377
**Instructions**:

Add balance decrement.

**Completion Criteria**:
- [ ] Balance update added

---

## Phase 6: Service Layer - Transfer Service

### Subtask 6.1: Update createTransferTransaction to Update Balances
**File**: `/home/pbrown/SkuInventory/src/services/transfer.ts`
**Pattern**: Current function at lines 35-175
**Instructions**:

Inside the existing `prisma.$transaction`, add balance updates:

```typescript
// After creating transaction, add:
// Decrement source location
await updateInventoryBalance(
  tx,
  componentId,
  fromLocationId,
  -quantity
)

// Increment destination location
await updateInventoryBalance(
  tx,
  componentId,
  toLocationId,
  quantity
)
```

Import the helper from inventory service.

**Completion Criteria**:
- [ ] Balance updates added for both locations
- [ ] Tests pass

---

## Phase 7: Service Layer - Draft Transaction Service

### Subtask 7.1: Update approveDraftTransaction to Update Balances
**File**: `/home/pbrown/SkuInventory/src/services/draft-transaction.ts`
**Pattern**: Current function at lines 393-628
**Instructions**:

Add balance updates for each transaction type during approval:
- Build: decrement component balances, increment FG balance
- Receipt/Initial: increment component balance
- Adjustment: increment/decrement component balance
- Transfer: decrement source, increment destination

**Completion Criteria**:
- [ ] Balance updates added for all transaction types
- [ ] Tests pass

---

## Phase 8: Service Layer - Transaction Edit Service

### Subtask 8.1: Update reverseTransactionLines to Reverse Balances
**File**: `/home/pbrown/SkuInventory/src/services/transaction-edit.ts`
**Pattern**: Current function at lines 25-56
**Instructions**:

Add balance reversal logic:

```typescript
async function reverseTransactionLines(
  tx: Prisma.TransactionClient,
  transactionId: string,
  locationId: string
): Promise<void> {
  const lines = await tx.transactionLine.findMany({
    where: { transactionId },
    include: { lot: true },
  })

  for (const line of lines) {
    // Reverse lot balance (existing logic)
    if (line.lotId) {
      await tx.lotBalance.update({...})
    }

    // Reverse inventory balance
    await updateInventoryBalance(
      tx,
      line.componentId,
      locationId,
      -line.quantityChange.toNumber() // Negate to reverse
    )
  }

  await tx.transactionLine.deleteMany({
    where: { transactionId },
  })
}
```

**Completion Criteria**:
- [ ] Balance reversal added
- [ ] Tests pass

### Subtask 8.2: Update deleteTransaction to Reverse Balances
**File**: `/home/pbrown/SkuInventory/src/services/transaction-edit.ts`
**Pattern**: Current function at lines 837-896
**Instructions**:

Add balance reversal before deleting transaction.

**Completion Criteria**:
- [ ] Balance reversal added
- [ ] Tests pass

---

## Phase 9: Inventory Service Raw SQL Optimization

### Subtask 9.1: Update getComponentsWithReorderStatus Raw SQL
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Current function at lines 1272-1557
**Instructions**:

Update the raw SQL CTE to query `InventoryBalance` instead of aggregating `TransactionLine`:

Replace the quantity subquery with:
```sql
SELECT c.id as "componentId", COALESCE(
  (SELECT SUM(ib.quantity)
   FROM "InventoryBalance" ib
   WHERE ib."componentId" = c.id
   ${locationId ? 'AND ib."locationId" = $5' : ''}
  ), 0
) as qty_sum
FROM "Component" c
WHERE c."companyId" = $1
```

**Completion Criteria**:
- [ ] Raw SQL updated
- [ ] Tests pass

---

## Phase 10: Tests

### Subtask 10.1: Update Existing Unit Tests
**File**: `/home/pbrown/SkuInventory/tests/unit/inventory-quantity.test.ts`
**Instructions**:

Update tests to verify balance updates occur correctly:
1. Add tests for balance creation on first transaction
2. Add tests for balance increment/decrement
3. Add tests for balance reversal on edit/delete

**Completion Criteria**:
- [ ] All existing tests pass
- [ ] New balance-specific tests added

### Subtask 10.2: Add Integration Tests for Balance Consistency
**File**: `/home/pbrown/SkuInventory/tests/integration/inventory-balance.test.ts` (NEW)
**Instructions**:

Create integration tests that:
1. Create transactions and verify balances match calculated values
2. Edit transactions and verify balances are updated
3. Delete transactions and verify balances are reversed
4. Test race conditions with concurrent transactions

**Completion Criteria**:
- [ ] Integration tests pass
- [ ] Balance consistency verified

### Subtask 10.3: Run Full Test Suite
**Instructions**:
```bash
npm test
```

**Completion Criteria**:
- [ ] All tests pass
- [ ] No regressions

---

## Phase 11: Validation and Cleanup

### Subtask 11.1: Run Population Script on Test Database
**Instructions**:
```bash
DATABASE_URL="postgresql://inventory_test:inventory_test_2025@localhost:2346/inventory_test" npx ts-node scripts/populate-inventory-balances.ts
```

**Completion Criteria**:
- [ ] Script completes without errors
- [ ] Balances match calculated values

### Subtask 11.2: Verify Build and Type Check
**Instructions**:
```bash
npm run build
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Build succeeds
- [ ] No TypeScript errors
- [ ] No lint errors

---

## Summary of Deliverables

**Files Created**: 3
- `/home/pbrown/SkuInventory/src/types/inventory-balance.ts`
- `/home/pbrown/SkuInventory/scripts/populate-inventory-balances.ts`
- `/home/pbrown/SkuInventory/tests/integration/inventory-balance.test.ts`

**Files Modified**: 7
- `/home/pbrown/SkuInventory/prisma/schema.prisma`
- `/home/pbrown/SkuInventory/src/services/inventory.ts`
- `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
- `/home/pbrown/SkuInventory/src/services/transfer.ts`
- `/home/pbrown/SkuInventory/src/services/draft-transaction.ts`
- `/home/pbrown/SkuInventory/src/services/transaction-edit.ts`
- `/home/pbrown/SkuInventory/tests/unit/inventory-quantity.test.ts`

**Migration Files**: 1
- `prisma/migrations/[timestamp]_add_inventory_balance_tables/migration.sql`

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 0 through Phase 11)
2. Complete Phase 1 (schema + migration) before any service changes
3. Run the population script (Phase 3) after migration before testing
4. Test completion criteria before next subtask
5. Follow reference patterns exactly (especially LotBalance pattern)
6. All balance updates MUST be inside Prisma $transaction blocks for atomicity

---

## Test Strategy Note

- Use Vitest for unit tests
- Use existing test patterns in `tests/unit/inventory-quantity.test.ts`
- Full test suite required due to architectural impact

---

## Performance Metrics

| Phase | Estimated Duration |
|-------|----------|
| Phase 0: Analysis | 30m |
| Phase 1: Schema | 1h |
| Phase 2: Types | 30m |
| Phase 3: Migration Script | 2h |
| Phase 4: Inventory Service | 4h |
| Phase 5: Finished Goods Service | 2h |
| Phase 6: Transfer Service | 1h |
| Phase 7: Draft Transaction Service | 1.5h |
| Phase 8: Transaction Edit Service | 1.5h |
| Phase 9: Raw SQL Update | 1h |
| Phase 10: Tests | 3h |
| Phase 11: Validation | 1h |
| **Total** | **18-19h** |

---

## Risk Mitigation

1. **Data Consistency**: Population script includes validation queries to verify balance totals match calculated values
2. **Atomicity**: All balance updates wrapped in Prisma transactions
3. **Rollback Plan**: If issues discovered, can revert to O(N) queries by changing function implementations (balance tables remain as optimization layer)
4. **Testing**: Full test suite ensures no regressions

---

## Notes for Production Deployment

After successful implementation and testing:
1. Run migration on production database during maintenance window
2. Run population script to populate initial balances
3. Verify balance totals match calculated values
4. Deploy code changes
5. Monitor for any balance drift (should not occur if all transactions properly update balances)
