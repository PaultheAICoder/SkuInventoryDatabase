# Implementation Plan
**Generated**: 2025-12-04T03:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #72 - [Parent #9] Phase 5: Finished goods inventory tracking from builds
**Estimated Build Time**: 14-18 hours
**Complexity**: High

## Investigation Summary

### Request Analysis
**Type**: Feature (Major Enhancement)
**Source**: GitHub Issue #72
**Priority**: High - Core inventory functionality for V2 roadmap

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED - Test affected modules (services, API routes, components)
**Suggested Filter**: `--filter="inventory|sku|build|finished"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- Issue #71 (Transfer transactions) - CLOSED (dependency satisfied)
- Issue #70 (Location-aware queries) - CLOSED (provides patterns to follow)
- Issue #96 (Company scoping) - CLOSED (all queries now scope by company)

### Current State Assessment

**Existing Components:**
- `src/services/inventory.ts` - Contains `createBuildTransaction`, `getComponentQuantity`, `getComponentQuantities`
- `src/services/transfer.ts` - Pattern for location-to-location inventory movement
- `src/services/bom.ts` - `calculateMaxBuildableUnits`, `calculateMaxBuildableUnitsForSKUs`
- `src/services/location.ts` - `getDefaultLocationId`, location management utilities
- `src/app/api/transactions/build/route.ts` - Build transaction API endpoint
- `src/components/features/BuildDialog.tsx` - Build form UI with location selector
- `src/app/(dashboard)/skus/[id]/page.tsx` - SKU detail page
- `src/components/features/SKUTable.tsx` - SKU list table (already has Buildable column)

**Database:**
- TransactionLine model tracks component inventory (componentId is currently required)
- Transaction model has locationId, fromLocationId, toLocationId
- SKU model has transactions relation for build history
- LocationType enum includes `finished_goods` type

**API Routes:**
- `/api/skus/[id]` - SKU detail (has locationId query param support)
- `/api/skus` - SKU list (has locationId query param support)
- `/api/transactions/build` - Build transaction creation

**Types:**
- `src/types/sku.ts` - SKUResponse, SKUDetailResponse
- `src/types/transaction.ts` - CreateBuildInput, TransactionResponse

### Dependencies & Blockers

1. **Issue #71 (Transfer transactions)**: CLOSED - Provides pattern for finished goods transfers
2. **Issue #70 (Location-aware queries)**: CLOSED - Provides `getComponentQuantity(id, locationId?)` pattern

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: High
**Effort**: 14-18 hours (split across multiple phases)
**Risk**: Medium - Schema change, service layer changes, multiple UI touchpoints

**Risk Factors:**
1. Schema migration required (new model FinishedGoodsLine)
2. Build transaction service needs extension (not breaking change)
3. Multiple API endpoints affected
4. Frontend UI additions (Build dialog, SKU detail page)

### Patterns Identified

**Primary Pattern**: `src/services/transfer.ts` - Location-based inventory movement
- Use for: FinishedGoodsLine creation pattern, transfer finished goods

**Secondary Pattern**: `src/services/inventory.ts:getComponentQuantities`
- Use for: `getSkuQuantities` implementation (aggregate by skuId instead of componentId)

**Tertiary Pattern**: `src/app/api/transactions/build/route.ts`
- Use for: Extending build API with outputLocationId

### Ripple Effect Analysis

**Files to CREATE (6)**:
- `prisma/migrations/[timestamp]_add_finished_goods_line/migration.sql`
- `src/services/finished-goods.ts`
- `src/app/api/skus/[id]/inventory/route.ts`
- `src/types/finished-goods.ts`

**Files to MODIFY (8)**:
- `prisma/schema.prisma` - Add FinishedGoodsLine model
- `src/services/inventory.ts` - Add `getSkuQuantity`, `getSkuQuantities`, extend `createBuildTransaction`
- `src/app/api/transactions/build/route.ts` - Add outputLocationId handling
- `src/types/transaction.ts` - Extend CreateBuildInput schema
- `src/types/sku.ts` - Add finishedGoodsQuantity to SKUResponse
- `src/components/features/BuildDialog.tsx` - Add output location selector
- `src/app/(dashboard)/skus/[id]/page.tsx` - Display finished goods inventory
- `src/app/api/skus/route.ts` - Include finished goods quantities in list
- `src/app/api/skus/[id]/route.ts` - Include finished goods inventory by location

**TOTAL FILES AFFECTED**: 12+

---

## Executive Summary

This implementation adds finished goods (SKU) inventory tracking. When a build transaction is created with an optional `outputLocationId`, it will create a FinishedGoodsLine that tracks positive SKU inventory at that location. The SKU detail page will display finished goods inventory by location, and the SKU list will show total finished goods quantity. The existing transfer pattern will be extended to support finished goods transfers.

---

## Phase 1: Database Schema Layer

### Subtask 1.1: Add FinishedGoodsLine Model to Prisma Schema

**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing TransactionLine model structure (line 230-240)

**Instructions**:
1. Add `FinishedGoodsLine` model after the `TransactionLine` model:

```prisma
model FinishedGoodsLine {
  id             String      @id @default(uuid())
  transactionId  String
  transaction    Transaction @relation("FinishedGoodsLines", fields: [transactionId], references: [id], onDelete: Cascade)
  skuId          String
  sku            SKU         @relation("FinishedGoodsLines", fields: [skuId], references: [id])
  quantityChange Decimal     @db.Decimal(10, 4)  // Positive for production, negative for consumption
  costPerUnit    Decimal?    @db.Decimal(10, 4)  // unitBomCost from build
  locationId     String
  location       Location    @relation("FinishedGoodsAtLocation", fields: [locationId], references: [id])

  @@index([skuId])
  @@index([locationId])
  @@index([transactionId])
}
```

2. Add relation to Transaction model (after `lines` relation on line 219):
```prisma
  finishedGoodsLines FinishedGoodsLine[] @relation("FinishedGoodsLines")
```

3. Add relation to SKU model (after `defectAlerts` relation on line 268):
```prisma
  finishedGoodsLines FinishedGoodsLine[] @relation("FinishedGoodsLines")
```

4. Add relation to Location model (after `transfersTo` on line 55):
```prisma
  finishedGoodsLines FinishedGoodsLine[] @relation("FinishedGoodsAtLocation")
```

**Validation**:
```bash
npx prisma validate
```

**Completion Criteria**:
- [ ] FinishedGoodsLine model added with correct fields
- [ ] Relations added to Transaction, SKU, and Location models
- [ ] `npx prisma validate` passes

### Subtask 1.2: Create and Run Migration

**File**: `/home/pbrown/SkuInventory/prisma/migrations/[timestamp]_add_finished_goods_line/migration.sql`

**Instructions**:
1. Generate migration:
```bash
cd /home/pbrown/SkuInventory && npx prisma migrate dev --name add_finished_goods_line
```

2. Verify migration created correctly

**Validation**:
```bash
npx prisma generate
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Migration file created
- [ ] Migration applied successfully
- [ ] Prisma client generated without errors
- [ ] TypeScript compiles without errors

---

## Phase 2: Types Layer

### Subtask 2.1: Create Finished Goods Types

**File**: `/home/pbrown/SkuInventory/src/types/finished-goods.ts` (NEW)
**Pattern**: Follow `src/types/transaction.ts` for schema patterns

**Instructions**:
Create new file with:

```typescript
import { z } from 'zod'

// Finished goods adjustment schema
export const adjustFinishedGoodsSchema = z.object({
  skuId: z.string().uuid('Invalid SKU ID'),
  locationId: z.string().uuid('Invalid location ID'),
  quantity: z.coerce.number().refine((val) => val !== 0, 'Quantity cannot be zero'),
  reason: z.string().min(1, 'Reason is required').max(200),
  notes: z.string().optional().nullable(),
  date: z.coerce.date(),
})

export type AdjustFinishedGoodsInput = z.infer<typeof adjustFinishedGoodsSchema>

// Finished goods transfer schema
export const transferFinishedGoodsSchema = z.object({
  skuId: z.string().uuid('Invalid SKU ID'),
  fromLocationId: z.string().uuid('Invalid from location ID'),
  toLocationId: z.string().uuid('Invalid to location ID'),
  quantity: z.coerce.number().positive('Quantity must be positive'),
  notes: z.string().optional().nullable(),
  date: z.coerce.date(),
})

export type TransferFinishedGoodsInput = z.infer<typeof transferFinishedGoodsSchema>

// SKU inventory response (per location)
export interface SkuInventoryByLocation {
  locationId: string
  locationName: string
  locationType: string
  quantity: number
}

// SKU inventory summary
export interface SkuInventorySummary {
  totalQuantity: number
  byLocation: SkuInventoryByLocation[]
}

// Finished goods line response
export interface FinishedGoodsLineResponse {
  id: string
  skuId: string
  skuName: string
  skuInternalCode: string
  quantityChange: string
  costPerUnit: string | null
  locationId: string
  locationName: string
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Types file created with all schemas and interfaces
- [ ] TypeScript compiles without errors

### Subtask 2.2: Extend Transaction Types

**File**: `/home/pbrown/SkuInventory/src/types/transaction.ts`
**Pattern**: Follow existing schema patterns in file

**Instructions**:
1. Extend `createBuildSchema` (around line 55-66) to add optional output fields:

```typescript
export const createBuildSchema = z.object({
  date: z.coerce.date(),
  skuId: z.string().uuid('Invalid SKU ID'),
  unitsToBuild: z.coerce.number().int().positive('Units must be positive'),
  salesChannel: z.string().optional(),
  notes: z.string().optional().nullable(),
  defectCount: z.coerce.number().int().nonnegative().optional().nullable(),
  defectNotes: z.string().optional().nullable(),
  affectedUnits: z.coerce.number().int().nonnegative().optional().nullable(),
  allowInsufficientInventory: z.boolean().default(false),
  locationId: z.string().uuid('Invalid location ID').optional(),
  // NEW: Finished goods output
  outputLocationId: z.string().uuid('Invalid output location ID').optional(),
  outputQuantity: z.coerce.number().int().positive().optional(),
})
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] createBuildSchema extended with outputLocationId and outputQuantity
- [ ] TypeScript compiles without errors

### Subtask 2.3: Extend SKU Types

**File**: `/home/pbrown/SkuInventory/src/types/sku.ts`
**Pattern**: Follow existing response interfaces

**Instructions**:
1. Add import at top:
```typescript
import type { SkuInventorySummary } from './finished-goods'
```

2. Add to SKUResponse interface (around line 43-60):
```typescript
  finishedGoodsQuantity?: number | null
```

3. Add to SKUDetailResponse interface (around line 62-72):
```typescript
  finishedGoodsInventory?: SkuInventorySummary | null
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] SKUResponse extended with finishedGoodsQuantity
- [ ] SKUDetailResponse extended with finishedGoodsInventory
- [ ] TypeScript compiles without errors

---

## Phase 3: Service Layer

### Subtask 3.1: Create Finished Goods Service

**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts` (NEW)
**Pattern**: Follow `src/services/inventory.ts` for query patterns

**Instructions**:
Create new service file:

```typescript
import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'
import type { SkuInventorySummary, SkuInventoryByLocation } from '@/types/finished-goods'

/**
 * Get finished goods quantity for a SKU
 * If locationId provided, returns quantity at that location
 * Otherwise returns global total
 */
export async function getSkuQuantity(
  skuId: string,
  locationId?: string
): Promise<number> {
  const where: Prisma.FinishedGoodsLineWhereInput = { skuId }
  if (locationId) {
    where.locationId = locationId
  }

  const result = await prisma.finishedGoodsLine.aggregate({
    where,
    _sum: { quantityChange: true },
  })

  return result._sum.quantityChange?.toNumber() ?? 0
}

/**
 * Get finished goods quantities for multiple SKUs
 * If locationId provided, returns quantities at that location
 * Otherwise returns global totals
 */
export async function getSkuQuantities(
  skuIds: string[],
  locationId?: string
): Promise<Map<string, number>> {
  const where: Prisma.FinishedGoodsLineWhereInput = {
    skuId: { in: skuIds },
  }
  if (locationId) {
    where.locationId = locationId
  }

  const results = await prisma.finishedGoodsLine.groupBy({
    by: ['skuId'],
    where,
    _sum: { quantityChange: true },
  })

  const quantities = new Map<string, number>()

  // Initialize all to 0
  for (const id of skuIds) {
    quantities.set(id, 0)
  }

  // Set actual quantities
  for (const result of results) {
    quantities.set(result.skuId, result._sum.quantityChange?.toNumber() ?? 0)
  }

  return quantities
}

/**
 * Get finished goods inventory summary for a SKU (grouped by location)
 */
export async function getSkuInventorySummary(
  skuId: string
): Promise<SkuInventorySummary> {
  // Get quantities grouped by location
  const results = await prisma.finishedGoodsLine.groupBy({
    by: ['locationId'],
    where: { skuId },
    _sum: { quantityChange: true },
  })

  // Get location details
  const locationIds = results.map((r) => r.locationId)
  const locations = await prisma.location.findMany({
    where: { id: { in: locationIds } },
    select: { id: true, name: true, type: true },
  })

  const locationMap = new Map(locations.map((l) => [l.id, l]))

  const byLocation: SkuInventoryByLocation[] = []
  let totalQuantity = 0

  for (const result of results) {
    const qty = result._sum.quantityChange?.toNumber() ?? 0
    if (qty !== 0) {
      const loc = locationMap.get(result.locationId)
      if (loc) {
        byLocation.push({
          locationId: result.locationId,
          locationName: loc.name,
          locationType: loc.type,
          quantity: qty,
        })
        totalQuantity += qty
      }
    }
  }

  // Sort by quantity descending
  byLocation.sort((a, b) => b.quantity - a.quantity)

  return { totalQuantity, byLocation }
}

/**
 * Create a finished goods adjustment transaction
 */
export async function adjustFinishedGoods(params: {
  companyId: string
  skuId: string
  locationId: string
  quantity: number
  reason: string
  notes?: string | null
  date: Date
  createdById: string
}): Promise<{ id: string }> {
  const { companyId, skuId, locationId, quantity, reason, notes, date, createdById } = params

  // Create adjustment transaction with finished goods line
  const transaction = await prisma.transaction.create({
    data: {
      companyId,
      type: 'adjustment',
      date,
      skuId,
      reason,
      notes,
      createdById,
      finishedGoodsLines: {
        create: {
          skuId,
          locationId,
          quantityChange: new Prisma.Decimal(quantity),
          costPerUnit: null, // Adjustment doesn't have cost
        },
      },
    },
    select: { id: true },
  })

  return transaction
}

/**
 * Create a finished goods transfer between locations
 */
export async function transferFinishedGoods(params: {
  companyId: string
  skuId: string
  fromLocationId: string
  toLocationId: string
  quantity: number
  notes?: string | null
  date: Date
  createdById: string
}): Promise<{ id: string }> {
  const { companyId, skuId, fromLocationId, toLocationId, quantity, notes, date, createdById } = params

  // Validate not same location
  if (fromLocationId === toLocationId) {
    throw new Error('Cannot transfer to the same location')
  }

  return prisma.$transaction(async (tx) => {
    // Validate locations belong to company
    const [fromLocation, toLocation] = await Promise.all([
      tx.location.findFirst({
        where: { id: fromLocationId, companyId, isActive: true },
      }),
      tx.location.findFirst({
        where: { id: toLocationId, companyId, isActive: true },
      }),
    ])

    if (!fromLocation) {
      throw new Error('Source location not found or not active')
    }
    if (!toLocation) {
      throw new Error('Destination location not found or not active')
    }

    // Check sufficient inventory at source
    const available = await getSkuQuantity(skuId, fromLocationId)
    if (available < quantity) {
      throw new Error(
        `Insufficient finished goods at source location. Available: ${available}, Required: ${quantity}`
      )
    }

    // Get SKU for cost reference (optional - use average or null)
    // For now, transfers don't affect cost

    // Create transfer transaction with two finished goods lines
    const transaction = await tx.transaction.create({
      data: {
        companyId,
        type: 'transfer',
        date,
        skuId,
        notes,
        fromLocationId,
        toLocationId,
        createdById,
        finishedGoodsLines: {
          create: [
            // Deduction from source
            {
              skuId,
              locationId: fromLocationId,
              quantityChange: new Prisma.Decimal(-quantity),
              costPerUnit: null,
            },
            // Addition to destination
            {
              skuId,
              locationId: toLocationId,
              quantityChange: new Prisma.Decimal(quantity),
              costPerUnit: null,
            },
          ],
        },
      },
      select: { id: true },
    })

    return transaction
  })
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Service file created with all functions
- [ ] TypeScript compiles without errors

### Subtask 3.2: Extend createBuildTransaction in Inventory Service

**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Follow existing function structure (lines 587-747)

**Instructions**:
1. Update `createBuildTransaction` function signature to add new parameters (around line 587):

Add to params type:
```typescript
  outputLocationId?: string  // Where finished goods go
  outputQuantity?: number    // How many finished units (default = unitsToBuild)
```

2. Update the function body after creating the transaction (after line 722, before defect evaluation):

```typescript
    // Create finished goods line if outputLocationId is provided
    if (params.outputLocationId) {
      const outputQty = params.outputQuantity ?? params.unitsToBuild

      // Validate output location belongs to company
      const outputLocation = await prisma.location.findFirst({
        where: {
          id: params.outputLocationId,
          companyId: params.companyId,
          isActive: true,
        },
      })

      if (!outputLocation) {
        throw new Error('Output location not found or not active')
      }

      // Create finished goods line
      await prisma.finishedGoodsLine.create({
        data: {
          transactionId: transaction.id,
          skuId: params.skuId,
          locationId: params.outputLocationId,
          quantityChange: new Prisma.Decimal(outputQty),
          costPerUnit: new Prisma.Decimal(unitBomCost),
        },
      })
    }
```

3. Update `BuildTransactionResult` interface (around line 557) to add:
```typescript
  outputLocationId?: string | null
  outputLocation?: { id: string; name: string } | null
  outputQuantity?: number | null
```

4. Update the include in the transaction query to fetch finished goods lines and return them in the result.

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] createBuildTransaction extended with outputLocationId support
- [ ] Finished goods line created when outputLocationId provided
- [ ] TypeScript compiles without errors
- [ ] Build passes

---

## Phase 4: API Routes Layer

### Subtask 4.1: Extend Build Transaction API

**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
**Pattern**: Follow existing validation and response patterns

**Instructions**:
1. Add validation for outputLocationId (after locationId validation, around line 63-74):

```typescript
    // Validate output location if provided
    if (data.outputLocationId) {
      const outputLocation = await prisma.location.findFirst({
        where: {
          id: data.outputLocationId,
          companyId: selectedCompanyId,
          isActive: true,
        },
      })
      if (!outputLocation) {
        return notFound('Output Location')
      }
    }
```

2. Pass outputLocationId and outputQuantity to createBuildTransaction (around line 85-99):

```typescript
      const result = await createBuildTransaction({
        companyId: selectedCompanyId,
        skuId: data.skuId,
        bomVersionId: selectedBomVersionId,
        unitsToBuild: data.unitsToBuild,
        salesChannel: data.salesChannel,
        date: data.date,
        notes: data.notes,
        defectCount: data.defectCount,
        defectNotes: data.defectNotes,
        affectedUnits: data.affectedUnits,
        createdById: session.user.id,
        allowInsufficientInventory: allowInsufficient,
        locationId: data.locationId,
        outputLocationId: data.outputLocationId,  // NEW
        outputQuantity: data.outputQuantity,      // NEW
      })
```

3. Include output info in response (around line 101-128):

```typescript
        data: {
          // ... existing fields ...
          outputLocationId: result.transaction.outputLocationId,
          outputLocation: result.transaction.outputLocation,
          outputQuantity: result.transaction.outputQuantity,
        },
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] API validates outputLocationId
- [ ] API passes output params to service
- [ ] Response includes output info
- [ ] Build passes

### Subtask 4.2: Create SKU Inventory API Route

**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/inventory/route.ts` (NEW)
**Pattern**: Follow `src/app/api/skus/[id]/route.ts`

**Instructions**:
Create new route file:

```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { success, created, unauthorized, notFound, error, serverError, parseBody } from '@/lib/api-response'
import { getSkuInventorySummary, adjustFinishedGoods } from '@/services/finished-goods'
import { adjustFinishedGoodsSchema } from '@/types/finished-goods'

type RouteParams = { params: Promise<{ id: string }> }

// GET /api/skus/:id/inventory - Get SKU finished goods inventory by location
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    const { id } = await params
    const selectedCompanyId = session.user.selectedCompanyId

    // Verify SKU exists and belongs to company
    const sku = await prisma.sKU.findFirst({
      where: {
        id,
        companyId: selectedCompanyId,
      },
      select: { id: true, name: true, internalCode: true },
    })

    if (!sku) {
      return notFound('SKU')
    }

    const inventory = await getSkuInventorySummary(id)

    return success({
      skuId: sku.id,
      skuName: sku.name,
      skuInternalCode: sku.internalCode,
      ...inventory,
    })
  } catch (err) {
    console.error('Error getting SKU inventory:', err)
    return serverError()
  }
}

// POST /api/skus/:id/inventory - Create finished goods adjustment
export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    if (session.user.role === 'viewer') {
      return unauthorized('You do not have permission to adjust inventory')
    }

    const { id } = await params
    const selectedCompanyId = session.user.selectedCompanyId

    const bodyResult = await parseBody(request, adjustFinishedGoodsSchema)
    if (bodyResult.error) return bodyResult.error

    const data = bodyResult.data

    // Verify SKU exists and belongs to company
    const sku = await prisma.sKU.findFirst({
      where: {
        id,
        companyId: selectedCompanyId,
      },
    })

    if (!sku) {
      return notFound('SKU')
    }

    // Validate location
    const location = await prisma.location.findFirst({
      where: {
        id: data.locationId,
        companyId: selectedCompanyId,
        isActive: true,
      },
    })

    if (!location) {
      return notFound('Location')
    }

    const result = await adjustFinishedGoods({
      companyId: selectedCompanyId,
      skuId: id,
      locationId: data.locationId,
      quantity: data.quantity,
      reason: data.reason,
      notes: data.notes,
      date: data.date,
      createdById: session.user.id,
    })

    return created({ transactionId: result.id })
  } catch (err) {
    console.error('Error adjusting finished goods:', err)
    return serverError()
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] GET endpoint returns SKU inventory by location
- [ ] POST endpoint creates finished goods adjustment
- [ ] Both endpoints validate company ownership
- [ ] Build passes

### Subtask 4.3: Extend SKU List API to Include Finished Goods Quantity

**File**: `/home/pbrown/SkuInventory/src/app/api/skus/route.ts`
**Pattern**: Follow existing pattern for bomCosts and buildableUnits

**Instructions**:
1. Add import at top:
```typescript
import { getSkuQuantities } from '@/services/finished-goods'
```

2. After calculating buildableUnits (around line 82-85), add:
```typescript
    const [bomCosts, buildableUnits, finishedGoodsQtys] = await Promise.all([
      activeBomIds.length > 0 ? calculateBOMUnitCosts(activeBomIds) : new Map<string, number>(),
      skuIds.length > 0 ? calculateMaxBuildableUnitsForSKUs(skuIds, locationId) : new Map<string, number | null>(),
      skuIds.length > 0 ? getSkuQuantities(skuIds, locationId) : new Map<string, number>(),
    ])
```

3. Add to the response object (around line 110):
```typescript
        finishedGoodsQuantity: finishedGoodsQtys.get(sku.id) ?? 0,
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] SKU list includes finishedGoodsQuantity
- [ ] Location filter applied if provided
- [ ] Build passes

### Subtask 4.4: Extend SKU Detail API to Include Finished Goods Inventory

**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
**Pattern**: Follow existing maxBuildableUnits pattern

**Instructions**:
1. Add import at top:
```typescript
import { getSkuInventorySummary, getSkuQuantity } from '@/services/finished-goods'
```

2. After calculating maxBuildableUnits (around line 78), add:
```typescript
    // Get finished goods inventory
    const finishedGoodsInventory = await getSkuInventorySummary(id)
```

3. Add to response object (around line 103):
```typescript
      finishedGoodsInventory,
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] SKU detail includes finishedGoodsInventory with byLocation breakdown
- [ ] Build passes

---

## Phase 5: Frontend Components Layer

### Subtask 5.1: Extend BuildDialog with Output Location Selector

**File**: `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx`
**Pattern**: Follow existing locationId selector pattern (lines 363-382)

**Instructions**:
1. Add state for output fields (around line 49-59):
```typescript
    outputLocationId: '',
    outputQuantity: '',
```

2. Add output location selector after the existing location selector (after line 382):
```tsx
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="outputLocation" className="text-right">
                Output To
              </Label>
              <Select
                value={formData.outputLocationId}
                onValueChange={(value) => setFormData((prev) => ({ ...prev, outputLocationId: value }))}
                disabled={isLoadingLocations}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder={isLoadingLocations ? 'Loading...' : 'Select finished goods location (optional)'} />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="">No finished goods output</SelectItem>
                  {locations.map((loc) => (
                    <SelectItem key={loc.id} value={loc.id}>
                      {loc.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            {formData.outputLocationId && (
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="outputQuantity" className="text-right">
                  Output Qty
                </Label>
                <Input
                  id="outputQuantity"
                  type="number"
                  step="1"
                  min="1"
                  className="col-span-3"
                  placeholder={`Defaults to ${formData.unitsToBuild || 'units built'}`}
                  value={formData.outputQuantity}
                  onChange={(e) =>
                    setFormData((prev) => ({ ...prev, outputQuantity: e.target.value }))
                  }
                />
              </div>
            )}
```

3. Include output fields in submit payload (around line 141-152):
```typescript
          outputLocationId: formData.outputLocationId || undefined,
          outputQuantity: formData.outputQuantity ? parseInt(formData.outputQuantity) : undefined,
```

4. Reset output fields on form reset (around line 176-186):
```typescript
        outputLocationId: '',
        outputQuantity: '',
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Output location selector added
- [ ] Output quantity field shown when output location selected
- [ ] Fields included in API request
- [ ] Build passes

### Subtask 5.2: Display Finished Goods Inventory on SKU Detail Page

**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/skus/[id]/page.tsx`
**Pattern**: Follow existing SKU details card pattern

**Instructions**:
1. Add finished goods inventory section after the max buildable units display (around line 178):
```tsx
            {sku.finishedGoodsInventory && sku.finishedGoodsInventory.totalQuantity > 0 && (
              <div>
                <p className="text-sm text-muted-foreground">Finished Goods Inventory</p>
                <p className="font-mono text-lg" suppressHydrationWarning>
                  {sku.finishedGoodsInventory.totalQuantity.toLocaleString()} units
                </p>
                {sku.finishedGoodsInventory.byLocation.length > 1 && (
                  <div className="mt-2 space-y-1">
                    {sku.finishedGoodsInventory.byLocation.map((loc) => (
                      <div key={loc.locationId} className="text-sm flex justify-between">
                        <span className="text-muted-foreground">{loc.locationName}:</span>
                        <span className="font-mono" suppressHydrationWarning>{loc.quantity.toLocaleString()}</span>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
```

2. Update the SKUDetailResponse import/usage to include the new fields.

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Finished goods inventory displayed on SKU detail page
- [ ] Location breakdown shown when multiple locations have inventory
- [ ] Build passes

### Subtask 5.3: Add Finished Goods Column to SKU Table

**File**: `/home/pbrown/SkuInventory/src/components/features/SKUTable.tsx`
**Pattern**: Follow existing Buildable column pattern (lines 153, 190-198)

**Instructions**:
1. Add table header after Buildable (around line 153):
```tsx
              <TableHead className="text-right">FG Qty</TableHead>
```

2. Add table cell after Buildable cell (around line 198):
```tsx
                  <TableCell className="text-right font-mono">
                    {(sku as unknown as { finishedGoodsQuantity?: number }).finishedGoodsQuantity != null ? (
                      <span suppressHydrationWarning>
                        {((sku as unknown as { finishedGoodsQuantity: number }).finishedGoodsQuantity).toLocaleString()}
                      </span>
                    ) : (
                      '-'
                    )}
                  </TableCell>
```

3. Update colSpan for empty state (line 159) from 6 to 7.

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] FG Qty column added to SKU table
- [ ] Shows quantity or dash if none
- [ ] Build passes

---

## Phase 6: Final Validation

### Subtask 6.1: Run Full Build and Type Check

**Instructions**:
```bash
cd /home/pbrown/SkuInventory
npm run build
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] `npm run build` passes without errors
- [ ] `npx tsc --noEmit` passes without errors
- [ ] `npm run lint` passes without errors or warnings

### Subtask 6.2: Manual Testing Checklist

**Instructions**:
1. Create a build transaction without outputLocationId (backward compatibility)
2. Create a build transaction with outputLocationId
3. Verify finished goods line created
4. Check SKU list shows finishedGoodsQuantity
5. Check SKU detail shows finishedGoodsInventory by location
6. Test SKU inventory API endpoint

**Completion Criteria**:
- [ ] Build without output location works (backward compatible)
- [ ] Build with output location creates finished goods line
- [ ] SKU list shows finished goods quantities
- [ ] SKU detail shows inventory breakdown by location

---

## Summary of Deliverables

**Files Created (4)**:
1. `prisma/migrations/[timestamp]_add_finished_goods_line/migration.sql`
2. `src/types/finished-goods.ts`
3. `src/services/finished-goods.ts`
4. `src/app/api/skus/[id]/inventory/route.ts`

**Files Modified (8)**:
1. `prisma/schema.prisma` - FinishedGoodsLine model + relations
2. `src/types/transaction.ts` - Extended createBuildSchema
3. `src/types/sku.ts` - Extended response types
4. `src/services/inventory.ts` - Extended createBuildTransaction
5. `src/app/api/transactions/build/route.ts` - Added output params
6. `src/app/api/skus/route.ts` - Added finishedGoodsQuantity
7. `src/app/api/skus/[id]/route.ts` - Added finishedGoodsInventory
8. `src/components/features/BuildDialog.tsx` - Added output location selector
9. `src/app/(dashboard)/skus/[id]/page.tsx` - Display finished goods
10. `src/components/features/SKUTable.tsx` - FG Qty column

**TOTAL**: 12 files

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> 2 -> 3 -> 4 -> 5 -> 6)
2. Complete Phase 1 (database) fully before Phase 2 (types)
3. Test completion criteria after each subtask
4. Follow reference patterns exactly
5. Run `npx tsc --noEmit` after each file modification
6. Run `npm run build` at end of each phase

## Test Strategy Note

- Use Vitest for unit tests (if time permits)
- Manual testing via API and UI for this feature
- E2E tests can be added in follow-up if Playwright is configured

## Performance Metrics

| Phase | Estimated Duration |
|-------|----------|
| Phase 1: Database | 30m |
| Phase 2: Types | 20m |
| Phase 3: Services | 60m |
| Phase 4: API Routes | 45m |
| Phase 5: Frontend | 60m |
| Phase 6: Validation | 30m |
| **Total** | **~4 hours** |

## What is NOT Included (Per Issue Scope)

- Shipment/sales transactions that consume finished goods (future feature)
- Finished goods alerts and reorder points (future feature)
- Finished goods cost tracking beyond unitBomCost (future feature)
