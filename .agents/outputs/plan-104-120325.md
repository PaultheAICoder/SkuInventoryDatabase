# Implementation Plan
**Generated**: 2025-12-03T21:15:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #104 - [Parent #11] Database schema and core alert evaluation service
**Estimated Build Time**: 4-6 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Feature (Sub-issue 1 of 4 for low-stock alerts)
**Source**: GitHub Issue #104, Parent Issue #11
**Priority**: High (foundational - blocks sub-issues 2, 3, 4)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="lowstock"` or `--testPathPattern="lowstock"`

### Issue Validation
**Status**: Valid
**Recent Changes**: No existing low-stock alert implementation found. The existing `src/services/alert.ts` is for defect alerts only.
**Parent Issue #11**: CLOSED (master feature issue), this is the first implementation sub-issue.

### Current State Assessment
- **Existing components**:
  - `src/services/alert.ts` - Defect alert service (PATTERN REFERENCE)
  - `src/services/inventory.ts` - Contains `calculateReorderStatus()` and `getComponentQuantities()` (REUSE)
  - `src/types/alert.ts` - Defect alert types (PATTERN REFERENCE)
  - `src/types/settings.ts` - Company settings schema with Zod (PATTERN REFERENCE)
- **Database**:
  - `AlertConfig` model - DOES NOT EXIST (to be created)
  - `ComponentAlertState` model - DOES NOT EXIST (to be created)
  - Company model exists with `settings` JSON field
  - Component model exists with `reorderPoint` and `leadTimeDays`
- **API Routes**: None needed for this sub-issue (handled by sub-issue 2)
- **Types**:
  - `ReorderStatus` type exists: `'critical' | 'warning' | 'ok'`
  - New types needed for AlertConfig, ComponentAlertState, evaluation results

### Dependencies & Blockers
1. **None** - This is the foundational sub-issue
2. **Blocks**: Sub-issues 2 (Slack integration), 3 (Scheduler), 4 (Email)

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 4-6 hours
**Risk**: Low (follows existing patterns, no external API integration)

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/services/alert.ts` - Defect alert evaluation pattern
**Secondary**: `/home/pbrown/SkuInventory/src/types/alert.ts` - Alert type definitions with Zod
**Tertiary**: `/home/pbrown/SkuInventory/src/services/inventory.ts:72-87` - `calculateReorderStatus()` function

### Ripple Effect Analysis
**Files Identified**: 4 (new files only, no modifications to existing code except schema)

| File | Action | Reason |
|------|--------|--------|
| `prisma/schema.prisma` | Modify | Add AlertConfig, ComponentAlertState models |
| `src/types/lowstock-alert.ts` | Create | TypeScript types for new entities |
| `src/services/lowstock-alert.ts` | Create | Core evaluation service |
| `tests/unit/lowstock-alert.test.ts` | Create | Unit tests for evaluation logic |

**Existing Files NOT Modified**:
- `src/services/inventory.ts` - Reuses `calculateReorderStatus`, `getComponentQuantities`, `getCompanySettings` without changes
- `src/services/alert.ts` - Defect alerts remain separate
- `src/types/index.ts` - No barrel export needed (follow existing pattern)

---

## Executive Summary
Create the database foundation and core service logic for low-stock alerts. This includes two new Prisma models (`AlertConfig` for company-level alert channel settings, `ComponentAlertState` for tracking per-component alert history), TypeScript types with Zod validation, and the core `evaluateLowStockAlerts(companyId)` function that detects state transitions from OK to Warning/Critical. The service will reuse existing `calculateReorderStatus()` and `getComponentQuantities()` functions. Unit tests will cover evaluation logic and edge cases.

---

## Phase 1: Database Schema Layer

### Subtask 1.1: Add AlertConfig Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing `DefectThreshold` model structure (lines 245-263)
**Location**: After DefectAlert model (end of file, line 285)

**Instructions**:
1. Add the AlertConfig model with these fields:
```prisma
// ============================================
// Low-Stock Alert Configuration
// ============================================

model AlertConfig {
  id              String    @id @default(uuid())
  companyId       String    @unique
  company         Company   @relation(fields: [companyId], references: [id])

  // Channel configuration
  slackWebhookUrl String?   @db.VarChar(500)
  emailAddresses  String[]  // PostgreSQL array type

  // Toggles
  enableSlack     Boolean   @default(false)
  enableEmail     Boolean   @default(false)

  // Throttle settings
  alertMode       String    @default("daily_digest") @db.VarChar(20) // 'daily_digest' | 'per_transition'
  lastDigestSent  DateTime?

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}
```

2. Add relation to Company model (around line 24):
```prisma
// In Company model, add:
alertConfig      AlertConfig?
```

**Validation**:
```bash
npx prisma validate
```

**Completion Criteria**:
- [ ] AlertConfig model added with all fields
- [ ] Company relation added
- [ ] `npx prisma validate` passes

### Subtask 1.2: Add ComponentAlertState Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing model patterns
**Location**: After AlertConfig model

**Instructions**:
1. Add the ComponentAlertState model:
```prisma
model ComponentAlertState {
  id            String    @id @default(uuid())
  componentId   String    @unique
  component     Component @relation(fields: [componentId], references: [id], onDelete: Cascade)
  lastStatus    String    @db.VarChar(20) // 'ok' | 'warning' | 'critical'
  lastAlertSent DateTime?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}
```

2. Add relation to Component model (around line 118):
```prisma
// In Component model, add:
alertState       ComponentAlertState?
```

**Validation**:
```bash
npx prisma validate
```

**Completion Criteria**:
- [ ] ComponentAlertState model added with all fields
- [ ] Component relation added with onDelete: Cascade
- [ ] `npx prisma validate` passes

### Subtask 1.3: Run Prisma Migration
**File**: Migration file (auto-generated)
**Pattern**: Follow existing migration naming

**Instructions**:
1. Generate and run migration:
```bash
npx prisma migrate dev --name add_lowstock_alert_config
```
2. Verify migration created in `prisma/migrations/`
3. Generate Prisma client:
```bash
npx prisma generate
```

**Validation**:
```bash
npx prisma migrate status
```

**Completion Criteria**:
- [ ] Migration file created successfully
- [ ] Migration applied without errors
- [ ] `npx prisma migrate status` shows up to date
- [ ] Prisma client regenerated

---

## Phase 2: TypeScript Types Layer

### Subtask 2.1: Create Low-Stock Alert Types
**File**: `/home/pbrown/SkuInventory/src/types/lowstock-alert.ts` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/types/alert.ts` structure

**Instructions**:
1. Create the file with these type definitions:

```typescript
import { z } from 'zod'
import type { ReorderStatus } from '@/types'

// Alert modes for throttling
export const alertModeSchema = z.enum(['daily_digest', 'per_transition'])
export type AlertMode = z.infer<typeof alertModeSchema>

// Alert config create/update schema
export const alertConfigSchema = z.object({
  slackWebhookUrl: z.string().url().max(500).optional().nullable(),
  emailAddresses: z.array(z.string().email()).default([]),
  enableSlack: z.boolean().default(false),
  enableEmail: z.boolean().default(false),
  alertMode: alertModeSchema.default('daily_digest'),
})

export type AlertConfigInput = z.infer<typeof alertConfigSchema>

export const updateAlertConfigSchema = alertConfigSchema.partial()
export type UpdateAlertConfigInput = z.infer<typeof updateAlertConfigSchema>

// Alert config response (what API returns)
export interface AlertConfigResponse {
  id: string
  companyId: string
  slackWebhookUrl: string | null
  emailAddresses: string[]
  enableSlack: boolean
  enableEmail: boolean
  alertMode: AlertMode
  lastDigestSent: string | null
  createdAt: string
  updatedAt: string
}

// Component alert state response
export interface ComponentAlertStateResponse {
  id: string
  componentId: string
  lastStatus: ReorderStatus
  lastAlertSent: string | null
  createdAt: string
  updatedAt: string
}

// State transition types
export type AlertTransition =
  | 'ok_to_warning'
  | 'ok_to_critical'
  | 'warning_to_critical'
  | 'warning_to_ok'
  | 'critical_to_warning'
  | 'critical_to_ok'
  | 'no_change'

// Component that needs an alert (state transition detected)
export interface ComponentAlertNeeded {
  componentId: string
  componentName: string
  skuCode: string
  brandName: string
  previousStatus: ReorderStatus
  currentStatus: ReorderStatus
  transition: AlertTransition
  quantityOnHand: number
  reorderPoint: number
  leadTimeDays: number
}

// Result of evaluateLowStockAlerts()
export interface LowStockAlertEvaluation {
  companyId: string
  evaluatedAt: string
  totalComponents: number
  componentsNeedingAlert: ComponentAlertNeeded[]
  newWarnings: number
  newCriticals: number
  recoveries: number // Components that went back to OK
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with all type definitions
- [ ] Zod schemas for validation
- [ ] `npx tsc --noEmit` passes
- [ ] Types follow existing patterns

---

## Phase 3: Service Layer

### Subtask 3.1: Create Low-Stock Alert Service
**File**: `/home/pbrown/SkuInventory/src/services/lowstock-alert.ts` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/alert.ts` structure

**Instructions**:
1. Create the service file with these functions:

```typescript
import { prisma } from '@/lib/db'
import {
  getComponentQuantities,
  calculateReorderStatus,
  getCompanySettings,
} from './inventory'
import type { ReorderStatus } from '@/types'
import type {
  AlertConfigResponse,
  ComponentAlertNeeded,
  LowStockAlertEvaluation,
  AlertTransition,
} from '@/types/lowstock-alert'

/**
 * Determine the type of state transition
 */
function getTransition(
  previousStatus: ReorderStatus,
  currentStatus: ReorderStatus
): AlertTransition {
  if (previousStatus === currentStatus) return 'no_change'

  const key = `${previousStatus}_to_${currentStatus}` as AlertTransition
  return key
}

/**
 * Check if a transition should trigger an alert
 * Only alert on transitions TO warning or critical
 */
function shouldAlert(transition: AlertTransition): boolean {
  return [
    'ok_to_warning',
    'ok_to_critical',
    'warning_to_critical',
  ].includes(transition)
}

/**
 * Check if a transition is a recovery (back to OK)
 */
function isRecovery(transition: AlertTransition): boolean {
  return [
    'warning_to_ok',
    'critical_to_ok',
  ].includes(transition)
}

/**
 * Get or create alert config for a company
 */
export async function getAlertConfig(
  companyId: string
): Promise<AlertConfigResponse | null> {
  const config = await prisma.alertConfig.findUnique({
    where: { companyId },
  })

  if (!config) return null

  return {
    id: config.id,
    companyId: config.companyId,
    slackWebhookUrl: config.slackWebhookUrl,
    emailAddresses: config.emailAddresses,
    enableSlack: config.enableSlack,
    enableEmail: config.enableEmail,
    alertMode: config.alertMode as 'daily_digest' | 'per_transition',
    lastDigestSent: config.lastDigestSent?.toISOString() ?? null,
    createdAt: config.createdAt.toISOString(),
    updatedAt: config.updatedAt.toISOString(),
  }
}

/**
 * Create or update alert config for a company
 */
export async function upsertAlertConfig(
  companyId: string,
  input: {
    slackWebhookUrl?: string | null
    emailAddresses?: string[]
    enableSlack?: boolean
    enableEmail?: boolean
    alertMode?: 'daily_digest' | 'per_transition'
  }
): Promise<AlertConfigResponse> {
  const config = await prisma.alertConfig.upsert({
    where: { companyId },
    create: {
      companyId,
      slackWebhookUrl: input.slackWebhookUrl ?? null,
      emailAddresses: input.emailAddresses ?? [],
      enableSlack: input.enableSlack ?? false,
      enableEmail: input.enableEmail ?? false,
      alertMode: input.alertMode ?? 'daily_digest',
    },
    update: {
      ...(input.slackWebhookUrl !== undefined && { slackWebhookUrl: input.slackWebhookUrl }),
      ...(input.emailAddresses !== undefined && { emailAddresses: input.emailAddresses }),
      ...(input.enableSlack !== undefined && { enableSlack: input.enableSlack }),
      ...(input.enableEmail !== undefined && { enableEmail: input.enableEmail }),
      ...(input.alertMode !== undefined && { alertMode: input.alertMode }),
    },
  })

  return {
    id: config.id,
    companyId: config.companyId,
    slackWebhookUrl: config.slackWebhookUrl,
    emailAddresses: config.emailAddresses,
    enableSlack: config.enableSlack,
    enableEmail: config.enableEmail,
    alertMode: config.alertMode as 'daily_digest' | 'per_transition',
    lastDigestSent: config.lastDigestSent?.toISOString() ?? null,
    createdAt: config.createdAt.toISOString(),
    updatedAt: config.updatedAt.toISOString(),
  }
}

/**
 * Update last digest sent timestamp
 */
export async function updateLastDigestSent(companyId: string): Promise<void> {
  await prisma.alertConfig.update({
    where: { companyId },
    data: { lastDigestSent: new Date() },
  })
}

/**
 * Get the previous alert state for a component
 */
async function getComponentAlertState(
  componentId: string
): Promise<ReorderStatus | null> {
  const state = await prisma.componentAlertState.findUnique({
    where: { componentId },
    select: { lastStatus: true },
  })
  return state?.lastStatus as ReorderStatus | null
}

/**
 * Update component alert state after evaluation
 */
async function updateComponentAlertState(
  componentId: string,
  status: ReorderStatus,
  alertSent: boolean
): Promise<void> {
  await prisma.componentAlertState.upsert({
    where: { componentId },
    create: {
      componentId,
      lastStatus: status,
      lastAlertSent: alertSent ? new Date() : null,
    },
    update: {
      lastStatus: status,
      ...(alertSent && { lastAlertSent: new Date() }),
    },
  })
}

/**
 * Main evaluation function - detects state transitions for components
 *
 * This function:
 * 1. Fetches all active components with reorder points > 0
 * 2. Calculates current quantities using getComponentQuantities()
 * 3. Determines reorder status using calculateReorderStatus()
 * 4. Compares to previous state in ComponentAlertState
 * 5. Returns list of components that need alerts (state transitions)
 */
export async function evaluateLowStockAlerts(
  companyId: string
): Promise<LowStockAlertEvaluation> {
  const evaluatedAt = new Date().toISOString()

  // Get company settings for reorderWarningMultiplier
  const settings = await getCompanySettings(companyId)

  // Fetch all active components with reorder points > 0 for this company
  const components = await prisma.component.findMany({
    where: {
      brand: { companyId },
      isActive: true,
      reorderPoint: { gt: 0 },
    },
    select: {
      id: true,
      name: true,
      skuCode: true,
      reorderPoint: true,
      leadTimeDays: true,
      brand: {
        select: { name: true },
      },
    },
  })

  if (components.length === 0) {
    return {
      companyId,
      evaluatedAt,
      totalComponents: 0,
      componentsNeedingAlert: [],
      newWarnings: 0,
      newCriticals: 0,
      recoveries: 0,
    }
  }

  // Get current quantities for all components
  const componentIds = components.map((c) => c.id)
  const quantities = await getComponentQuantities(componentIds)

  // Get previous states for all components
  const previousStates = await prisma.componentAlertState.findMany({
    where: { componentId: { in: componentIds } },
    select: { componentId: true, lastStatus: true },
  })
  const previousStateMap = new Map(
    previousStates.map((s) => [s.componentId, s.lastStatus as ReorderStatus])
  )

  const componentsNeedingAlert: ComponentAlertNeeded[] = []
  let newWarnings = 0
  let newCriticals = 0
  let recoveries = 0

  // Evaluate each component
  for (const component of components) {
    const quantityOnHand = quantities.get(component.id) ?? 0
    const currentStatus = calculateReorderStatus(
      quantityOnHand,
      component.reorderPoint,
      settings.reorderWarningMultiplier
    )

    // Default to 'ok' if no previous state (new component)
    const previousStatus = previousStateMap.get(component.id) ?? 'ok'
    const transition = getTransition(previousStatus, currentStatus)

    // Update state (always, to track current status)
    const needsAlert = shouldAlert(transition)
    await updateComponentAlertState(component.id, currentStatus, needsAlert)

    // Count by transition type
    if (transition === 'ok_to_warning' || transition === 'critical_to_warning') {
      newWarnings++
    }
    if (transition === 'ok_to_critical' || transition === 'warning_to_critical') {
      newCriticals++
    }
    if (isRecovery(transition)) {
      recoveries++
    }

    // Add to alert list if needs alert
    if (needsAlert) {
      componentsNeedingAlert.push({
        componentId: component.id,
        componentName: component.name,
        skuCode: component.skuCode,
        brandName: component.brand.name,
        previousStatus,
        currentStatus,
        transition,
        quantityOnHand,
        reorderPoint: component.reorderPoint,
        leadTimeDays: component.leadTimeDays,
      })
    }
  }

  return {
    companyId,
    evaluatedAt,
    totalComponents: components.length,
    componentsNeedingAlert,
    newWarnings,
    newCriticals,
    recoveries,
  }
}

/**
 * Check if alerts are enabled for a company
 */
export async function areAlertsEnabled(companyId: string): Promise<boolean> {
  const config = await getAlertConfig(companyId)
  if (!config) return false
  return config.enableSlack || config.enableEmail
}

/**
 * Get components currently in warning or critical status
 * Useful for digest emails
 */
export async function getComponentsInAlertStatus(
  companyId: string
): Promise<{
  warnings: Array<{ componentId: string; componentName: string; quantityOnHand: number; reorderPoint: number }>
  criticals: Array<{ componentId: string; componentName: string; quantityOnHand: number; reorderPoint: number }>
}> {
  const settings = await getCompanySettings(companyId)

  const components = await prisma.component.findMany({
    where: {
      brand: { companyId },
      isActive: true,
      reorderPoint: { gt: 0 },
    },
    select: {
      id: true,
      name: true,
      reorderPoint: true,
    },
  })

  const componentIds = components.map((c) => c.id)
  const quantities = await getComponentQuantities(componentIds)

  const warnings: Array<{ componentId: string; componentName: string; quantityOnHand: number; reorderPoint: number }> = []
  const criticals: Array<{ componentId: string; componentName: string; quantityOnHand: number; reorderPoint: number }> = []

  for (const component of components) {
    const quantityOnHand = quantities.get(component.id) ?? 0
    const status = calculateReorderStatus(
      quantityOnHand,
      component.reorderPoint,
      settings.reorderWarningMultiplier
    )

    if (status === 'warning') {
      warnings.push({
        componentId: component.id,
        componentName: component.name,
        quantityOnHand,
        reorderPoint: component.reorderPoint,
      })
    } else if (status === 'critical') {
      criticals.push({
        componentId: component.id,
        componentName: component.name,
        quantityOnHand,
        reorderPoint: component.reorderPoint,
      })
    }
  }

  return { warnings, criticals }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Service file created with all functions
- [ ] `evaluateLowStockAlerts()` implements state transition detection
- [ ] Reuses `calculateReorderStatus()` and `getComponentQuantities()`
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` succeeds

---

## Phase 4: Unit Tests

### Subtask 4.1: Create Unit Tests for Low-Stock Alert Service
**File**: `/home/pbrown/SkuInventory/tests/unit/lowstock-alert.test.ts` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/tests/unit/inventory-service.test.ts` structure

**Instructions**:
1. Create unit tests covering:
   - State transition detection logic
   - Alert trigger conditions (ok->warning, ok->critical, warning->critical)
   - Non-alert transitions (ok->ok, warning->ok recoveries)
   - Edge cases (reorderPoint = 0, negative quantities)

```typescript
import { describe, it, expect } from 'vitest'

/**
 * Unit tests for low-stock alert evaluation logic.
 *
 * These tests focus on the pure functions for state transition detection
 * without requiring database access.
 */

// Test the transition detection logic
describe('getTransition', () => {
  // We'll test the transition logic by simulating what evaluateLowStockAlerts does

  const getTransition = (
    previousStatus: 'ok' | 'warning' | 'critical',
    currentStatus: 'ok' | 'warning' | 'critical'
  ): string => {
    if (previousStatus === currentStatus) return 'no_change'
    return `${previousStatus}_to_${currentStatus}`
  }

  describe('state transitions', () => {
    it('detects ok to warning transition', () => {
      expect(getTransition('ok', 'warning')).toBe('ok_to_warning')
    })

    it('detects ok to critical transition', () => {
      expect(getTransition('ok', 'critical')).toBe('ok_to_critical')
    })

    it('detects warning to critical transition', () => {
      expect(getTransition('warning', 'critical')).toBe('warning_to_critical')
    })

    it('detects warning to ok recovery', () => {
      expect(getTransition('warning', 'ok')).toBe('warning_to_ok')
    })

    it('detects critical to ok recovery', () => {
      expect(getTransition('critical', 'ok')).toBe('critical_to_ok')
    })

    it('detects critical to warning (partial recovery)', () => {
      expect(getTransition('critical', 'warning')).toBe('critical_to_warning')
    })

    it('detects no change for same status', () => {
      expect(getTransition('ok', 'ok')).toBe('no_change')
      expect(getTransition('warning', 'warning')).toBe('no_change')
      expect(getTransition('critical', 'critical')).toBe('no_change')
    })
  })
})

describe('shouldAlert', () => {
  const shouldAlert = (transition: string): boolean => {
    return [
      'ok_to_warning',
      'ok_to_critical',
      'warning_to_critical',
    ].includes(transition)
  }

  describe('alert-triggering transitions', () => {
    it('should alert on ok to warning', () => {
      expect(shouldAlert('ok_to_warning')).toBe(true)
    })

    it('should alert on ok to critical', () => {
      expect(shouldAlert('ok_to_critical')).toBe(true)
    })

    it('should alert on warning to critical', () => {
      expect(shouldAlert('warning_to_critical')).toBe(true)
    })
  })

  describe('non-alert transitions', () => {
    it('should NOT alert on recovery (warning to ok)', () => {
      expect(shouldAlert('warning_to_ok')).toBe(false)
    })

    it('should NOT alert on recovery (critical to ok)', () => {
      expect(shouldAlert('critical_to_ok')).toBe(false)
    })

    it('should NOT alert on partial recovery (critical to warning)', () => {
      expect(shouldAlert('critical_to_warning')).toBe(false)
    })

    it('should NOT alert on no change', () => {
      expect(shouldAlert('no_change')).toBe(false)
    })
  })
})

describe('isRecovery', () => {
  const isRecovery = (transition: string): boolean => {
    return [
      'warning_to_ok',
      'critical_to_ok',
    ].includes(transition)
  }

  it('identifies warning to ok as recovery', () => {
    expect(isRecovery('warning_to_ok')).toBe(true)
  })

  it('identifies critical to ok as recovery', () => {
    expect(isRecovery('critical_to_ok')).toBe(true)
  })

  it('does NOT consider critical to warning as recovery', () => {
    // Critical to warning is improvement but not full recovery
    expect(isRecovery('critical_to_warning')).toBe(false)
  })

  it('does NOT consider alert transitions as recovery', () => {
    expect(isRecovery('ok_to_warning')).toBe(false)
    expect(isRecovery('ok_to_critical')).toBe(false)
    expect(isRecovery('warning_to_critical')).toBe(false)
  })
})

describe('AlertMode types', () => {
  it('should support daily_digest mode', () => {
    const mode: 'daily_digest' | 'per_transition' = 'daily_digest'
    expect(mode).toBe('daily_digest')
  })

  it('should support per_transition mode', () => {
    const mode: 'daily_digest' | 'per_transition' = 'per_transition'
    expect(mode).toBe('per_transition')
  })
})

describe('ComponentAlertNeeded structure', () => {
  it('contains all required fields', () => {
    const alertNeeded = {
      componentId: 'test-id',
      componentName: 'Test Component',
      skuCode: 'TEST-001',
      brandName: 'Test Brand',
      previousStatus: 'ok' as const,
      currentStatus: 'warning' as const,
      transition: 'ok_to_warning' as const,
      quantityOnHand: 5,
      reorderPoint: 10,
      leadTimeDays: 7,
    }

    expect(alertNeeded.componentId).toBe('test-id')
    expect(alertNeeded.previousStatus).toBe('ok')
    expect(alertNeeded.currentStatus).toBe('warning')
    expect(alertNeeded.transition).toBe('ok_to_warning')
  })
})

describe('LowStockAlertEvaluation structure', () => {
  it('contains all required fields', () => {
    const evaluation = {
      companyId: 'company-id',
      evaluatedAt: new Date().toISOString(),
      totalComponents: 10,
      componentsNeedingAlert: [],
      newWarnings: 2,
      newCriticals: 1,
      recoveries: 0,
    }

    expect(evaluation.companyId).toBe('company-id')
    expect(evaluation.totalComponents).toBe(10)
    expect(evaluation.newWarnings).toBe(2)
    expect(evaluation.newCriticals).toBe(1)
    expect(evaluation.recoveries).toBe(0)
  })
})
```

**Validation**:
```bash
npm test -- --testPathPattern="lowstock-alert"
```

**Completion Criteria**:
- [ ] Test file created
- [ ] All transition detection tests pass
- [ ] Alert trigger condition tests pass
- [ ] Edge case tests pass
- [ ] `npm test -- --testPathPattern="lowstock-alert"` passes

---

## Summary of Deliverables

**Files Created**: 3
- `src/types/lowstock-alert.ts` - TypeScript types with Zod schemas
- `src/services/lowstock-alert.ts` - Core evaluation service
- `tests/unit/lowstock-alert.test.ts` - Unit tests

**Files Modified**: 1
- `prisma/schema.prisma` - Added AlertConfig and ComponentAlertState models

**Migration File**: 1 (auto-generated)
- `prisma/migrations/[timestamp]_add_lowstock_alert_config/migration.sql`

---

## Handoff to Build Agent

1. Execute subtasks in exact order: Phase 1 (1.1, 1.2, 1.3) -> Phase 2 -> Phase 3 -> Phase 4
2. Run `npx prisma validate` after schema changes before migration
3. Run `npx prisma migrate dev` after all schema changes are complete
4. Run `npx tsc --noEmit` after each file creation
5. Run `npm run build` after Phase 3 completion
6. Run `npm test -- --testPathPattern="lowstock-alert"` after Phase 4 completion

## Test Strategy Note
- **Test Framework**: Vitest
- **Test Location**: `tests/unit/lowstock-alert.test.ts`
- **Test Command**: `npm test -- --testPathPattern="lowstock-alert"`
- **Integration tests**: Not included in this sub-issue (will be added with API routes in sub-issue 2)

## Final Validation Commands
```bash
npx tsc --noEmit
npm run build
npm test -- --testPathPattern="lowstock-alert"
npm run lint
```

## Acceptance Criteria Checklist (from Issue #104)
- [ ] `AlertConfig` table created with migration
- [ ] `ComponentAlertState` table created with migration
- [ ] `evaluateLowStockAlerts(companyId)` returns components needing alerts
- [ ] State transitions detected: OK->Warning, OK->Critical, Warning->Critical
- [ ] De-duplication: same status doesn't trigger repeated alerts
- [ ] Types exported from `@/types/lowstock-alert`
- [ ] Unit tests cover evaluation logic and edge cases
- [ ] `npm run build` and `npx tsc --noEmit` pass without errors

---

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Phase 1 (Database) | 30-45m |
| Phase 2 (Types) | 15-20m |
| Phase 3 (Service) | 60-90m |
| Phase 4 (Tests) | 30-45m |
| **Total** | **2.5-3.5h** |
