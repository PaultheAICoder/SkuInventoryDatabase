# Implementation Plan: Initial Inventory Import & Opening Balance Transactions

**Generated**: 2025-12-02T15:30:00Z
**Task ID**: Issue #8
**Estimated Build Time**: 10-12 hours
**Complexity**: Moderate

## Executive Summary

This feature enables users to create 'initial' transactions to set opening inventory balances for components. It includes a single-transaction API endpoint, a bulk CSV import capability, and UI integration on the import page. The database schema already supports the 'initial' transaction type in the enum, so no migration is required.

## Pre-Implementation Verification

**Schema Verification Results**:
- Transaction model: `prisma/schema.prisma` lines 128-154
- TransactionType enum includes `initial`: line 125
- TransactionLine model: lines 156-166 (includes `quantityChange`, `costPerUnit`)
- Component lookup uses `skuCode` field (line 98) via `brandId` + `skuCode` unique constraint (line 117)

**Pattern Reference Files**:
- Transaction API: `/home/pbrown/SkuInventory/src/app/api/transactions/receipt/route.ts` (74 lines)
- Transaction Service: `/home/pbrown/SkuInventory/src/services/inventory.ts` (lines 91-170 for receipt)
- Import API: `/home/pbrown/SkuInventory/src/app/api/import/components/route.ts` (149 lines)
- Import Service: `/home/pbrown/SkuInventory/src/services/import.ts` (318 lines)
- Types: `/home/pbrown/SkuInventory/src/types/transaction.ts` (101 lines)

**Ripple Effect Analysis**:
- All changes are additive (new functions, new routes)
- No existing function signatures are modified
- Existing tests in `tests/unit/csv-import.test.ts` should remain unaffected
- New tests will be added for initial inventory import

## Phase 1: Types Layer (30 minutes)

### Subtask 1.1: Add createInitialSchema to Transaction Types

**File**: `/home/pbrown/SkuInventory/src/types/transaction.ts`
**Pattern**: Follow `createReceiptSchema` (lines 4-12) and `createAdjustmentSchema` (lines 17-23)
**Location**: After line 25 (after `CreateAdjustmentInput` type)

**Instructions**:
1. Add `createInitialSchema` Zod schema with fields:
   - `date`: `z.coerce.date()` (required)
   - `componentId`: `z.string().uuid('Invalid component ID')` (required)
   - `quantity`: `z.coerce.number().positive('Quantity must be positive')` (required, must be positive for initial)
   - `costPerUnit`: `z.coerce.number().nonnegative().optional()` (optional, falls back to component cost)
   - `updateComponentCost`: `z.boolean().default(false)` (optional, whether to update component's default cost)
   - `notes`: `z.string().optional().nullable()` (optional)

2. Add `CreateInitialInput` type:
   ```typescript
   export type CreateInitialInput = z.infer<typeof createInitialSchema>
   ```

**Code Snippet**:
```typescript
// Initial transaction schema (opening balance)
export const createInitialSchema = z.object({
  date: z.coerce.date(),
  componentId: z.string().uuid('Invalid component ID'),
  quantity: z.coerce.number().positive('Quantity must be positive'),
  costPerUnit: z.coerce.number().nonnegative().optional(),
  updateComponentCost: z.boolean().default(false),
  notes: z.string().optional().nullable(),
})

export type CreateInitialInput = z.infer<typeof createInitialSchema>
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Schema compiles without errors
- [ ] Type is exported correctly
- [ ] Lint passes

---

## Phase 2: Service Layer (1-2 hours)

### Subtask 2.1: Add createInitialTransaction Function to Inventory Service

**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Follow `createReceiptTransaction` (lines 91-170)
**Location**: After line 224 (after `createAdjustmentTransaction` function)

**Instructions**:
1. Create `createInitialTransaction` function with parameters:
   - `companyId: string`
   - `componentId: string`
   - `quantity: number` (must be positive)
   - `date: Date`
   - `costPerUnit?: number` (optional)
   - `updateComponentCost: boolean`
   - `notes?: string | null`
   - `createdById: string`

2. Implementation logic:
   - Use `prisma.$transaction` for atomicity
   - Fetch component to get default `costPerUnit` if not provided
   - Throw error if component not found
   - Determine `lineCostPerUnit` from input or component default
   - Create Transaction with `type: 'initial'` and nested TransactionLine
   - If `updateComponentCost` is true and `costPerUnit` was provided, update component's cost
   - Include related data in response (lines, component, createdBy)

3. Return type should match the receipt transaction pattern

**Code Snippet**:
```typescript
/**
 * Create an initial transaction (sets opening balance for a component)
 */
export async function createInitialTransaction(params: {
  companyId: string
  componentId: string
  quantity: number
  date: Date
  costPerUnit?: number
  updateComponentCost: boolean
  notes?: string | null
  createdById: string
}) {
  const {
    companyId,
    componentId,
    quantity,
    date,
    costPerUnit,
    updateComponentCost,
    notes,
    createdById,
  } = params

  return prisma.$transaction(async (tx) => {
    // Get component for cost snapshot
    const component = await tx.component.findUnique({
      where: { id: componentId },
    })

    if (!component) {
      throw new Error('Component not found')
    }

    const lineCostPerUnit = costPerUnit ?? component.costPerUnit.toNumber()

    // Create transaction with line
    const transaction = await tx.transaction.create({
      data: {
        companyId,
        type: 'initial',
        date,
        notes,
        createdById,
        lines: {
          create: {
            componentId,
            quantityChange: new Prisma.Decimal(quantity),
            costPerUnit: new Prisma.Decimal(lineCostPerUnit),
          },
        },
      },
      include: {
        lines: {
          include: {
            component: {
              select: { id: true, name: true, skuCode: true },
            },
          },
        },
        createdBy: {
          select: { id: true, name: true },
        },
      },
    })

    // Update component cost if requested
    if (updateComponentCost && costPerUnit !== undefined) {
      await tx.component.update({
        where: { id: componentId },
        data: {
          costPerUnit: new Prisma.Decimal(costPerUnit),
          updatedById: createdById,
        },
      })
    }

    return transaction
  })
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Function compiles without errors
- [ ] Uses Prisma transaction for atomicity
- [ ] Returns transaction with related data
- [ ] Handles optional costPerUnit with fallback
- [ ] Lint passes

---

## Phase 3: Single Transaction API Route (1 hour)

### Subtask 3.1: Create POST /api/transactions/initial Route

**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/initial/route.ts` (CREATE NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/transactions/receipt/route.ts` exactly

**Instructions**:
1. Create new file with same imports pattern as receipt route
2. Import `createInitialSchema` from `@/types/transaction`
3. Import `createInitialTransaction` from `@/services/inventory`
4. Implement POST handler:
   - Session validation (lines 12-15 pattern)
   - Role check - viewer cannot create (lines 17-20 pattern)
   - Parse body with `createInitialSchema` (line 22 pattern)
   - Verify component exists and belongs to user's company (lines 27-39 pattern)
   - Call `createInitialTransaction` service function
   - Return `created()` response with formatted data (lines 54-68 pattern)
5. Error handling with try/catch and `serverError()` (lines 69-72 pattern)

**Code Snippet**:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { created, unauthorized, notFound, serverError, parseBody } from '@/lib/api-response'
import { createInitialSchema } from '@/types/transaction'
import { createInitialTransaction } from '@/services/inventory'

// POST /api/transactions/initial - Create an initial (opening balance) transaction
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    // Check role - Viewer cannot create transactions
    if (session.user.role === 'viewer') {
      return unauthorized('You do not have permission to create transactions')
    }

    const bodyResult = await parseBody(request, createInitialSchema)
    if (bodyResult.error) return bodyResult.error

    const data = bodyResult.data

    // Verify component exists and belongs to user's company
    const component = await prisma.component.findFirst({
      where: {
        id: data.componentId,
        brand: {
          company: { id: session.user.companyId },
        },
      },
    })

    if (!component) {
      return notFound('Component')
    }

    // Create the initial transaction
    const transaction = await createInitialTransaction({
      companyId: session.user.companyId,
      componentId: data.componentId,
      quantity: data.quantity,
      date: data.date,
      costPerUnit: data.costPerUnit,
      updateComponentCost: data.updateComponentCost,
      notes: data.notes,
      createdById: session.user.id,
    })

    return created({
      id: transaction.id,
      type: transaction.type,
      date: transaction.date.toISOString().split('T')[0],
      notes: transaction.notes,
      createdAt: transaction.createdAt.toISOString(),
      createdBy: transaction.createdBy,
      lines: transaction.lines.map((line) => ({
        id: line.id,
        component: line.component,
        quantityChange: line.quantityChange.toString(),
        costPerUnit: line.costPerUnit?.toString() ?? null,
      })),
    })
  } catch (error) {
    console.error('Error creating initial transaction:', error)
    return serverError()
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
npm run build
```

**Completion Criteria**:
- [ ] Route compiles without errors
- [ ] Authentication enforced
- [ ] Role check prevents viewers
- [ ] Component tenant validation works
- [ ] Returns proper response format
- [ ] Build passes

---

## Phase 4: CSV Import Service Functions (2-3 hours)

### Subtask 4.1: Add Initial Inventory Import Schema to Import Service

**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow `componentImportSchema` (lines 97-106) and `skuImportSchema` (lines 109-114)
**Location**: After line 114 (after `skuImportSchema`)

**Instructions**:
1. Add `initialInventoryImportSchema` Zod schema for CSV row validation:
   - `component_sku_code`: `z.string().min(1, 'Component SKU code is required')` (required)
   - `quantity`: `z.string().min(1, 'Quantity is required')` then transform to positive number
   - `cost_per_unit`: `z.string().optional()` then transform to number or undefined
   - `date`: `z.string().optional()` then transform to Date or today
   - `notes`: `z.string().optional()` then transform to string or null

**Code Snippet**:
```typescript
// Initial inventory import schema with CSV field mappings
const initialInventoryImportSchema = z.object({
  component_sku_code: z.string().min(1, 'Component SKU code is required'),
  quantity: z.string().min(1, 'Quantity is required').transform((v) => {
    const num = parseFloat(v)
    if (isNaN(num) || num <= 0) {
      throw new Error('Quantity must be a positive number')
    }
    return num
  }),
  cost_per_unit: z.string().optional().transform((v) => {
    if (!v || v.trim() === '') return undefined
    const num = parseFloat(v)
    if (isNaN(num) || num < 0) {
      throw new Error('Cost per unit must be a non-negative number')
    }
    return num
  }),
  date: z.string().optional().transform((v) => {
    if (!v || v.trim() === '') return new Date()
    const date = new Date(v)
    if (isNaN(date.getTime())) {
      throw new Error('Invalid date format')
    }
    return date
  }),
  notes: z.string().optional().transform((v) => v || null),
})
```

### Subtask 4.2: Add importInitialInventoryRow Function

**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow `importComponentRow` (lines 119-164) and `importSKURow` (lines 169-210)
**Location**: After `importSKURow` function

**Instructions**:
1. Create `importInitialInventoryRow` function that:
   - Takes `record: Record<string, string>` and `rowNumber: number`
   - Returns `ImportResult<InitialInventoryRowData>` type
   - Parses with `initialInventoryImportSchema`
   - Returns validated data or error array

2. Define `InitialInventoryRowData` interface:
   ```typescript
   export interface InitialInventoryRowData {
     componentSkuCode: string
     quantity: number
     costPerUnit?: number
     date: Date
     notes: string | null
   }
   ```

**Code Snippet**:
```typescript
export interface InitialInventoryRowData {
  componentSkuCode: string
  quantity: number
  costPerUnit?: number
  date: Date
  notes: string | null
}

/**
 * Import initial inventory row from CSV
 */
function importInitialInventoryRow(
  record: Record<string, string>,
  rowNumber: number
): ImportResult<InitialInventoryRowData> {
  try {
    const csvParsed = initialInventoryImportSchema.parse(record)

    const rowData: InitialInventoryRowData = {
      componentSkuCode: csvParsed.component_sku_code,
      quantity: csvParsed.quantity,
      costPerUnit: csvParsed.cost_per_unit,
      date: csvParsed.date,
      notes: csvParsed.notes,
    }

    return {
      success: true,
      rowNumber,
      data: rowData,
      errors: [],
    }
  } catch (err) {
    if (err instanceof z.ZodError) {
      return {
        success: false,
        rowNumber,
        data: null,
        errors: err.issues.map((e) => `${e.path.join('.')}: ${e.message}`),
      }
    }
    return {
      success: false,
      rowNumber,
      data: null,
      errors: [err instanceof Error ? err.message : 'Unknown error'],
    }
  }
}
```

### Subtask 4.3: Add processInitialInventoryImport Function

**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow `processComponentImport` (lines 216-244) and `processSKUImport` (lines 249-277)
**Location**: After `processSKUImport` function

**Instructions**:
1. Create `processInitialInventoryImport` function that:
   - Takes `csvContent: string`
   - Returns `ImportSummary<InitialInventoryRowData>`
   - Parses CSV using `parseCSV`
   - Extracts headers and data rows
   - Maps each row through `importInitialInventoryRow`
   - Returns summary with counts

**Code Snippet**:
```typescript
/**
 * Process CSV content for initial inventory import
 */
export function processInitialInventoryImport(
  csvContent: string
): ImportSummary<InitialInventoryRowData> {
  const rows = parseCSV(csvContent)

  if (rows.length < 2) {
    return {
      total: 0,
      successful: 0,
      failed: 0,
      results: [],
    }
  }

  const headers = rows[0]
  const dataRows = rows.slice(1)

  const results = dataRows.map((row, index) => {
    const record = rowToRecord(headers, row)
    return importInitialInventoryRow(record, index + 2) // +2 because 1-indexed and skip header
  })

  return {
    total: results.length,
    successful: results.filter((r) => r.success).length,
    failed: results.filter((r) => !r.success).length,
    results,
  }
}
```

### Subtask 4.4: Add generateInitialInventoryTemplate Function

**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow `generateComponentTemplate` (lines 282-306) and `generateSKUTemplate` (lines 311-317)
**Location**: After `generateSKUTemplate` function

**Instructions**:
1. Create `generateInitialInventoryTemplate` function that:
   - Returns CSV string with headers and example row
   - Headers: `Component SKU Code`, `Quantity`, `Cost Per Unit`, `Date`, `Notes`
   - Example row: `COMP-001`, `100`, `10.50`, `2025-01-01`, `Opening balance`

**Code Snippet**:
```typescript
/**
 * Generate CSV template for initial inventory import
 */
export function generateInitialInventoryTemplate(): string {
  const headers = [
    'Component SKU Code',
    'Quantity',
    'Cost Per Unit',
    'Date',
    'Notes',
  ]

  const exampleRow = [
    'COMP-001',
    '100',
    '10.50',
    '2025-01-01',
    'Opening balance',
  ]

  return [headers.join(','), exampleRow.join(',')].join('\n')
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Schema validates correctly
- [ ] Row import function handles errors properly
- [ ] Process function returns correct summary
- [ ] Template generates valid CSV
- [ ] All functions exported
- [ ] Lint passes

---

## Phase 5: Bulk Import API Route (2-3 hours)

### Subtask 5.1: Create POST /api/import/initial-inventory Route

**File**: `/home/pbrown/SkuInventory/src/app/api/import/initial-inventory/route.ts` (CREATE NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/import/components/route.ts` exactly

**Instructions**:
1. Create new file with same structure as components import route
2. Import `processInitialInventoryImport`, `InitialInventoryRowData` from `@/services/import`
3. Import `createInitialTransaction` from `@/services/inventory`
4. Define `InitialInventoryImportResult` interface matching `ComponentImportResult` pattern
5. Implement POST handler:
   - Session validation (lines 24-27 pattern)
   - Role check (lines 29-32 pattern)
   - Get user's brandId (lines 34-44 pattern)
   - Parse CSV from multipart or raw body (lines 46-66 pattern)
   - Process CSV with `processInitialInventoryImport`
   - For each successful row:
     - Look up component by `skuCode` + `brandId`
     - **Idempotency check**: Check if component already has 'initial' transaction
     - If exists, skip with error message (unless `allowOverwrite` in future)
     - Call `createInitialTransaction` for each row
     - Track imported/skipped/errors
   - Return summary response

**Key Idempotency Logic**:
```typescript
// Check for existing initial transaction for this component
const existingInitial = await prisma.transaction.findFirst({
  where: {
    type: 'initial',
    lines: {
      some: { componentId: component.id },
    },
  },
})

if (existingInitial) {
  result.skipped++
  result.errors.push({
    rowNumber: row.rowNumber,
    componentSkuCode: rowData.componentSkuCode,
    errors: [`Component "${rowData.componentSkuCode}" already has an initial inventory transaction`],
  })
  continue
}
```

**Full Code Snippet**:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { success, unauthorized, serverError, error } from '@/lib/api-response'
import { processInitialInventoryImport, type InitialInventoryRowData, type ImportSummary } from '@/services/import'
import { createInitialTransaction } from '@/services/inventory'

interface InitialInventoryImportResult {
  total: number
  imported: number
  skipped: number
  errors: Array<{
    rowNumber: number
    componentSkuCode: string
    errors: string[]
  }>
}

// POST /api/import/initial-inventory - Import initial inventory from CSV
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    // Only ops and admin can import
    if (session.user.role === 'viewer') {
      return unauthorized('Viewers cannot import data')
    }

    // Get user's brand
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { company: { include: { brands: { where: { isActive: true }, take: 1 } } } },
    })

    if (!user?.company.brands[0]) {
      return error('No active brand found', 400)
    }

    const brandId = user.company.brands[0].id

    // Parse multipart form data or raw CSV
    const contentType = request.headers.get('content-type') || ''

    let csvContent: string

    if (contentType.includes('multipart/form-data')) {
      const formData = await request.formData()
      const file = formData.get('file') as File | null

      if (!file) {
        return error('No file provided', 400)
      }

      csvContent = await file.text()
    } else {
      csvContent = await request.text()
    }

    if (!csvContent.trim()) {
      return error('Empty file provided', 400)
    }

    // Process CSV
    const importSummary: ImportSummary<InitialInventoryRowData> = processInitialInventoryImport(csvContent)

    const result: InitialInventoryImportResult = {
      total: importSummary.total,
      imported: 0,
      skipped: 0,
      errors: [],
    }

    // Import successful rows
    for (const row of importSummary.results) {
      if (!row.success || !row.data) {
        result.skipped++
        result.errors.push({
          rowNumber: row.rowNumber,
          componentSkuCode: '',
          errors: row.errors,
        })
        continue
      }

      const rowData = row.data

      try {
        // Look up component by SKU code
        const component = await prisma.component.findFirst({
          where: {
            brandId,
            skuCode: rowData.componentSkuCode,
          },
        })

        if (!component) {
          result.skipped++
          result.errors.push({
            rowNumber: row.rowNumber,
            componentSkuCode: rowData.componentSkuCode,
            errors: [`Component with SKU code "${rowData.componentSkuCode}" not found`],
          })
          continue
        }

        // Idempotency check: Check for existing initial transaction
        const existingInitial = await prisma.transaction.findFirst({
          where: {
            type: 'initial',
            lines: {
              some: { componentId: component.id },
            },
          },
        })

        if (existingInitial) {
          result.skipped++
          result.errors.push({
            rowNumber: row.rowNumber,
            componentSkuCode: rowData.componentSkuCode,
            errors: [`Component "${rowData.componentSkuCode}" already has an initial inventory transaction`],
          })
          continue
        }

        // Create initial transaction
        await createInitialTransaction({
          companyId: session.user.companyId,
          componentId: component.id,
          quantity: rowData.quantity,
          date: rowData.date,
          costPerUnit: rowData.costPerUnit,
          updateComponentCost: rowData.costPerUnit !== undefined,
          notes: rowData.notes,
          createdById: session.user.id,
        })

        result.imported++
      } catch (err) {
        result.skipped++
        result.errors.push({
          rowNumber: row.rowNumber,
          componentSkuCode: rowData.componentSkuCode,
          errors: [err instanceof Error ? err.message : 'Database error'],
        })
      }
    }

    return success(result)
  } catch (err) {
    console.error('Error importing initial inventory:', err)
    return serverError()
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
npm run build
```

**Completion Criteria**:
- [ ] Route compiles without errors
- [ ] Authentication and role check work
- [ ] Component lookup by SKU code works
- [ ] Idempotency check prevents duplicates
- [ ] Proper error messages for missing components
- [ ] Returns correct summary format
- [ ] Build passes

---

## Phase 6: Template Route Update (30 minutes)

### Subtask 6.1: Update Template Route to Include Initial Inventory

**File**: `/home/pbrown/SkuInventory/src/app/api/import/template/[type]/route.ts`
**Pattern**: Follow existing switch case pattern (lines 30-41)
**Location**: Add new case before `default` at line 39

**Instructions**:
1. Import `generateInitialInventoryTemplate` from `@/services/import`
2. Add case for `'initial-inventory'` in switch statement:
   ```typescript
   case 'initial-inventory':
     csvContent = generateInitialInventoryTemplate()
     filename = 'initial-inventory-import-template.csv'
     break
   ```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Template download works for initial-inventory type
- [ ] Returns correct filename
- [ ] Lint passes

---

## Phase 7: UI Integration (2-3 hours)

### Subtask 7.1: Update ImportForm Component Types

**File**: `/home/pbrown/SkuInventory/src/components/features/ImportForm.tsx`
**Pattern**: Extend existing `importType` union type
**Location**: Line 26

**Instructions**:
1. Update `importType` prop type to include `'initial-inventory'`:
   ```typescript
   importType: 'components' | 'skus' | 'initial-inventory'
   ```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Type compiles without errors
- [ ] Existing functionality unaffected

### Subtask 7.2: Update Import Page with Initial Inventory Form

**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/import/page.tsx`
**Pattern**: Follow existing component/SKU import pattern (lines 71-84)

**Instructions**:
1. Add state for initial inventory result:
   ```typescript
   const [initialInventoryResult, setInitialInventoryResult] = useState<ImportResult | null>(null)
   const [showInitialInventoryResult, setShowInitialInventoryResult] = useState(false)
   ```

2. Add handler function:
   ```typescript
   const handleInitialInventoryImport = (result: ImportResult) => {
     setInitialInventoryResult(result)
     setShowInitialInventoryResult(true)
   }
   ```

3. Add third ImportForm in the grid (after SKUs form):
   ```typescript
   <ImportForm
     importType="initial-inventory"
     title="Initial Inventory"
     description="Set opening balances for existing components with quantities and optional costs"
     onImportComplete={handleInitialInventoryImport}
   />
   ```

4. Add ImportResultDialog for initial inventory:
   ```typescript
   <ImportResultDialog
     open={showInitialInventoryResult}
     onClose={() => setShowInitialInventoryResult(false)}
     result={initialInventoryResult}
     importType="initial-inventory"
   />
   ```

5. Update page description to mention initial inventory:
   ```typescript
   <p className="text-muted-foreground">Import components, SKUs, and initial inventory from CSV files</p>
   ```

**UI Acceptance Criteria**:
- [ ] Initial Inventory card visible on desktop (1024px+)
- [ ] Initial Inventory card visible on tablet (768px-1023px)
- [ ] Initial Inventory card visible on mobile (<768px)
- [ ] Grid layout adjusts appropriately (2 cols on md, 3 cols on lg, or stacked on smaller screens)

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
npm run build
```

**Completion Criteria**:
- [ ] Page compiles without errors
- [ ] Import form displays correctly
- [ ] Template download works
- [ ] Upload triggers API correctly
- [ ] Result dialog shows import summary
- [ ] Build passes

---

## Phase 8: Testing (2 hours)

### Subtask 8.1: Add Unit Tests for Initial Inventory Import Service

**File**: `/home/pbrown/SkuInventory/tests/unit/csv-import.test.ts`
**Pattern**: Follow existing `processComponentImport` and `processSKUImport` test patterns
**Location**: After `processSKUImport` describe block (after line 273)

**Instructions**:
1. Add new describe block for `processInitialInventoryImport`
2. Test cases to add:
   - Processes valid initial inventory CSV
   - Reports validation errors for missing quantity
   - Reports validation errors for negative quantity
   - Returns empty result for CSV with only headers
   - Handles optional cost per unit field
   - Handles optional date field (defaults to today)
   - Handles optional notes field
   - Handles decimal quantity values
   - Reports row numbers correctly
   - Handles mixed valid and invalid rows

**Code Snippet**:
```typescript
describe('processInitialInventoryImport', () => {
  it('processes valid initial inventory CSV', () => {
    const csv = `Component SKU Code,Quantity,Cost Per Unit,Date,Notes
COMP-001,100,10.50,2025-01-01,Opening balance`

    const result = processInitialInventoryImport(csv)

    expect(result.total).toBe(1)
    expect(result.successful).toBe(1)
    expect(result.failed).toBe(0)
    expect(result.results[0].success).toBe(true)
    expect(result.results[0].data).toMatchObject({
      componentSkuCode: 'COMP-001',
      quantity: 100,
      costPerUnit: 10.5,
    })
  })

  it('reports validation errors for missing quantity', () => {
    const csv = `Component SKU Code,Quantity
COMP-001,`

    const result = processInitialInventoryImport(csv)

    expect(result.failed).toBe(1)
    expect(result.results[0].success).toBe(false)
  })

  it('reports validation errors for negative quantity', () => {
    const csv = `Component SKU Code,Quantity
COMP-001,-50`

    const result = processInitialInventoryImport(csv)

    expect(result.failed).toBe(1)
    expect(result.results[0].success).toBe(false)
  })

  it('returns empty result for CSV with only headers', () => {
    const csv = 'Component SKU Code,Quantity'

    const result = processInitialInventoryImport(csv)

    expect(result.total).toBe(0)
    expect(result.results).toEqual([])
  })

  it('handles optional cost per unit field', () => {
    const csv = `Component SKU Code,Quantity,Cost Per Unit
COMP-001,100,`

    const result = processInitialInventoryImport(csv)

    expect(result.successful).toBe(1)
    expect(result.results[0].data?.costPerUnit).toBeUndefined()
  })

  it('handles optional date field with default to today', () => {
    const csv = `Component SKU Code,Quantity,Cost Per Unit,Date
COMP-001,100,10.50,`

    const result = processInitialInventoryImport(csv)

    expect(result.successful).toBe(1)
    expect(result.results[0].data?.date).toBeInstanceOf(Date)
  })

  it('handles decimal quantity values', () => {
    const csv = `Component SKU Code,Quantity
COMP-001,99.5`

    const result = processInitialInventoryImport(csv)

    expect(result.successful).toBe(1)
    expect(result.results[0].data?.quantity).toBe(99.5)
  })

  it('reports row numbers correctly', () => {
    const csv = `Component SKU Code,Quantity
COMP-001,100
COMP-002,50`

    const result = processInitialInventoryImport(csv)

    expect(result.results[0].rowNumber).toBe(2)
    expect(result.results[1].rowNumber).toBe(3)
  })

  it('handles mixed valid and invalid rows', () => {
    const csv = `Component SKU Code,Quantity
COMP-001,100
,50
COMP-002,75`

    const result = processInitialInventoryImport(csv)

    expect(result.total).toBe(3)
    expect(result.successful).toBe(2)
    expect(result.failed).toBe(1)
  })
})
```

**Validation Commands**:
```bash
npm test -- --filter="initial"
npm test
```

**Completion Criteria**:
- [ ] All new tests pass
- [ ] Existing tests still pass
- [ ] Test coverage for validation, edge cases, and happy path

---

## Summary of Deliverables

**Files Created** (3 files):
- `/home/pbrown/SkuInventory/src/app/api/transactions/initial/route.ts` - Single transaction API
- `/home/pbrown/SkuInventory/src/app/api/import/initial-inventory/route.ts` - Bulk import API

**Files Modified** (6 files):
- `/home/pbrown/SkuInventory/src/types/transaction.ts` - Add createInitialSchema
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Add createInitialTransaction
- `/home/pbrown/SkuInventory/src/services/import.ts` - Add CSV processing functions
- `/home/pbrown/SkuInventory/src/app/api/import/template/[type]/route.ts` - Add template case
- `/home/pbrown/SkuInventory/src/components/features/ImportForm.tsx` - Extend type
- `/home/pbrown/SkuInventory/src/app/(dashboard)/import/page.tsx` - Add UI form
- `/home/pbrown/SkuInventory/tests/unit/csv-import.test.ts` - Add tests

**Total Files**: 9

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 through Phase 8)
2. Each phase builds on the previous - do not skip ahead
3. Test completion criteria before moving to next subtask
4. Follow reference patterns exactly - do not deviate
5. Run validation commands after each subtask
6. All TypeScript errors must be resolved before proceeding
7. Build must pass before considering implementation complete

**Critical Notes**:
- No database migration required (initial type already exists in enum)
- Idempotency check is critical for bulk import (Phase 5)
- Component lookup in bulk import uses `skuCode` field, not `id`
- Cost per unit is optional - falls back to component's default cost
- The UI grid may need CSS adjustment for 3 cards (consider `lg:grid-cols-3`)

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Scout Review | 5m |
| Pattern Research | 15m |
| Schema Verification | 5m |
| Plan Writing | 25m |
| **Total** | **50m** |
