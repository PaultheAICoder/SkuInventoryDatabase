# Implementation Plan
**Generated**: 2025-12-06T10:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #180
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #180
**Priority**: Medium

**User Request**: Enable editing BOM details (price changes, qty/unit changes) inside an existing SKU version without creating a new version. User wants an "edit" button on the SKU that allows manual updates for occasional corrections.

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="bom"` or `--testPathPattern="bom"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- `9b4cafb feat(issue #176): add fraction input support for BOM qty/unit` (relevant - uses same fraction parsing)
- No existing BOM edit functionality found

### Current State Assessment
- **Existing components**:
  - `BOMVersionList.tsx` - displays BOM versions, has Clone and Activate buttons, NO Edit button
  - `BOMVersionForm.tsx` - creates new BOM versions, only handles CREATE (not update)
  - Clone and Activate routes exist at `/api/bom-versions/[id]/clone` and `/api/bom-versions/[id]/activate`
- **Database**:
  - `BOMVersion` model exists with `updatedAt` field
  - `BOMLine` model tracks component quantities and notes
  - No `updatedById` field on BOMVersion (unlike Component/SKU models)
- **API Routes**:
  - `/api/bom-versions/[id]/route.ts` - only has GET method, NO PATCH
  - No update schema exists in `src/types/bom.ts`
- **Types**:
  - `BOMVersionResponse` type exists
  - `CreateBOMVersionInput` exists but no `UpdateBOMVersionInput`

### Dependencies & Blockers
1. Need to add `updatedById` field to BOMVersion model for audit tracking (optional but recommended)
2. No external dependencies required

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 6-8 hours
**Risk**: Low - follows established patterns from Component/SKU update APIs

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts` - PATCH handler pattern for updates
**Secondary**: `/home/pbrown/SkuInventory/src/services/bom.ts` - existing BOM service functions

### Ripple Effect Analysis
**Files Identified**: 8

| File | Why Affected |
|------|--------------|
| `src/types/bom.ts` | Add update schema and types |
| `src/app/api/bom-versions/[id]/route.ts` | Add PATCH handler |
| `src/services/bom.ts` | Add updateBOMVersion service function |
| `src/components/features/BOMVersionList.tsx` | Add Edit button |
| `src/components/features/BOMVersionEditForm.tsx` | NEW - Edit form component |
| `src/app/(dashboard)/skus/[id]/bom/[bomId]/edit/page.tsx` | NEW - Edit page |
| `prisma/schema.prisma` | Add updatedById field (optional) |
| `prisma/migrations/` | Migration if schema change (optional) |

---

## Executive Summary

This feature enables users to edit BOM details (component quantities, notes) directly on an existing BOM version without needing to clone or recreate a new version. Implementation includes: (1) a new PATCH API endpoint at `/api/bom-versions/[id]`, (2) an updateBOMVersion service function, (3) a new BOMVersionEditForm component, (4) an edit page at `/skus/[id]/bom/[bomId]/edit`, and (5) an Edit button on the BOMVersionList component.

---

## Phase 1: Types Layer

### Subtask 1.1: Add Update BOM Version Schema
**File**: `/home/pbrown/SkuInventory/src/types/bom.ts`
**Pattern**: Follow `updateSKUSchema` pattern from `/home/pbrown/SkuInventory/src/types/sku.ts:21`
**Instructions**:
1. Add `updateBOMVersionSchema` after `createBOMVersionSchema` (around line 47)
2. Schema should allow partial updates to:
   - `versionName` (string, optional)
   - `effectiveStartDate` (date, optional)
   - `notes` (string, optional, nullable)
   - `defectNotes` (string, optional, nullable)
   - `qualityMetadata` (record, optional)
   - `lines` (array, optional - for updating quantities/notes)
3. Add `UpdateBOMVersionInput` type export

```typescript
// BOM version update schema (partial updates allowed)
export const updateBOMVersionSchema = z.object({
  versionName: z.string().min(1).max(50).optional(),
  effectiveStartDate: z.coerce.date().optional(),
  notes: z.string().optional().nullable(),
  defectNotes: z.string().optional().nullable(),
  qualityMetadata: z.record(z.string(), z.unknown()).optional(),
  lines: z.array(bomLineSchema).optional(),
})

export type UpdateBOMVersionInput = z.infer<typeof updateBOMVersionSchema>
```

**Validation commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Schema compiles without errors
- [ ] Type is exported

---

## Phase 2: Service Layer

### Subtask 2.1: Add Update BOM Version Service Function
**File**: `/home/pbrown/SkuInventory/src/services/bom.ts`
**Pattern**: Follow `updateComponent` in inventory service and existing `activateBOMVersion` pattern
**Instructions**:
1. Add `updateBOMVersion` function after `activateBOMVersion` (around line 366)
2. Function should:
   - Accept bomVersionId and partial update data
   - Verify BOM version exists
   - Update BOMVersion fields if provided
   - If lines are provided, delete existing lines and recreate with new data (simpler than diffing)
   - Use transaction for atomicity
   - Return updated BOM version with lines

```typescript
/**
 * Update a BOM version's details and optionally its lines
 */
export async function updateBOMVersion(params: {
  bomVersionId: string
  versionName?: string
  effectiveStartDate?: Date
  notes?: string | null
  defectNotes?: string | null
  qualityMetadata?: Record<string, unknown>
  lines?: Array<{
    componentId: string
    quantityPerUnit: number
    notes?: string | null
  }>
}) {
  const { bomVersionId, lines, ...updateData } = params

  return prisma.$transaction(async (tx) => {
    // Check if BOM version exists
    const existing = await tx.bOMVersion.findUnique({
      where: { id: bomVersionId },
    })

    if (!existing) {
      throw new Error('BOM version not found')
    }

    // If lines are provided, delete existing and recreate
    if (lines && lines.length > 0) {
      await tx.bOMLine.deleteMany({
        where: { bomVersionId },
      })

      await tx.bOMLine.createMany({
        data: lines.map((line) => ({
          bomVersionId,
          componentId: line.componentId,
          quantityPerUnit: new Prisma.Decimal(line.quantityPerUnit),
          notes: line.notes,
        })),
      })
    }

    // Update BOM version metadata
    const updated = await tx.bOMVersion.update({
      where: { id: bomVersionId },
      data: {
        ...(updateData.versionName !== undefined && { versionName: updateData.versionName }),
        ...(updateData.effectiveStartDate !== undefined && { effectiveStartDate: updateData.effectiveStartDate }),
        ...(updateData.notes !== undefined && { notes: updateData.notes }),
        ...(updateData.defectNotes !== undefined && { defectNotes: updateData.defectNotes }),
        ...(updateData.qualityMetadata !== undefined && {
          qualityMetadata: updateData.qualityMetadata as Prisma.InputJsonValue
        }),
      },
      include: {
        lines: {
          include: {
            component: {
              select: {
                id: true,
                name: true,
                skuCode: true,
                costPerUnit: true,
                unitOfMeasure: true,
              },
            },
          },
        },
        createdBy: {
          select: { id: true, name: true },
        },
      },
    })

    return updated
  })
}
```

**Validation commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Function compiles without errors
- [ ] Uses transaction for atomicity
- [ ] Handles both metadata-only and lines updates

---

## Phase 3: API Routes

### Subtask 3.1: Add PATCH Handler to BOM Version Route
**File**: `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/route.ts`
**Pattern**: Follow PATCH pattern from `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts:256`
**Instructions**:
1. Import `updateBOMVersionSchema` from `@/types/bom`
2. Import `updateBOMVersion` from `@/services/bom`
3. Add PATCH handler after GET handler
4. Include:
   - Session authentication check
   - Company scoping verification
   - Component validation (ensure all componentIds exist and are active in company)
   - Call updateBOMVersion service
   - Return formatted response with unit cost calculation

```typescript
// PATCH /api/bom-versions/:id - Update BOM version
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    const { id } = await params

    // Parse optional locationId query parameter
    const { searchParams } = new URL(request.url)
    const locationId = searchParams.get('locationId') ?? undefined

    const bodyResult = await parseBody(request, updateBOMVersionSchema)
    if (bodyResult.error) return bodyResult.error

    const data = bodyResult.data

    // Use selected company for scoping
    const selectedCompanyId = session.user.selectedCompanyId

    // Verify BOM version exists and belongs to user's selected company
    const existingBom = await prisma.bOMVersion.findFirst({
      where: {
        id,
        sku: {
          companyId: selectedCompanyId,
        },
      },
    })

    if (!existingBom) {
      return notFound('BOM version')
    }

    // If updating lines, verify all components exist and are active
    if (data.lines && data.lines.length > 0) {
      const componentIds = data.lines.map((l) => l.componentId)
      const components = await prisma.component.findMany({
        where: {
          id: { in: componentIds },
          isActive: true,
          companyId: selectedCompanyId,
        },
      })

      if (components.length !== componentIds.length) {
        return serverError('One or more components not found or inactive')
      }
    }

    // Update BOM version
    const bomVersion = await updateBOMVersion({
      bomVersionId: id,
      ...data,
    })

    // Calculate unit cost
    const unitCost = await calculateBOMUnitCost(bomVersion.id)

    // Get component quantities (filtered by location if specified)
    const componentIds = bomVersion.lines.map((l) => l.componentId)
    const quantities = await getComponentQuantities(componentIds, locationId)

    return success({
      id: bomVersion.id,
      skuId: bomVersion.skuId,
      versionName: bomVersion.versionName,
      effectiveStartDate: bomVersion.effectiveStartDate.toISOString().split('T')[0],
      effectiveEndDate: bomVersion.effectiveEndDate?.toISOString().split('T')[0] ?? null,
      isActive: bomVersion.isActive,
      notes: bomVersion.notes,
      defectNotes: bomVersion.defectNotes,
      qualityMetadata: bomVersion.qualityMetadata as Record<string, unknown>,
      unitCost: unitCost.toFixed(4),
      lines: bomVersion.lines.map((line) => ({
        id: line.id,
        component: {
          id: line.component.id,
          name: line.component.name,
          skuCode: line.component.skuCode,
          costPerUnit: line.component.costPerUnit.toString(),
          unitOfMeasure: line.component.unitOfMeasure,
          quantityOnHand: quantities.get(line.componentId) ?? 0,
        },
        quantityPerUnit: line.quantityPerUnit.toString(),
        lineCost: (line.quantityPerUnit.toNumber() * line.component.costPerUnit.toNumber()).toFixed(4),
        notes: line.notes,
      })),
      createdAt: bomVersion.createdAt.toISOString(),
      createdBy: bomVersion.createdBy,
    })
  } catch (error) {
    console.error('Error updating BOM version:', error)
    return serverError()
  }
}
```

**Import additions at top of file**:
```typescript
import {
  success,
  unauthorized,
  notFound,
  serverError,
  parseBody,  // Add this
} from '@/lib/api-response'
import { updateBOMVersionSchema } from '@/types/bom'  // Add this
import { getComponentQuantities } from '@/services/inventory'
import { calculateBOMUnitCost, updateBOMVersion } from '@/services/bom'  // Add updateBOMVersion
```

**Validation commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] PATCH endpoint responds to requests
- [ ] Authentication enforced
- [ ] Company scoping validated
- [ ] Component validation works

---

## Phase 4: Frontend Components

### Subtask 4.1: Create BOM Version Edit Form Component
**File**: `/home/pbrown/SkuInventory/src/components/features/BOMVersionEditForm.tsx`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/components/features/BOMVersionForm.tsx`
**Instructions**:
1. Create new component that pre-populates form with existing BOM data
2. Modify to use PATCH instead of POST
3. Accept `bomVersionId` and `initialData` as props
4. Use same table structure for editing lines
5. Keep fraction input support from issue #176

**Key differences from create form**:
- Title: "Edit BOM Version" instead of "New BOM Version"
- Button: "Save Changes" instead of "Create BOM Version"
- Pre-populate form fields from initialData
- Use PATCH `/api/bom-versions/${bomVersionId}` instead of POST

```typescript
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import { Plus, Trash2 } from 'lucide-react'
import type { ComponentResponse } from '@/types/component'
import type { BOMVersionResponse } from '@/types/bom'
import { parseFractionOrNumber } from '@/lib/utils'

interface BOMLine {
  componentId: string
  componentName: string
  quantityPerUnit: string
  costPerUnit: string
  notes: string
}

interface BOMVersionEditFormProps {
  bomVersionId: string
  skuId: string
  skuName: string
  initialData: BOMVersionResponse
  onSuccess?: () => void
}

export function BOMVersionEditForm({
  bomVersionId,
  skuId,
  skuName,
  initialData,
  onSuccess
}: BOMVersionEditFormProps) {
  const router = useRouter()

  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [components, setComponents] = useState<ComponentResponse[]>([])
  const [loadingComponents, setLoadingComponents] = useState(true)

  const [formData, setFormData] = useState({
    versionName: initialData.versionName,
    effectiveStartDate: initialData.effectiveStartDate,
    notes: initialData.notes || '',
    defectNotes: initialData.defectNotes || '',
  })

  const [lines, setLines] = useState<BOMLine[]>(
    initialData.lines.map((line) => ({
      componentId: line.component.id,
      componentName: line.component.name,
      quantityPerUnit: line.quantityPerUnit,
      costPerUnit: line.component.costPerUnit,
      notes: line.notes || '',
    }))
  )

  useEffect(() => {
    async function fetchComponents() {
      try {
        const res = await fetch('/api/components?isActive=true&pageSize=100')
        if (res.ok) {
          const data = await res.json().catch(() => ({}))
          setComponents(data?.data || [])
        }
      } catch (err) {
        console.error('Failed to fetch components:', err)
      } finally {
        setLoadingComponents(false)
      }
    }
    fetchComponents()
  }, [])

  const addLine = () => {
    setLines((prev) => [
      ...prev,
      { componentId: '', componentName: '', quantityPerUnit: '1', costPerUnit: '0', notes: '' },
    ])
  }

  const removeLine = (index: number) => {
    setLines((prev) => prev.filter((_, i) => i !== index))
  }

  const updateLine = (index: number, field: keyof BOMLine, value: string) => {
    setLines((prev) =>
      prev.map((line, i) => {
        if (i !== index) return line
        if (field === 'componentId') {
          const component = components.find((c) => c.id === value)
          return {
            ...line,
            componentId: value,
            componentName: component?.name ?? '',
            costPerUnit: component?.costPerUnit ?? '0',
          }
        }
        return { ...line, [field]: value }
      })
    )
  }

  const calculateTotalCost = () => {
    return lines.reduce((total, line) => {
      const qty = parseFractionOrNumber(line.quantityPerUnit) ?? 0
      const cost = parseFloat(line.costPerUnit) || 0
      return total + qty * cost
    }, 0)
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError(null)

    if (lines.length === 0) {
      setError('At least one component is required')
      setIsLoading(false)
      return
    }

    if (lines.some((line) => !line.componentId)) {
      setError('All lines must have a component selected')
      setIsLoading(false)
      return
    }

    try {
      const res = await fetch(`/api/bom-versions/${bomVersionId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          versionName: formData.versionName,
          effectiveStartDate: formData.effectiveStartDate,
          notes: formData.notes || null,
          defectNotes: formData.defectNotes || null,
          lines: lines.map((line) => ({
            componentId: line.componentId,
            quantityPerUnit: line.quantityPerUnit,
            notes: line.notes || null,
          })),
        }),
      })

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.message || 'Failed to update BOM version')
      }

      if (onSuccess) {
        onSuccess()
      } else {
        router.push(`/skus/${skuId}`)
        router.refresh()
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  const availableComponents = components.filter(
    (c) => !lines.some((line) => line.componentId === c.id)
  )

  return (
    <form onSubmit={handleSubmit}>
      <Card>
        <CardHeader>
          <CardTitle>Edit BOM Version for {skuName}</CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          {error && (
            <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
              {error}
            </div>
          )}

          <div className="grid gap-4 sm:grid-cols-2">
            <div className="space-y-2">
              <Label htmlFor="versionName">Version Name *</Label>
              <Input
                id="versionName"
                value={formData.versionName}
                onChange={(e) => setFormData((prev) => ({ ...prev, versionName: e.target.value }))}
                placeholder="e.g., v1, v2-cheaper-mailer"
                required
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="effectiveStartDate">Effective Start Date *</Label>
              <Input
                id="effectiveStartDate"
                type="date"
                value={formData.effectiveStartDate}
                onChange={(e) =>
                  setFormData((prev) => ({ ...prev, effectiveStartDate: e.target.value }))
                }
                required
              />
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="notes">Notes</Label>
            <textarea
              id="notes"
              className="flex min-h-[60px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
              value={formData.notes}
              onChange={(e) => setFormData((prev) => ({ ...prev, notes: e.target.value }))}
              placeholder="Reason for this version..."
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="defectNotes">Defect Notes</Label>
            <textarea
              id="defectNotes"
              className="flex min-h-[60px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
              value={formData.defectNotes}
              onChange={(e) => setFormData((prev) => ({ ...prev, defectNotes: e.target.value }))}
              placeholder="Document any known defects or quality issues with this BOM version..."
            />
          </div>

          {/* BOM Lines */}
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <Label>Components *</Label>
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={addLine}
                disabled={loadingComponents || availableComponents.length === 0}
              >
                <Plus className="h-4 w-4 mr-1" />
                Add Component
              </Button>
            </div>

            {loadingComponents ? (
              <p className="text-sm text-muted-foreground">Loading components...</p>
            ) : lines.length === 0 ? (
              <p className="text-sm text-muted-foreground">
                No components added. Click "Add Component" to start building the BOM.
              </p>
            ) : (
              <div className="rounded-md border">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-[250px]">Component</TableHead>
                      <TableHead className="w-[100px]">Qty/Unit</TableHead>
                      <TableHead className="text-right w-[100px]">Cost/Unit</TableHead>
                      <TableHead className="text-right w-[100px]">Line Cost</TableHead>
                      <TableHead className="w-[50px]"></TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {lines.map((line, index) => {
                      const lineCost =
                        (parseFractionOrNumber(line.quantityPerUnit) ?? 0) *
                        (parseFloat(line.costPerUnit) || 0)
                      return (
                        <TableRow key={index}>
                          <TableCell>
                            <Select
                              value={line.componentId}
                              onValueChange={(value) => updateLine(index, 'componentId', value)}
                            >
                              <SelectTrigger>
                                <SelectValue placeholder="Select component" />
                              </SelectTrigger>
                              <SelectContent>
                                {line.componentId && (
                                  <SelectItem value={line.componentId}>
                                    {line.componentName}
                                  </SelectItem>
                                )}
                                {availableComponents.map((c) => (
                                  <SelectItem key={c.id} value={c.id}>
                                    {c.name} ({c.skuCode})
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                          </TableCell>
                          <TableCell>
                            <Input
                              type="text"
                              value={line.quantityPerUnit}
                              onChange={(e) =>
                                updateLine(index, 'quantityPerUnit', e.target.value)
                              }
                              placeholder="e.g., 1, 0.5, 1/45"
                              className="w-full"
                            />
                          </TableCell>
                          <TableCell className="text-right font-mono">
                            ${parseFloat(line.costPerUnit).toFixed(4)}
                          </TableCell>
                          <TableCell className="text-right font-mono">
                            ${lineCost.toFixed(4)}
                          </TableCell>
                          <TableCell>
                            <Button
                              type="button"
                              variant="ghost"
                              size="sm"
                              onClick={() => removeLine(index)}
                            >
                              <Trash2 className="h-4 w-4 text-destructive" />
                            </Button>
                          </TableCell>
                        </TableRow>
                      )
                    })}
                    {lines.length > 0 && (
                      <TableRow>
                        <TableCell colSpan={3} className="text-right font-medium">
                          Total Unit Cost:
                        </TableCell>
                        <TableCell className="text-right font-mono font-medium">
                          ${calculateTotalCost().toFixed(4)}
                        </TableCell>
                        <TableCell></TableCell>
                      </TableRow>
                    )}
                  </TableBody>
                </Table>
              </div>
            )}
          </div>
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button type="button" variant="outline" onClick={() => router.back()}>
            Cancel
          </Button>
          <Button type="submit" disabled={isLoading || lines.length === 0}>
            {isLoading ? 'Saving...' : 'Save Changes'}
          </Button>
        </CardFooter>
      </Card>
    </form>
  )
}
```

**Validation commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Component compiles
- [ ] Pre-populates data correctly
- [ ] Uses PATCH method

### Subtask 4.2: Create BOM Version Edit Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/skus/[id]/bom/[bomId]/edit/page.tsx`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/(dashboard)/skus/[id]/bom/new/page.tsx`
**Instructions**:
1. Create new page component
2. Fetch both SKU and BOM version data
3. Pass data to BOMVersionEditForm

```typescript
'use client'

import { useState, useEffect } from 'react'
import { useRouter, useParams } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { ArrowLeft } from 'lucide-react'
import { BOMVersionEditForm } from '@/components/features/BOMVersionEditForm'
import type { BOMVersionResponse } from '@/types/bom'

export default function EditBOMPage() {
  const router = useRouter()
  const params = useParams()
  const skuId = params.id as string
  const bomId = params.bomId as string
  const [skuName, setSkuName] = useState<string>('')
  const [bomVersion, setBomVersion] = useState<BOMVersionResponse | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    async function fetchData() {
      try {
        const [skuRes, bomRes] = await Promise.all([
          fetch(`/api/skus/${skuId}`),
          fetch(`/api/bom-versions/${bomId}`),
        ])

        if (!skuRes.ok) {
          throw new Error('SKU not found')
        }
        if (!bomRes.ok) {
          throw new Error('BOM version not found')
        }

        const skuData = await skuRes.json().catch(() => ({}))
        const bomData = await bomRes.json().catch(() => ({}))

        setSkuName(skuData?.data?.name || '')
        setBomVersion(bomData?.data || null)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load data')
      } finally {
        setIsLoading(false)
      }
    }

    fetchData()
  }, [skuId, bomId])

  if (isLoading) {
    return (
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="sm" onClick={() => router.back()}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Button>
        </div>
        <p>Loading...</p>
      </div>
    )
  }

  if (error || !bomVersion) {
    return (
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="sm" onClick={() => router.back()}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Button>
        </div>
        <p className="text-red-500">{error || 'BOM version not found'}</p>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="sm" onClick={() => router.back()}>
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back
        </Button>
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Edit BOM Version</h1>
          <p className="text-muted-foreground">
            Editing {bomVersion.versionName} for {skuName}
          </p>
        </div>
      </div>

      <div className="max-w-4xl">
        <BOMVersionEditForm
          bomVersionId={bomId}
          skuId={skuId}
          skuName={skuName}
          initialData={bomVersion}
        />
      </div>
    </div>
  )
}
```

**Validation commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Page loads at `/skus/[id]/bom/[bomId]/edit`
- [ ] Fetches SKU and BOM data
- [ ] Renders edit form

### Subtask 4.3: Add Edit Button to BOMVersionList Component
**File**: `/home/pbrown/SkuInventory/src/components/features/BOMVersionList.tsx`
**Pattern**: Follow existing Clone button pattern in same file (line 159-165)
**Instructions**:
1. Import `Edit` icon from lucide-react (add to existing import)
2. Add Edit button next to Clone button in the version row actions
3. Edit button should navigate to `/skus/${skuId}/bom/${version.id}/edit`
4. Use `router.push()` for navigation

**Changes to make**:

1. Add `Edit` to imports (line 26):
```typescript
import { Copy, CheckCircle, ChevronDown, ChevronRight, Edit } from 'lucide-react'
```

2. Add Edit button after Clone button (around line 159-165), inside the `<div className="flex gap-2">`:
```typescript
<Button
  variant="outline"
  size="sm"
  onClick={() => router.push(`/skus/${skuId}/bom/${version.id}/edit`)}
>
  <Edit className="h-4 w-4" />
</Button>
```

**Full updated actions section (lines 158-177)**:
```typescript
<div className="flex gap-2" onClick={(e) => e.stopPropagation()}>
  <Button
    variant="outline"
    size="sm"
    onClick={() => router.push(`/skus/${skuId}/bom/${version.id}/edit`)}
  >
    <Edit className="h-4 w-4" />
  </Button>
  <Button
    variant="outline"
    size="sm"
    onClick={() => openCloneDialog(version.id, version.versionName)}
  >
    <Copy className="h-4 w-4" />
  </Button>
  {!version.isActive && (
    <Button
      variant="outline"
      size="sm"
      onClick={() => handleActivate(version.id)}
      disabled={isActivating === version.id}
    >
      <CheckCircle className="h-4 w-4 mr-1" />
      {isActivating === version.id ? 'Activating...' : 'Activate'}
    </Button>
  )}
</div>
```

**Validation commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Edit button visible on each BOM version row
- [ ] Clicking Edit navigates to edit page
- [ ] Button icon displays correctly

---

## Phase 5: Verification

### Subtask 5.1: End-to-End Verification
**Instructions**:
1. Run full build to verify no TypeScript errors
2. Start dev server and manually test:
   - Navigate to SKU detail page
   - Click Edit button on a BOM version
   - Modify version name, notes, or component quantities
   - Save changes
   - Verify changes persisted

**Validation commands**:
```bash
npx tsc --noEmit
npm run build
npm run lint
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build completes successfully
- [ ] Lint passes
- [ ] Manual testing passes

---

## Summary of Deliverables

**Files Created**: 2
- `src/components/features/BOMVersionEditForm.tsx`
- `src/app/(dashboard)/skus/[id]/bom/[bomId]/edit/page.tsx`

**Files Modified**: 4
- `src/types/bom.ts` - Add update schema
- `src/services/bom.ts` - Add updateBOMVersion function
- `src/app/api/bom-versions/[id]/route.ts` - Add PATCH handler
- `src/components/features/BOMVersionList.tsx` - Add Edit button

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> 2 -> 3 -> 4 -> 5)
2. Test completion criteria before moving to next subtask
3. Follow reference patterns exactly
4. Run validation commands after each phase

## Test Strategy Note
- Use Vitest for unit tests if adding tests
- Manual testing required for UI verification

## Design Decisions

1. **Lines Update Strategy**: When lines are provided in the update, we delete all existing lines and recreate them. This is simpler than diffing and handles all edge cases (add, remove, modify).

2. **No updatedById Field**: Unlike Components/SKUs, BOMVersion doesn't have an updatedById field. Adding this would require a migration. For now, we skip this to minimize scope. Can be added as enhancement.

3. **Edit vs Clone**: The Edit button modifies the existing version in-place. Users who want to preserve history should use Clone first, then edit the clone.

4. **Fraction Support**: Retained from issue #176 - users can enter quantities as fractions (e.g., "1/45").

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 20m |
| **Total** | **40m** |
