# Implementation Plan
**Generated**: 2025-12-03T15:30:00Z
**Task ID**: Issue #21 - Build transactions should apply BOM by effective date (backdated builds)
**Estimated Build Time**: 2-3 hours
**Complexity**: Medium

## Executive Summary

Build transactions currently select the "active" BOM (`isActive: true`) regardless of the build date. This issue requires modifying the build API route to select the BOM version whose effective date range covers the build transaction date. When backdating a build, the system should apply the BOM that was effective on that historical date, ensuring accurate cost calculations and component consumption records.

## Acceptance Criteria Mapping

| Acceptance Criteria | Implementation | Validation |
|---------------------|----------------|------------|
| Backdated builds pick BOM version by effective date range | Date-based query in build route (lines 36-39) | Integration test with historical date |
| Costs and consumption reflect date-appropriate BOM | Service layer already calculates costs from provided bomVersionId | Integration test verifying correct BOM costs used |
| Clear error if no BOM covers the date | Error handling after BOM query | Integration test for missing BOM scenario |
| Tests cover current and backdated builds | New tests in transactions.test.ts | Tests pass with `npm test` |

## Schema Verification

**Verified via grep** (confirmed in `prisma/schema.prisma` lines 204-205):
- `effectiveStartDate` - DateTime @db.Date (Required)
- `effectiveEndDate` - DateTime? @db.Date (Optional, null = open-ended)
- `isActive` - Boolean (will no longer be used for build BOM selection)

**No schema changes required** - all date fields already exist.

---

## Phase 1: Update Build Route with Date-Based BOM Selection

### Subtask 1.1: Replace isActive Query with Date-Based Query

**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
**Lines to Modify**: 36-39
**Pattern Reference**: `/home/pbrown/SkuInventory/src/services/bom.ts` lines 319-328 (effectiveEndDate handling)

**Current Implementation** (lines 36-39):
```typescript
bomVersions: {
  where: { isActive: true },
  take: 1,
}
```

**New Implementation**:
```typescript
bomVersions: {
  where: {
    effectiveStartDate: { lte: data.date },
    OR: [
      { effectiveEndDate: null },
      { effectiveEndDate: { gte: data.date } }
    ]
  },
  orderBy: { effectiveStartDate: 'desc' },
  take: 1,
}
```

**Instructions**:
1. Open file at `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
2. Locate the `bomVersions` query within the `prisma.sKU.findFirst` call (lines 36-39)
3. Replace the `where: { isActive: true }` clause with the date-based query
4. Add `orderBy: { effectiveStartDate: 'desc' }` to select the most recent applicable BOM
5. Keep `take: 1` to retrieve only one BOM version

**Logic Explanation**:
- `effectiveStartDate: { lte: data.date }` - BOM must have started on or before the build date
- `effectiveEndDate: null` - BOM is still current (no end date)
- `effectiveEndDate: { gte: data.date }` - BOM end date is on or after the build date
- `orderBy: effectiveStartDate desc` - If multiple BOMs match, use the most recently started one

**Completion Criteria**:
- [ ] Query changed from `isActive: true` to date-based filter
- [ ] `orderBy: { effectiveStartDate: 'desc' }` added
- [ ] `take: 1` preserved

---

### Subtask 1.2: Update Error Message for Missing BOM

**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
**Lines to Modify**: 47-49
**Pattern Reference**: Same file, existing error handling patterns

**Current Implementation** (lines 47-49):
```typescript
if (!sku.bomVersions[0]) {
  return error('SKU has no active BOM', 400)
}
```

**New Implementation**:
```typescript
if (!sku.bomVersions[0]) {
  const buildDateStr = data.date.toISOString().split('T')[0]
  return error(`No BOM version effective on ${buildDateStr} for this SKU`, 400)
}
```

**Instructions**:
1. Locate the BOM existence check at lines 47-49
2. Add date formatting to include the build date in the error message
3. Update error message to clarify the date-specific nature of the error

**Logic Explanation**:
- The error now clearly indicates that the issue is date-related, not that no BOM exists at all
- Users can see exactly which date failed so they can create/modify BOMs accordingly

**Completion Criteria**:
- [ ] Error message includes the build date
- [ ] Error message distinguishes "no BOM effective on date" from "no BOM exists"

---

### Subtask 1.3: Update Error Handler BOM Reference

**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
**Lines to Review**: 104-120
**Pattern Reference**: Same file, error handling block

**Current Context** (lines 108-111):
```typescript
const insufficientItems = await checkInsufficientInventory({
  bomVersionId: activeBomVersionId,
  unitsToBuild: data.unitsToBuild,
})
```

**Instructions**:
1. Verify the variable name `activeBomVersionId` at line 51 is still appropriate (it references the date-selected BOM, not the "active" one)
2. **Optional**: Rename variable from `activeBomVersionId` to `selectedBomVersionId` for clarity
3. Ensure all references to this variable are updated if renamed

**Decision Point**:
- If renaming, update lines 51, 65, and 109
- If not renaming, document that "active" now means "date-effective"

**Completion Criteria**:
- [ ] Variable naming is consistent
- [ ] No broken references

---

## Phase 2: Validation and Testing

### Subtask 2.1: Verify TypeScript Compilation

**Command**:
```bash
npx tsc --noEmit
```

**Instructions**:
1. Run TypeScript compiler in check mode
2. Verify no type errors in modified files
3. Fix any issues before proceeding

**Completion Criteria**:
- [ ] `npx tsc --noEmit` completes without errors

---

### Subtask 2.2: Verify Build Process

**Command**:
```bash
npm run build
```

**Instructions**:
1. Run full Next.js build
2. Verify no build errors
3. Fix any issues before proceeding

**Completion Criteria**:
- [ ] `npm run build` completes without errors

---

### Subtask 2.3: Verify Lint Passes

**Command**:
```bash
npm run lint
```

**Instructions**:
1. Run ESLint on codebase
2. Fix any lint errors or warnings
3. Ensure no new warnings introduced

**Completion Criteria**:
- [ ] `npm run lint` completes without errors or warnings

---

## Phase 3: Add Integration Tests

### Subtask 3.1: Add Test - Current Date Build Uses Effective BOM

**File**: `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`
**Location**: After line 509 (end of existing build tests, before `describe('Transaction List')`)
**Pattern Reference**: Existing build tests (lines 286-509)

**New Test**:
```typescript
it('build with current date uses date-effective BOM', async () => {
  setTestSession(TEST_SESSIONS.admin!)
  const prisma = getIntegrationPrisma()
  const companyId = TEST_SESSIONS.admin!.user.companyId

  // Create component with inventory
  const component = await createTestComponentInDb(companyId)

  const receiptRequest = createTestRequest('/api/transactions/receipt', {
    method: 'POST',
    body: {
      componentId: component.id,
      quantity: 100,
      supplier: 'Test Supplier',
      date: new Date().toISOString().split('T')[0],
    },
  })
  await createReceipt(receiptRequest)

  // Create SKU
  const sku = await createTestSKUInDb(companyId)

  const admin = await prisma.user.findFirst({
    where: { companyId, role: 'admin' },
  })

  // Create BOM version effective from today (no end date = current)
  const today = new Date()
  const bomVersion = await prisma.bOMVersion.create({
    data: {
      skuId: sku.id,
      versionName: 'v1.0-current',
      effectiveStartDate: today,
      effectiveEndDate: null,
      isActive: true,
      createdById: admin!.id,
      lines: {
        create: {
          componentId: component.id,
          quantityPerUnit: 2,
        },
      },
    },
  })

  // Build with today's date
  const buildRequest = createTestRequest('/api/transactions/build', {
    method: 'POST',
    body: {
      skuId: sku.id,
      unitsToBuild: 5,
      date: today.toISOString().split('T')[0],
    },
  })

  const response = await createBuild(buildRequest)
  const result = await parseRouteResponse(response)

  expect(result.status).toBe(201)
  expect(result.data?.bomVersion?.id).toBe(bomVersion.id)
})
```

**Completion Criteria**:
- [ ] Test creates BOM with current effective date
- [ ] Test builds with current date
- [ ] Test verifies correct BOM was used

---

### Subtask 3.2: Add Test - Backdated Build Uses Historical BOM

**File**: `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`
**Location**: After subtask 3.1 test
**Pattern Reference**: Existing build tests (lines 286-509)

**New Test**:
```typescript
it('backdated build uses BOM effective on that date', async () => {
  setTestSession(TEST_SESSIONS.admin!)
  const prisma = getIntegrationPrisma()
  const companyId = TEST_SESSIONS.admin!.user.companyId

  // Create component with inventory
  const component = await createTestComponentInDb(companyId)

  const receiptRequest = createTestRequest('/api/transactions/receipt', {
    method: 'POST',
    body: {
      componentId: component.id,
      quantity: 100,
      supplier: 'Test Supplier',
      date: new Date().toISOString().split('T')[0],
    },
  })
  await createReceipt(receiptRequest)

  // Create SKU
  const sku = await createTestSKUInDb(companyId)

  const admin = await prisma.user.findFirst({
    where: { companyId, role: 'admin' },
  })

  // Create OLD BOM version (effective 30 days ago, ended 10 days ago)
  const thirtyDaysAgo = new Date()
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
  const tenDaysAgo = new Date()
  tenDaysAgo.setDate(tenDaysAgo.getDate() - 10)

  const oldBomVersion = await prisma.bOMVersion.create({
    data: {
      skuId: sku.id,
      versionName: 'v1.0-old',
      effectiveStartDate: thirtyDaysAgo,
      effectiveEndDate: tenDaysAgo,
      isActive: false,
      createdById: admin!.id,
      lines: {
        create: {
          componentId: component.id,
          quantityPerUnit: 3, // Different quantity from current
        },
      },
    },
  })

  // Create CURRENT BOM version (effective from 10 days ago, no end date)
  const currentBomVersion = await prisma.bOMVersion.create({
    data: {
      skuId: sku.id,
      versionName: 'v2.0-current',
      effectiveStartDate: tenDaysAgo,
      effectiveEndDate: null,
      isActive: true,
      createdById: admin!.id,
      lines: {
        create: {
          componentId: component.id,
          quantityPerUnit: 2, // Different quantity from old
        },
      },
    },
  })

  // Build backdated to 20 days ago (should use old BOM)
  const twentyDaysAgo = new Date()
  twentyDaysAgo.setDate(twentyDaysAgo.getDate() - 20)

  const buildRequest = createTestRequest('/api/transactions/build', {
    method: 'POST',
    body: {
      skuId: sku.id,
      unitsToBuild: 5,
      date: twentyDaysAgo.toISOString().split('T')[0],
    },
  })

  const response = await createBuild(buildRequest)
  const result = await parseRouteResponse(response)

  expect(result.status).toBe(201)
  expect(result.data?.bomVersion?.id).toBe(oldBomVersion.id)

  // Verify component consumption matches OLD BOM (3 per unit * 5 units = 15)
  const componentTx = result.data?.lines?.find((l: { component: { id: string } }) => l.component.id === component.id)
  expect(Number(componentTx?.quantityChange)).toBe(-15) // Negative = consumed
})
```

**Completion Criteria**:
- [ ] Test creates two BOMs with different effective date ranges
- [ ] Test creates build with a historical date
- [ ] Test verifies the OLD BOM (not current) was used
- [ ] Test verifies component consumption matches old BOM quantities

---

### Subtask 3.3: Add Test - Build Fails When No BOM Covers Date

**File**: `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`
**Location**: After subtask 3.2 test
**Pattern Reference**: Existing build failure tests (lines 356-404)

**New Test**:
```typescript
it('build fails when no BOM covers the date', async () => {
  setTestSession(TEST_SESSIONS.admin!)
  const prisma = getIntegrationPrisma()
  const companyId = TEST_SESSIONS.admin!.user.companyId

  // Create component
  const component = await createTestComponentInDb(companyId)

  // Create SKU
  const sku = await createTestSKUInDb(companyId)

  const admin = await prisma.user.findFirst({
    where: { companyId, role: 'admin' },
  })

  // Create BOM version that starts tomorrow (not effective yet)
  const tomorrow = new Date()
  tomorrow.setDate(tomorrow.getDate() + 1)

  await prisma.bOMVersion.create({
    data: {
      skuId: sku.id,
      versionName: 'v1.0-future',
      effectiveStartDate: tomorrow,
      effectiveEndDate: null,
      isActive: true,
      createdById: admin!.id,
      lines: {
        create: {
          componentId: component.id,
          quantityPerUnit: 2,
        },
      },
    },
  })

  // Try to build with today's date (should fail - BOM not yet effective)
  const buildRequest = createTestRequest('/api/transactions/build', {
    method: 'POST',
    body: {
      skuId: sku.id,
      unitsToBuild: 5,
      date: new Date().toISOString().split('T')[0],
      allowInsufficientInventory: true, // Bypass inventory check
    },
  })

  const response = await createBuild(buildRequest)
  const result = await parseRouteResponse(response)

  expect(result.status).toBe(400)
  expect(result.error).toContain('No BOM version effective on')
})
```

**Completion Criteria**:
- [ ] Test creates BOM with future effective date
- [ ] Test attempts build with current date
- [ ] Test verifies 400 error response
- [ ] Test verifies error message mentions the date

---

### Subtask 3.4: Add Test - Build Selects Most Recent Applicable BOM

**File**: `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`
**Location**: After subtask 3.3 test
**Pattern Reference**: Existing build tests

**New Test**:
```typescript
it('build selects most recent applicable BOM when multiple match', async () => {
  setTestSession(TEST_SESSIONS.admin!)
  const prisma = getIntegrationPrisma()
  const companyId = TEST_SESSIONS.admin!.user.companyId

  // Create component with inventory
  const component = await createTestComponentInDb(companyId)

  const receiptRequest = createTestRequest('/api/transactions/receipt', {
    method: 'POST',
    body: {
      componentId: component.id,
      quantity: 100,
      supplier: 'Test Supplier',
      date: new Date().toISOString().split('T')[0],
    },
  })
  await createReceipt(receiptRequest)

  // Create SKU
  const sku = await createTestSKUInDb(companyId)

  const admin = await prisma.user.findFirst({
    where: { companyId, role: 'admin' },
  })

  // Create OLDER BOM (effective 30 days ago, no end date)
  const thirtyDaysAgo = new Date()
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

  const olderBom = await prisma.bOMVersion.create({
    data: {
      skuId: sku.id,
      versionName: 'v1.0-older',
      effectiveStartDate: thirtyDaysAgo,
      effectiveEndDate: null, // Still valid
      isActive: false,
      createdById: admin!.id,
      lines: {
        create: {
          componentId: component.id,
          quantityPerUnit: 5,
        },
      },
    },
  })

  // Create NEWER BOM (effective 10 days ago, no end date)
  const tenDaysAgo = new Date()
  tenDaysAgo.setDate(tenDaysAgo.getDate() - 10)

  const newerBom = await prisma.bOMVersion.create({
    data: {
      skuId: sku.id,
      versionName: 'v2.0-newer',
      effectiveStartDate: tenDaysAgo,
      effectiveEndDate: null, // Also still valid
      isActive: true,
      createdById: admin!.id,
      lines: {
        create: {
          componentId: component.id,
          quantityPerUnit: 2,
        },
      },
    },
  })

  // Build with today's date - both BOMs are technically valid
  // Should select the NEWER one (more recent effectiveStartDate)
  const buildRequest = createTestRequest('/api/transactions/build', {
    method: 'POST',
    body: {
      skuId: sku.id,
      unitsToBuild: 5,
      date: new Date().toISOString().split('T')[0],
    },
  })

  const response = await createBuild(buildRequest)
  const result = await parseRouteResponse(response)

  expect(result.status).toBe(201)
  expect(result.data?.bomVersion?.id).toBe(newerBom.id)

  // Verify consumption uses newer BOM (2 per unit, not 5)
  const componentTx = result.data?.lines?.find((l: { component: { id: string } }) => l.component.id === component.id)
  expect(Number(componentTx?.quantityChange)).toBe(-10) // 2 * 5 = 10 consumed
})
```

**Completion Criteria**:
- [ ] Test creates two BOMs with overlapping validity
- [ ] Test builds with current date
- [ ] Test verifies newer BOM was selected
- [ ] Test verifies consumption matches newer BOM quantities

---

### Subtask 3.5: Run All Tests

**Command**:
```bash
npm test
```

**Instructions**:
1. Run the complete test suite
2. Verify all existing tests still pass (backward compatibility)
3. Verify all new tests pass
4. Fix any failing tests

**Completion Criteria**:
- [ ] All existing build tests pass
- [ ] All new date-based BOM tests pass
- [ ] No regressions in other tests

---

## Summary of Deliverables

**Files Modified**: 2
1. `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts` - PRIMARY CHANGE
   - Lines 36-39: Date-based BOM query
   - Lines 47-49: Updated error message

2. `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts` - ADD NEW TESTS
   - 4 new test cases for date-based BOM selection

**Files Created**: 0

**Files Unchanged** (verified no changes needed):
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Service layer correctly decoupled (receives bomVersionId)
- `/home/pbrown/SkuInventory/src/services/bom.ts` - BOM utilities use isActive correctly for their purposes
- `/home/pbrown/SkuInventory/src/types/transaction.ts` - Schema already supports date field
- `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx` - Frontend unchanged
- `/home/pbrown/SkuInventory/prisma/schema.prisma` - Already has effectiveStartDate/effectiveEndDate

---

## Handoff to Build Agent

### Execution Order
1. **Phase 1**: Update build route (Subtasks 1.1, 1.2, 1.3)
   - Modify the query logic
   - Update error message
   - Review variable naming
2. **Phase 2**: Validation (Subtasks 2.1, 2.2, 2.3)
   - TypeScript compilation check
   - Build verification
   - Lint verification
3. **Phase 3**: Testing (Subtasks 3.1-3.5)
   - Add all four new test cases
   - Run complete test suite

### Key Implementation Notes

1. **Date Handling**: The `data.date` from the request body is already a `Date` object (parsed by zod's `z.coerce.date()`)

2. **Prisma Query Syntax**: Use `lte` (less than or equal) and `gte` (greater than or equal) operators:
   ```typescript
   effectiveStartDate: { lte: data.date },
   effectiveEndDate: { gte: data.date }
   ```

3. **OR Clause**: For nullable effectiveEndDate, use the `OR` array pattern:
   ```typescript
   OR: [
     { effectiveEndDate: null },
     { effectiveEndDate: { gte: data.date } }
   ]
   ```

4. **Order By**: To get the most recent applicable BOM, order by `effectiveStartDate` descending:
   ```typescript
   orderBy: { effectiveStartDate: 'desc' }
   ```

5. **Test Date Arithmetic**: When creating test dates, use:
   ```typescript
   const thirtyDaysAgo = new Date()
   thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)
   ```

6. **Backward Compatibility**: Current behavior where builds use the "active" BOM will still work because:
   - The active BOM typically has `effectiveStartDate <= today` and `effectiveEndDate = null`
   - The new query will still select it for current-date builds

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Scout Review | 5m |
| Pattern Research | 8m |
| Ripple Effect Verification | 5m |
| Plan Writing | 15m |
| **Total** | **33m** |

---

AGENT_RETURN: plan-21-120325
