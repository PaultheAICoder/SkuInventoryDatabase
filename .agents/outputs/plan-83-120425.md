# Implementation Plan
**Generated**: 2025-12-04T06:25:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #83
**Estimated Build Time**: 3-4 hours
**Complexity**: Low

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #83 - [Parent #14] Add finished goods adjustment and receipt API endpoints
**Priority**: Medium
**Parent Issue**: #14 (CLOSED) - Finished goods/WIP inventory tracking (separate from components)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="finished-goods"` or `--testPathPattern="finished-goods"`

### Issue Validation
**Status**: Partially Implemented / Needs Refinement
**Recent Changes**:
- `1bc6c25` feat(issue #72): add finished goods inventory tracking from builds
- Existing adjustment endpoint at `/api/skus/[id]/inventory` (POST)
- Existing `adjustFinishedGoods()` service function in `/src/services/finished-goods.ts`

### Critical Finding - Existing Implementation

**IMPORTANT**: During investigation, I discovered that MOST of this issue's functionality already exists:

| Requested | Current State |
|-----------|--------------|
| `POST /api/skus/[id]/inventory/adjustment` | **EXISTS** at `POST /api/skus/[id]/inventory` |
| `adjustFinishedGoods()` service function | **EXISTS** in `src/services/finished-goods.ts` |
| `adjustFinishedGoodsSchema` validation | **EXISTS** in `src/types/finished-goods.ts` |
| `POST /api/skus/[id]/inventory/receipt` | **NOT YET IMPLEMENTED** |
| `receiveFinishedGoods()` service function | **NOT YET IMPLEMENTED** |

**The issue asks for SEPARATE endpoints at:**
- `/api/skus/[id]/inventory/adjustment/route.ts` (new location)
- `/api/skus/[id]/inventory/receipt/route.ts` (new endpoint)

**Decision needed**: Should we:
1. Create new endpoints at the requested paths AND keep the existing `/api/skus/[id]/inventory` POST handler?
2. Move the adjustment logic to the new path and update `/api/skus/[id]/inventory` to only do GET?
3. Just add the receipt endpoint and document that adjustment already exists?

**Recommendation**: Option 3 - Add receipt endpoint only, as the adjustment functionality is complete. The existing endpoint follows REST conventions (POST to collection = create). Document this in the issue completion notes.

### Current State Assessment
- **Database**: `FinishedGoodsLine` model exists with `skuId`, `locationId`, `quantityChange` fields
- **TransactionType enum**: `receipt`, `build`, `adjustment`, `initial`, `transfer` - reuse `receipt` for FG receipt
- **Services**: `src/services/finished-goods.ts` has `adjustFinishedGoods()`, `transferFinishedGoods()`, `getSkuQuantity()`, `getSkuQuantities()`, `getSkuInventorySummary()`
- **API Routes**: `/api/skus/[id]/inventory/route.ts` handles GET (summary) and POST (adjustment)
- **Types**: `src/types/finished-goods.ts` has `adjustFinishedGoodsSchema`, `transferFinishedGoodsSchema`

### Dependencies & Blockers
1. **Dependency #75** (SkuInventoryBalance schema) - CLOSED, schema uses `FinishedGoodsLine` aggregation instead
2. **No blockers identified** - all prerequisites are in place

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Simple
**Effort**: 3-4 hours
**Risk**: Low - follows established patterns, service layer already exists

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/inventory/route.ts` - existing FG adjustment endpoint
**Secondary**: `/home/pbrown/SkuInventory/src/app/api/transactions/receipt/route.ts` - component receipt pattern

### Ripple Effect Analysis
**Files Identified**: 5 files
- `/src/services/finished-goods.ts` - add `receiveFinishedGoods()` function
- `/src/types/finished-goods.ts` - add `receiveFinishedGoodsSchema`
- `/src/app/api/skus/[id]/inventory/receipt/route.ts` - NEW FILE
- `/tests/unit/finished-goods-service.test.ts` - add tests for receipt
- No UI changes required (per issue scope)

---

## Executive Summary
Create a finished goods receipt endpoint and service function that allows receiving finished goods inventory (e.g., customer returns, corrections). This complements the existing adjustment functionality by providing a dedicated semantic endpoint for stock additions. The receipt endpoint will use a positive-only quantity (unlike adjustments which can be +/-) and will track supplier/source information.

## Phase 1: Types Layer

### Subtask 1.1: Add Finished Goods Receipt Validation Schema
**File**: `/home/pbrown/SkuInventory/src/types/finished-goods.ts`
**Pattern**: Follow existing `adjustFinishedGoodsSchema` in same file
**Instructions**:
1. Add new Zod schema `receiveFinishedGoodsSchema` after the existing `adjustFinishedGoodsSchema`:
```typescript
// Finished goods receipt schema (for returns, corrections - always positive)
export const receiveFinishedGoodsSchema = z.object({
  locationId: z.string().uuid('Invalid location ID'),
  quantity: z.coerce.number().positive('Quantity must be positive'),
  source: z.string().min(1, 'Source is required').max(100), // e.g., "Customer Return", "Correction"
  costPerUnit: z.coerce.number().nonnegative().optional(),
  notes: z.string().optional().nullable(),
  date: z.coerce.date(),
})

export type ReceiveFinishedGoodsInput = z.infer<typeof receiveFinishedGoodsSchema>
```

**Note**: The schema intentionally does NOT include `skuId` because it will come from the URL parameter.

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Schema added with positive quantity constraint
- [ ] Type exported
- [ ] No TypeScript errors

---

## Phase 2: Service Layer

### Subtask 2.1: Add Finished Goods Receipt Service Function
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Pattern**: Follow existing `adjustFinishedGoods()` function in same file
**Instructions**:
1. Add new function `receiveFinishedGoods` after `adjustFinishedGoods`:

```typescript
/**
 * Create a finished goods receipt transaction (for returns, corrections)
 * Always adds to inventory (positive quantity only)
 */
export async function receiveFinishedGoods(params: {
  companyId: string
  skuId: string
  locationId: string
  quantity: number
  source: string
  costPerUnit?: number
  notes?: string | null
  date: Date
  createdById: string
}): Promise<{ id: string; newBalance: number }> {
  const { companyId, skuId, locationId, quantity, source, costPerUnit, notes, date, createdById } = params

  // Create receipt transaction with finished goods line
  const transaction = await prisma.transaction.create({
    data: {
      companyId,
      type: 'receipt',
      date,
      skuId,
      supplier: source, // Reuse supplier field for source
      notes,
      createdById,
      locationId, // For FG receipt, location goes on transaction for reference
      finishedGoodsLines: {
        create: {
          skuId,
          locationId,
          quantityChange: new Prisma.Decimal(quantity),
          costPerUnit: costPerUnit ? new Prisma.Decimal(costPerUnit) : null,
        },
      },
    },
    select: { id: true },
  })

  // Get new balance at this location
  const newBalance = await getSkuQuantity(skuId, locationId)

  return { id: transaction.id, newBalance }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Function added with proper types
- [ ] Uses `receipt` transaction type
- [ ] Returns transaction ID and new balance
- [ ] No TypeScript errors

---

## Phase 3: API Route Layer

### Subtask 3.1: Create Receipt Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/inventory/receipt/route.ts` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/skus/[id]/inventory/route.ts` (POST handler)
**Instructions**:
1. Create new directory if needed: `src/app/api/skus/[id]/inventory/receipt/`
2. Create `route.ts` with POST handler:

```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { created, unauthorized, notFound, serverError, parseBody } from '@/lib/api-response'
import { receiveFinishedGoods } from '@/services/finished-goods'
import { receiveFinishedGoodsSchema } from '@/types/finished-goods'

type RouteParams = { params: Promise<{ id: string }> }

// POST /api/skus/:id/inventory/receipt - Receive finished goods (returns, corrections)
export async function POST(request: NextRequest, { params }: RouteParams) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    // Check role - Viewer cannot create transactions
    if (session.user.role === 'viewer') {
      return unauthorized('You do not have permission to receive inventory')
    }

    const { id } = await params
    const selectedCompanyId = session.user.selectedCompanyId

    const bodyResult = await parseBody(request, receiveFinishedGoodsSchema)
    if (bodyResult.error) return bodyResult.error

    const data = bodyResult.data

    // Verify SKU exists and belongs to company
    const sku = await prisma.sKU.findFirst({
      where: {
        id,
        companyId: selectedCompanyId,
      },
    })

    if (!sku) {
      return notFound('SKU')
    }

    // Validate location
    const location = await prisma.location.findFirst({
      where: {
        id: data.locationId,
        companyId: selectedCompanyId,
        isActive: true,
      },
    })

    if (!location) {
      return notFound('Location')
    }

    const result = await receiveFinishedGoods({
      companyId: selectedCompanyId,
      skuId: id,
      locationId: data.locationId,
      quantity: data.quantity,
      source: data.source,
      costPerUnit: data.costPerUnit,
      notes: data.notes,
      date: data.date,
      createdById: session.user.id,
    })

    return created({
      transactionId: result.id,
      newBalance: result.newBalance,
    })
  } catch (err) {
    console.error('Error receiving finished goods:', err)
    return serverError()
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] File created at correct path
- [ ] Auth check present (rejects viewer role)
- [ ] SKU tenant scoping enforced
- [ ] Location validation enforced
- [ ] Returns 201 with transactionId and newBalance
- [ ] Build passes

---

## Phase 4: Unit Tests

### Subtask 4.1: Add Service Tests for Receipt Function
**File**: `/home/pbrown/SkuInventory/tests/unit/finished-goods-service.test.ts`
**Pattern**: Follow existing `adjustFinishedGoods` tests in same file
**Instructions**:
1. Add describe block for `receiveFinishedGoods`:

```typescript
describe('receiveFinishedGoods', () => {
  it('creates receipt transaction with finished goods line', async () => {
    vi.mocked(prisma.transaction.create).mockResolvedValue({
      id: 'trans-1',
    } as never)

    vi.mocked(prisma.finishedGoodsLine.aggregate).mockResolvedValue({
      _sum: { quantityChange: new Prisma.Decimal(125) },
    } as never)

    const result = await receiveFinishedGoods({
      companyId: 'company-1',
      skuId: 'sku-1',
      locationId: 'loc-1',
      quantity: 25,
      source: 'Customer Return',
      costPerUnit: 10.50,
      notes: 'Return from order #12345',
      date: new Date('2024-01-15'),
      createdById: 'user-1',
    })

    expect(result.id).toBe('trans-1')
    expect(result.newBalance).toBe(125)
    expect(prisma.transaction.create).toHaveBeenCalledWith({
      data: expect.objectContaining({
        companyId: 'company-1',
        type: 'receipt',
        skuId: 'sku-1',
        supplier: 'Customer Return',
        notes: 'Return from order #12345',
        createdById: 'user-1',
        finishedGoodsLines: {
          create: expect.objectContaining({
            skuId: 'sku-1',
            locationId: 'loc-1',
            quantityChange: new Prisma.Decimal(25),
            costPerUnit: new Prisma.Decimal(10.50),
          }),
        },
      }),
      select: { id: true },
    })
  })

  it('works without optional costPerUnit', async () => {
    vi.mocked(prisma.transaction.create).mockResolvedValue({
      id: 'trans-1',
    } as never)

    vi.mocked(prisma.finishedGoodsLine.aggregate).mockResolvedValue({
      _sum: { quantityChange: new Prisma.Decimal(50) },
    } as never)

    const result = await receiveFinishedGoods({
      companyId: 'company-1',
      skuId: 'sku-1',
      locationId: 'loc-1',
      quantity: 50,
      source: 'Production Correction',
      date: new Date(),
      createdById: 'user-1',
    })

    expect(result.id).toBe('trans-1')
    expect(prisma.transaction.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          finishedGoodsLines: {
            create: expect.objectContaining({
              costPerUnit: null,
            }),
          },
        }),
      })
    )
  })
})
```

2. Update the import at the top of the file to include `receiveFinishedGoods`:
```typescript
import {
  getSkuQuantity,
  getSkuQuantities,
  getSkuInventorySummary,
  adjustFinishedGoods,
  transferFinishedGoods,
  receiveFinishedGoods,
} from '@/services/finished-goods'
```

**Validation Commands**:
```bash
npm test -- --testPathPattern="finished-goods-service"
```
**Completion Criteria**:
- [ ] Tests added for receipt function
- [ ] Tests pass
- [ ] Import updated

---

## Phase 5: Final Validation

### Subtask 5.1: Full Build and Test Validation
**Instructions**:
1. Run full TypeScript check:
```bash
npx tsc --noEmit
```
2. Run full build:
```bash
npm run build
```
3. Run lint:
```bash
npm run lint
```
4. Run related tests:
```bash
npm test -- --testPathPattern="finished-goods"
```

**Completion Criteria**:
- [ ] TypeScript check passes
- [ ] Build passes
- [ ] Lint passes
- [ ] Tests pass

---

## Summary of Deliverables

**Files Created**: 1
- `/src/app/api/skus/[id]/inventory/receipt/route.ts`

**Files Modified**: 3
- `/src/types/finished-goods.ts` - add `receiveFinishedGoodsSchema`
- `/src/services/finished-goods.ts` - add `receiveFinishedGoods()`
- `/tests/unit/finished-goods-service.test.ts` - add receipt tests

## Handoff to Build Agent
1. Execute subtasks in exact order (1.1 -> 2.1 -> 3.1 -> 4.1 -> 5.1)
2. After Phase 1, verify types compile before moving to Phase 2
3. After Phase 2, verify service compiles before moving to Phase 3
4. After Phase 3, verify build passes before moving to Phase 4
5. Follow reference patterns exactly

## Important Notes for Issue Closure

When closing issue #83, note the following in the completion comment:

1. **Adjustment endpoint already existed** at `POST /api/skus/[id]/inventory` - this issue only added the receipt endpoint
2. **New endpoint created**: `POST /api/skus/[id]/inventory/receipt`
3. **Service function added**: `receiveFinishedGoods()` in `src/services/finished-goods.ts`
4. **The existing adjustment behavior** (POST to `/api/skus/[id]/inventory`) remains unchanged and continues to work for adjustments

The issue specified `/api/skus/[id]/inventory/adjustment` as a separate endpoint, but since `POST /api/skus/[id]/inventory` already handles adjustments following REST conventions, we did not duplicate this functionality. The receipt endpoint was the only new capability needed.

## Test Strategy Note
- Use Vitest for unit tests
- Targeted test run: `npm test -- --testPathPattern="finished-goods"`

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 10m |
| **Total** | **30m** |
