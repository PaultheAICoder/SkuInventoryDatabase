# Implementation Plan
**Generated**: 2025-12-17T20:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #309
**Estimated Build Time**: 8-10 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #309
**Priority**: High

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="sku|bom"`

### Issue Validation
**Status**: Valid
**Recent Changes**: No conflicting changes to SKU/BOM update logic in last 60 days

### Current State Assessment

#### Database Layer
- **SKU model** (lines 391-426): Has `updatedAt DateTime @updatedAt` but NO `version` field
- **BOMVersion model** (lines 443-463): Has `updatedAt DateTime @updatedAt` but NO `version` field
- Neither model has optimistic concurrency control

#### API Routes
- **SKU Update**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts` (PATCH handler, lines 139-240)
  - Currently performs update without version check
  - Uses `prisma.sKU.update()` directly (line 186)
- **BOMVersion Update**: `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/route.ts` (PATCH handler, lines 117-214)
  - Delegates to `updateBOMVersion()` service function
  - No version check in either route or service

#### Service Layer
- **SKU service**: `/home/pbrown/SkuInventory/src/services/sku.ts` - Has `createSku` but no update function
- **BOM service**: `/home/pbrown/SkuInventory/src/services/bom.ts` - Has `updateBOMVersion()` function (lines 471-550)
  - Uses transaction but no version check

#### Type Definitions
- **SKU types**: `/home/pbrown/SkuInventory/src/types/sku.ts`
  - `updateSKUSchema` (line 31): Does not include version
  - `SKUResponse` (line 65): Does not include version
- **BOM types**: `/home/pbrown/SkuInventory/src/types/bom.ts`
  - `updateBOMVersionSchema` (line 53): Does not include version
  - `BOMVersionResponse` (line 98): Does not include version

#### Frontend Components
- **SKUForm**: `/home/pbrown/SkuInventory/src/components/features/SKUForm.tsx`
  - Handles SKU creation and editing
  - PATCH request on line 131 - needs to include version
- **BOMVersionEditForm**: `/home/pbrown/SkuInventory/src/components/features/BOMVersionEditForm.tsx`
  - PATCH request on line 148 - needs to include version

### Dependencies & Blockers

1. **No blockers identified**
2. **Dependencies**:
   - Prisma migration system
   - Existing test infrastructure

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 8-10 hours
**Risk**: Low

### Patterns Identified

**Primary**: Existing `updatedAt` pattern for timestamp tracking
**Secondary**: Transaction-based updates in `updateBOMVersion()` service

### Ripple Effect Analysis

**Files Requiring Modification**: 14

| File | Why Affected |
|------|--------------|
| `prisma/schema.prisma` | Add `version` field to SKU and BOMVersion models |
| `src/types/sku.ts` | Add version to updateSKUSchema and SKUResponse |
| `src/types/bom.ts` | Add version to updateBOMVersionSchema and BOMVersionResponse |
| `src/app/api/skus/[id]/route.ts` | Add version check to PATCH handler |
| `src/app/api/bom-versions/[id]/route.ts` | Add version check to PATCH handler |
| `src/services/bom.ts` | Add version check to updateBOMVersion function |
| `src/services/sku.ts` | Add updateSku function with version check |
| `src/components/features/SKUForm.tsx` | Include version in PATCH payload |
| `src/components/features/BOMVersionEditForm.tsx` | Include version in PATCH payload |
| `src/lib/api-response.ts` | Add `versionConflict` error helper |
| `tests/integration/sku-api.test.ts` | Add version conflict test cases |
| `tests/unit/bom-calculations.test.ts` | Update mocks if needed |
| New: `src/lib/errors.ts` | Create VersionConflictError class |
| New: `tests/unit/optimistic-locking.test.ts` | Unit tests for version checking |

---

## Executive Summary

Implement optimistic concurrency control for SKU and BOMVersion entities using a `version` field that auto-increments on each update. When updating, the client sends the version they read; if the database version is higher, the update is rejected with a 409 Conflict status and a user-friendly error message.

---

## Phase 1: Database/Types Layer

### Subtask 1.1: Add version field to Prisma schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing field patterns (e.g., `updatedAt DateTime @updatedAt`)
**Instructions**:
1. Add `version Int @default(1)` field to SKU model after line 404:
```prisma
model SKU {
  // ... existing fields ...
  updatedAt    DateTime @updatedAt
  version      Int      @default(1)  // Optimistic locking version
  createdById  String
```

2. Add `version Int @default(1)` field to BOMVersion model after line 455:
```prisma
model BOMVersion {
  // ... existing fields ...
  updatedAt          DateTime  @updatedAt
  version            Int       @default(1)  // Optimistic locking version
  createdById        String
```

**Validation Commands**:
```bash
npx prisma validate
npx prisma format
```
**Completion Criteria**:
- [ ] Prisma schema validates without errors
- [ ] Both SKU and BOMVersion models have `version Int @default(1)` field

### Subtask 1.2: Create and apply database migration
**File**: New migration in `/home/pbrown/SkuInventory/prisma/migrations/`
**Instructions**:
1. Generate migration:
```bash
DATABASE_URL="postgresql://inventory_test:inventory_test_2025@localhost:2346/inventory_test" npx prisma migrate dev --name add_version_to_sku_bomversion
```
2. Verify migration SQL adds version columns with default value of 1
3. Run migration on test database

**Validation Commands**:
```bash
docker exec inventory-db-test psql -U inventory_test -d inventory_test -c "SELECT column_name, data_type, column_default FROM information_schema.columns WHERE table_name IN ('SKU', 'BOMVersion') AND column_name = 'version';"
```
**Completion Criteria**:
- [ ] Migration creates successfully
- [ ] Test database has version column on SKU table
- [ ] Test database has version column on BOMVersion table
- [ ] Existing records have version=1

### Subtask 1.3: Update SKU TypeScript types
**File**: `/home/pbrown/SkuInventory/src/types/sku.ts`
**Pattern**: Follow existing schema patterns
**Instructions**:
1. Add version to `updateSKUSchema` (around line 31):
```typescript
// SKU update schema (all fields optional)
export const updateSKUSchema = createSKUSchema.partial().extend({
  isActive: z.boolean().optional(),
  version: z.number().int().positive().optional(), // Required for optimistic locking
})
```

2. Add version to `SKUResponse` interface (around line 65):
```typescript
export interface SKUResponse {
  id: string
  name: string
  internalCode: string
  salesChannel: string
  externalIds: Record<string, string>
  notes: string | null
  isActive: boolean
  version: number  // Optimistic locking version
  createdAt: string
  updatedAt: string
  // ... rest of fields
}
```

3. Add version to `SKUDetailResponse` if it inherits from `SKUResponse` (it does, so no change needed)

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] `updateSKUSchema` includes optional version field
- [ ] `SKUResponse` includes version field

### Subtask 1.4: Update BOM TypeScript types
**File**: `/home/pbrown/SkuInventory/src/types/bom.ts`
**Pattern**: Follow existing schema patterns
**Instructions**:
1. Add version to `updateBOMVersionSchema` (around line 53):
```typescript
export const updateBOMVersionSchema = z.object({
  versionName: z.string().min(1).max(50).optional(),
  effectiveStartDate: dateSchema.optional(),
  notes: z.string().optional().nullable(),
  defectNotes: z.string().optional().nullable(),
  qualityMetadata: z.record(z.string(), z.unknown()).optional(),
  lines: z.array(bomLineSchema).optional(),
  version: z.number().int().positive().optional(), // Required for optimistic locking
})
```

2. Add version to `BOMVersionResponse` interface (around line 98):
```typescript
export interface BOMVersionResponse {
  id: string
  skuId: string
  versionName: string
  effectiveStartDate: string
  effectiveEndDate: string | null
  isActive: boolean
  notes: string | null
  defectNotes: string | null
  qualityMetadata: Record<string, unknown>
  unitCost: string
  version: number  // Optimistic locking version
  lines: BOMLineResponse[]
  createdAt: string
  createdBy?: { id: string; name: string }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] `updateBOMVersionSchema` includes optional version field
- [ ] `BOMVersionResponse` includes version field

---

## Phase 2: API Response Utilities

### Subtask 2.1: Add versionConflict error helper
**File**: `/home/pbrown/SkuInventory/src/lib/api-response.ts`
**Pattern**: Follow existing error helpers like `conflict()` (line 60)
**Instructions**:
Add new helper function after the `conflict` function (around line 62):
```typescript
export function versionConflict(resource = 'Record'): NextResponse<ApiError> {
  return error(
    `${resource} has been modified by another user. Please refresh and try again.`,
    409,
    'VersionConflict'
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] `versionConflict` function exported from api-response

---

## Phase 3: Service Layer

### Subtask 3.1: Add updateSku service function
**File**: `/home/pbrown/SkuInventory/src/services/sku.ts`
**Pattern**: Follow `createSku` function pattern (lines 188-326)
**Instructions**:
Add new service function with version check:

```typescript
/**
 * Parameters for updateSku service function
 */
export interface UpdateSkuParams {
  skuId: string
  companyId: string
  userId: string
  input: {
    name?: string
    internalCode?: string
    salesChannel?: string
    externalIds?: Record<string, string>
    notes?: string | null
    isActive?: boolean
    version?: number // Required for optimistic locking
  }
}

/**
 * Custom error for version conflicts
 */
export class VersionConflictError extends Error {
  constructor(resource: string = 'Record') {
    super('VERSION_CONFLICT')
    this.name = 'VersionConflictError'
  }
}

/**
 * Update an existing SKU with optimistic locking
 *
 * @throws VersionConflictError if version mismatch detected
 * @throws Error with 'SKU_NOT_FOUND' if SKU doesn't exist
 * @throws Error with 'DUPLICATE_INTERNAL_CODE' if code already exists
 */
export async function updateSku(params: UpdateSkuParams): Promise<{
  id: string
  name: string
  internalCode: string
  salesChannel: string
  externalIds: Record<string, string>
  notes: string | null
  isActive: boolean
  version: number
  createdAt: string
  updatedAt: string
  createdBy: { id: string; name: string }
}> {
  const { skuId, companyId, userId, input } = params

  // Verify SKU exists and get current version
  const existing = await prisma.sKU.findFirst({
    where: { id: skuId, companyId },
    select: { id: true, version: true, brandId: true, internalCode: true },
  })

  if (!existing) {
    throw new Error('SKU_NOT_FOUND')
  }

  // Check version for optimistic locking
  if (input.version !== undefined && existing.version > input.version) {
    throw new VersionConflictError('SKU')
  }

  // Check for duplicate internalCode if changed
  if (input.internalCode && input.internalCode !== existing.internalCode) {
    const duplicate = await prisma.sKU.findFirst({
      where: {
        brandId: existing.brandId,
        internalCode: input.internalCode,
        id: { not: skuId },
      },
    })
    if (duplicate) {
      throw new Error('DUPLICATE_INTERNAL_CODE')
    }
  }

  // Update with version increment
  const sku = await prisma.sKU.update({
    where: { id: skuId },
    data: {
      ...(input.name !== undefined && { name: input.name }),
      ...(input.internalCode !== undefined && { internalCode: input.internalCode }),
      ...(input.salesChannel !== undefined && { salesChannel: input.salesChannel }),
      ...(input.externalIds !== undefined && { externalIds: input.externalIds as Prisma.InputJsonValue }),
      ...(input.notes !== undefined && { notes: input.notes }),
      ...(input.isActive !== undefined && { isActive: input.isActive }),
      updatedById: userId,
      version: { increment: 1 },
    },
    include: {
      createdBy: { select: { id: true, name: true } },
    },
  })

  return {
    id: sku.id,
    name: sku.name,
    internalCode: sku.internalCode,
    salesChannel: sku.salesChannel,
    externalIds: sku.externalIds as Record<string, string>,
    notes: sku.notes,
    isActive: sku.isActive,
    version: sku.version,
    createdAt: sku.createdAt.toISOString(),
    updatedAt: sku.updatedAt.toISOString(),
    createdBy: sku.createdBy,
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] `updateSku` function exported from service
- [ ] `VersionConflictError` class exported

### Subtask 3.2: Update updateBOMVersion service with version check
**File**: `/home/pbrown/SkuInventory/src/services/bom.ts`
**Pattern**: Existing `updateBOMVersion` function (lines 471-550)
**Instructions**:
1. Import VersionConflictError from sku service or create local class
2. Add version parameter to updateBOMVersion params
3. Add version check after existence check
4. Increment version on update

Update the function signature (around line 471):
```typescript
export async function updateBOMVersion(params: {
  bomVersionId: string
  companyId: string
  versionName?: string
  effectiveStartDate?: Date
  notes?: string | null
  defectNotes?: string | null
  qualityMetadata?: Record<string, unknown>
  lines?: Array<{
    componentId: string
    quantityPerUnit: number
    notes?: string | null
  }>
  version?: number  // Optimistic locking version
}) {
  const { bomVersionId, companyId, lines, version: expectedVersion, ...updateData } = params

  return prisma.$transaction(async (tx) => {
    // Check if BOM version exists and belongs to company
    const existing = await tx.bOMVersion.findFirst({
      where: {
        id: bomVersionId,
        sku: { companyId },
      },
      select: { id: true, version: true },
    })

    if (!existing) {
      throw new Error('BOM version not found')
    }

    // Check version for optimistic locking
    if (expectedVersion !== undefined && existing.version > expectedVersion) {
      throw new VersionConflictError('BOM version')
    }

    // If lines are provided, delete existing and recreate
    if (lines && lines.length > 0) {
      await tx.bOMLine.deleteMany({
        where: { bomVersionId },
      })

      await tx.bOMLine.createMany({
        data: lines.map((line) => ({
          bomVersionId,
          componentId: line.componentId,
          quantityPerUnit: new Prisma.Decimal(line.quantityPerUnit),
          notes: line.notes,
        })),
      })
    }

    // Update BOM version metadata with version increment
    const updated = await tx.bOMVersion.update({
      where: { id: bomVersionId },
      data: {
        ...(updateData.versionName !== undefined && { versionName: updateData.versionName }),
        ...(updateData.effectiveStartDate !== undefined && { effectiveStartDate: updateData.effectiveStartDate }),
        ...(updateData.notes !== undefined && { notes: updateData.notes }),
        ...(updateData.defectNotes !== undefined && { defectNotes: updateData.defectNotes }),
        ...(updateData.qualityMetadata !== undefined && {
          qualityMetadata: updateData.qualityMetadata as Prisma.InputJsonValue
        }),
        version: { increment: 1 },
      },
      include: {
        lines: {
          include: {
            component: {
              select: {
                id: true,
                name: true,
                skuCode: true,
                costPerUnit: true,
                unitOfMeasure: true,
              },
            },
          },
        },
        createdBy: {
          select: { id: true, name: true },
        },
      },
    })

    return updated
  })
}
```

Add VersionConflictError class at top of file (after imports):
```typescript
/**
 * Custom error for version conflicts in optimistic locking
 */
export class VersionConflictError extends Error {
  constructor(resource: string = 'Record') {
    super('VERSION_CONFLICT')
    this.name = 'VersionConflictError'
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] `updateBOMVersion` accepts version parameter
- [ ] Version check throws VersionConflictError on mismatch
- [ ] Version incremented on successful update

---

## Phase 4: API Routes

### Subtask 4.1: Update SKU PATCH route with version check
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
**Pattern**: Existing PATCH handler (lines 139-240)
**Instructions**:
1. Import updateSku and VersionConflictError from service
2. Import versionConflict from api-response
3. Replace inline Prisma calls with service function
4. Add version to response

Update imports at top of file:
```typescript
import { updateSku, VersionConflictError } from '@/services/sku'
import {
  success,
  unauthorized,
  notFound,
  conflict,
  versionConflict,
  serverError,
  parseBody,
  error,
} from '@/lib/api-response'
```

Replace PATCH handler (lines 139-240):
```typescript
// PATCH /api/skus/:id - Update SKU
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    const { id } = await params

    const bodyResult = await parseBody(request, updateSKUSchema)
    if (bodyResult.error) return bodyResult.error

    const data = bodyResult.data

    // Use selected company for scoping
    const selectedCompanyId = session.user.selectedCompanyId
    if (!selectedCompanyId) {
      return error('No company selected. Please select a company from the sidebar.', 400)
    }

    // Update via service (handles version check and duplicate code check)
    const result = await updateSku({
      skuId: id,
      companyId: selectedCompanyId,
      userId: session.user.id,
      input: data,
    })

    // Calculate active BOM cost
    const activeBom = await prisma.sKU.findUnique({
      where: { id },
      select: {
        bomVersions: {
          where: { isActive: true },
          take: 1,
          select: { id: true, versionName: true },
        },
      },
    })

    let activeBomCost: number | null = null
    if (activeBom?.bomVersions[0]) {
      const costs = await calculateBOMUnitCosts([activeBom.bomVersions[0].id], selectedCompanyId)
      activeBomCost = costs.get(activeBom.bomVersions[0].id) ?? 0
    }

    const maxBuildableUnits = await calculateMaxBuildableUnits(id, selectedCompanyId)

    return success({
      ...result,
      activeBom: activeBom?.bomVersions[0]
        ? {
            id: activeBom.bomVersions[0].id,
            versionName: activeBom.bomVersions[0].versionName,
            unitCost: activeBomCost?.toFixed(4) ?? '0.0000',
          }
        : null,
      maxBuildableUnits,
    })
  } catch (err) {
    if (err instanceof VersionConflictError) {
      return versionConflict('SKU')
    }
    if (err instanceof Error) {
      switch (err.message) {
        case 'SKU_NOT_FOUND':
          return notFound('SKU')
        case 'DUPLICATE_INTERNAL_CODE':
          return conflict('A SKU with this internal code already exists')
      }
    }
    console.error('Error updating SKU:', err)
    return serverError()
  }
}
```

Also update GET handler to include version in response (lines 23-136):
Add `version: sku.version,` to the response object around line 100.

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] PATCH handler uses updateSku service
- [ ] Version conflict returns 409 with VersionConflict error code
- [ ] GET response includes version field

### Subtask 4.2: Update BOMVersion PATCH route with version check
**File**: `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/route.ts`
**Pattern**: Existing PATCH handler (lines 117-214)
**Instructions**:
1. Import VersionConflictError from bom service
2. Import versionConflict from api-response
3. Pass version to updateBOMVersion call
4. Handle VersionConflictError
5. Include version in response

Update imports:
```typescript
import { updateBOMVersion, VersionConflictError, calculateBOMUnitCost } from '@/services/bom'
import {
  success,
  unauthorized,
  notFound,
  versionConflict,
  serverError,
  parseBody,
} from '@/lib/api-response'
```

Update PATCH handler error handling (around line 210):
```typescript
  } catch (err) {
    if (err instanceof VersionConflictError) {
      return versionConflict('BOM version')
    }
    if (err instanceof Error && err.message === 'BOM version not found') {
      return notFound('BOM version')
    }
    console.error('Error updating BOM version:', err)
    return serverError()
  }
```

Update the updateBOMVersion call to include version:
```typescript
const bomVersion = await updateBOMVersion({
  bomVersionId: id,
  companyId: selectedCompanyId!,
  ...data,
  version: data.version,  // Pass version for optimistic locking
})
```

Add version to response objects in both GET and PATCH handlers:
```typescript
return success({
  // ... existing fields ...
  version: bomVersion.version,
  lines: bomVersion.lines.map((line) => ({
    // ... existing line fields ...
  })),
  // ...
})
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] PATCH handler passes version to service
- [ ] Version conflict returns 409 with VersionConflict error code
- [ ] GET and PATCH responses include version field

### Subtask 4.3: Update SKU list GET route to include version
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/route.ts`
**Instructions**:
Update the GET handler to include version in SKU responses. The service function already fetches SKU data, but we need to ensure version is included.

In `/home/pbrown/SkuInventory/src/services/sku.ts`, update `getSkusWithCosts` function:
1. Add `version` to the select clause in the SKU query
2. Include version in the transformed response

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] GET /api/skus response includes version for each SKU

---

## Phase 5: Frontend Components

### Subtask 5.1: Update SKUForm to handle version
**File**: `/home/pbrown/SkuInventory/src/components/features/SKUForm.tsx`
**Pattern**: Existing form submission pattern (lines 96-175)
**Instructions**:
1. Store version from initial SKU data
2. Include version in PATCH request body
3. Handle 409 VersionConflict error with user-friendly message

Update the form to track version:
```typescript
// In the SKUFormProps interface, SKU already has version after type update
// In handleSubmit, update the body:

const body: Record<string, unknown> = {
  name: formData.name,
  internalCode: formData.internalCode,
  salesChannel: formData.salesChannel,
  externalIds,
  notes: formData.notes || null,
  // Include version for optimistic locking on edits
  ...(isEditing && sku?.version && { version: sku.version }),
}
```

Update error handling to show version conflict message:
```typescript
if (!res.ok) {
  const data = await res.json().catch(() => ({}))

  // Handle version conflict specifically
  if (res.status === 409 && data.error === 'VersionConflict') {
    toast.error('Update conflict', {
      description: 'This record was modified by another user. Please refresh and try again.',
    })
    return
  }

  const parsed = parseApiError(data)
  setFieldErrors(parsed.fieldErrors)
  setError(parsed.message)
  toast.error('Failed to save SKU', {
    description: parsed.message,
  })
  return
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] PATCH requests include version when editing
- [ ] Version conflict shows user-friendly toast message

### Subtask 5.2: Update BOMVersionEditForm to handle version
**File**: `/home/pbrown/SkuInventory/src/components/features/BOMVersionEditForm.tsx`
**Pattern**: Existing form submission pattern (lines 130-180)
**Instructions**:
1. Store version from initialData
2. Include version in PATCH request body
3. Handle 409 VersionConflict error with user-friendly message

Update handleSubmit to include version:
```typescript
const res = await fetch(`/api/bom-versions/${bomVersionId}`, {
  method: 'PATCH',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    versionName: formData.versionName,
    effectiveStartDate: formData.effectiveStartDate,
    notes: formData.notes || null,
    defectNotes: formData.defectNotes || null,
    lines: lines.map((line) => ({
      componentId: line.componentId,
      quantityPerUnit: line.quantityPerUnit,
      notes: line.notes || null,
    })),
    version: initialData.version, // Include for optimistic locking
  }),
})
```

Update error handling:
```typescript
if (!res.ok) {
  const data = await res.json().catch(() => ({}))

  // Handle version conflict
  if (res.status === 409 && data.error === 'VersionConflict') {
    throw new Error('This BOM version was modified by another user. Please refresh the page and try again.')
  }

  throw new Error(data?.message || 'Failed to update BOM version')
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] PATCH requests include version
- [ ] Version conflict shows user-friendly error message

---

## Phase 6: Tests

### Subtask 6.1: Add SKU version conflict integration test
**File**: `/home/pbrown/SkuInventory/tests/integration/sku-api.test.ts`
**Pattern**: Existing test structure (lines 1-211)
**Instructions**:
Add new test case for version conflict:

```typescript
it('returns 409 when version conflicts on update', async () => {
  // Create a SKU
  const code = `VER-${Date.now()}`
  const createRequest = createTestRequest('/api/skus', {
    method: 'POST',
    body: {
      name: 'Version Test SKU',
      internalCode: code,
      salesChannel: 'Amazon',
      externalIds: {},
    },
  })
  const createResponse = await createSKU(createRequest)
  const createResult = await parseRouteResponse(createResponse)
  expect(createResult.status).toBe(201)

  const skuId = createResult.data.id
  const originalVersion = createResult.data.version
  expect(originalVersion).toBe(1)

  // Update the SKU once to increment version
  const updateRequest1 = createTestRequest(`/api/skus/${skuId}`, {
    method: 'PATCH',
    body: {
      name: 'Updated Name',
      version: originalVersion,
    },
  })
  const { PATCH: updateSKU } = await import('@/app/api/skus/[id]/route')
  const updateResponse1 = await updateSKU(updateRequest1, { params: Promise.resolve({ id: skuId }) })
  const updateResult1 = await parseRouteResponse(updateResponse1)
  expect(updateResult1.status).toBe(200)
  expect(updateResult1.data.version).toBe(2)

  // Try to update with stale version (should fail)
  const updateRequest2 = createTestRequest(`/api/skus/${skuId}`, {
    method: 'PATCH',
    body: {
      name: 'Another Update',
      version: originalVersion, // Stale version
    },
  })
  const updateResponse2 = await updateSKU(updateRequest2, { params: Promise.resolve({ id: skuId }) })
  const updateResult2 = await parseRouteResponse(updateResponse2)

  expect(updateResult2.status).toBe(409)
  expect(updateResult2.error).toBe('VersionConflict')
})
```

**Validation Commands**:
```bash
npm test -- --filter="sku"
```
**Completion Criteria**:
- [ ] Test passes
- [ ] Version conflict returns 409 status

### Subtask 6.2: Add BOM version conflict unit test
**File**: `/home/pbrown/SkuInventory/tests/unit/bom-calculations.test.ts` or new file `tests/unit/optimistic-locking.test.ts`
**Instructions**:
Add unit test for updateBOMVersion version check:

```typescript
describe('updateBOMVersion with optimistic locking', () => {
  it('throws VersionConflictError when version is stale', async () => {
    // Mock existing BOM version with version 2
    vi.mocked(prisma.bOMVersion.findFirst).mockResolvedValue({
      id: 'bom-1',
      version: 2,
    } as never)

    // Attempt update with stale version 1
    await expect(
      updateBOMVersion({
        bomVersionId: 'bom-1',
        companyId: 'company-1',
        versionName: 'v2',
        version: 1, // Stale version
      })
    ).rejects.toThrow('VERSION_CONFLICT')
  })

  it('succeeds when version matches', async () => {
    // Mock transaction
    vi.mocked(prisma.$transaction).mockImplementation(async (fn) => {
      return fn({
        bOMVersion: {
          findFirst: vi.fn().mockResolvedValue({ id: 'bom-1', version: 1 }),
          update: vi.fn().mockResolvedValue({
            id: 'bom-1',
            version: 2,
            lines: [],
            createdBy: { id: 'user-1', name: 'Test User' },
          }),
        },
        bOMLine: {
          deleteMany: vi.fn(),
          createMany: vi.fn(),
        },
      } as never)
    })

    const result = await updateBOMVersion({
      bomVersionId: 'bom-1',
      companyId: 'company-1',
      versionName: 'v2',
      version: 1,
    })

    expect(result.version).toBe(2)
  })
})
```

**Validation Commands**:
```bash
npm test -- --filter="bom|optimistic"
```
**Completion Criteria**:
- [ ] Tests pass
- [ ] Version mismatch throws VersionConflictError

---

## Summary of Deliverables

**Files Created**: 1
- New migration file in `prisma/migrations/`

**Files Modified**: 12
- `prisma/schema.prisma` - Add version field to SKU and BOMVersion
- `src/types/sku.ts` - Add version to schema and response types
- `src/types/bom.ts` - Add version to schema and response types
- `src/lib/api-response.ts` - Add versionConflict helper
- `src/services/sku.ts` - Add updateSku function with version check, add VersionConflictError
- `src/services/bom.ts` - Add version check to updateBOMVersion, add VersionConflictError
- `src/app/api/skus/[id]/route.ts` - Use service, handle version conflict
- `src/app/api/bom-versions/[id]/route.ts` - Pass version, handle version conflict
- `src/components/features/SKUForm.tsx` - Include version in PATCH, handle conflict
- `src/components/features/BOMVersionEditForm.tsx` - Include version in PATCH, handle conflict
- `tests/integration/sku-api.test.ts` - Add version conflict test
- `tests/unit/bom-calculations.test.ts` (or new file) - Add version check tests

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5 -> Phase 6)
2. Complete each subtask fully before moving to next
3. Run validation commands after each subtask
4. Verify completion criteria before proceeding
5. Follow reference patterns exactly

## Test Strategy Note

- Use Vitest for unit tests
- Integration tests use test database on port 2346
- Run tests with: `npm test`
- Filter by module: `npm test -- --filter="sku|bom"`

## Performance Metrics

| Phase | Estimated Duration |
|-------|-------------------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 25m |
| **Total** | **45m** |
