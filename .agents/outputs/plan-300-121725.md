# Implementation Plan
**Generated**: 2025-12-17T12:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: Issue #300
**Estimated Build Time**: 2-3 hours
**Complexity**: Low

## Investigation Summary

### Request Analysis
**Type**: Refactoring
**Source**: GitHub Issue #300
**Priority**: Medium

### Task Classification
**Category**: REFACTORING
**Test Strategy**: FAST_PATH (smoke tests only)
**Suggested Filter**: None

### Issue Validation
**Status**: Valid
**Recent Changes**: Issue #298 already created `src/services/sku.ts` with `getSkusWithCosts()` - this provides the foundation to add `createSku()`.

### Current State Assessment
- **SKU API Route (`src/app/api/skus/route.ts`)**: 293 lines total
  - GET handler: Lines 21-60 (~40 lines) - Already refactored to use `getSkusWithCosts()` service
  - POST handler: Lines 63-293 (~230 lines) - **Bloated, needs extraction**
- **SKU Service (`src/services/sku.ts`)**: Already exists with `getSkusWithCosts()` function
- **Types (`src/types/sku.ts`)**: Already has `CreateSKUInput` and `SKUResponse` types defined

### Dependencies & Blockers
None identified. All prerequisites are in place:
- `src/services/sku.ts` exists and can be extended
- `src/types/sku.ts` has the necessary input/output types
- Pattern exists in `src/services/bom.ts::createBOMVersion()` for transaction-based creation

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Low
**Effort**: 2-3 hours
**Risk**: Low - Pure refactoring with existing patterns

### Patterns Identified
**Primary**: `src/services/bom.ts::createBOMVersion()` (lines 257-339) - Service function with transaction, validation, and typed return
**Secondary**: `src/services/draft-transaction.ts::createDraftTransaction()` - Similar pattern for complex creation with params object

### Ripple Effect Analysis
**Files Identified**: 2

| File | Why Affected |
|------|--------------|
| `src/app/api/skus/route.ts` | POST handler will be refactored to call new service |
| `src/services/sku.ts` | New `createSku()` function will be added |

---

## Executive Summary

Extract the bloated POST handler logic from `src/app/api/skus/route.ts` (230+ lines) into a clean `createSku()` service function in `src/services/sku.ts`. The API route will be slimmed down to handle only authentication, request parsing, and delegating to the service. This follows the established Service Layer pattern used throughout the codebase and enables isolated unit testing of the business logic.

---

## Phase 1: Create Service Function

### Subtask 1.1: Define CreateSkuParams Interface
**File**: `/home/pbrown/SkuInventory/src/services/sku.ts`
**Pattern**: Follow `GetSkusWithCostsParams` interface pattern (lines 10-21)
**Instructions**:

1. Add a new interface after `GetSkusWithCostsResult` (around line 33):

```typescript
/**
 * Parameters for createSku service function
 */
export interface CreateSkuParams {
  companyId: string
  brandId: string | null // null = resolve from companyId
  userId: string
  input: {
    name: string
    internalCode: string
    salesChannel: string
    externalIds: Record<string, string>
    notes?: string | null
    bomLines?: Array<{
      componentId: string
      quantityPerUnit: string
    }>
  }
}

/**
 * Result type for createSku service function
 */
export interface CreateSkuResult {
  id: string
  name: string
  internalCode: string
  salesChannel: string
  externalIds: Record<string, string>
  notes: string | null
  isActive: boolean
  createdAt: string
  updatedAt: string
  createdBy: { id: string; name: string }
  activeBom: {
    id: string
    versionName: string
    unitCost: string
  } | null
  maxBuildableUnits: number | null
}
```

**Completion Criteria**:
- [ ] `CreateSkuParams` interface defined with all required fields
- [ ] `CreateSkuResult` interface defined matching API response
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`

---

### Subtask 1.2: Implement createSku Service Function
**File**: `/home/pbrown/SkuInventory/src/services/sku.ts`
**Pattern**: Follow `createBOMVersion()` in `src/services/bom.ts` (lines 257-339)
**Instructions**:

1. Add required imports at the top of the file:

```typescript
import { parseFractionOrNumber } from '@/lib/utils'
```

2. Add the `createSku` function after the interfaces (around line 70):

```typescript
/**
 * Create a new SKU with optional inline BOM
 *
 * This is the single source of truth for SKU creation.
 * Handles:
 * - Brand validation/resolution
 * - Duplicate internalCode check
 * - SKU creation
 * - Optional BOM version creation with lines
 *
 * @throws Error if brand not found or internalCode already exists
 */
export async function createSku(params: CreateSkuParams): Promise<CreateSkuResult> {
  const { companyId, brandId: providedBrandId, userId, input } = params

  // Resolve brand ID
  let brandId = providedBrandId

  if (!brandId) {
    // Fall back to first active brand if none selected
    const brand = await prisma.brand.findFirst({
      where: { companyId, isActive: true },
    })
    if (!brand) {
      throw new Error('NO_ACTIVE_BRAND')
    }
    brandId = brand.id
  } else {
    // Validate brand belongs to selected company
    const validBrand = await prisma.brand.findFirst({
      where: {
        id: brandId,
        companyId,
        isActive: true,
      },
    })

    if (!validBrand) {
      throw new Error('INVALID_BRAND')
    }
  }

  // Check for duplicate internalCode within the company
  const existing = await prisma.sKU.findFirst({
    where: {
      companyId,
      internalCode: input.internalCode,
    },
  })

  if (existing) {
    throw new Error('DUPLICATE_INTERNAL_CODE')
  }

  // Check if BOM lines are provided
  const hasBomLines = input.bomLines && input.bomLines.length > 0

  if (hasBomLines) {
    // Create SKU and BOM version in a transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create SKU
      const sku = await tx.sKU.create({
        data: {
          brandId,
          companyId,
          name: input.name,
          internalCode: input.internalCode,
          salesChannel: input.salesChannel,
          externalIds: input.externalIds as Prisma.InputJsonValue,
          notes: input.notes,
          createdById: userId,
          updatedById: userId,
        },
        include: {
          createdBy: { select: { id: true, name: true } },
        },
      })

      // Create BOM version with lines
      const bomVersion = await tx.bOMVersion.create({
        data: {
          skuId: sku.id,
          versionName: 'v1',
          effectiveStartDate: new Date(),
          isActive: true,
          createdById: userId,
          lines: {
            create: input.bomLines!.map((line) => ({
              componentId: line.componentId,
              quantityPerUnit: parseFractionOrNumber(line.quantityPerUnit) ?? 1,
            })),
          },
        },
      })

      return { sku, bomVersion }
    })

    return {
      id: result.sku.id,
      name: result.sku.name,
      internalCode: result.sku.internalCode,
      salesChannel: result.sku.salesChannel,
      externalIds: result.sku.externalIds as Record<string, string>,
      notes: result.sku.notes,
      isActive: result.sku.isActive,
      createdAt: result.sku.createdAt.toISOString(),
      updatedAt: result.sku.updatedAt.toISOString(),
      createdBy: result.sku.createdBy,
      activeBom: {
        id: result.bomVersion.id,
        versionName: result.bomVersion.versionName,
        unitCost: '0.0000', // Will be calculated on refresh
      },
      maxBuildableUnits: null,
    }
  }

  // No BOM lines - create SKU only
  const sku = await prisma.sKU.create({
    data: {
      brandId,
      companyId,
      name: input.name,
      internalCode: input.internalCode,
      salesChannel: input.salesChannel,
      externalIds: input.externalIds as Prisma.InputJsonValue,
      notes: input.notes,
      createdById: userId,
      updatedById: userId,
    },
    include: {
      createdBy: { select: { id: true, name: true } },
    },
  })

  return {
    id: sku.id,
    name: sku.name,
    internalCode: sku.internalCode,
    salesChannel: sku.salesChannel,
    externalIds: sku.externalIds as Record<string, string>,
    notes: sku.notes,
    isActive: sku.isActive,
    createdAt: sku.createdAt.toISOString(),
    updatedAt: sku.updatedAt.toISOString(),
    createdBy: sku.createdBy,
    activeBom: null,
    maxBuildableUnits: null,
  }
}
```

**Completion Criteria**:
- [ ] `createSku` function implemented with all business logic
- [ ] Error messages use sentinel strings (NO_ACTIVE_BRAND, INVALID_BRAND, DUPLICATE_INTERNAL_CODE)
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`

---

## Phase 2: Refactor API Route

### Subtask 2.1: Update Imports in SKU Route
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/route.ts`
**Instructions**:

1. Update the import from `@/services/sku` to include `createSku`:

```typescript
import { getSkusWithCosts, createSku } from '@/services/sku'
```

2. Remove the `parseFractionOrNumber` import (it will be in the service now):

```typescript
// REMOVE THIS LINE:
import { parseFractionOrNumber } from '@/lib/utils'
```

**Completion Criteria**:
- [ ] Import updated to include `createSku`
- [ ] `parseFractionOrNumber` import removed from route file
- [ ] TypeScript compiles without errors

---

### Subtask 2.2: Refactor POST Handler
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/route.ts`
**Pattern**: Follow the slim POST handler in `src/app/api/components/route.ts` (lines 126-216)
**Instructions**:

Replace the POST function (lines 63-293) with this slimmed-down version:

```typescript
// POST /api/skus - Create a new SKU
export async function POST(request: NextRequest) {
  // Store context for error logging
  let errorContext: {
    userId?: string
    companyId?: string | null
    brandId?: string | null
    internalCode?: string
  } = {}

  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    // Store session info for error logging
    errorContext = {
      userId: session.user.id,
      companyId: session.user.selectedCompanyId,
      brandId: session.user.selectedBrandId,
    }

    // Validate session has required company context
    if (!session.user.selectedCompanyId) {
      console.error('SKU creation failed: No selectedCompanyId in session', {
        userId: session.user.id,
        email: session.user.email,
      })
      return error('Company context is required. Please select a company and try again.', 400, 'BadRequest')
    }

    // Defense-in-depth: Validate user still exists in database
    const validUser = await validateUserExists(session.user.id)
    if (!validUser) {
      console.error('SKU creation failed: User ID not found in database (stale JWT token)', {
        userId: session.user.id,
        email: session.user.email,
      })
      return error('Your session has expired. Please log out and log back in.', 401, 'Unauthorized')
    }
    if (!validUser.isActive) {
      console.error('SKU creation failed: User is inactive', {
        userId: session.user.id,
        email: session.user.email,
      })
      return error('Your account is inactive. Please contact an administrator.', 403, 'Forbidden')
    }

    const bodyResult = await parseBody(request, createSKUSchema)
    if (bodyResult.error) return bodyResult.error

    const data = bodyResult.data
    errorContext.internalCode = data.internalCode

    // Delegate to service
    const result = await createSku({
      companyId: session.user.selectedCompanyId,
      brandId: session.user.selectedBrandId,
      userId: session.user.id,
      input: data,
    })

    return created(result)
  } catch (err) {
    // Handle known service errors
    if (err instanceof Error) {
      switch (err.message) {
        case 'NO_ACTIVE_BRAND':
          return serverError('No active brand found for selected company')
        case 'INVALID_BRAND':
          console.error('SKU creation failed: Brand does not belong to company', {
            brandId: errorContext.brandId,
            companyId: errorContext.companyId,
          })
          return error('Invalid brand selection. Please refresh the page and try again.', 400, 'BadRequest')
        case 'DUPLICATE_INTERNAL_CODE':
          return conflict('A SKU with this internal code already exists')
      }

      // Handle database constraint violations
      if (err.message.includes('Unique constraint')) {
        return conflict('A SKU with this internal code already exists')
      }
      if (err.message.includes('Foreign key constraint')) {
        if (err.message.includes('createdById') || err.message.includes('updatedById')) {
          return error('Your session has expired. Please log out and log back in.', 401, 'Unauthorized')
        }
        if (err.message.includes('brandId')) {
          return error('Invalid brand selection. Please refresh the page and try again.', 400, 'BadRequest')
        }
        if (err.message.includes('companyId')) {
          return error('Company context is invalid. Please log out and log back in.', 400, 'BadRequest')
        }
      }
    }

    // Log detailed error for debugging
    const errorDetails = {
      message: err instanceof Error ? err.message : 'Unknown error',
      stack: err instanceof Error ? err.stack : undefined,
      name: err instanceof Error ? err.name : undefined,
      ...errorContext,
    }
    console.error('Error creating SKU:', JSON.stringify(errorDetails, null, 2))

    return serverError('Failed to create SKU. Please try again or contact support.')
  }
}
```

**Completion Criteria**:
- [ ] POST handler reduced from ~230 lines to ~100 lines
- [ ] Business logic delegated to `createSku()` service
- [ ] Error handling maps service errors to HTTP responses
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`
- [ ] Build succeeds: `npm run build`

---

## Phase 3: Verification

### Subtask 3.1: Type Check and Build
**Instructions**:

1. Run TypeScript check:
```bash
npx tsc --noEmit
```

2. Run build:
```bash
npm run build
```

3. Run lint:
```bash
npm run lint
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` succeeds
- [ ] `npm run lint` passes

---

### Subtask 3.2: Manual Smoke Test (Optional)
**Instructions**:

If test environment is available, verify SKU creation still works:

1. Start test environment
2. Create a SKU without BOM lines via the UI
3. Create a SKU with BOM lines via the UI
4. Verify both appear correctly in SKU list

**Completion Criteria**:
- [ ] SKU creation without BOM works
- [ ] SKU creation with BOM works
- [ ] No console errors during operation

---

## Summary of Deliverables

**Files Created**: 0
**Files Modified**: 2

| File | Change Type | Description |
|------|-------------|-------------|
| `/home/pbrown/SkuInventory/src/services/sku.ts` | Modified | Add `CreateSkuParams`, `CreateSkuResult` interfaces and `createSku()` function |
| `/home/pbrown/SkuInventory/src/app/api/skus/route.ts` | Modified | Slim down POST handler to use `createSku()` service |

---

## Handoff to Build Agent

1. Execute subtasks in exact order (1.1 -> 1.2 -> 2.1 -> 2.2 -> 3.1)
2. Test completion criteria before moving to next subtask
3. Follow reference patterns exactly
4. Use sentinel error strings as specified (NO_ACTIVE_BRAND, INVALID_BRAND, DUPLICATE_INTERNAL_CODE)

## Test Strategy Note
- **Strategy**: FAST_PATH (smoke tests only)
- No new tests required for pure refactoring
- Existing functionality should continue to work unchanged

## Performance Metrics
| Phase | Estimated Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 20m |
| **Total** | **40m** |
