# Implementation Plan: Lock Down Tenant Scoping Across APIs

**Generated**: 2025-12-02T21:00:00Z
**Task ID**: Issue #2
**Estimated Build Time**: 6-8 hours
**Complexity**: Moderate (security fix with comprehensive scope)

## Executive Summary

This plan addresses a critical multi-tenant security vulnerability where API routes for components, SKUs, and BOM versions accept ID parameters without validating tenant ownership. Attackers can enumerate IDs to read, modify, or delete resources belonging to other tenants. The fix requires adding tenant ownership validation using `findFirst` with nested brand/company filters before performing operations, returning 404 (not 403) to prevent information leakage.

## Scout Validation Summary

**Scout's findings confirmed**:
- All 6 vulnerable API route files verified
- Reference patterns in receipt/adjustment routes confirmed
- Prisma schema relationships validated (Component -> Brand -> Company, SKU -> Brand -> Company, BOMVersion -> SKU -> Brand -> Company)
- No additional vulnerable routes discovered beyond Scout's report
- transactions/[id] route already properly scoped (line 22: `companyId: session.user.companyId`)

**Key Schema Relationships Verified**:
```
Component.brandId -> Brand.companyId -> session.user.companyId
SKU.brandId -> Brand.companyId -> session.user.companyId
BOMVersion.skuId -> SKU.brandId -> Brand.companyId -> session.user.companyId
```

---

## Phase 1: Component API Tenant Scoping

### Subtask 1.1: Add Tenant Validation to GET /api/components/:id

**File**: `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts`
**Pattern Reference**: `/home/pbrown/SkuInventory/src/app/api/transactions/receipt/route.ts:28-39`

**Current Code (lines 34-68)**:
```typescript
const component = await prisma.component.findUnique({
  where: { id },
  include: {
    // ... includes
  },
})

if (!component) {
  return notFound('Component')
}
```

**Replace With**:
```typescript
const component = await prisma.component.findFirst({
  where: {
    id,
    brand: {
      companyId: session.user.companyId,
    },
  },
  include: {
    // ... existing includes unchanged
  },
})

if (!component) {
  return notFound('Component')
}
```

**Instructions**:
1. Change `findUnique` to `findFirst` on line 34
2. Add nested `brand.companyId` filter to the `where` clause
3. Keep all existing `include` statements unchanged
4. The existing `if (!component)` check handles both not-found and cross-tenant cases

**Completion Criteria**:
- [ ] `findUnique` changed to `findFirst` with tenant filter
- [ ] Cross-tenant GET returns 404 (not 200 or 403)
- [ ] Same-tenant GET returns correct data
- [ ] `npx tsc --noEmit` passes

---

### Subtask 1.2: Add Tenant Validation to PATCH /api/components/:id

**File**: `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts`
**Pattern Reference**: Same as Subtask 1.1

**Current Code (lines 150-156)**:
```typescript
const existing = await prisma.component.findUnique({
  where: { id },
})

if (!existing) {
  return notFound('Component')
}
```

**Replace With**:
```typescript
const existing = await prisma.component.findFirst({
  where: {
    id,
    brand: {
      companyId: session.user.companyId,
    },
  },
})

if (!existing) {
  return notFound('Component')
}
```

**Instructions**:
1. Change `findUnique` to `findFirst` on line 150
2. Add nested `brand.companyId` filter to the `where` clause
3. Keep the rest of the function unchanged (duplicate check, update, response)

**Completion Criteria**:
- [ ] `findUnique` changed to `findFirst` with tenant filter
- [ ] Cross-tenant PATCH returns 404
- [ ] Same-tenant PATCH updates correctly
- [ ] Duplicate name/skuCode check still works (it uses `existing.brandId`)

---

### Subtask 1.3: Add Tenant Validation to DELETE /api/components/:id

**File**: `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts`
**Pattern Reference**: Same as Subtask 1.1

**Current Code (lines 236-243)**:
```typescript
const existing = await prisma.component.findUnique({
  where: { id },
})

if (!existing) {
  return notFound('Component')
}
```

**Replace With**:
```typescript
const existing = await prisma.component.findFirst({
  where: {
    id,
    brand: {
      companyId: session.user.companyId,
    },
  },
})

if (!existing) {
  return notFound('Component')
}
```

**Instructions**:
1. Change `findUnique` to `findFirst` on line 236
2. Add nested `brand.companyId` filter to the `where` clause
3. Keep the `canDeleteComponent` check and update logic unchanged

**Completion Criteria**:
- [ ] `findUnique` changed to `findFirst` with tenant filter
- [ ] Cross-tenant DELETE returns 404
- [ ] Same-tenant DELETE deactivates correctly

---

## Phase 2: SKU API Tenant Scoping

### Subtask 2.1: Add Tenant Validation to GET /api/skus/:id

**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
**Pattern Reference**: Same pattern as components

**Current Code (lines 29-53)**:
```typescript
const sku = await prisma.sKU.findUnique({
  where: { id },
  include: {
    // ... includes
  },
})

if (!sku) {
  return notFound('SKU')
}
```

**Replace With**:
```typescript
const sku = await prisma.sKU.findFirst({
  where: {
    id,
    brand: {
      companyId: session.user.companyId,
    },
  },
  include: {
    // ... existing includes unchanged
  },
})

if (!sku) {
  return notFound('SKU')
}
```

**Instructions**:
1. Change `findUnique` to `findFirst` on line 29
2. Add nested `brand.companyId` filter to the `where` clause
3. Keep all existing `include` statements unchanged

**Completion Criteria**:
- [ ] `findUnique` changed to `findFirst` with tenant filter
- [ ] Cross-tenant GET returns 404
- [ ] Same-tenant GET returns correct data with BOM versions

---

### Subtask 2.2: Add Tenant Validation to PATCH /api/skus/:id

**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
**Pattern Reference**: Same pattern as components

**Current Code (lines 130-136)**:
```typescript
const existing = await prisma.sKU.findUnique({
  where: { id },
})

if (!existing) {
  return notFound('SKU')
}
```

**Replace With**:
```typescript
const existing = await prisma.sKU.findFirst({
  where: {
    id,
    brand: {
      companyId: session.user.companyId,
    },
  },
})

if (!existing) {
  return notFound('SKU')
}
```

**Instructions**:
1. Change `findUnique` to `findFirst` on line 130
2. Add nested `brand.companyId` filter to the `where` clause
3. Keep the rest of the function unchanged (duplicate check, update, response)

**Completion Criteria**:
- [ ] `findUnique` changed to `findFirst` with tenant filter
- [ ] Cross-tenant PATCH returns 404
- [ ] Same-tenant PATCH updates correctly
- [ ] Duplicate internalCode check still works (it uses `existing.brandId`)

---

### Subtask 2.3: Add Tenant Validation to DELETE /api/skus/:id

**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
**Pattern Reference**: Same pattern as components

**Current Code (lines 220-226)**:
```typescript
const existing = await prisma.sKU.findUnique({
  where: { id },
})

if (!existing) {
  return notFound('SKU')
}
```

**Replace With**:
```typescript
const existing = await prisma.sKU.findFirst({
  where: {
    id,
    brand: {
      companyId: session.user.companyId,
    },
  },
})

if (!existing) {
  return notFound('SKU')
}
```

**Instructions**:
1. Change `findUnique` to `findFirst` on line 220
2. Add nested `brand.companyId` filter to the `where` clause

**Completion Criteria**:
- [ ] `findUnique` changed to `findFirst` with tenant filter
- [ ] Cross-tenant DELETE returns 404
- [ ] Same-tenant DELETE deactivates correctly

---

## Phase 3: SKU BOM Versions API Tenant Scoping

### Subtask 3.1: Add Tenant Validation to GET /api/skus/:id/bom-versions

**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/bom-versions/route.ts`
**Pattern Reference**: Same pattern, validates SKU ownership before listing BOM versions

**Current Code (lines 36-42)**:
```typescript
const sku = await prisma.sKU.findUnique({
  where: { id: skuId },
})

if (!sku) {
  return notFound('SKU')
}
```

**Replace With**:
```typescript
const sku = await prisma.sKU.findFirst({
  where: {
    id: skuId,
    brand: {
      companyId: session.user.companyId,
    },
  },
})

if (!sku) {
  return notFound('SKU')
}
```

**Instructions**:
1. Change `findUnique` to `findFirst` on line 36
2. Add nested `brand.companyId` filter to the `where` clause
3. BOM version list will naturally be scoped since it filters by `skuId`

**Completion Criteria**:
- [ ] `findUnique` changed to `findFirst` with tenant filter
- [ ] Cross-tenant GET returns 404
- [ ] Same-tenant GET returns all BOM versions for the SKU

---

### Subtask 3.2: Add Tenant Validation to POST /api/skus/:id/bom-versions

**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/bom-versions/route.ts`
**Pattern Reference**: Same pattern, validates SKU ownership before creating BOM version

**Current Code (lines 135-141)**:
```typescript
const sku = await prisma.sKU.findUnique({
  where: { id: skuId },
})

if (!sku) {
  return notFound('SKU')
}
```

**Replace With**:
```typescript
const sku = await prisma.sKU.findFirst({
  where: {
    id: skuId,
    brand: {
      companyId: session.user.companyId,
    },
  },
})

if (!sku) {
  return notFound('SKU')
}
```

**Additional Validation Needed** (after line 154):
The current code validates components exist but not that they belong to the same tenant. Add tenant filter:

**Current Code (lines 145-154)**:
```typescript
const componentIds = data.lines.map((l) => l.componentId)
const components = await prisma.component.findMany({
  where: {
    id: { in: componentIds },
    isActive: true,
  },
})

if (components.length !== componentIds.length) {
  return serverError('One or more components not found or inactive')
}
```

**Replace With**:
```typescript
const componentIds = data.lines.map((l) => l.componentId)
const components = await prisma.component.findMany({
  where: {
    id: { in: componentIds },
    isActive: true,
    brand: {
      companyId: session.user.companyId,
    },
  },
})

if (components.length !== componentIds.length) {
  return serverError('One or more components not found or inactive')
}
```

**Instructions**:
1. Change `findUnique` to `findFirst` for SKU check on line 135
2. Add nested `brand.companyId` filter to the SKU `where` clause
3. Add nested `brand.companyId` filter to the components `findMany` query

**Completion Criteria**:
- [ ] SKU `findUnique` changed to `findFirst` with tenant filter
- [ ] Component findMany includes tenant filter
- [ ] Cross-tenant POST returns 404 for invalid SKU
- [ ] Cross-tenant component references fail validation
- [ ] Same-tenant POST creates BOM version correctly

---

## Phase 4: BOM Version API Tenant Scoping

### Subtask 4.1: Add Tenant Validation to GET /api/bom-versions/:id

**File**: `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/route.ts`
**Pattern Reference**: Needs deeper nesting through SKU -> Brand -> Company

**Current Code (lines 25-50)**:
```typescript
const bomVersion = await prisma.bOMVersion.findUnique({
  where: { id },
  include: {
    sku: {
      select: {
        id: true,
        name: true,
        internalCode: true,
      },
    },
    // ... other includes
  },
})

if (!bomVersion) {
  return notFound('BOM version')
}
```

**Replace With**:
```typescript
const bomVersion = await prisma.bOMVersion.findFirst({
  where: {
    id,
    sku: {
      brand: {
        companyId: session.user.companyId,
      },
    },
  },
  include: {
    sku: {
      select: {
        id: true,
        name: true,
        internalCode: true,
      },
    },
    // ... existing includes unchanged
  },
})

if (!bomVersion) {
  return notFound('BOM version')
}
```

**Instructions**:
1. Change `findUnique` to `findFirst` on line 25
2. Add nested `sku.brand.companyId` filter to the `where` clause
3. Keep all existing `include` statements unchanged

**Completion Criteria**:
- [ ] `findUnique` changed to `findFirst` with tenant filter
- [ ] Cross-tenant GET returns 404
- [ ] Same-tenant GET returns BOM version with lines

---

### Subtask 4.2: Add Tenant Validation to POST /api/bom-versions/:id/activate

**File**: `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/activate/route.ts`
**Pattern Reference**: Must validate before calling service function

**Current Code (lines 22-24)**:
```typescript
const { id } = await params

const bomVersion = await activateBOMVersion(id)
```

**Replace With**:
```typescript
const { id } = await params

// Verify BOM version exists and belongs to user's company
const existingBom = await prisma.bOMVersion.findFirst({
  where: {
    id,
    sku: {
      brand: {
        companyId: session.user.companyId,
      },
    },
  },
})

if (!existingBom) {
  return notFound('BOM version')
}

const bomVersion = await activateBOMVersion(id)
```

**Additional Import Needed**:
Add at top of file (after line 3):
```typescript
import { prisma } from '@/lib/db'
```

**Also add `notFound` to the existing imports** (line 4-8):
```typescript
import {
  success,
  unauthorized,
  notFound,
  serverError,
} from '@/lib/api-response'
```

**Instructions**:
1. Add `prisma` import at top of file
2. Add `notFound` to the api-response imports
3. Add tenant validation before calling `activateBOMVersion`
4. Remove the error handling for 'BOM version not found' at the end (lines 60-63) since we handle it earlier

**Completion Criteria**:
- [ ] Prisma import added
- [ ] notFound import added
- [ ] Tenant validation added before service call
- [ ] Cross-tenant POST returns 404
- [ ] Same-tenant POST activates correctly
- [ ] Error handling for not-found moved earlier in flow

---

### Subtask 4.3: Add Tenant Validation to POST /api/bom-versions/:id/clone

**File**: `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/clone/route.ts`
**Pattern Reference**: Same as activate route

**Current Code (lines 24-35)**:
```typescript
const { id } = await params

const bodyResult = await parseBody(request, cloneBOMVersionSchema)
if (bodyResult.error) return bodyResult.error

const { versionName } = bodyResult.data

const newBomVersion = await cloneBOMVersion({
  bomVersionId: id,
  newVersionName: versionName,
  createdById: session.user.id,
})
```

**Replace With**:
```typescript
const { id } = await params

const bodyResult = await parseBody(request, cloneBOMVersionSchema)
if (bodyResult.error) return bodyResult.error

const { versionName } = bodyResult.data

// Verify BOM version exists and belongs to user's company
const existingBom = await prisma.bOMVersion.findFirst({
  where: {
    id,
    sku: {
      brand: {
        companyId: session.user.companyId,
      },
    },
  },
})

if (!existingBom) {
  return notFound('BOM version')
}

const newBomVersion = await cloneBOMVersion({
  bomVersionId: id,
  newVersionName: versionName,
  createdById: session.user.id,
})
```

**Additional Import Needed**:
Add at top of file (after line 3):
```typescript
import { prisma } from '@/lib/db'
```

**Also add `notFound` to the existing imports** (line 4-9):
```typescript
import {
  created,
  unauthorized,
  notFound,
  serverError,
  parseBody,
} from '@/lib/api-response'
```

**Instructions**:
1. Add `prisma` import at top of file
2. Add `notFound` to the api-response imports
3. Add tenant validation after body parsing, before calling `cloneBOMVersion`
4. Remove the error handling for 'BOM version not found' at the end (lines 71-74) since we handle it earlier

**Completion Criteria**:
- [ ] Prisma import added
- [ ] notFound import added
- [ ] Tenant validation added before service call
- [ ] Cross-tenant POST returns 404
- [ ] Same-tenant POST clones correctly
- [ ] Error handling for not-found moved earlier in flow

---

## Phase 5: Comprehensive Testing

### Subtask 5.1: Create E2E Tenant Scoping Tests

**File**: `/home/pbrown/SkuInventory/tests/e2e/tenant-scoping.spec.ts` (NEW)
**Pattern Reference**: `/home/pbrown/SkuInventory/tests/e2e/sku-recent-transactions.spec.ts`

**Instructions**:
Create a new E2E test file with the following test cases:

```typescript
import { test, expect } from '@playwright/test'

test.describe('Tenant Scoping Security', () => {
  // Note: These tests require setup of two separate tenant users
  // For E2E, we test that the UI properly handles 404 responses
  // For API-level security testing, use the unit tests or manual curl

  test.beforeEach(async ({ page }) => {
    // Login as primary tenant user
    await page.goto('/login')
    await page.waitForSelector('#email', { timeout: 10000 })
    await page.fill('#email', 'admin@tonsil.tech')
    await page.fill('#password', 'changeme123')
    await page.click('button[type="submit"]')
    await page.waitForURL('/', { timeout: 15000 })
  })

  test('Component detail page returns 404 for non-existent ID', async ({ page }) => {
    // Navigate to a component detail page with a fake UUID
    await page.goto('/components/00000000-0000-0000-0000-000000000000')

    // Should show 404 or redirect, not crash
    // The exact behavior depends on your 404 handling
    const response = await page.waitForResponse(
      (resp) => resp.url().includes('/api/components/') && resp.status() === 404,
      { timeout: 5000 }
    ).catch(() => null)

    // Either we got a 404 API response or the page handled it gracefully
    if (response) {
      expect(response.status()).toBe(404)
    }
  })

  test('SKU detail page returns 404 for non-existent ID', async ({ page }) => {
    await page.goto('/skus/00000000-0000-0000-0000-000000000000')

    const response = await page.waitForResponse(
      (resp) => resp.url().includes('/api/skus/') && resp.status() === 404,
      { timeout: 5000 }
    ).catch(() => null)

    if (response) {
      expect(response.status()).toBe(404)
    }
  })
})
```

**Notes for Build Agent**:
- These E2E tests verify basic 404 handling
- True cross-tenant testing requires multiple tenant setup (see Attack Scenarios in Scout report)
- Manual API testing with curl is recommended for security verification

**Completion Criteria**:
- [ ] Test file created
- [ ] Tests pass with `npm run test:e2e`
- [ ] No false positives (tests should pass for properly scoped routes)

---

### Subtask 5.2: Manual Security Verification Checklist

**File**: Not a code file - manual verification steps

**Attack Scenarios to Test** (from Scout report):

1. **Scenario 1**: User from Company A tries to read Component from Company B
   - Request: `GET /api/components/{company-b-component-id}`
   - Expected: 404 Not Found
   - Test with: curl or API client

2. **Scenario 2**: User from Company A tries to update SKU from Company B
   - Request: `PATCH /api/skus/{company-b-sku-id}`
   - Expected: 404 Not Found

3. **Scenario 3**: User from Company A tries to activate BOM version for Company B's SKU
   - Request: `POST /api/bom-versions/{company-b-bom-id}/activate`
   - Expected: 404 Not Found

4. **Scenario 4**: User from Company A tries to clone BOM version from Company B
   - Request: `POST /api/bom-versions/{company-b-bom-id}/clone`
   - Expected: 404 Not Found

**To perform manual testing**:
1. Log in as user from Company A, note auth cookie
2. Get a valid resource ID from Company B (requires DB access or second user session)
3. Make API requests with Company A's auth to Company B's resources
4. Verify all return 404 (not 200, 403, or 500)

**Completion Criteria**:
- [ ] All 4 attack scenarios return 404
- [ ] No information leakage in error messages
- [ ] Same-tenant operations still work correctly

---

## Phase 6: Validation and Cleanup

### Subtask 6.1: Run Full Validation Suite

**Instructions**:
Execute the following commands and verify all pass:

```bash
# TypeScript compilation
npx tsc --noEmit

# Lint check
npm run lint

# Build check
npm run build

# Unit tests
npm test

# E2E tests (optional, requires running app)
npm run test:e2e
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run lint` passes with no errors
- [ ] `npm run build` completes successfully
- [ ] `npm test` passes
- [ ] No TypeScript errors introduced

---

## Summary of Deliverables

**Files Modified**: 6
| File | Changes |
|------|---------|
| `src/app/api/components/[id]/route.ts` | 3 findUnique -> findFirst with tenant filter |
| `src/app/api/skus/[id]/route.ts` | 3 findUnique -> findFirst with tenant filter |
| `src/app/api/skus/[id]/bom-versions/route.ts` | 2 findUnique -> findFirst with tenant filter, 1 findMany with tenant filter |
| `src/app/api/bom-versions/[id]/route.ts` | 1 findUnique -> findFirst with tenant filter |
| `src/app/api/bom-versions/[id]/activate/route.ts` | Add prisma import, notFound import, tenant validation |
| `src/app/api/bom-versions/[id]/clone/route.ts` | Add prisma import, notFound import, tenant validation |

**Files Created**: 1
| File | Purpose |
|------|---------|
| `tests/e2e/tenant-scoping.spec.ts` | E2E tests for tenant scoping |

**Total Changes**: 12 API endpoint validations fixed across 6 files, 1 new test file

---

## Handoff to Build Agent

1. Execute subtasks **in exact order** (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5 -> Phase 6)
2. After each subtask, run `npx tsc --noEmit` to verify no TypeScript errors
3. All `findUnique` -> `findFirst` conversions must include the nested tenant filter
4. Follow the reference pattern exactly: `brand: { companyId: session.user.companyId }`
5. For BOM versions, the path is: `sku: { brand: { companyId: session.user.companyId } }`
6. Test each route manually after modification to verify:
   - Valid same-tenant requests return expected data
   - Invalid cross-tenant requests return 404 (not 403 or 500)
7. Run full validation suite (Subtask 6.1) before marking complete

**Critical Reminders**:
- Return 404 for cross-tenant access (not 403) to prevent ID enumeration
- The `session.user.companyId` is always available after authentication (verified in auth.ts:91)
- Do NOT modify service layer functions - validation happens at API route level

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Scout Review | 5m |
| Pattern Research | 8m |
| Schema Verification | 5m |
| Plan Writing | 15m |
| **Total** | **33m** |

---

## Acceptance Criteria (from Scout Report)

- [ ] All 6 vulnerable API routes validate tenant ownership
- [ ] Cross-tenant access attempts return 404 (not 403 or 200)
- [ ] Existing functionality preserved for valid same-tenant requests
- [ ] Build completes without errors or warnings
- [ ] TypeScript compilation passes
- [ ] E2E tests pass
- [ ] Manual penetration test confirms vulnerability is fixed
