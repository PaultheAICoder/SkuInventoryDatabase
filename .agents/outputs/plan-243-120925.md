# Implementation Plan
**Generated**: 2025-12-09T22:45:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #243 - Edit transactions feature
**Estimated Build Time**: 10-14 hours
**Complexity**: High

## Investigation Summary

### Request Analysis
**Type**: Feature - Edit Approved Transactions
**Source**: GitHub Issue #243
**Priority**: High (User-requested core functionality)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED (affected modules, ~10-15 min)
**Suggested Filter**: `--filter="transaction"` for transaction-related tests

### Issue Validation
**Status**: Valid - No existing edit functionality for approved transactions
**Recent Changes**: Draft transaction update exists (src/services/draft-transaction.ts:271), but no editing of approved transactions

### Current State Assessment
- **Transaction creation**: Fully implemented for all types (receipt, build, adjustment, initial, transfer, outbound)
- **Draft editing**: Exists via `updateDraftTransaction()` in draft-transaction service
- **Approved transaction editing**: NOT IMPLEMENTED - This is the gap
- **API Routes**: `src/app/api/transactions/[id]/route.ts` only has GET method, no PUT
- **UI Components**: `TransactionDetail.tsx` displays transactions read-only, no edit capability
- **Database**: Transaction model supports updates (has updatedAt via @updatedAt)

### Dependencies & Blockers
1. **Inventory recalculation**: Editing a transaction MUST recalculate component quantities
   - Original transaction lines must be reversed
   - New transaction lines must be applied
   - This is complex for build transactions (lot consumption, finished goods)
2. **Build transactions**: Special handling needed for:
   - Lot balance adjustments
   - Finished goods lines
   - BOM cost recalculation
3. **Transfer transactions**: Must handle both from/to location quantity changes
4. **Outbound transactions**: Must handle finished goods line adjustments

**Can Proceed?**: YES - But requires careful inventory reversal logic

### Complexity Assessment
**Complexity**: High
**Effort**: 10-14 hours
**Risk**: Medium - Inventory consistency is critical

### Patterns Identified
**Primary**: `src/services/draft-transaction.ts:271-314` - updateDraftTransaction pattern for field updates
**Secondary**: `src/services/inventory.ts:346-507` - createReceiptTransaction for atomic transaction creation
**Reference**: `src/app/api/transactions/[id]/route.ts` - GET route pattern for dynamic routes

### Ripple Effect Analysis
**Files to Create**: 3
- `src/services/transaction-edit.ts` (new service)
- `src/types/transaction-edit.ts` (new types)
- `src/app/(dashboard)/transactions/[id]/edit/page.tsx` (new UI page)

**Files to Modify**: 6
- `src/app/api/transactions/[id]/route.ts` - Add PUT handler
- `src/types/transaction.ts` - Add update schemas
- `src/components/features/TransactionDetail.tsx` - Add edit button
- `src/app/(dashboard)/transactions/[id]/page.tsx` - Add edit navigation
- `src/services/inventory.ts` - Add reversal functions (or in new service)
- `src/services/finished-goods.ts` - Add reversal functions for outbound

**TOTAL FILES AFFECTED**: 9

---

## Executive Summary

Implement full transaction editing capability for approved transactions. Users will be able to edit any field on existing transactions, with immediate inventory recalculation. The implementation requires:
1. A new transaction edit service with reversal logic to undo original transaction effects
2. PUT API endpoint on `/api/transactions/[id]`
3. Edit page UI with pre-populated form
4. Edit button on transaction detail page

The key technical challenge is reversing the inventory impact of the original transaction before applying the edited values, especially for complex transaction types like build (which affects lots and finished goods).

## Phase 0: Architecture Decision

### Subtask 0.1: Determine Edit Approach

**Decision Required**: Choose between two approaches:
1. **Reversal + Recreate**: Reverse original transaction lines, then create new lines (cleaner, preserves audit trail)
2. **In-place Update**: Directly modify transaction lines and recalculate deltas (more complex, harder to audit)

**Recommendation**: Use Reversal + Recreate approach for these reasons:
- Simpler inventory calculation logic
- Better audit trail (original values preserved in transaction history)
- Consistent with how adjustments work
- Matches user expectation from issue: "if I added 50 Advil, but updated later to 75 Advil, the Advil component should reflect that change right away"

**Implementation Note**: The transaction ID stays the same, but internally we:
1. Reverse all original transaction line effects
2. Delete old transaction lines
3. Create new transaction lines with updated values
4. For builds: recalculate lot consumption and finished goods

---

## Phase 1: Types Layer

### Subtask 1.1: Create Transaction Edit Types
**File**: `src/types/transaction-edit.ts` (NEW)
**Pattern**: Follow `src/types/draft.ts` structure
**Instructions**:
1. Create Zod schemas for each transaction type's editable fields:
```typescript
import { z } from 'zod'

// Base update schema for all transaction types
export const updateTransactionBaseSchema = z.object({
  date: z.coerce.date().optional(),
  notes: z.string().optional().nullable(),
  locationId: z.string().uuid('Invalid location ID').optional(),
})

// Receipt transaction update schema
export const updateReceiptSchema = updateTransactionBaseSchema.extend({
  componentId: z.string().uuid('Invalid component ID'),
  quantity: z.coerce.number().positive('Quantity must be positive'),
  supplier: z.string().min(1, 'Supplier is required').max(100),
  costPerUnit: z.coerce.number().nonnegative().optional(),
  lotNumber: z.string().max(100).optional(),
  expiryDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Invalid date format').optional(),
})

// Adjustment transaction update schema
export const updateAdjustmentSchema = updateTransactionBaseSchema.extend({
  componentId: z.string().uuid('Invalid component ID'),
  quantity: z.coerce.number().refine((val) => val !== 0, 'Quantity cannot be zero'),
  reason: z.string().min(1, 'Reason is required').max(200),
})

// Initial transaction update schema
export const updateInitialSchema = updateTransactionBaseSchema.extend({
  componentId: z.string().uuid('Invalid component ID'),
  quantity: z.coerce.number().positive('Quantity must be positive'),
  costPerUnit: z.coerce.number().nonnegative().optional(),
})

// Transfer transaction update schema
export const updateTransferSchema = updateTransactionBaseSchema.extend({
  componentId: z.string().uuid('Invalid component ID'),
  quantity: z.coerce.number().positive('Quantity must be positive'),
  fromLocationId: z.string().uuid('Invalid from location ID'),
  toLocationId: z.string().uuid('Invalid to location ID'),
})

// Build transaction update schema
export const updateBuildSchema = updateTransactionBaseSchema.extend({
  unitsToBuild: z.coerce.number().int().positive('Units must be positive'),
  salesChannel: z.string().optional(),
  defectCount: z.coerce.number().int().nonnegative().optional().nullable(),
  defectNotes: z.string().optional().nullable(),
  affectedUnits: z.coerce.number().int().nonnegative().optional().nullable(),
  allowInsufficientInventory: z.boolean().default(false),
})

// Outbound transaction update schema
export const updateOutboundSchema = updateTransactionBaseSchema.extend({
  skuId: z.string().uuid('Invalid SKU ID'),
  salesChannel: z.string().min(1, 'Sales channel is required'),
  quantity: z.coerce.number().int().positive('Quantity must be positive'),
})

export type UpdateReceiptInput = z.infer<typeof updateReceiptSchema>
export type UpdateAdjustmentInput = z.infer<typeof updateAdjustmentSchema>
export type UpdateInitialInput = z.infer<typeof updateInitialSchema>
export type UpdateTransferInput = z.infer<typeof updateTransferSchema>
export type UpdateBuildInput = z.infer<typeof updateBuildSchema>
export type UpdateOutboundInput = z.infer<typeof updateOutboundSchema>
```
2. Export types for service layer use

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] All schemas compile without errors
- [ ] Types exported and importable

---

## Phase 2: Service Layer

### Subtask 2.1: Create Transaction Edit Service
**File**: `src/services/transaction-edit.ts` (NEW)
**Pattern**: Follow `src/services/inventory.ts` structure for atomic operations
**Instructions**:
1. Create the core update function structure:
```typescript
import { prisma } from '@/lib/db'
import { Prisma, TransactionType } from '@prisma/client'
import { getComponentQuantity } from './inventory'
import { getSkuQuantity } from './finished-goods'

/**
 * Reverse the inventory effects of a transaction
 * This is called before applying new values
 */
async function reverseTransactionEffects(
  tx: Prisma.TransactionClient,
  transactionId: string,
  companyId: string
): Promise<void> {
  const transaction = await tx.transaction.findUnique({
    where: { id: transactionId },
    include: {
      lines: true,
      finishedGoodsLines: true,
    },
  })

  if (!transaction) {
    throw new Error('Transaction not found')
  }

  // Reverse lot balance changes for lines with lots
  for (const line of transaction.lines) {
    if (line.lotId) {
      // Reverse: if original was negative (consumption), add back
      // if original was positive (receipt), subtract
      await tx.lotBalance.update({
        where: { lotId: line.lotId },
        data: {
          quantity: {
            decrement: line.quantityChange, // decrement reverses the original change
          },
        },
      })
    }
  }

  // Delete existing transaction lines (will recreate with new values)
  await tx.transactionLine.deleteMany({
    where: { transactionId },
  })

  // Delete existing finished goods lines
  await tx.finishedGoodsLine.deleteMany({
    where: { transactionId },
  })
}

/**
 * Update a receipt transaction
 */
export async function updateReceiptTransaction(params: {
  transactionId: string
  companyId: string
  userId: string
  input: UpdateReceiptInput
}): Promise<TransactionResult> {
  // Implementation following createReceiptTransaction pattern
  // 1. Verify transaction exists and belongs to company
  // 2. Verify transaction is approved status
  // 3. Verify component exists
  // 4. Use prisma.$transaction for atomicity
  // 5. Call reverseTransactionEffects
  // 6. Create new transaction lines
  // 7. Update lot balance if applicable
  // 8. Return updated transaction
}

// Similar functions for:
// - updateAdjustmentTransaction
// - updateInitialTransaction
// - updateTransferTransaction
// - updateBuildTransaction (most complex - handles lots, BOM, finished goods)
// - updateOutboundTransaction
```

2. Implement each update function following the creation functions in `inventory.ts`
3. Handle special cases:
   - Build: Must recalculate BOM costs, lot consumption, finished goods
   - Transfer: Must handle both locations
   - Outbound: Must handle finished goods balance

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] All update functions implemented
- [ ] Inventory reversal logic correct
- [ ] Lot balances updated correctly
- [ ] Build transactions handle finished goods

### Subtask 2.2: Add Type-Dispatch Update Function
**File**: `src/services/transaction-edit.ts`
**Instructions**:
Add a dispatcher function that routes to the correct update function based on transaction type:
```typescript
export async function updateTransaction(params: {
  transactionId: string
  companyId: string
  userId: string
  type: TransactionType
  input: Record<string, unknown>
}): Promise<TransactionResult> {
  const { type, ...rest } = params

  switch (type) {
    case 'receipt':
      return updateReceiptTransaction({ ...rest, input: rest.input as UpdateReceiptInput })
    case 'adjustment':
      return updateAdjustmentTransaction({ ...rest, input: rest.input as UpdateAdjustmentInput })
    // ... etc
    default:
      throw new Error(`Unsupported transaction type: ${type}`)
  }
}
```

**Completion Criteria**:
- [ ] Dispatcher function handles all transaction types
- [ ] TypeScript types are correct

---

## Phase 3: API Layer

### Subtask 3.1: Add PUT Handler to Transaction Route
**File**: `src/app/api/transactions/[id]/route.ts`
**Pattern**: Follow existing POST routes in `src/app/api/transactions/receipt/route.ts`
**Instructions**:
1. Add PUT export function after existing GET:
```typescript
import { updateTransaction } from '@/services/transaction-edit'
import {
  updateReceiptSchema,
  updateAdjustmentSchema,
  // ... other schemas
} from '@/types/transaction-edit'

// PUT /api/transactions/[id] - Update an approved transaction
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check role - Viewer cannot update transactions
    if (session.user.role === 'viewer') {
      return NextResponse.json(
        { error: 'You do not have permission to update transactions' },
        { status: 403 }
      )
    }

    const { id } = await params
    const body = await request.json()
    const selectedCompanyId = session.user.selectedCompanyId

    // First fetch the transaction to determine its type
    const existingTransaction = await prisma.transaction.findFirst({
      where: {
        id,
        companyId: selectedCompanyId,
        status: 'approved', // Can only edit approved transactions
      },
    })

    if (!existingTransaction) {
      return NextResponse.json(
        { error: 'Transaction not found or cannot be edited' },
        { status: 404 }
      )
    }

    // Validate input based on transaction type
    let validatedInput: Record<string, unknown>
    switch (existingTransaction.type) {
      case 'receipt':
        const receiptResult = updateReceiptSchema.safeParse(body)
        if (!receiptResult.success) {
          return NextResponse.json({ error: receiptResult.error.issues[0].message }, { status: 400 })
        }
        validatedInput = receiptResult.data
        break
      // ... handle other types
    }

    // Call the update service
    const updated = await updateTransaction({
      transactionId: id,
      companyId: selectedCompanyId,
      userId: session.user.id,
      type: existingTransaction.type,
      input: validatedInput,
    })

    return NextResponse.json({ data: updated })
  } catch (error) {
    console.error('Error updating transaction:', error)
    if (error instanceof Error) {
      return NextResponse.json({ error: error.message }, { status: 400 })
    }
    return NextResponse.json({ error: 'Failed to update transaction' }, { status: 500 })
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] PUT handler implemented
- [ ] All transaction types handled
- [ ] Proper authentication/authorization checks
- [ ] Validation errors return 400
- [ ] Updates return 200 with data

---

## Phase 4: Frontend Layer

### Subtask 4.1: Create Edit Transaction Page
**File**: `src/app/(dashboard)/transactions/[id]/edit/page.tsx` (NEW)
**Pattern**: Follow `src/app/(dashboard)/transactions/new/page.tsx` and `QuickEntryForm.tsx`
**Instructions**:
1. Create the edit page component:
```typescript
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useParams, useRouter } from 'next/navigation'
import Link from 'next/link'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { ArrowLeft, Save } from 'lucide-react'
import type { TransactionResponse } from '@/types/transaction'

export default function EditTransactionPage() {
  const params = useParams()
  const router = useRouter()
  const id = params.id as string

  const [transaction, setTransaction] = useState<TransactionResponse | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [isSaving, setIsSaving] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Form state - initialized from fetched transaction
  const [formData, setFormData] = useState<Record<string, unknown>>({})

  // Fetch transaction on mount
  useEffect(() => {
    async function fetchTransaction() {
      try {
        const res = await fetch(`/api/transactions/${id}`)
        if (!res.ok) throw new Error('Failed to load transaction')
        const data = await res.json()
        setTransaction(data.data)
        // Initialize form with transaction data
        initializeFormData(data.data)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred')
      } finally {
        setIsLoading(false)
      }
    }
    fetchTransaction()
  }, [id])

  // Initialize form based on transaction type
  const initializeFormData = (tx: TransactionResponse) => {
    // Set form fields based on transaction type
    // Similar to how QuickEntryForm handles each type
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsSaving(true)
    setError(null)

    try {
      const res = await fetch(`/api/transactions/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      })

      const data = await res.json()
      if (!res.ok) throw new Error(data.error || 'Failed to update')

      // Success - redirect to transaction detail
      router.push(`/transactions/${id}`)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsSaving(false)
    }
  }

  // Render form fields based on transaction type
  // Follow QuickEntryForm pattern for each type
}
```

2. Implement form fields for each transaction type (receipt, adjustment, build, etc.)
3. Add validation before submit
4. Handle success/error states

**Completion Criteria**:
- [ ] Edit page loads transaction data
- [ ] Form pre-populated with current values
- [ ] All transaction types supported
- [ ] Submit updates transaction
- [ ] Redirects to detail on success

### Subtask 4.2: Add Edit Button to Transaction Detail
**File**: `src/components/features/TransactionDetail.tsx`
**Pattern**: Follow existing button patterns in the component
**Instructions**:
1. Import Link and Pencil icon:
```typescript
import Link from 'next/link'
import { Pencil } from 'lucide-react'
```

2. Add Edit button in the header section (after the date display):
```typescript
// In the CardHeader div, add after the date display:
<div className="flex items-center gap-2">
  <Link href={`/transactions/${transaction.id}/edit`}>
    <Button variant="outline" size="sm">
      <Pencil className="h-4 w-4 mr-2" />
      Edit
    </Button>
  </Link>
</div>
```

3. Note: Edit button should be visible to all users except viewers (role check needed)

**Completion Criteria**:
- [ ] Edit button visible on transaction detail
- [ ] Button links to edit page
- [ ] Proper styling consistent with UI

### Subtask 4.3: Update Transaction Detail Page for Edit Navigation
**File**: `src/app/(dashboard)/transactions/[id]/page.tsx`
**Instructions**:
1. Pass user role to TransactionDetail component (if not already available)
2. Or handle role check in TransactionDetail component via useSession

The current TransactionDetail component doesn't check roles. We need to either:
- Pass role as prop from page
- Use useSession in TransactionDetail

**Completion Criteria**:
- [ ] Edit button respects user role (viewers cannot edit)

---

## Phase 5: Testing & Validation

### Subtask 5.1: Manual Testing Checklist
**Instructions**:
Test the following scenarios in the test environment (http://172.16.20.50:2345):

1. **Receipt Edit**:
   - [ ] Create a receipt transaction for component X with quantity 50
   - [ ] Edit to change quantity to 75
   - [ ] Verify component quantity increased by 25

2. **Adjustment Edit**:
   - [ ] Create adjustment -10 for component Y
   - [ ] Edit to change to -15
   - [ ] Verify component quantity decreased by additional 5

3. **Build Edit**:
   - [ ] Create build for 5 units of SKU Z
   - [ ] Edit to change to 10 units
   - [ ] Verify component consumption doubled
   - [ ] Verify finished goods quantity updated

4. **Transfer Edit**:
   - [ ] Create transfer of 20 units from Location A to B
   - [ ] Edit to change to 30 units
   - [ ] Verify both location quantities updated correctly

5. **Outbound Edit**:
   - [ ] Create outbound of 5 SKU units
   - [ ] Edit to change to 8 units
   - [ ] Verify finished goods decreased by additional 3

6. **Edge Cases**:
   - [ ] Viewer role cannot see edit button
   - [ ] Editing with insufficient inventory shows error
   - [ ] Concurrent edits are handled (optimistic locking if implemented)

**Completion Criteria**:
- [ ] All test scenarios pass
- [ ] Inventory calculations are correct
- [ ] UI displays appropriate feedback

### Subtask 5.2: Build Verification
**Instructions**:
```bash
# TypeScript check
npx tsc --noEmit

# Build check
npm run build

# Lint check
npm run lint
```

**Completion Criteria**:
- [ ] No TypeScript errors
- [ ] Build succeeds
- [ ] No lint errors

---

## Summary of Deliverables

**Files Created**: 3
- `src/types/transaction-edit.ts` - Zod schemas for transaction updates
- `src/services/transaction-edit.ts` - Service layer for transaction editing
- `src/app/(dashboard)/transactions/[id]/edit/page.tsx` - Edit page UI

**Files Modified**: 3
- `src/app/api/transactions/[id]/route.ts` - Add PUT handler
- `src/components/features/TransactionDetail.tsx` - Add edit button
- `src/app/(dashboard)/transactions/[id]/page.tsx` - Minor updates if needed for role handling

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 0 decision first)
2. Complete Phase 1 (types) before Phase 2 (services)
3. Test completion criteria before moving to next subtask
4. Follow reference patterns exactly
5. Key complexity areas:
   - Build transaction editing (lot consumption reversal, finished goods)
   - Transfer transaction editing (dual location updates)
   - Inventory consistency after edit

## Test Strategy Note
- Use Vitest for unit tests if adding service layer tests
- Manual testing is primary for this feature due to inventory complexity
- Focus on component quantity verification after edits

## Architectural Notes

### Key Consideration: Reversal Logic
The most complex part of this feature is correctly reversing the original transaction effects. For each transaction type:

| Type | Reversal Steps |
|------|---------------|
| Receipt | Subtract original quantity from component, reverse lot balance |
| Adjustment | Reverse quantity change (add becomes subtract, vice versa) |
| Initial | Subtract original quantity |
| Transfer | Add back to fromLocation, subtract from toLocation |
| Build | Add back consumed components, reverse lot consumption, remove finished goods |
| Outbound | Add back to finished goods inventory |

### Data Integrity
- All updates MUST use Prisma transactions (`prisma.$transaction`)
- Lot balances must never go negative
- Finished goods balances must never go negative (unless allowNegativeInventory setting)

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 45m |
| Validation | 15m |
| Planning | 30m |
| **Total** | **90m** |
