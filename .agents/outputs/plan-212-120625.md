# Implementation Plan
**Generated**: 2025-12-06T12:06:25
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #212
**Estimated Build Time**: 8-10 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature (Phase 2 of chatbot)
**Source**: GitHub Issue #212
**Priority**: High

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="chatbot"` for E2E tests

### Issue Validation
**Status**: Valid
**Recent Changes**: Phase 1 completed in commit ea29bf1 on 2025-12-06
**Predecessor**: Issue #184 (closed, Phase 1 complete)

### Current State Assessment

**Existing Components**:
- `/home/pbrown/SkuInventory/src/lib/chatbot.ts` - Phase 1 implementation with system prompt and basic chat
- `/home/pbrown/SkuInventory/src/types/chatbot.ts` - ChatMessage, ChatRole, ChatResponse types
- `/home/pbrown/SkuInventory/src/app/api/chatbot/route.ts` - API endpoint (admin-only)
- `/home/pbrown/SkuInventory/src/components/features/ChatbotPanel.tsx` - UI component
- `/home/pbrown/SkuInventory/src/services/bom.ts` - Contains `calculateMaxBuildableUnits` and `calculateLimitingFactors`
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Contains `getComponentQuantity`, `getComponentQuantities`, `getComponentQuantitiesByLocation`
- `/home/pbrown/SkuInventory/src/services/feedback.ts` - Contains Octokit GitHub issue creation pattern

**Database**: No new models needed; read-only queries against existing models (SKU, Component, BOMVersion, BOMLine, Transaction, TransactionLine)

**API Routes**: Existing `/api/chatbot` needs modification to handle tool execution loop

**Types**: New types needed for tool definitions and tool results

### Dependencies & Blockers

1. **Anthropic SDK**: @anthropic-ai/sdk@0.71.0 installed - supports tool use
2. **Octokit**: @octokit/rest@22.0.1 installed - ready for GitHub issue creation
3. **Environment Variables**:
   - `ANTHROPIC_API_KEY` - Already configured
   - `GITHUB_API_TOKEN` - Already configured (gho_...)

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 8-10 hours
**Risk**: Medium (tool use API requires proper loop handling)

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/lib/chatbot.ts` - existing Claude API call pattern
**Secondary**: `/home/pbrown/SkuInventory/src/services/feedback.ts:366-386` - Octokit issue creation pattern
**Tertiary**: `/home/pbrown/SkuInventory/src/services/bom.ts:176-238` - calculateLimitingFactors pattern

### Ripple Effect Analysis
**Files Identified**: 6

| File | Reason |
|------|--------|
| `/home/pbrown/SkuInventory/src/lib/chatbot.ts` | Major modification - add tool definitions and execution loop |
| `/home/pbrown/SkuInventory/src/app/api/chatbot/route.ts` | Minor modification - pass conversation history, handle tool status |
| `/home/pbrown/SkuInventory/src/types/chatbot.ts` | Add tool-related types |
| `/home/pbrown/SkuInventory/src/lib/chatbot-tools.ts` | NEW - Tool definitions and handlers |
| `/home/pbrown/SkuInventory/src/services/chatbot-queries.ts` | NEW - Read-only Prisma queries for chatbot |
| `/home/pbrown/SkuInventory/tests/e2e/chatbot.spec.ts` | Add tool-related E2E tests |

---

## Executive Summary

This implementation adds Claude tool use (function calling) to the existing chatbot, enabling it to:
1. Query the database for real-time SKU buildable details, component inventory, and transaction history
2. Create GitHub issues (bugs/features) using Octokit SDK

The implementation involves creating tool definitions, a tool execution handler, read-only database query functions, and modifying the existing chatbot to support the tool use loop pattern.

---

## Phase 0: Environment Pre-flight

### Subtask 0.1: Verify Environment Dependencies
**Instructions**:
1. Verify `ANTHROPIC_API_KEY` is set in environment
2. Verify `GITHUB_API_TOKEN` is set in environment
3. Confirm Octokit is installed: `npm list @octokit/rest`
4. Confirm Anthropic SDK version supports tool use: `npm list @anthropic-ai/sdk`

**Completion Criteria**:
- [ ] Both environment variables confirmed present
- [ ] @octokit/rest@22.x confirmed
- [ ] @anthropic-ai/sdk@0.71.x confirmed

---

## Phase 1: Types Layer

### Subtask 1.1: Add Tool-Related Types to chatbot.ts Types
**File**: `/home/pbrown/SkuInventory/src/types/chatbot.ts`
**Pattern**: Follow existing type definitions in this file
**Instructions**:

Add the following types after the existing types:

```typescript
// Tool use types for Phase 2

// Tool call status (for UI feedback)
export type ToolCallStatus = 'idle' | 'calling' | 'success' | 'error'

// Tool call metadata for conversation
export interface ToolCallInfo {
  toolName: string
  input: Record<string, unknown>
  status: ToolCallStatus
  result?: unknown
  error?: string
}

// Extended chat message with tool calls
export interface ChatMessageWithTools extends ChatMessage {
  toolCalls?: ToolCallInfo[]
}

// Tool result types
export interface SkuBuildableDetails {
  skuCode: string
  skuName: string
  maxBuildable: number | null
  limitingComponents: Array<{
    componentName: string
    skuCode: string
    quantityOnHand: number
    quantityPerUnit: number
    maxBuildable: number
    rank: number
  }>
  bomLines: Array<{
    componentName: string
    skuCode: string
    quantityPerUnit: number
    quantityOnHand: number
  }>
}

export interface ComponentInventoryDetails {
  componentCode: string
  componentName: string
  totalQuantity: number
  byLocation: Array<{
    locationName: string
    locationType: string
    quantity: number
  }>
  recentTransactions: Array<{
    type: string
    date: string
    quantityChange: number
    notes: string | null
  }>
}

export interface TransactionHistoryResult {
  entityType: 'sku' | 'component'
  code: string
  transactions: Array<{
    id: string
    type: string
    date: string
    quantityChange?: number
    unitsBuild?: number
    notes: string | null
  }>
}

export interface CreateIssueResult {
  issueNumber: number
  issueUrl: string
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Types compile without errors
- [ ] All tool result types defined
- [ ] ToolCallInfo type for UI feedback defined

---

## Phase 2: Service Layer - Database Queries

### Subtask 2.1: Create Chatbot Queries Service
**File**: `/home/pbrown/SkuInventory/src/services/chatbot-queries.ts` (NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/bom.ts` for Prisma queries
**Instructions**:

Create a new service file with read-only Prisma queries:

```typescript
/**
 * Chatbot Queries Service
 *
 * Read-only Prisma queries for chatbot tool use.
 * All functions return data suitable for Claude to interpret and explain.
 */

import { prisma } from '@/lib/db'
import { calculateLimitingFactors, calculateMaxBuildableUnits } from './bom'
import { getComponentQuantity, getComponentQuantitiesByLocation } from './inventory'
import type {
  SkuBuildableDetails,
  ComponentInventoryDetails,
  TransactionHistoryResult,
} from '@/types/chatbot'

/**
 * Get SKU buildable details including limiting components and BOM lines
 * Used by chatbot to explain "why can I only build X units?"
 */
export async function getSkuBuildableDetails(
  skuCode: string,
  companyId: string
): Promise<SkuBuildableDetails | null> {
  // Find SKU by internal code
  const sku = await prisma.sKU.findFirst({
    where: {
      internalCode: skuCode,
      companyId,
      isActive: true,
    },
    include: {
      bomVersions: {
        where: { isActive: true },
        include: {
          lines: {
            include: {
              component: {
                select: {
                  id: true,
                  name: true,
                  skuCode: true,
                },
              },
            },
          },
        },
      },
    },
  })

  if (!sku) {
    return null
  }

  // Calculate max buildable and limiting factors
  const maxBuildable = await calculateMaxBuildableUnits(sku.id)
  const limitingFactors = await calculateLimitingFactors(sku.id, undefined, 10) // Get top 10

  // Get BOM lines with current quantities
  const activeBom = sku.bomVersions[0]
  const bomLines: SkuBuildableDetails['bomLines'] = []

  if (activeBom) {
    for (const line of activeBom.lines) {
      const qty = await getComponentQuantity(line.componentId)
      bomLines.push({
        componentName: line.component.name,
        skuCode: line.component.skuCode,
        quantityPerUnit: line.quantityPerUnit.toNumber(),
        quantityOnHand: qty,
      })
    }
  }

  return {
    skuCode: sku.internalCode,
    skuName: sku.name,
    maxBuildable,
    limitingComponents: limitingFactors?.map((lf) => ({
      componentName: lf.componentName,
      skuCode: lf.skuCode,
      quantityOnHand: lf.quantityOnHand,
      quantityPerUnit: lf.quantityPerUnit,
      maxBuildable: lf.maxBuildable,
      rank: lf.rank,
    })) ?? [],
    bomLines,
  }
}

/**
 * Get component inventory details including breakdown by location
 * Used by chatbot to answer "how much of X do I have?"
 */
export async function getComponentInventoryDetails(
  componentCode: string,
  companyId: string
): Promise<ComponentInventoryDetails | null> {
  // Find component by SKU code
  const component = await prisma.component.findFirst({
    where: {
      skuCode: componentCode,
      companyId,
      isActive: true,
    },
    select: {
      id: true,
      name: true,
      skuCode: true,
    },
  })

  if (!component) {
    return null
  }

  // Get total quantity
  const totalQuantity = await getComponentQuantity(component.id)

  // Get breakdown by location
  const locationBreakdown = await getComponentQuantitiesByLocation(component.id, companyId)

  // Get recent transactions (last 10)
  const recentTx = await prisma.transactionLine.findMany({
    where: {
      componentId: component.id,
      transaction: { status: 'approved' },
    },
    include: {
      transaction: {
        select: {
          type: true,
          date: true,
          notes: true,
        },
      },
    },
    orderBy: { transaction: { createdAt: 'desc' } },
    take: 10,
  })

  return {
    componentCode: component.skuCode,
    componentName: component.name,
    totalQuantity,
    byLocation: locationBreakdown.map((loc) => ({
      locationName: loc.locationName,
      locationType: loc.locationType,
      quantity: loc.quantity,
    })),
    recentTransactions: recentTx.map((tx) => ({
      type: tx.transaction.type,
      date: tx.transaction.date.toISOString().split('T')[0],
      quantityChange: tx.quantityChange.toNumber(),
      notes: tx.transaction.notes,
    })),
  }
}

/**
 * Get transaction history for an entity (SKU or component)
 * Used by chatbot to explain recent changes
 */
export async function getTransactionHistory(
  entityType: 'sku' | 'component',
  code: string,
  companyId: string,
  limit: number = 10
): Promise<TransactionHistoryResult | null> {
  if (entityType === 'component') {
    const component = await prisma.component.findFirst({
      where: {
        skuCode: code,
        companyId,
        isActive: true,
      },
    })

    if (!component) return null

    const transactions = await prisma.transactionLine.findMany({
      where: {
        componentId: component.id,
        transaction: { status: 'approved' },
      },
      include: {
        transaction: {
          select: {
            id: true,
            type: true,
            date: true,
            notes: true,
          },
        },
      },
      orderBy: { transaction: { createdAt: 'desc' } },
      take: limit,
    })

    return {
      entityType: 'component',
      code,
      transactions: transactions.map((tx) => ({
        id: tx.transaction.id,
        type: tx.transaction.type,
        date: tx.transaction.date.toISOString().split('T')[0],
        quantityChange: tx.quantityChange.toNumber(),
        notes: tx.transaction.notes,
      })),
    }
  } else {
    const sku = await prisma.sKU.findFirst({
      where: {
        internalCode: code,
        companyId,
        isActive: true,
      },
    })

    if (!sku) return null

    const transactions = await prisma.transaction.findMany({
      where: {
        skuId: sku.id,
        status: 'approved',
      },
      select: {
        id: true,
        type: true,
        date: true,
        unitsBuild: true,
        notes: true,
      },
      orderBy: { createdAt: 'desc' },
      take: limit,
    })

    return {
      entityType: 'sku',
      code,
      transactions: transactions.map((tx) => ({
        id: tx.id,
        type: tx.type,
        date: tx.date.toISOString().split('T')[0],
        unitsBuild: tx.unitsBuild ?? undefined,
        notes: tx.notes,
      })),
    }
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Service file created at correct path
- [ ] All three query functions implemented
- [ ] All queries are read-only (no mutations)
- [ ] TypeScript compiles without errors

---

## Phase 3: Tool Definitions and Handlers

### Subtask 3.1: Create Chatbot Tools Library
**File**: `/home/pbrown/SkuInventory/src/lib/chatbot-tools.ts` (NEW)
**Pattern**: Follow Anthropic tool use documentation format
**Instructions**:

Create tool definitions and execution handler:

```typescript
/**
 * Chatbot Tools Library
 *
 * Defines Claude tools and handles their execution.
 * Tools enable the chatbot to query real data and create GitHub issues.
 */

import { Octokit } from '@octokit/rest'
import type { Tool, ToolUseBlock, ToolResultBlockParam } from '@anthropic-ai/sdk/resources/messages'
import {
  getSkuBuildableDetails,
  getComponentInventoryDetails,
  getTransactionHistory,
} from '@/services/chatbot-queries'
import type { CreateIssueResult } from '@/types/chatbot'

// GitHub configuration
const GITHUB_OWNER = 'PaultheAICoder'
const GITHUB_REPO = 'SkuInventoryDatabase'

/**
 * Tool definitions for Claude
 * These describe the available functions Claude can call
 */
export const CHATBOT_TOOLS: Tool[] = [
  {
    name: 'get_sku_buildable_details',
    description: 'Get detailed information about a SKU\'s buildable units, including the max buildable count, all limiting components ranked by constraint severity, and the full BOM (bill of materials) with current inventory levels. Use this to answer questions like "why can I only build X units of SKU Y?"',
    input_schema: {
      type: 'object' as const,
      properties: {
        skuCode: {
          type: 'string',
          description: 'The internal code of the SKU (e.g., "AMZ_3pk", "TGT_6pk")',
        },
      },
      required: ['skuCode'],
    },
  },
  {
    name: 'get_component_inventory',
    description: 'Get detailed inventory information for a component, including total quantity on hand, breakdown by location, and recent transactions. Use this to answer questions about component stock levels.',
    input_schema: {
      type: 'object' as const,
      properties: {
        componentCode: {
          type: 'string',
          description: 'The SKU code of the component (e.g., "Box-3pk", "Insert-Card")',
        },
      },
      required: ['componentCode'],
    },
  },
  {
    name: 'get_transaction_history',
    description: 'Get recent transaction history for a SKU or component. Use this to understand recent inventory changes, receipts, builds, or adjustments.',
    input_schema: {
      type: 'object' as const,
      properties: {
        entityType: {
          type: 'string',
          enum: ['sku', 'component'],
          description: 'Whether to look up transactions for a SKU or a component',
        },
        code: {
          type: 'string',
          description: 'The internal code (for SKU) or SKU code (for component)',
        },
        limit: {
          type: 'number',
          description: 'Maximum number of transactions to return (default: 10)',
        },
      },
      required: ['entityType', 'code'],
    },
  },
  {
    name: 'create_bug_issue',
    description: 'Create a GitHub issue for a bug report. Use this when the user confirms they want to report a bug or when data appears incorrect.',
    input_schema: {
      type: 'object' as const,
      properties: {
        title: {
          type: 'string',
          description: 'A concise title for the bug (e.g., "Component quantity mismatch: Box-3pk shows 234 but expected 500")',
        },
        description: {
          type: 'string',
          description: 'Detailed description of the bug including what was expected vs what was observed',
        },
        severity: {
          type: 'string',
          enum: ['critical', 'high', 'medium', 'low'],
          description: 'Severity of the bug',
        },
        errorDetails: {
          type: 'string',
          description: 'Optional technical error details or data snapshots',
        },
      },
      required: ['title', 'description', 'severity'],
    },
  },
  {
    name: 'create_feature_issue',
    description: 'Create a GitHub issue for a feature request. Use this when the user wants to request new functionality or improvements.',
    input_schema: {
      type: 'object' as const,
      properties: {
        title: {
          type: 'string',
          description: 'A concise title for the feature request',
        },
        description: {
          type: 'string',
          description: 'Detailed description of the desired feature and its value',
        },
        userStory: {
          type: 'string',
          description: 'Optional user story in format "As a [role], I want [action] so that [benefit]"',
        },
      },
      required: ['title', 'description'],
    },
  },
]

/**
 * Execute a tool call and return the result
 */
export async function executeTool(
  toolUse: ToolUseBlock,
  companyId: string
): Promise<ToolResultBlockParam> {
  const { name, id, input } = toolUse
  const toolInput = input as Record<string, unknown>

  console.log(`[Chatbot] Executing tool: ${name}`, toolInput)

  try {
    let result: unknown

    switch (name) {
      case 'get_sku_buildable_details': {
        const skuCode = toolInput.skuCode as string
        result = await getSkuBuildableDetails(skuCode, companyId)
        if (!result) {
          result = { error: `SKU "${skuCode}" not found` }
        }
        break
      }

      case 'get_component_inventory': {
        const componentCode = toolInput.componentCode as string
        result = await getComponentInventoryDetails(componentCode, companyId)
        if (!result) {
          result = { error: `Component "${componentCode}" not found` }
        }
        break
      }

      case 'get_transaction_history': {
        const entityType = toolInput.entityType as 'sku' | 'component'
        const code = toolInput.code as string
        const limit = (toolInput.limit as number) || 10
        result = await getTransactionHistory(entityType, code, companyId, limit)
        if (!result) {
          result = { error: `${entityType} "${code}" not found` }
        }
        break
      }

      case 'create_bug_issue': {
        result = await createBugIssue({
          title: toolInput.title as string,
          description: toolInput.description as string,
          severity: toolInput.severity as string,
          errorDetails: toolInput.errorDetails as string | undefined,
        })
        break
      }

      case 'create_feature_issue': {
        result = await createFeatureIssue({
          title: toolInput.title as string,
          description: toolInput.description as string,
          userStory: toolInput.userStory as string | undefined,
        })
        break
      }

      default:
        result = { error: `Unknown tool: ${name}` }
    }

    console.log(`[Chatbot] Tool ${name} result:`, result)

    return {
      type: 'tool_result',
      tool_use_id: id,
      content: JSON.stringify(result),
    }
  } catch (error) {
    console.error(`[Chatbot] Tool ${name} error:`, error)
    return {
      type: 'tool_result',
      tool_use_id: id,
      content: JSON.stringify({
        error: error instanceof Error ? error.message : 'Tool execution failed',
      }),
      is_error: true,
    }
  }
}

/**
 * Create a bug issue on GitHub
 */
async function createBugIssue(params: {
  title: string
  description: string
  severity: string
  errorDetails?: string
}): Promise<CreateIssueResult> {
  const githubToken = process.env.GITHUB_API_TOKEN
  if (!githubToken) {
    throw new Error('GITHUB_API_TOKEN not configured')
  }

  const octokit = new Octokit({ auth: githubToken })

  const body = `## Reported Issue
**What's broken**: ${params.description}
**Severity**: ${params.severity}

${params.errorDetails ? `## Error Details\n\`\`\`\n${params.errorDetails}\n\`\`\`\n` : ''}

## Source
Reported via chatbot assistant.

---
*This issue was automatically created from a chatbot conversation.*`

  const { data: issue } = await octokit.issues.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: params.title,
    body,
    labels: ['bug'],
  })

  return {
    issueNumber: issue.number,
    issueUrl: issue.html_url,
  }
}

/**
 * Create a feature issue on GitHub
 */
async function createFeatureIssue(params: {
  title: string
  description: string
  userStory?: string
}): Promise<CreateIssueResult> {
  const githubToken = process.env.GITHUB_API_TOKEN
  if (!githubToken) {
    throw new Error('GITHUB_API_TOKEN not configured')
  }

  const octokit = new Octokit({ auth: githubToken })

  const body = `## Feature Description
${params.description}

${params.userStory ? `## User Story\n${params.userStory}\n` : ''}

## Source
Requested via chatbot assistant.

---
*This issue was automatically created from a chatbot conversation.*`

  const { data: issue } = await octokit.issues.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: params.title,
    body,
    labels: ['enhancement'],
  })

  return {
    issueNumber: issue.number,
    issueUrl: issue.html_url,
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] All 5 tools defined with correct schemas
- [ ] executeTool function handles all tools
- [ ] GitHub issue creation uses Octokit (not gh CLI)
- [ ] All database queries are read-only
- [ ] Error handling for all tool calls
- [ ] TypeScript compiles without errors

---

## Phase 4: Chatbot Service Modification

### Subtask 4.1: Update Chatbot Library for Tool Use
**File**: `/home/pbrown/SkuInventory/src/lib/chatbot.ts`
**Pattern**: Follow Anthropic tool use documentation
**Instructions**:

Modify the existing chatbot.ts to support tool use. Key changes:

1. Import the tools and executor
2. Update the system prompt to mention tool capabilities
3. Add tool use loop to handle tool calls
4. Pass companyId for database queries

```typescript
// Add imports at top
import { CHATBOT_TOOLS, executeTool } from './chatbot-tools'
import type { MessageParam, ContentBlock, ToolUseBlock, ToolResultBlockParam } from '@anthropic-ai/sdk/resources/messages'

// Update SYSTEM_PROMPT to add section about tool capabilities (add before "## Your Role"):
/*
## Tool Capabilities (Phase 2)
You now have access to real data through these tools:
- **get_sku_buildable_details**: Get actual max buildable units, limiting components, and BOM for any SKU
- **get_component_inventory**: Get component quantities by location and recent transactions
- **get_transaction_history**: Get recent transaction history for SKUs or components
- **create_bug_issue**: Create a GitHub issue for bug reports
- **create_feature_issue**: Create a GitHub issue for feature requests

When users ask about specific data (like "why is my max buildable 234?"), USE THE TOOLS to get real information. Don't guess or provide hypothetical examples when you can look up actual data.

When creating issues, always confirm with the user before calling create_bug_issue or create_feature_issue.
*/

// Add new function signature with companyId parameter
export async function sendChatMessage(
  userMessage: string,
  conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }> = [],
  companyId?: string
): Promise<ChatResponse> {
  // ... existing API key check code ...

  try {
    // Build messages array including conversation history
    const messages: MessageParam[] = [
      ...conversationHistory.map(msg => ({
        role: msg.role as 'user' | 'assistant',
        content: msg.content,
      })),
      { role: 'user', content: userMessage },
    ]

    // Initial API call with tools
    let response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1024,
      system: SYSTEM_PROMPT,
      messages,
      tools: companyId ? CHATBOT_TOOLS : undefined, // Only provide tools if companyId available
    })

    // Tool use loop - handle tool calls until we get a final response
    while (response.stop_reason === 'tool_use' && companyId) {
      // Find all tool use blocks
      const toolUseBlocks = response.content.filter(
        (block): block is ToolUseBlock => block.type === 'tool_use'
      )

      // Execute all tool calls
      const toolResults: ToolResultBlockParam[] = await Promise.all(
        toolUseBlocks.map(toolUse => executeTool(toolUse, companyId))
      )

      // Add assistant response and tool results to messages
      messages.push({
        role: 'assistant',
        content: response.content,
      })
      messages.push({
        role: 'user',
        content: toolResults,
      })

      // Continue the conversation
      response = await anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1024,
        system: SYSTEM_PROMPT,
        messages,
        tools: CHATBOT_TOOLS,
      })
    }

    // Extract final text response
    const textContent = response.content.find((block): block is { type: 'text'; text: string } => block.type === 'text')
    const assistantContent = textContent?.text ?? 'I apologize, but I was unable to generate a response. Please try again.'

    return {
      message: {
        id: uuidv4(),
        role: 'assistant',
        content: assistantContent,
        timestamp: new Date(),
      },
      conversationId: generateConversationId(),
    }
  } catch (error) {
    // ... existing error handling ...
  }
}
```

**Important Notes**:
- Keep all existing error handling
- The tool use loop continues until stop_reason is not 'tool_use'
- Pass companyId through to executeTool for database queries

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] System prompt updated with tool capabilities
- [ ] Tool use loop implemented
- [ ] companyId parameter added to sendChatMessage
- [ ] All existing functionality preserved
- [ ] TypeScript compiles without errors
- [ ] Build succeeds

### Subtask 4.2: Update API Route to Pass CompanyId
**File**: `/home/pbrown/SkuInventory/src/app/api/chatbot/route.ts`
**Pattern**: Follow existing session pattern
**Instructions**:

Update the API route to:
1. Extract companyId from session
2. Pass companyId to sendChatMessage
3. Optionally pass conversation history

```typescript
// In POST handler, after auth check:
const companyId = session.user.companyId

// Update sendChatMessage call:
const response = await sendChatMessage(message, [], companyId)
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] companyId extracted from session
- [ ] companyId passed to sendChatMessage
- [ ] Build succeeds

---

## Phase 5: Testing

### Subtask 5.1: Add E2E Tests for Tool Use
**File**: `/home/pbrown/SkuInventory/tests/e2e/chatbot.spec.ts`
**Pattern**: Follow existing chatbot tests
**Instructions**:

Add new tests at the end of the file:

```typescript
test.describe('Chatbot Tool Use (Issue #212)', () => {
  test('Chatbot API can handle data query questions', async ({ page }) => {
    await loginAsAdmin(page)
    await page.waitForLoadState('networkidle')

    // Make request asking about buildable units (will use tool)
    const response = await page.request.post('/api/chatbot', {
      data: { message: 'How does max buildable calculation work?' },
    })

    // Should return 200
    expect([200, 500]).toContain(response.status())

    if (response.status() === 200) {
      const data = await response.json()
      expect(data.data).toBeDefined()
      expect(data.data.message.content).toBeDefined()
      // Response should mention buildable or limiting
      expect(data.data.message.content.toLowerCase()).toMatch(/buildable|limiting|component/i)
    }
  })
})
```

**Validation**:
```bash
npx playwright test tests/e2e/chatbot.spec.ts --headed
```

**Completion Criteria**:
- [ ] New test added for tool use functionality
- [ ] Test passes when run against test environment

---

## Phase 6: Final Validation

### Subtask 6.1: Run Full Validation Suite
**Instructions**:

1. TypeScript check:
```bash
npx tsc --noEmit
```

2. Build check:
```bash
npm run build
```

3. Lint check:
```bash
npm run lint
```

4. Unit tests:
```bash
npm test
```

5. E2E tests (chatbot focused):
```bash
npx playwright test tests/e2e/chatbot.spec.ts
```

**Completion Criteria**:
- [ ] TypeScript: 0 errors
- [ ] Build: SUCCESS
- [ ] Lint: 0 errors, 0 warnings
- [ ] Unit tests: All pass
- [ ] E2E tests: All pass

---

## Summary of Deliverables

**Files Created**: 2
- `/home/pbrown/SkuInventory/src/lib/chatbot-tools.ts` - Tool definitions and handlers
- `/home/pbrown/SkuInventory/src/services/chatbot-queries.ts` - Read-only database queries

**Files Modified**: 3
- `/home/pbrown/SkuInventory/src/types/chatbot.ts` - Add tool-related types
- `/home/pbrown/SkuInventory/src/lib/chatbot.ts` - Add tool use support
- `/home/pbrown/SkuInventory/src/app/api/chatbot/route.ts` - Pass companyId

**Test Files Modified**: 1
- `/home/pbrown/SkuInventory/tests/e2e/chatbot.spec.ts` - Add tool use tests

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 0 through Phase 6)
2. Complete Phase 0 environment verification before proceeding
3. Test completion criteria before moving to next subtask
4. Follow reference patterns exactly
5. Run validation commands after each phase
6. Do NOT skip any validation steps

## Test Strategy Note
- Use Vitest for unit tests
- Use Playwright for E2E tests
- Focus E2E tests on tool use scenarios

## Security Considerations
- All database queries are READ-ONLY (use Prisma, not raw SQL)
- GitHub issues created via Octokit SDK (not gh CLI)
- Tool calls are logged with console.log for audit trail
- All tools require admin authentication (enforced at API route level)

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 20m |
| **Total** | **55m** |
