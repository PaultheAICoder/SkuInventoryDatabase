# Implementation Plan
**Generated**: 2024-12-04T18:40:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #160
**Estimated Build Time**: 4-6 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Enhancement (Missing Feature)
**Source**: GitHub Issue #160
**Priority**: Medium

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="company"` (for related test files)

### Issue Validation
**Status**: Valid
**Recent Changes**: Company management added in commit 95b3255 (feat(issue #92): add company management admin page with CRUD operations)

### Current State Assessment

**Existing Components**:
- `/src/app/(dashboard)/settings/companies/[id]/edit/page.tsx` - Edit company page (loads company data, renders CompanyForm)
- `/src/components/features/CompanyForm.tsx` - Form component (only shows name field, displays brandCount as read-only text)
- `/src/app/api/companies/[id]/route.ts` - GET/PATCH/DELETE handlers (only updates name field)
- `/src/types/company.ts` - Types and Zod schemas (no brand array support)

**Database**:
- Brand model has `companyId` FK to Company (one brand belongs to one company)
- No many-to-many relationship - brands are owned by companies directly
- Changing brand association means updating `brand.companyId`

**API Routes**:
- `GET /api/companies/[id]` - Returns company with brandCount (not brand list)
- `PATCH /api/companies/[id]` - Only accepts `name` field
- `GET /api/brands` - Returns brands for SELECTED company (scoped by session)

**Types**:
- `CompanyResponse` only has `brandCount: number`, no `brands` array
- `updateCompanySchema` only validates `name` field

### Dependencies & Blockers

1. **API Scoping Issue**: The `/api/brands` endpoint is scoped to `session.user.selectedCompanyId`, which means it returns brands for the currently selected company in the session, NOT for an arbitrary company being edited. We need a new endpoint or query param to fetch brands for a specific company.

2. **Brand Reassignment Logic**: Moving a brand between companies could orphan components/SKUs. Need to validate or prevent this.

**Can Proceed?**: YES - With careful handling of brand scoping

### Complexity Assessment
**Complexity**: Medium
**Effort**: 4-6 hours
**Risk**: Low-Medium (brand reassignment could affect data integrity)

### Patterns Identified

**Primary**: `/src/components/features/BrandForm.tsx` (lines 70-128) - Form structure with Card, checkbox handling
**Secondary**: `/src/app/api/brands/[id]/route.ts` - PATCH handler pattern for updating resources

### Ripple Effect Analysis

**Files to Modify**: 5

| File | Change | Impact |
|------|--------|--------|
| `src/types/company.ts` | Add `brands` array to response type, add brandIds to update schema | Low |
| `src/app/api/companies/[id]/route.ts` | Include brands in GET, handle brandIds in PATCH | Medium |
| `src/components/features/CompanyForm.tsx` | Add checkbox list for brand management | Medium |
| `src/app/api/brands/route.ts` | Add optional `companyId` query param for admin override | Low |
| `src/app/(dashboard)/settings/companies/[id]/edit/page.tsx` | Fetch and pass available brands | Low |

**Indirect Callers**: None identified - changes are isolated to company edit flow

---

## Executive Summary

This implementation adds the ability to manage brand associations when editing a company. The edit page will show a list of checkboxes for all existing brands (from any company), allowing admins to check/uncheck which brands belong to the company being edited. The API will be updated to handle brand reassignment safely, including validation to prevent orphaning components or SKUs.

---

## Phase 1: Types Layer

### Subtask 1.1: Update Company Types
**File**: `/home/pbrown/SkuInventory/src/types/company.ts`
**Pattern**: Follow existing Zod schema patterns in this file
**Instructions**:
1. Add a new `BrandInfo` interface for brand data returned with company:
```typescript
export interface BrandInfo {
  id: string
  name: string
  isActive: boolean
  componentCount: number
  skuCount: number
}
```

2. Extend `CompanyResponse` to include optional brands array:
```typescript
export interface CompanyResponse {
  id: string
  name: string
  userCount: number
  brandCount: number
  brands?: BrandInfo[]  // Add this line
  createdAt: string
  updatedAt: string
}
```

3. Update `updateCompanySchema` to accept optional brandIds array:
```typescript
export const updateCompanySchema = z.object({
  name: z.string().min(1, 'Name is required').max(100, 'Name must be 100 characters or less').optional(),
  brandIds: z.array(z.string().uuid()).optional(),
})
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] `BrandInfo` interface defined
- [ ] `CompanyResponse` includes optional `brands` array
- [ ] `updateCompanySchema` accepts `brandIds` array
- [ ] TypeScript compiles without errors

---

## Phase 2: API Layer

### Subtask 2.1: Update Company GET Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/companies/[id]/route.ts`
**Pattern**: Follow existing GET handler pattern (lines 8-58)
**Instructions**:

1. Update the Prisma query in the GET handler (around line 25-38) to include brands:
```typescript
const company = await prisma.company.findUnique({
  where: { id },
  select: {
    id: true,
    name: true,
    createdAt: true,
    updatedAt: true,
    brands: {
      select: {
        id: true,
        name: true,
        isActive: true,
        _count: {
          select: {
            components: true,
            skus: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    },
    _count: {
      select: {
        users: true,
        brands: true,
      },
    },
  },
})
```

2. Update the response mapping (around line 45-53) to include brands:
```typescript
return NextResponse.json({
  data: {
    id: company.id,
    name: company.name,
    userCount: company._count.users,
    brandCount: company._count.brands,
    brands: company.brands.map((b) => ({
      id: b.id,
      name: b.name,
      isActive: b.isActive,
      componentCount: b._count.components,
      skuCount: b._count.skus,
    })),
    createdAt: company.createdAt.toISOString(),
    updatedAt: company.updatedAt.toISOString(),
  },
})
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] GET endpoint returns brands array with each company
- [ ] Brand info includes id, name, isActive, componentCount, skuCount
- [ ] TypeScript compiles without errors

### Subtask 2.2: Update Company PATCH Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/companies/[id]/route.ts`
**Pattern**: Follow existing PATCH handler pattern (lines 61-149)
**Instructions**:

1. After the name uniqueness check (around line 110), add brand reassignment logic:
```typescript
// Handle brand reassignment if brandIds provided
if (validation.data.brandIds !== undefined) {
  const newBrandIds = validation.data.brandIds

  // Get current brands for this company
  const currentBrands = await prisma.brand.findMany({
    where: { companyId: id },
    select: { id: true },
  })
  const currentBrandIds = currentBrands.map((b) => b.id)

  // Find brands to add (not currently in this company)
  const brandsToAdd = newBrandIds.filter((bid) => !currentBrandIds.includes(bid))

  // Find brands to remove (currently in this company but not in new list)
  const brandsToRemove = currentBrandIds.filter((bid) => !newBrandIds.includes(bid))

  // Validate brands to remove don't have associated data
  if (brandsToRemove.length > 0) {
    const brandsWithData = await prisma.brand.findMany({
      where: {
        id: { in: brandsToRemove },
        OR: [
          { components: { some: {} } },
          { skus: { some: {} } },
        ],
      },
      select: { id: true, name: true },
    })

    if (brandsWithData.length > 0) {
      return NextResponse.json(
        {
          error: `Cannot remove brands with associated components or SKUs: ${brandsWithData.map((b) => b.name).join(', ')}`,
        },
        { status: 400 }
      )
    }
  }

  // Validate brands to add exist
  if (brandsToAdd.length > 0) {
    const existingBrands = await prisma.brand.findMany({
      where: { id: { in: brandsToAdd } },
      select: { id: true },
    })
    const existingIds = existingBrands.map((b) => b.id)
    const invalidIds = brandsToAdd.filter((bid) => !existingIds.includes(bid))

    if (invalidIds.length > 0) {
      return NextResponse.json(
        { error: `Invalid brand IDs: ${invalidIds.join(', ')}` },
        { status: 400 }
      )
    }
  }

  // Update brand associations in a transaction
  await prisma.$transaction(async (tx) => {
    // Remove brands from this company (set companyId to null or another company)
    // For safety, we'll just disassociate empty brands
    if (brandsToRemove.length > 0) {
      // Since brands MUST have a companyId (required FK), we cannot simply null it
      // Instead, we prevent removal if brand has data (checked above)
      // For truly empty brands, deletion might be more appropriate
      // For now, log a warning - the validation above prevents this case
      console.warn(`Removing ${brandsToRemove.length} brands from company ${id}`)
    }

    // Add brands to this company
    if (brandsToAdd.length > 0) {
      await tx.brand.updateMany({
        where: { id: { in: brandsToAdd } },
        data: { companyId: id },
      })
    }
  })
}
```

2. Wait - looking at the Prisma schema, `companyId` on Brand is required (not nullable). This means:
   - Brands must always belong to a company
   - "Removing" a brand from a company means either deleting it or moving it to another company
   - For this implementation, we should ONLY allow ADDING brands to the company (create new or reassign from other companies)
   - Removing should only work for empty brands (no components/SKUs)

Let me revise the approach. Update the PATCH handler with this logic instead:

```typescript
// Handle brand association updates if brandIds provided
if (validation.data.brandIds !== undefined) {
  const requestedBrandIds = validation.data.brandIds

  // Get current brands for this company
  const currentBrands = await prisma.brand.findMany({
    where: { companyId: id },
    select: {
      id: true,
      name: true,
      _count: { select: { components: true, skus: true } }
    },
  })
  const currentBrandIds = currentBrands.map((b) => b.id)

  // Brands to add to this company (reassign from other companies)
  const brandsToAdd = requestedBrandIds.filter((bid) => !currentBrandIds.includes(bid))

  // Brands to remove from this company
  const brandsToRemove = currentBrandIds.filter((bid) => !requestedBrandIds.includes(bid))

  // Validate: cannot remove brands that have components or SKUs
  if (brandsToRemove.length > 0) {
    const brandsWithData = currentBrands.filter(
      (b) => brandsToRemove.includes(b.id) && (b._count.components > 0 || b._count.skus > 0)
    )

    if (brandsWithData.length > 0) {
      return NextResponse.json(
        {
          error: `Cannot disassociate brands with components or SKUs: ${brandsWithData.map((b) => b.name).join(', ')}. Delete the brand's components and SKUs first.`,
        },
        { status: 400 }
      )
    }

    // For empty brands being removed, we'll delete them
    await prisma.brand.deleteMany({
      where: {
        id: { in: brandsToRemove },
        components: { none: {} },
        skus: { none: {} },
      },
    })
  }

  // Validate brands to add exist (and get their current company info)
  if (brandsToAdd.length > 0) {
    const brandsToReassign = await prisma.brand.findMany({
      where: { id: { in: brandsToAdd } },
      select: {
        id: true,
        name: true,
        companyId: true,
        _count: { select: { components: true, skus: true } }
      },
    })

    const foundIds = brandsToReassign.map((b) => b.id)
    const missingIds = brandsToAdd.filter((bid) => !foundIds.includes(bid))

    if (missingIds.length > 0) {
      return NextResponse.json(
        { error: `Brand IDs not found: ${missingIds.join(', ')}` },
        { status: 400 }
      )
    }

    // Warn about brands with data being moved (could orphan data)
    const brandsWithData = brandsToReassign.filter(
      (b) => b._count.components > 0 || b._count.skus > 0
    )
    if (brandsWithData.length > 0) {
      // Allow but warn - the components/SKUs will move with the brand
      console.warn(
        `Moving brands with data to company ${id}: ${brandsWithData.map((b) => `${b.name} (${b._count.components} components, ${b._count.skus} SKUs)`).join(', ')}`
      )
    }

    // Reassign brands to this company
    await prisma.brand.updateMany({
      where: { id: { in: brandsToAdd } },
      data: { companyId: id },
    })
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] PATCH endpoint accepts `brandIds` array
- [ ] Validates brands with data cannot be removed
- [ ] Empty brands are deleted when unchecked
- [ ] Brands from other companies can be reassigned
- [ ] TypeScript compiles without errors

### Subtask 2.3: Add All-Brands Endpoint for Admin
**File**: `/home/pbrown/SkuInventory/src/app/api/brands/route.ts`
**Pattern**: Follow existing GET handler (lines 9-95)
**Instructions**:

Add an optional `all=true` query parameter to return all brands across all companies (for admin use when editing a company):

1. Update the query parsing (around line 21-29) to include `all` param:
```typescript
const validation = brandListQuerySchema.safeParse(searchParams)
// ... existing validation ...

const { page, pageSize, search, isActive, sortBy, sortOrder } = validation.data

// Check for admin "all brands" mode
const showAll = searchParams.all === 'true'
```

2. Update the where clause building (around line 37-47):
```typescript
// Build where clause
const where: Prisma.BrandWhereInput = {}

// Only scope to company if NOT showing all (admin mode)
if (!showAll) {
  where.companyId = selectedCompanyId
}

if (search) {
  where.name = { contains: search, mode: 'insensitive' }
}

if (isActive !== undefined) {
  where.isActive = isActive
}
```

3. Update the select to include company info when showing all (around line 53-72):
```typescript
const brands = await prisma.brand.findMany({
  where,
  select: {
    id: true,
    name: true,
    isActive: true,
    companyId: true,  // Add this
    company: {         // Add this block
      select: {
        id: true,
        name: true,
      },
    },
    createdAt: true,
    updatedAt: true,
    _count: {
      select: {
        components: true,
        skus: true,
      },
    },
  },
  orderBy: {
    [sortBy]: sortOrder,
  },
  skip: (page - 1) * pageSize,
  take: pageSize,
})
```

4. Update the response mapping (around line 76-84) to include company info:
```typescript
return NextResponse.json({
  data: brands.map((brand) => ({
    id: brand.id,
    name: brand.name,
    isActive: brand.isActive,
    companyId: brand.companyId,
    companyName: brand.company?.name,
    componentCount: brand._count.components,
    skuCount: brand._count.skus,
    createdAt: brand.createdAt.toISOString(),
    updatedAt: brand.updatedAt.toISOString(),
  })),
  meta: {
    page,
    pageSize,
    total,
    totalPages: Math.ceil(total / pageSize),
  },
})
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] `GET /api/brands?all=true` returns brands from all companies
- [ ] Response includes `companyId` and `companyName` fields
- [ ] Non-admin mode (no `all` param) still scopes to selected company
- [ ] TypeScript compiles without errors

---

## Phase 3: Frontend Layer

### Subtask 3.1: Update Company Edit Page to Fetch Brands
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/companies/[id]/edit/page.tsx`
**Pattern**: Follow existing useEffect fetch pattern (lines 18-35)
**Instructions**:

1. Add state for all available brands (around line 16):
```typescript
const [allBrands, setAllBrands] = useState<Array<{
  id: string
  name: string
  isActive: boolean
  companyId: string
  companyName?: string
  componentCount: number
  skuCount: number
}>>([])
```

2. Add a second fetch for all brands in the useEffect (around line 18-35):
```typescript
useEffect(() => {
  async function fetchData() {
    try {
      // Fetch company and all brands in parallel
      const [companyRes, brandsRes] = await Promise.all([
        fetch(`/api/companies/${id}`),
        fetch('/api/brands?all=true&pageSize=100'),
      ])

      if (!companyRes.ok) {
        throw new Error('Company not found')
      }
      if (!brandsRes.ok) {
        throw new Error('Failed to load brands')
      }

      const companyData = await companyRes.json().catch(() => ({}))
      const brandsData = await brandsRes.json().catch(() => ({}))

      setCompany(companyData?.data)
      setAllBrands(brandsData?.data || [])
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  fetchData()
}, [id])
```

3. Pass allBrands to CompanyForm (around line 84):
```typescript
<CompanyForm company={company} allBrands={allBrands} />
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Edit page fetches all brands alongside company data
- [ ] Brands are passed to CompanyForm component
- [ ] Loading state handles both fetches
- [ ] TypeScript compiles without errors

### Subtask 3.2: Update CompanyForm with Brand Management UI
**File**: `/home/pbrown/SkuInventory/src/components/features/CompanyForm.tsx`
**Pattern**: Follow BrandForm checkbox pattern (`/home/pbrown/SkuInventory/src/components/features/BrandForm.tsx` lines 100-115)
**Instructions**:

1. Update imports (top of file):
```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Checkbox } from '@/components/ui/checkbox'
import { ScrollArea } from '@/components/ui/scroll-area'
import { Badge } from '@/components/ui/badge'
import type { CompanyResponse } from '@/types/company'
```

2. Update the props interface (around line 11):
```typescript
interface BrandOption {
  id: string
  name: string
  isActive: boolean
  companyId: string
  companyName?: string
  componentCount: number
  skuCount: number
}

interface CompanyFormProps {
  company?: CompanyResponse
  allBrands?: BrandOption[]
  onSuccess?: () => void
}
```

3. Update the component signature and add brand state (around line 16-24):
```typescript
export function CompanyForm({ company, allBrands = [], onSuccess }: CompanyFormProps) {
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Get initial selected brand IDs from company's brands
  const initialBrandIds = company?.brands?.map((b) => b.id) || []

  const [formData, setFormData] = useState({
    name: company?.name ?? '',
    selectedBrandIds: initialBrandIds,
  })

  const isEditing = !!company
```

4. Update handleSubmit to include brandIds (around line 36-39):
```typescript
const body: Record<string, unknown> = {
  name: formData.name,
}

if (isEditing) {
  body.brandIds = formData.selectedBrandIds
}
```

5. Add brand toggle handler (after handleSubmit function):
```typescript
const handleBrandToggle = (brandId: string, checked: boolean) => {
  setFormData((prev) => ({
    ...prev,
    selectedBrandIds: checked
      ? [...prev.selectedBrandIds, brandId]
      : prev.selectedBrandIds.filter((id) => id !== brandId),
  }))
}
```

6. Replace the existing brand count display (around lines 93-98) with a brand management section:
```typescript
{isEditing && allBrands.length > 0 && (
  <div className="space-y-3">
    <Label>Brand Associations</Label>
    <p className="text-xs text-muted-foreground">
      Select which brands belong to this company. Brands with components or SKUs cannot be removed.
    </p>
    <ScrollArea className="h-[200px] rounded-md border p-3">
      <div className="space-y-2">
        {allBrands.map((brand) => {
          const isChecked = formData.selectedBrandIds.includes(brand.id)
          const belongsToThisCompany = brand.companyId === company.id
          const hasData = brand.componentCount > 0 || brand.skuCount > 0
          const isDisabled = belongsToThisCompany && hasData && isChecked

          return (
            <div
              key={brand.id}
              className="flex items-center justify-between py-1"
            >
              <div className="flex items-center space-x-2">
                <Checkbox
                  id={`brand-${brand.id}`}
                  checked={isChecked}
                  onCheckedChange={(checked) => handleBrandToggle(brand.id, !!checked)}
                  disabled={isDisabled}
                />
                <Label
                  htmlFor={`brand-${brand.id}`}
                  className={`font-normal ${isDisabled ? 'text-muted-foreground' : ''}`}
                >
                  {brand.name}
                  {!brand.isActive && (
                    <Badge variant="secondary" className="ml-2 text-xs">
                      Inactive
                    </Badge>
                  )}
                </Label>
              </div>
              <div className="flex items-center gap-2 text-xs text-muted-foreground">
                {!belongsToThisCompany && brand.companyName && (
                  <Badge variant="outline" className="text-xs">
                    {brand.companyName}
                  </Badge>
                )}
                {hasData && (
                  <span>
                    {brand.componentCount} comp, {brand.skuCount} SKUs
                  </span>
                )}
              </div>
            </div>
          )
        })}
      </div>
    </ScrollArea>
    {formData.selectedBrandIds.length === 0 && (
      <p className="text-xs text-amber-600">
        Warning: Company has no brands selected
      </p>
    )}
  </div>
)}

{isEditing && allBrands.length === 0 && (
  <div className="text-sm text-muted-foreground">
    <p>Users: {company.userCount}</p>
    <p>Brands: {company.brandCount}</p>
  </div>
)}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] CompanyForm accepts allBrands prop
- [ ] Checkbox list shows all available brands
- [ ] Current company's brands are pre-checked
- [ ] Brands with data are disabled from being unchecked
- [ ] Brands from other companies show their current company name
- [ ] Form submits brandIds array on save
- [ ] TypeScript compiles without errors

---

## Phase 4: Update Brand Type (if needed)

### Subtask 4.1: Extend BrandResponse Type
**File**: `/home/pbrown/SkuInventory/src/types/brand.ts`
**Pattern**: Follow existing type pattern
**Instructions**:

Add optional company fields to BrandResponse (around line 34-42):
```typescript
export interface BrandResponse {
  id: string
  name: string
  isActive: boolean
  companyId?: string       // Add
  companyName?: string     // Add
  componentCount: number
  skuCount: number
  createdAt: string
  updatedAt: string
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] BrandResponse includes optional companyId and companyName
- [ ] TypeScript compiles without errors

---

## Phase 5: Validation & Testing

### Subtask 5.1: Build Verification
**Instructions**:
1. Run full build:
```bash
npm run build
```
2. Run TypeScript check:
```bash
npx tsc --noEmit
```
3. Run linter:
```bash
npm run lint
```

**Completion Criteria**:
- [ ] Build completes without errors
- [ ] No TypeScript errors
- [ ] No linting errors or warnings

### Subtask 5.2: Manual Testing Checklist
**Instructions**:
Test the following scenarios in the browser at `http://172.16.20.50:2345`:

1. **View company edit page**:
   - [ ] Navigate to Settings > Companies
   - [ ] Click Edit on a company
   - [ ] Verify brand checkboxes appear in a scrollable list
   - [ ] Verify current company's brands are pre-checked

2. **Add brand to company**:
   - [ ] Check an unchecked brand (from another company)
   - [ ] Click Save
   - [ ] Verify brand now shows in company's brand list
   - [ ] Verify brand was moved from previous company

3. **Remove empty brand**:
   - [ ] Uncheck a brand with 0 components and 0 SKUs
   - [ ] Click Save
   - [ ] Verify brand is deleted (not just unassigned)

4. **Cannot remove brand with data**:
   - [ ] Try to uncheck a brand with components or SKUs
   - [ ] Verify checkbox is disabled
   - [ ] Verify tooltip/message explains why

5. **Edge cases**:
   - [ ] Company with no brands - shows warning
   - [ ] Brand names display correctly
   - [ ] Inactive brands show badge
   - [ ] External brands show their current company name

**Completion Criteria**:
- [ ] All manual tests pass
- [ ] No console errors
- [ ] UI is responsive and usable

---

## Summary of Deliverables

**Files Modified**: 5
| File | Type | Description |
|------|------|-------------|
| `src/types/company.ts` | Types | Add BrandInfo interface, brands array to response, brandIds to update schema |
| `src/types/brand.ts` | Types | Add companyId/companyName to BrandResponse |
| `src/app/api/companies/[id]/route.ts` | API | Include brands in GET, handle brandIds in PATCH |
| `src/app/api/brands/route.ts` | API | Add `all=true` query param for admin brand listing |
| `src/components/features/CompanyForm.tsx` | UI | Add brand checkbox list with management logic |
| `src/app/(dashboard)/settings/companies/[id]/edit/page.tsx` | UI | Fetch all brands and pass to form |

**Files Created**: 0

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> 2 -> 3 -> 4 -> 5)
2. After each subtask, run `npx tsc --noEmit` to verify TypeScript
3. Test completion criteria before moving to next subtask
4. Follow reference patterns exactly
5. Pay attention to the brand removal logic - brands with data cannot be removed

## Important Implementation Notes

1. **Brand ownership model**: Brands MUST belong to a company (`companyId` is required). "Removing" a brand means either deleting it (if empty) or preventing removal (if has data).

2. **Data integrity**: When moving a brand from Company A to Company B, all associated components and SKUs move with it. This is intentional but should be logged/warned.

3. **UI disabled state**: Brands that have components or SKUs and belong to the current company should have disabled checkboxes to prevent accidental data loss.

4. **ScrollArea component**: Already exists at `/home/pbrown/SkuInventory/src/components/ui/scroll-area.tsx` - use for the brand list.

---

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 20m |
| **Total** | **40m** |
