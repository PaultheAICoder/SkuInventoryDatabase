# Implementation Plan
**Generated**: 2025-12-17T14:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #296
**Estimated Build Time**: 2-3 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Bug Fix
**Source**: GitHub Issue #296
**Priority**: High (data integrity issue)

### Task Classification
**Category**: BUG_FIX
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="build"` (run build-related tests)

### Issue Validation
**Status**: Valid - code analysis confirms the race condition exists
**Recent Changes**: None affecting this specific code path

### Current State Assessment

The race condition exists in `createBuildTransaction` function in `/home/pbrown/SkuInventory/src/services/inventory.ts`:

**Problem Location**: Lines 972-1000

1. **Lines 972-983**: BOM lines with component costs are fetched OUTSIDE the `prisma.$transaction` block
2. **Lines 985-988**: `unitBomCost` is calculated from these potentially stale costs
3. **Line 1000**: `prisma.$transaction` starts, but uses the pre-calculated `unitBomCost` and `totalBomCost`

**Root Cause**: If a component's `costPerUnit` is updated between the BOM line fetch (line 973) and the transaction commit (line 1000+), the recorded costs will be stale.

**Related Pattern**: The `approveDraftTransaction` function in `/home/pbrown/SkuInventory/src/services/draft-transaction.ts` has a similar issue at lines 387-404 where `checkInsufficientInventory` is called OUTSIDE the transaction block.

### Dependencies & Blockers
None - this is a self-contained fix in the service layer.

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 2-3 hours
**Risk**: Low - the fix is straightforward and follows existing patterns

### Patterns Identified
**Primary**: Existing transaction patterns in the same file that fetch data INSIDE `prisma.$transaction`
- `createReceiptTransaction` (lines 377-506) - correctly fetches component inside transaction
- `createInitialTransaction` (lines 598-656) - correctly fetches component inside transaction

**Secondary**: `updateBuildTransaction` in `/home/pbrown/SkuInventory/src/services/transaction-edit.ts` (lines 473-668) - already does BOM cost calculation inside transaction at lines 544-548

### Ripple Effect Analysis
**Files Identified**: 3

| File | Why Affected |
|------|--------------|
| `src/services/inventory.ts` | Primary fix - move BOM line fetch inside transaction |
| `src/services/draft-transaction.ts` | Similar pattern - move inventory check inside transaction |
| `tests/unit/build-finished-goods.test.ts` | Existing tests should still pass (no API change) |

**No breaking changes expected** - function signatures remain the same.

---

## Executive Summary

This fix addresses a race condition in the build transaction flow where component costs are fetched before the database transaction begins. If another process updates component costs between the fetch and the transaction commit, the recorded BOM cost snapshot will be incorrect. The fix moves the BOM line query inside the `prisma.$transaction` block to ensure atomicity.

A similar pattern exists in `approveDraftTransaction` where the inventory check happens outside the transaction, which could lead to approving a build when inventory has become insufficient.

---

## Phase 1: Fix createBuildTransaction Race Condition

### Subtask 1.1: Move BOM Lines Query Inside Transaction

**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Follow `createReceiptTransaction` pattern (lines 377-506) where component is fetched inside `tx`
**Lines to Modify**: 972-1000

**Current Code (BEFORE - lines 972-1000)**:
```typescript
  // Get BOM lines with component costs for snapshot
  const bomLines = await prisma.bOMLine.findMany({
    where: { bomVersionId },
    include: {
      component: {
        select: {
          id: true,
          costPerUnit: true,
        },
      },
    },
  })

  // Calculate unit BOM cost (snapshot at time of build)
  const unitBomCost = bomLines.reduce((total, line) => {
    return total + line.quantityPerUnit.toNumber() * line.component.costPerUnit.toNumber()
  }, 0)

  const totalBomCost = unitBomCost * unitsToBuild

  // ... other code ...

  // Use atomic transaction to create build transaction + finished goods line together
  const transactionResult = await prisma.$transaction(async (tx) => {
```

**Instructions**:
1. Move the BOM lines query (lines 973-983) INSIDE the `prisma.$transaction` block
2. Change `prisma.bOMLine.findMany` to `tx.bOMLine.findMany`
3. Move the `unitBomCost` and `totalBomCost` calculations inside the transaction block
4. The variables will need to be declared earlier or handled appropriately within the transaction scope

**New Code Structure (AFTER)**:
```typescript
  // Use atomic transaction to create build transaction + finished goods line together
  const transactionResult = await prisma.$transaction(async (tx) => {
    // Get BOM lines with component costs for snapshot - INSIDE transaction for atomicity
    const bomLines = await tx.bOMLine.findMany({
      where: { bomVersionId },
      include: {
        component: {
          select: {
            id: true,
            costPerUnit: true,
          },
        },
      },
    })

    // Calculate unit BOM cost (snapshot at time of build)
    const unitBomCost = bomLines.reduce((total, line) => {
      return total + line.quantityPerUnit.toNumber() * line.component.costPerUnit.toNumber()
    }, 0)

    const totalBomCost = unitBomCost * unitsToBuild

    // ... rest of transaction code continues ...
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
npm test -- --testPathPattern="build"
```

**Completion Criteria**:
- [ ] BOM lines query uses `tx.bOMLine.findMany` instead of `prisma.bOMLine.findMany`
- [ ] `unitBomCost` and `totalBomCost` calculations are inside the transaction
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] Existing build-related tests pass

---

## Phase 2: Fix approveDraftTransaction Similar Pattern

### Subtask 2.1: Move Inventory Check Inside Transaction

**File**: `/home/pbrown/SkuInventory/src/services/draft-transaction.ts`
**Pattern**: The inventory check at lines 387-401 happens OUTSIDE the transaction (line 404)
**Lines to Modify**: 385-404

**Current Code (BEFORE - lines 385-404)**:
```typescript
  try {
    // For build transactions, re-validate inventory availability
    if (draft.type === 'build' && draft.bomVersionId && draft.unitsBuild) {
      const insufficientItems = await checkInsufficientInventory({
        bomVersionId: draft.bomVersionId,
        companyId,
        unitsToBuild: draft.unitsBuild,
        locationId: draft.locationId ?? undefined,
      })

      if (insufficientItems.length > 0) {
        return {
          success: false,
          error: `Insufficient inventory for: ${insufficientItems.map((i) => i.componentName).join(', ')}`,
        }
      }
    }

    // Use a Prisma transaction to ensure atomicity
    const result = await prisma.$transaction(async (tx) => {
```

**Instructions**:
1. Move the `checkInsufficientInventory` call INSIDE the `prisma.$transaction` block
2. Note: `checkInsufficientInventory` itself uses `prisma` directly, so we need to create a version that accepts a transaction client OR restructure the check
3. For now, move the check inside the transaction and use the same prisma client (this provides serialization at the transaction level)
4. Alternative: Create `checkInsufficientInventoryTx` that accepts a transaction client

**Recommended Approach** (simpler - move logic inline):
Since `checkInsufficientInventory` is a read-only check, moving it inside the transaction is sufficient for most race conditions. The transaction will provide isolation.

**New Code Structure (AFTER)**:
```typescript
  try {
    // Use a Prisma transaction to ensure atomicity
    const result = await prisma.$transaction(async (tx) => {
      // For build transactions, re-validate inventory availability INSIDE transaction
      if (draft.type === 'build' && draft.bomVersionId && draft.unitsBuild) {
        const insufficientItems = await checkInsufficientInventory({
          bomVersionId: draft.bomVersionId,
          companyId,
          unitsToBuild: draft.unitsBuild,
          locationId: draft.locationId ?? undefined,
        })

        if (insufficientItems.length > 0) {
          throw new Error(
            `Insufficient inventory for: ${insufficientItems.map((i) => i.componentName).join(', ')}`
          )
        }
      }

      // ... rest of transaction code continues ...
```

**Note**: Since `checkInsufficientInventory` uses the global `prisma` client, this provides transaction-level serialization but not perfect isolation. For full isolation, we would need to refactor `checkInsufficientInventory` to accept a transaction client. This is acceptable for now as the primary concern is atomic writes.

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
npm test -- --testPathPattern="draft"
```

**Completion Criteria**:
- [ ] Inventory check is performed inside the transaction block
- [ ] Error is thrown (not returned) inside transaction to trigger rollback
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] Draft transaction tests pass

---

## Phase 3: Verification

### Subtask 3.1: Run Full Test Suite

**Instructions**:
1. Run all tests to ensure no regressions
2. Verify build transactions work correctly
3. Verify draft approval works correctly

**Validation Commands**:
```bash
npm run build
npx tsc --noEmit
npm test
npm run lint
```

**Completion Criteria**:
- [ ] All tests pass
- [ ] No TypeScript errors
- [ ] No lint errors
- [ ] Build succeeds

---

## Summary of Deliverables

**Files Created**: 0
**Files Modified**: 2
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Move BOM query inside transaction
- `/home/pbrown/SkuInventory/src/services/draft-transaction.ts` - Move inventory check inside transaction

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1, Phase 2, Phase 3)
2. Test completion criteria before next subtask
3. Follow reference patterns exactly
4. The function signatures do NOT change - this is purely an internal restructuring

## Test Strategy Note

- Use existing test suite - no new tests needed
- Focus on `npm test -- --testPathPattern="build"` for build transactions
- Focus on `npm test -- --testPathPattern="draft"` for draft transactions
- Full test suite for final verification

## Risk Assessment

**Risk Level**: Low
- No API changes
- No database schema changes
- Existing tests cover the functionality
- Changes are isolated to transaction ordering

**Potential Issues**:
- The `checkInsufficientInventory` function uses global `prisma` client, not transaction client
  - Mitigation: This is acceptable for reads; the transaction provides serialization
  - Future enhancement: Refactor to accept transaction client for full isolation

## Performance Metrics

| Phase | Estimated Duration |
|-------|----------|
| Phase 1 (createBuildTransaction fix) | 30-45m |
| Phase 2 (approveDraftTransaction fix) | 30-45m |
| Phase 3 (Verification) | 15-30m |
| **Total** | **75-120m** |
