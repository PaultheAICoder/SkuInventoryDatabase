# Implementation Plan
**Generated**: 2025-12-08T14:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #201
**Estimated Build Time**: 16-24 hours (Complex)
**Complexity**: High

## Investigation Summary

### Request Analysis
**Type**: Refactoring / Performance Enhancement
**Source**: GitHub Issue #201 (Sub-issue of #195 Architectural Audit)
**Priority**: Lower priority for V1 - V2 Candidate
**Labels**: enhancement, v2

### V2 Deferral Recommendation

**RECOMMENDATION: DEFER TO V2**

Based on the investigation, this issue should be deferred to V2 for the following reasons:

1. **Current System Works Correctly**: The inventory calculation via aggregation produces accurate results. This is a performance optimization, not a bug fix.

2. **Current Data Scale is Small**: Test database shows only 13 transactions and 13 transaction lines. The O(N) aggregation is negligible at this scale.

3. **High Implementation Risk**: The refactoring touches ALL transaction creation paths:
   - 6+ API routes (receipt, adjustment, initial, build, transfer, outbound)
   - 3 service files (inventory.ts, finished-goods.ts, transfer.ts, draft-transaction.ts)
   - Multiple batch operations (draft approval, import)
   - Complex atomic transaction handling

4. **Extensive Test Coverage Required**:
   - Existing tests are mock-based, not integration tests
   - New snapshot-based approach needs comprehensive verification
   - Backfill verification requires production-like data

5. **No Immediate Business Impact**: Users will not notice performance issues until transaction volume grows significantly (thousands of records).

6. **Dependencies Complete but Timing Risk**: While issues #198, #199, #200 are closed, making major architectural changes right before V1 release increases risk.

### If Implementation is Needed for V1

If business requirements dictate this must be done for V1, the plan below provides full implementation details. **However, I strongly recommend deferring.**

---

### Task Classification
**Category**: REFACTORING (Architectural)
**Test Strategy**: FULL - Requires comprehensive testing including integration tests and data verification
**Suggested Filter**: None - full suite required

### Issue Validation
**Status**: Valid
**Recent Changes**: Recent commits (b422d7e, 5a9e312, a85ca90) added companyId enforcement to service layers - dependencies met
**Dependencies**: #198, #199, #200 - ALL CLOSED

### Current State Assessment

**Existing Components:**
- `getComponentQuantity` - Single component, O(N) aggregation, ~130 lines
- `getComponentQuantities` - Batch, O(N) aggregation with location handling, ~130 lines
- `getComponentQuantitiesByLocation` - Per-location breakdown, calls getComponentQuantity in loop

**Database:**
- No ComponentBalance table exists
- No SkuBalance table exists (for finished goods)
- All inventory calculated from TransactionLine aggregation

**Transaction Creation Paths (ALL need modification):**
1. `src/services/inventory.ts`:
   - `createReceiptTransaction` (lines 346-507)
   - `createAdjustmentTransaction` (lines 512-568)
   - `createInitialTransaction` (lines 573-657)
   - `createBuildTransaction` (lines 911-1240)

2. `src/services/transfer.ts`:
   - `createTransferTransaction` (lines 35-175)

3. `src/services/finished-goods.ts`:
   - `adjustFinishedGoods` (lines 158-193)
   - `receiveFinishedGoods` (lines 199-239)
   - `transferFinishedGoods` (lines 244-322)
   - `createOutboundTransaction` (lines 328-377)

4. `src/services/draft-transaction.ts`:
   - `approveDraftTransaction` (lines 356-520) - Creates transaction lines on approval

**API Routes:**
- `/api/transactions/receipt/route.ts`
- `/api/transactions/adjustment/route.ts`
- `/api/transactions/initial/route.ts`
- `/api/transactions/build/route.ts`
- `/api/transactions/transfer/route.ts`
- `/api/transactions/outbound/route.ts`
- `/api/transactions/drafts/[id]/approve/route.ts`
- `/api/transactions/drafts/batch-approve/route.ts`
- `/api/import/initial-inventory/route.ts`
- `/api/import/inventory-snapshot/route.ts`

### Dependencies & Blockers
1. Multi-tenancy fixes (Issues #198, #199, #200) - **COMPLETED**
2. No technical blockers remaining

**Can Proceed?**: YES (if business decides V1 is required)

### Complexity Assessment
**Complexity**: HIGH (Complex)
**Effort**: 16-24 hours
**Risk**: MEDIUM-HIGH
- Many transaction creation paths to modify
- Need atomic balance updates within existing Prisma transactions
- Backfill script needs careful verification
- Risk of balance drift if any path is missed

### Patterns Identified
**Primary**: `LotBalance` table (prisma/schema.prisma lines 228-236)
- Already implements snapshot-based balance for lot tracking
- Uses `prisma.lotBalance.upsert` pattern
- Updated atomically within transaction create operations

**Secondary**: `FinishedGoodsLine` aggregation pattern
- Similar to current TransactionLine approach
- Could also benefit from balance table (future)

### Ripple Effect Analysis

**Schema Changes:**
- Add `ComponentBalance` model to `prisma/schema.prisma`

**Service Layer Changes (11 functions across 4 files):**

| File | Function | Change Type |
|------|----------|-------------|
| `src/services/inventory.ts` | `getComponentQuantity` | READ - Use balance table |
| `src/services/inventory.ts` | `getComponentQuantities` | READ - Use balance table |
| `src/services/inventory.ts` | `getComponentQuantitiesByLocation` | READ - Indirect |
| `src/services/inventory.ts` | `createReceiptTransaction` | WRITE - Add balance update |
| `src/services/inventory.ts` | `createAdjustmentTransaction` | WRITE - Add balance update |
| `src/services/inventory.ts` | `createInitialTransaction` | WRITE - Add balance update |
| `src/services/inventory.ts` | `createBuildTransaction` | WRITE - Add balance update per component |
| `src/services/transfer.ts` | `createTransferTransaction` | WRITE - Add balance update (2 locations) |
| `src/services/finished-goods.ts` | N/A (uses FinishedGoodsLine) | No changes needed |
| `src/services/draft-transaction.ts` | `approveDraftTransaction` | WRITE - Add balance update |

**Tests Requiring Updates:**
- `tests/unit/inventory-quantity.test.ts` - Mock balance table queries
- `tests/unit/inventory-service.test.ts` - Add balance update verification

**Total Files Affected:**
- Schema: 1
- Services: 3 (inventory.ts, transfer.ts, draft-transaction.ts)
- Tests: 2+
- Scripts: 1 (new backfill script)

---

## Executive Summary

This issue proposes refactoring the inventory calculation system from on-the-fly aggregation of `TransactionLine` entries to a snapshot-based approach using a new `ComponentBalance` table. The change improves query performance from O(N) to O(1) but requires modifying all 11+ transaction creation paths and running a backfill script for existing data.

**RECOMMENDATION: DEFER TO V2** - The current system works correctly, data scale is small, and the risk/effort ratio is unfavorable for V1.

---

## Phase 0: Pre-Implementation Verification

### Subtask 0.1: Verify Dependencies Are Complete
**Instructions**:
1. Confirm issues #198, #199, #200 are closed
2. Review recent commits to ensure companyId enforcement is in place
3. Run `npm run build` to verify current state is stable

**Completion Criteria**:
- [ ] All dependency issues confirmed closed
- [ ] Build passes without errors

---

## Phase 1: Database Schema Layer

### Subtask 1.1: Add ComponentBalance Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing `LotBalance` model (lines 228-236)
**Instructions**:

Add the following model after the `LotBalance` model (around line 237):

```prisma
model ComponentBalance {
  id          String   @id @default(uuid())
  componentId String
  component   Component @relation(fields: [componentId], references: [id])
  locationId  String?
  location    Location? @relation(fields: [locationId], references: [id])
  quantity    Decimal  @db.Decimal(10, 4)
  updatedAt   DateTime @updatedAt

  @@unique([componentId, locationId])
  @@index([componentId])
  @@index([locationId])
}
```

Also add relation to Component model (around line 199):
```prisma
  balances         ComponentBalance[]
```

And to Location model (around line 62):
```prisma
  componentBalances ComponentBalance[]
```

**Validation Commands**:
```bash
npx prisma validate
npx prisma format
```

**Completion Criteria**:
- [ ] Schema validates without errors
- [ ] Model includes componentId, locationId (nullable), quantity, updatedAt
- [ ] Unique constraint on [componentId, locationId]
- [ ] Relations added to Component and Location models

### Subtask 1.2: Create and Apply Migration
**File**: New migration in `/home/pbrown/SkuInventory/prisma/migrations/`
**Instructions**:

```bash
# Generate migration (test database)
DATABASE_URL="postgresql://inventory_test:inventory_test_2025@localhost:2346/inventory_test" npx prisma migrate dev --name add_component_balance

# Generate Prisma client
npx prisma generate
```

**Completion Criteria**:
- [ ] Migration file created
- [ ] Migration applies successfully to test database
- [ ] Prisma client regenerated
- [ ] `npx tsc --noEmit` passes

---

## Phase 2: Balance Update Functions

### Subtask 2.1: Create Balance Update Helper Function
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Follow `LotBalance` upsert in `createReceiptTransaction` (lines 417-428)
**Instructions**:

Add helper function after imports (around line 12):

```typescript
/**
 * Update component balance atomically within a transaction
 * Creates balance record if not exists, otherwise increments
 */
async function updateComponentBalance(
  tx: Prisma.TransactionClient,
  componentId: string,
  locationId: string | null,
  quantityChange: number
): Promise<void> {
  await tx.componentBalance.upsert({
    where: {
      componentId_locationId: {
        componentId,
        locationId: locationId ?? null,
      },
    },
    create: {
      componentId,
      locationId: locationId ?? null,
      quantity: new Prisma.Decimal(quantityChange),
    },
    update: {
      quantity: { increment: new Prisma.Decimal(quantityChange) },
    },
  })
}
```

**Completion Criteria**:
- [ ] Function handles both global (locationId=null) and location-specific balances
- [ ] Uses Prisma.TransactionClient for atomicity
- [ ] TypeScript compiles without errors

### Subtask 2.2: Update createReceiptTransaction
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 346-507
**Instructions**:

After transaction creation (around line 492), add balance update:

```typescript
// Update component balance
await updateComponentBalance(tx, componentId, locationIdToUse ?? null, quantity)
```

This should be inside the `prisma.$transaction` block.

**Completion Criteria**:
- [ ] Balance updated atomically with transaction
- [ ] locationIdToUse used for location-specific balance
- [ ] Existing functionality unchanged

### Subtask 2.3: Update createAdjustmentTransaction
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 512-568
**Instructions**:

Wrap existing code in `prisma.$transaction` and add balance update:

```typescript
return prisma.$transaction(async (tx) => {
  // ... existing component fetch logic moved here ...

  const transaction = await tx.transaction.create({
    // ... existing create logic ...
  })

  // Update component balance
  await updateComponentBalance(tx, componentId, locationIdToUse ?? null, quantity)

  return transaction
})
```

**Completion Criteria**:
- [ ] Converted to use Prisma transaction
- [ ] Balance updated with quantity (can be positive or negative)
- [ ] Existing functionality unchanged

### Subtask 2.4: Update createInitialTransaction
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 573-657
**Instructions**:

Already uses `prisma.$transaction`. Add balance update after transaction creation (around line 640):

```typescript
// Update component balance
await updateComponentBalance(tx, componentId, locationIdToUse ?? null, quantity)
```

**Completion Criteria**:
- [ ] Balance updated atomically
- [ ] Initial quantity added correctly
- [ ] Existing functionality unchanged

### Subtask 2.5: Update createBuildTransaction
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 911-1240
**Instructions**:

After consumption lines are created (around line 1180), add balance updates for each component:

```typescript
// Update component balances for all consumption lines
for (const line of consumptionLines) {
  await updateComponentBalance(
    tx,
    line.componentId,
    locationIdToUse ?? null,
    line.quantityChange.toNumber() // Already negative for consumption
  )
}
```

**Completion Criteria**:
- [ ] Balance decremented for each consumed component
- [ ] All components in BOM updated
- [ ] Handles lot-based and pooled consumption
- [ ] Existing functionality unchanged

### Subtask 2.6: Update createTransferTransaction
**File**: `/home/pbrown/SkuInventory/src/services/transfer.ts`
**Location**: Lines 35-175
**Instructions**:

After transaction creation (around line 157), add balance updates for both locations:

```typescript
// Update component balances for transfer
// Decrement at source location
await updateComponentBalance(tx, componentId, fromLocationId, -quantity)
// Increment at destination location
await updateComponentBalance(tx, componentId, toLocationId, quantity)
```

Need to import the helper:
```typescript
import { updateComponentBalance } from './inventory'
```

Or duplicate the helper in this file.

**Completion Criteria**:
- [ ] Source location balance decremented
- [ ] Destination location balance incremented
- [ ] Atomic within existing transaction
- [ ] Existing functionality unchanged

### Subtask 2.7: Update approveDraftTransaction
**File**: `/home/pbrown/SkuInventory/src/services/draft-transaction.ts`
**Location**: Lines 356-520
**Instructions**:

Add balance updates after transaction lines are created for each transaction type:

1. For build transactions (around line 448):
```typescript
// Update component balance for build consumption
await updateComponentBalance(tx, bomLine.componentId, draft.locationId ?? null, -requiredQty)
```

2. For receipt/adjustment/initial (after line 504):
```typescript
// For receipt, adjustment, initial - update balance based on existing line
if (draft.lines.length > 0) {
  const line = draft.lines[0]
  await updateComponentBalance(
    tx,
    line.componentId,
    draft.locationId ?? null,
    line.quantityChange.toNumber()
  )
}
```

3. For transfer (around line 502):
```typescript
// Update both location balances for transfer
await updateComponentBalance(tx, originalLine.componentId, draft.fromLocationId!, -quantity)
await updateComponentBalance(tx, originalLine.componentId, draft.toLocationId!, quantity)
```

**Completion Criteria**:
- [ ] All draft approval paths update balance
- [ ] Build, receipt, adjustment, initial, transfer all handled
- [ ] Existing functionality unchanged

---

## Phase 3: Read Path Refactor

### Subtask 3.1: Update getComponentQuantity to Read from Balance
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 46-130
**Instructions**:

Replace the aggregation logic with balance table read:

```typescript
export async function getComponentQuantity(
  componentId: string,
  companyId: string,
  locationId?: string
): Promise<number> {
  // Verify component belongs to company
  const component = await prisma.component.findFirst({
    where: { id: componentId, companyId },
    select: { id: true }
  })
  if (!component) {
    throw new Error('Component not found or access denied')
  }

  // Read from balance table
  const balance = await prisma.componentBalance.findUnique({
    where: {
      componentId_locationId: {
        componentId,
        locationId: locationId ?? null,
      },
    },
    select: { quantity: true },
  })

  return balance?.quantity.toNumber() ?? 0
}
```

**Completion Criteria**:
- [ ] Reads from ComponentBalance table
- [ ] Handles both global (locationId=null) and location-specific queries
- [ ] Returns 0 if no balance record exists
- [ ] Company verification retained

### Subtask 3.2: Update getComponentQuantities to Read from Balance
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 142-266
**Instructions**:

Replace aggregation with batch balance read:

```typescript
export async function getComponentQuantities(
  componentIds: string[],
  companyId: string,
  locationId?: string
): Promise<Map<string, number>> {
  if (componentIds.length === 0) {
    return new Map()
  }

  // Filter to only components the company owns
  const validComponents = await prisma.component.findMany({
    where: { id: { in: componentIds }, companyId },
    select: { id: true }
  })
  const validIds = validComponents.map(c => c.id)

  // Initialize all to 0
  const quantities = new Map<string, number>()
  for (const id of componentIds) {
    quantities.set(id, 0)
  }

  if (validIds.length === 0) {
    return quantities
  }

  // Read from balance table
  const balances = await prisma.componentBalance.findMany({
    where: {
      componentId: { in: validIds },
      locationId: locationId ?? null,
    },
    select: { componentId: true, quantity: true },
  })

  for (const balance of balances) {
    quantities.set(balance.componentId, balance.quantity.toNumber())
  }

  return quantities
}
```

**Completion Criteria**:
- [ ] Batch reads from ComponentBalance table
- [ ] Handles location filtering
- [ ] Returns 0 for components without balance records
- [ ] Company verification retained

### Subtask 3.3: Add Fallback Verification Mode (Optional)
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Instructions**:

Add a verification function that can compare balance table to aggregation:

```typescript
/**
 * Verify balance table matches transaction aggregation (for debugging/testing)
 */
export async function verifyComponentBalance(
  componentId: string,
  companyId: string,
  locationId?: string
): Promise<{ balance: number; aggregated: number; matches: boolean }> {
  const balance = await getComponentQuantity(componentId, companyId, locationId)

  // Run old aggregation logic
  const aggregated = await getComponentQuantityAggregated(componentId, companyId, locationId)

  return {
    balance,
    aggregated,
    matches: Math.abs(balance - aggregated) < 0.0001, // Allow small decimal variance
  }
}

// Keep old aggregation logic as private function for verification
async function getComponentQuantityAggregated(
  componentId: string,
  companyId: string,
  locationId?: string
): Promise<number> {
  // ... old aggregation code ...
}
```

**Completion Criteria**:
- [ ] Verification function available
- [ ] Old aggregation preserved as fallback
- [ ] Can detect balance drift

---

## Phase 4: Backfill Script

### Subtask 4.1: Create Backfill Script
**File**: `/home/pbrown/SkuInventory/scripts/backfill-component-balances.ts`
**Instructions**:

Create script to populate ComponentBalance from existing transactions:

```typescript
import { PrismaClient, Prisma } from '@prisma/client'

const prisma = new PrismaClient()

async function backfillComponentBalances() {
  console.log('Starting component balance backfill...')

  // Get all approved transactions with their lines
  const transactions = await prisma.transaction.findMany({
    where: { status: 'approved' },
    include: {
      lines: true,
    },
  })

  console.log(`Processing ${transactions.length} transactions...`)

  // Build balance map: Map<componentId, Map<locationId | 'global', quantity>>
  const balances = new Map<string, Map<string, number>>()

  for (const tx of transactions) {
    for (const line of tx.lines) {
      const componentId = line.componentId
      const quantityChange = line.quantityChange.toNumber()

      // Determine locationId based on transaction type
      let locationId: string | null = null
      if (tx.type === 'transfer') {
        // For transfers, negative = from location, positive = to location
        if (quantityChange < 0) {
          locationId = tx.fromLocationId
        } else {
          locationId = tx.toLocationId
        }
      } else {
        locationId = tx.locationId
      }

      const locationKey = locationId ?? 'global'

      // Initialize nested map if needed
      if (!balances.has(componentId)) {
        balances.set(componentId, new Map())
      }

      const componentBalances = balances.get(componentId)!
      const current = componentBalances.get(locationKey) ?? 0
      componentBalances.set(locationKey, current + quantityChange)
    }
  }

  console.log(`Calculated balances for ${balances.size} components...`)

  // Insert balances
  let inserted = 0
  for (const [componentId, locationMap] of balances) {
    for (const [locationKey, quantity] of locationMap) {
      const locationId = locationKey === 'global' ? null : locationKey

      await prisma.componentBalance.upsert({
        where: {
          componentId_locationId: {
            componentId,
            locationId,
          },
        },
        create: {
          componentId,
          locationId,
          quantity: new Prisma.Decimal(quantity),
        },
        update: {
          quantity: new Prisma.Decimal(quantity),
        },
      })
      inserted++
    }
  }

  console.log(`Backfill complete. Inserted/updated ${inserted} balance records.`)
}

backfillComponentBalances()
  .catch(console.error)
  .finally(() => prisma.$disconnect())
```

**Completion Criteria**:
- [ ] Script handles all transaction types
- [ ] Transfer logic correctly determines location
- [ ] Uses upsert to handle re-runs safely
- [ ] Logs progress

### Subtask 4.2: Create Verification Script
**File**: `/home/pbrown/SkuInventory/scripts/verify-component-balances.ts`
**Instructions**:

Create script to verify balances match aggregation:

```typescript
import { PrismaClient, Prisma } from '@prisma/client'

const prisma = new PrismaClient()

async function verifyBalances() {
  console.log('Verifying component balances...')

  // Get all component balances
  const balances = await prisma.componentBalance.findMany({
    include: {
      component: {
        select: { id: true, name: true, companyId: true },
      },
    },
  })

  let mismatches = 0

  for (const balance of balances) {
    // Aggregate from transactions
    const aggregated = await aggregateQuantity(
      balance.componentId,
      balance.component.companyId!,
      balance.locationId
    )

    const stored = balance.quantity.toNumber()
    const matches = Math.abs(stored - aggregated) < 0.0001

    if (!matches) {
      console.log(`MISMATCH: Component ${balance.component.name}`)
      console.log(`  Location: ${balance.locationId ?? 'global'}`)
      console.log(`  Balance table: ${stored}`)
      console.log(`  Aggregated: ${aggregated}`)
      mismatches++
    }
  }

  if (mismatches === 0) {
    console.log('All balances verified successfully!')
  } else {
    console.log(`Found ${mismatches} mismatches.`)
  }
}

async function aggregateQuantity(
  componentId: string,
  companyId: string,
  locationId: string | null
): Promise<number> {
  // ... aggregation logic matching old getComponentQuantity ...
}

verifyBalances()
  .catch(console.error)
  .finally(() => prisma.$disconnect())
```

**Completion Criteria**:
- [ ] Compares balance table to aggregation
- [ ] Reports any mismatches with details
- [ ] Can be run after backfill to verify

---

## Phase 5: Testing

### Subtask 5.1: Update Unit Tests
**File**: `/home/pbrown/SkuInventory/tests/unit/inventory-quantity.test.ts`
**Instructions**:

Update mocks to use ComponentBalance instead of TransactionLine aggregation:

```typescript
vi.mock('@/lib/db', () => ({
  prisma: {
    componentBalance: {
      findUnique: vi.fn(),
      findMany: vi.fn(),
      upsert: vi.fn(),
    },
    component: {
      findFirst: vi.fn(),
      findMany: vi.fn(),
    },
    // ... keep existing mocks for create operations
  },
}))
```

Update test cases to verify balance table queries instead of aggregation queries.

**Completion Criteria**:
- [ ] All existing tests pass with new implementation
- [ ] Mocks updated for ComponentBalance
- [ ] Balance update tests added for create operations

### Subtask 5.2: Add Integration Tests
**File**: `/home/pbrown/SkuInventory/tests/integration/component-balance.test.ts` (new)
**Instructions**:

Create integration tests that verify balance updates:

```typescript
describe('ComponentBalance Integration', () => {
  it('updates balance on receipt transaction', async () => {
    // Create receipt -> verify balance incremented
  })

  it('updates balance on build transaction', async () => {
    // Create build -> verify balance decremented for all components
  })

  it('handles transfer between locations', async () => {
    // Create transfer -> verify source decremented, destination incremented
  })

  it('balance matches aggregation after multiple operations', async () => {
    // Multiple operations -> verify balance equals sum of transaction lines
  })
})
```

**Completion Criteria**:
- [ ] Receipt balance update verified
- [ ] Adjustment balance update verified
- [ ] Build balance update verified (multiple components)
- [ ] Transfer balance update verified (two locations)
- [ ] Balance matches aggregation after operations

---

## Phase 6: Deployment & Verification

### Subtask 6.1: Test Environment Deployment
**Instructions**:
1. Apply migration to test database
2. Run backfill script
3. Run verification script
4. Run full test suite

```bash
# Apply migration
DATABASE_URL="postgresql://inventory_test:inventory_test_2025@localhost:2346/inventory_test" npx prisma migrate deploy

# Run backfill
DATABASE_URL="postgresql://inventory_test:inventory_test_2025@localhost:2346/inventory_test" npx ts-node scripts/backfill-component-balances.ts

# Verify
DATABASE_URL="postgresql://inventory_test:inventory_test_2025@localhost:2346/inventory_test" npx ts-node scripts/verify-component-balances.ts

# Run tests
npm test
```

**Completion Criteria**:
- [ ] Migration applies successfully
- [ ] Backfill completes without errors
- [ ] Verification shows 0 mismatches
- [ ] All tests pass

### Subtask 6.2: Final Build Verification
**Instructions**:
```bash
npm run build
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Build completes without errors
- [ ] TypeScript compiles without errors
- [ ] No lint warnings

---

## Summary of Deliverables

**Files Created**: 3
- `/home/pbrown/SkuInventory/prisma/migrations/[timestamp]_add_component_balance/migration.sql`
- `/home/pbrown/SkuInventory/scripts/backfill-component-balances.ts`
- `/home/pbrown/SkuInventory/scripts/verify-component-balances.ts`

**Files Modified**: 5
- `/home/pbrown/SkuInventory/prisma/schema.prisma` - Add ComponentBalance model
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Balance updates and reads
- `/home/pbrown/SkuInventory/src/services/transfer.ts` - Balance updates
- `/home/pbrown/SkuInventory/src/services/draft-transaction.ts` - Balance updates
- `/home/pbrown/SkuInventory/tests/unit/inventory-quantity.test.ts` - Update mocks

---

## Handoff to Build Agent

1. **READ THIS FIRST**: Review the V2 deferral recommendation at the top. If proceeding, follow the phases in order.
2. Complete Phase 0 verification before any code changes
3. Apply migration before modifying service code
4. Add balance updates to ALL transaction creation paths (missed paths cause balance drift)
5. Run verification script after backfill to confirm correctness
6. Run full test suite - this is a high-risk change

## Test Strategy Note
- Use Vitest for unit tests with updated mocks
- Integration tests required for this change
- Verification script provides additional safety net

## Risk Mitigation
- Verification function preserved to detect balance drift
- Backfill can be re-run safely (uses upsert)
- Old aggregation code kept as fallback

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 45m |
| Validation | 15m |
| Planning | 30m |
| **Total** | **90m** |
