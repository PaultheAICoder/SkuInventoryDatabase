# Implementation Plan
**Generated**: 2025-12-06T15:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #192
**Estimated Build Time**: 4-6 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Bug (Security Vulnerability)
**Source**: GitHub Issue #192
**Priority**: High

### Task Classification
**Category**: BUG_FIX
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="auth"` or None (auth-related tests)

### Issue Validation
**Status**: Valid
**Recent Changes**:
- `132766f` - fix(issue #173): add user validation to catch stale JWT tokens in SKU creation
- The `validateUserExists` function was added but only implemented in one API route

### Current State Assessment

**Problem Summary**:
Users can continue accessing the API for up to 30 days after their account is deleted or deactivated. This occurs because the JWT callback only validates the user against the database at initial login, not on subsequent requests. The JWT `maxAge` is set to 30 days (line 9 in auth.ts).

**Existing Components**:
- `src/lib/auth.ts` - Contains `authOptions` with JWT strategy, `validateUserExists` function already exists (lines 334-344)
- `src/middleware.ts` - Uses `withAuth` middleware with basic token presence check
- `src/app/api/skus/route.ts` - POST endpoint has `validateUserExists` check (partial implementation from issue #173)

**Current JWT Callback Flow** (lines 146-203 in auth.ts):
1. On initial login (`if (user)`): Populates token with user data from database
2. On session update (`trigger === 'update'`): Handles company/brand switching
3. **Missing**: No database validation on regular token access

**Database Schema**:
- `User` model has `isActive: Boolean @default(true)` field
- `validateUserExists` returns `{ id, email, isActive } | null`

**API Routes Using getServerSession**: 87 files identified
- Only 1 file (`src/app/api/skus/route.ts`) currently uses `validateUserExists`

### Dependencies & Blockers
1. **None** - All required infrastructure exists (`validateUserExists`, `prisma`, types)

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 4-6 hours
**Risk**: Medium (performance impact of DB check on every request needs consideration)

### Patterns Identified
**Primary**: `src/lib/auth.ts:334-344` - `validateUserExists` function
**Secondary**: `src/app/api/skus/route.ts:159-173` - Usage pattern for user validation

### Ripple Effect Analysis
**Files Identified**: 3 core files + 87 API routes (indirect benefit)
- `src/lib/auth.ts` - Primary modification (JWT callback)
- `src/middleware.ts` - No changes needed (relies on token presence)
- `tests/integration/auth.test.ts` - Add test for stale token rejection

**Note**: The solution modifies the JWT callback centrally, so individual API routes do NOT need to be modified. The partial implementation in `src/app/api/skus/route.ts` can remain as a defense-in-depth measure or be removed to avoid redundancy.

---

## Executive Summary

This fix adds user existence and active status validation to the NextAuth JWT callback, ensuring deleted or deactivated users are immediately denied access rather than continuing to use stale JWT tokens for up to 30 days. The `validateUserExists` function already exists in the codebase but is not being called in the JWT callback. The fix implements a lightweight database check on every session access.

---

## Phase 1: Core Authentication Fix

### Subtask 1.1: Add User Validation to JWT Callback
**File**: `/home/pbrown/SkuInventory/src/lib/auth.ts`
**Pattern**: Follow existing `validateUserExists` function usage in `src/app/api/skus/route.ts:159-173`

**Instructions**:
1. In the `jwt` callback (starting at line 146), add user validation logic AFTER the initial user population block and BEFORE the session update blocks
2. The validation should:
   - Only run when we have a token.id (user is logged in)
   - Skip validation when user object is present (initial login - user was just validated)
   - Call `validateUserExists(token.id as string)`
   - If user doesn't exist or is inactive, return an empty/invalidated token that will fail authorization
3. Consider performance: The check runs on every `getServerSession()` call but is a simple indexed lookup by primary key

**Code Location** (after line 159, before line 161):
```typescript
// Inside jwt callback, after the initial user block:

// Validate user still exists and is active in database
// This runs on every session access to catch deleted/deactivated users
if (token.id && !user) {
  // Skip validation on initial login (user object present)
  // Only validate on subsequent requests
  const validUser = await validateUserExists(token.id as string)
  if (!validUser || !validUser.isActive) {
    // User deleted or deactivated - invalidate token
    // Return minimal token that will fail session checks
    return {
      ...token,
      id: undefined,
      role: undefined,
      companyId: undefined,
      error: validUser ? 'user_deactivated' : 'user_not_found',
    }
  }
}
```

4. Update the `session` callback (starting at line 204) to check for invalidated tokens:
```typescript
async session({ session, token }) {
  // Check if token was invalidated due to user deletion/deactivation
  if (!token.id || (token as { error?: string }).error) {
    // Return null session to trigger re-authentication
    return { ...session, user: undefined, expires: new Date(0).toISOString() }
  }
  // ... rest of existing session callback
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] JWT callback validates user existence on every non-initial request
- [ ] Inactive users receive invalidated token
- [ ] Deleted users receive invalidated token
- [ ] Session callback handles invalidated tokens
- [ ] TypeScript compiles without errors
- [ ] Build completes successfully

### Subtask 1.2: Add Security Event Logging for Token Invalidation
**File**: `/home/pbrown/SkuInventory/src/lib/auth.ts`
**Pattern**: Follow existing `logSecurityEvent` function at lines 275-300

**Instructions**:
1. When a user is found to be deleted or deactivated during JWT validation, log a security event
2. Use the existing `SECURITY_EVENTS` constants or add a new one
3. Note: Cannot use async logging in JWT callback easily, so use fire-and-forget pattern

**Code Addition**:
```typescript
// Add to SECURITY_EVENTS constant (around line 305):
TOKEN_INVALIDATED: 'token_invalidated',

// In the JWT callback when invalidating:
if (!validUser || !validUser.isActive) {
  // Fire-and-forget security logging (don't await to avoid performance impact)
  logSecurityEvent({
    companyId: token.companyId as string,
    userId: token.id as string,
    eventType: SECURITY_EVENTS.TOKEN_INVALIDATED,
    details: {
      reason: validUser ? 'user_deactivated' : 'user_not_found',
      email: token.email as string,
    },
  }).catch(() => {}) // Ignore logging failures

  // ... return invalidated token
}
```

**Completion Criteria**:
- [ ] Security event logged when token invalidated
- [ ] Event includes reason (deactivated vs deleted)
- [ ] Logging failure doesn't block authentication flow

---

## Phase 2: Testing

### Subtask 2.1: Add Integration Test for Stale Token Rejection
**File**: `/home/pbrown/SkuInventory/tests/integration/auth.test.ts`
**Pattern**: Follow existing test structure in the same file

**Instructions**:
1. Add a new `describe` block: `'Stale JWT Token Handling'`
2. Add test: user deleted during active session should be rejected
3. Add test: user deactivated during active session should be rejected
4. Use the existing test helpers (`setTestSession`, `TEST_SESSIONS`, etc.)

**Test Approach**:
```typescript
describe('Stale JWT Token Handling', () => {
  it('rejects requests when user is deleted during active session', async () => {
    // 1. Create a test user
    // 2. Set up a session with that user
    // 3. Delete the user from database
    // 4. Make an API request
    // 5. Verify request is rejected with 401
  })

  it('rejects requests when user is deactivated during active session', async () => {
    // 1. Use ops user session
    // 2. Deactivate ops user in database (isActive = false)
    // 3. Make an API request
    // 4. Verify request is rejected
    // 5. Reactivate user for other tests
  })
})
```

**Note**: The existing test mock for `getServerSession` may need adjustment since it doesn't go through the real JWT callback. Consider:
- Testing at a higher level (actual HTTP requests)
- Or testing the `validateUserExists` function directly
- Or documenting that this is best tested via E2E tests

**Validation**:
```bash
npm test -- --testPathPattern="auth.test"
```

**Completion Criteria**:
- [ ] Test for deleted user rejection exists
- [ ] Test for deactivated user rejection exists
- [ ] All auth tests pass

### Subtask 2.2: Add Unit Test for validateUserExists Function
**File**: `/home/pbrown/SkuInventory/tests/unit/auth-validation.test.ts` (new file)
**Pattern**: Follow existing unit test patterns in `tests/unit/`

**Instructions**:
1. Create unit tests for the `validateUserExists` function
2. Test cases:
   - Returns user when user exists and is active
   - Returns user with isActive=false when user is deactivated
   - Returns null when user doesn't exist
   - Handles database errors gracefully

**Validation**:
```bash
npm test -- --testPathPattern="auth-validation"
```

**Completion Criteria**:
- [ ] Unit tests for all `validateUserExists` scenarios
- [ ] Tests pass

---

## Phase 3: Cleanup (Optional)

### Subtask 3.1: Remove Redundant validateUserExists Call from SKU Route
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/route.ts`
**Decision**: KEEP for defense-in-depth OR REMOVE for consistency

**Instructions**:
- If removing: Delete lines 159-173 (the `validateUserExists` check in POST handler)
- If keeping: Add comment explaining it's defense-in-depth

**Recommendation**: KEEP the check as defense-in-depth for critical operations like creating SKUs. The overhead is minimal since the database connection is already open.

**Completion Criteria**:
- [ ] Decision documented
- [ ] Code updated if removing, or comment added if keeping

---

## Summary of Deliverables

**Files Modified**:
- `src/lib/auth.ts` - JWT callback modification, security event constant
- `tests/integration/auth.test.ts` - New test cases

**Files Created**:
- `tests/unit/auth-validation.test.ts` - Unit tests for validateUserExists

**Files Unchanged** (decision to keep defense-in-depth):
- `src/app/api/skus/route.ts` - Existing validateUserExists check remains

---

## Handoff to Build Agent

1. Execute subtasks in exact order (1.1 -> 1.2 -> 2.1 -> 2.2 -> 3.1)
2. After each phase, run validation commands
3. The key change is in Phase 1.1 - modifying the JWT callback
4. Pay attention to TypeScript types when modifying token structure
5. The session callback modification in 1.1 is critical - must handle invalidated tokens

## Test Strategy Note

- **Unit Tests**: `npm test -- --testPathPattern="auth-validation"`
- **Integration Tests**: `npm test -- --testPathPattern="auth.test"`
- **Full Suite**: `npm test`

## Performance Considerations

The database check (`validateUserExists`) runs on every `getServerSession()` call. This is acceptable because:
1. It's a simple SELECT by primary key (indexed, fast)
2. Prisma connection pooling handles connection overhead
3. The alternative (checking only periodically) leaves a security window
4. Standard practice for JWT + database hybrid authentication

If performance becomes an issue in the future, consider:
- Redis cache with short TTL (e.g., 5 minutes)
- Check only on write operations (less secure)
- Shorter JWT maxAge (currently 30 days)

## Security Event Types Reference

Current types in `SECURITY_EVENTS`:
- `LOGIN`, `LOGIN_FAILED`, `LOGOUT`
- `PASSWORD_CHANGED`
- `USER_CREATED`, `USER_UPDATED`, `USER_DEACTIVATED`
- `ROLE_CHANGED`, `SETTINGS_CHANGED`, `COMPANY_SWITCH`

Adding: `TOKEN_INVALIDATED`

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 10m |
| **Total** | **30m** |

---

## Sources Referenced

- [NextAuth.js Callbacks Documentation](https://next-auth.js.org/configuration/callbacks)
- [NextAuth.js FAQ on JWT Security](https://next-auth.js.org/faq)
- [NextAuth.js Client API](https://next-auth.js.org/getting-started/client)
