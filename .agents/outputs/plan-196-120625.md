# Implementation Plan
**Generated**: 2025-12-06T15:45:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #196
**Estimated Build Time**: 2-3 hours
**Complexity**: Low

## Investigation Summary

### Request Analysis
**Type**: Enhancement (Data Integrity)
**Source**: GitHub Issue #196 (part of parent #195: Architectural Audit)
**Priority**: High (data integrity improvement)

### Task Classification
**Category**: NEW_FEATURE (database constraint)
**Test Strategy**: TARGETED (affected BOM activation paths)
**Suggested Filter**: `--filter="bom"` or None for TARGETED coverage

### Issue Validation
**Status**: Valid
**Recent Changes**: No recent changes to BOMVersion model or bom.ts service - last schema change was December 6 for outbound transaction type (unrelated)

### Current State Assessment

**Existing Components**:
- `BOMVersion` model in `prisma/schema.prisma` (lines 384-404) - has `isActive` boolean field, no partial unique index
- `src/services/bom.ts` - contains `createBOMVersion()` (line 247) and `activateBOMVersion()` (line 387) that enforce single-active-BOM rule via application logic
- Index exists: `@@index([skuId, isActive])` - but this is NOT a unique constraint

**Database**:
- No partial unique index currently enforcing "one active BOM per SKU"
- Application logic handles deactivation in a transaction (lines 266-277 and 398-409 in bom.ts)
- Uses `$transaction` for atomicity but vulnerable to race conditions, manual DB edits

**API Routes Affected**:
- `src/app/api/bom-versions/[id]/activate/route.ts` - calls `activateBOMVersion()`
- `src/app/api/skus/[id]/bom-versions/route.ts` - POST calls `createBOMVersion()` with isActive flag
- `src/app/api/bom-versions/[id]/route.ts` - potential PATCH operations
- `src/app/api/import/skus/route.ts` - may create BOMs during import

**Types**: No changes needed - constraint is database-level only

### Dependencies & Blockers
1. **None identified** - this is a standalone database constraint addition

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Simple
**Effort**: 2-3 hours
**Risk**: Low (additive change, no application logic changes required)

**Risk Mitigation**:
- Must verify no existing data violations before applying migration
- Include verification step in migration process

### Patterns Identified
**Primary**: `prisma/migrations/20251204131153_add_transaction_status/migration.sql` - shows pattern for creating indexes with raw SQL
**Secondary**: `prisma/migrations/20251206044609_add_outbound_transaction_type/migration.sql` - most recent migration pattern

### Ripple Effect Analysis
**Files Identified**: 1 (migration file only)

No application code changes required because:
- The existing application logic in `src/services/bom.ts` correctly deactivates old BOMs before activating new ones
- The database constraint acts as a safety net, not a replacement for application logic
- If the constraint is violated, the database will reject the operation with an error that the application's try/catch will handle gracefully

---

## Executive Summary
This task adds a PostgreSQL partial unique index on the `BOMVersion` table to enforce the "one active BOM per SKU" business rule at the database level. This provides defense-in-depth against race conditions, manual database edits, or application logic bugs that could result in multiple active BOMs for the same SKU.

## Phase 0: Pre-Migration Verification

### Subtask 0.1: Verify No Existing Data Violations
**Instructions**:
Before creating the migration, run a query against the database to check for any existing violations:

```sql
SELECT "skuId", COUNT(*) as active_count
FROM "BOMVersion"
WHERE "isActive" = true
GROUP BY "skuId"
HAVING COUNT(*) > 1;
```

If this returns any rows, those must be cleaned up before the migration can be applied.

**Completion Criteria**:
- [ ] Query returns 0 rows (no violations)
- [ ] If violations exist, document them and create cleanup plan before proceeding

## Phase 1: Database Migration

### Subtask 1.1: Create Prisma Migration for Partial Unique Index
**File**: New migration in `prisma/migrations/`
**Pattern**: Follow `prisma/migrations/20251204131153_add_transaction_status/migration.sql`

**Instructions**:
1. Create a new migration file using Prisma's create-only flag:
   ```bash
   cd /home/pbrown/SkuInventory
   npx prisma migrate dev --create-only --name add_single_active_bom_constraint
   ```

2. Edit the generated migration file to contain the partial unique index:
   ```sql
   -- CreateIndex
   CREATE UNIQUE INDEX "one_active_bom_per_sku" ON "BOMVersion"("skuId") WHERE "isActive" = true;
   ```

3. Apply the migration:
   ```bash
   npx prisma migrate dev
   ```

4. Regenerate Prisma client:
   ```bash
   npx prisma generate
   ```

**Validation Commands**:
```bash
# Verify migration applied
npx prisma migrate status

# Verify index exists in database
psql $DATABASE_URL -c "SELECT indexname FROM pg_indexes WHERE tablename = 'BOMVersion' AND indexname = 'one_active_bom_per_sku';"
```

**Completion Criteria**:
- [ ] Migration file created with correct SQL
- [ ] Migration applies without errors
- [ ] `npx prisma migrate status` shows all migrations applied
- [ ] Index verified to exist in database

### Subtask 1.2: Document Schema Change (Optional Prisma Comment)
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing comment style in schema

**Instructions**:
Add a comment above the BOMVersion model to document the constraint:

Find the BOMVersion model (around line 384) and add a comment:
```prisma
// Note: Partial unique index "one_active_bom_per_sku" enforces one active BOM per SKU
// Created via raw SQL migration (Prisma doesn't support partial unique indexes in schema)
model BOMVersion {
```

**Completion Criteria**:
- [ ] Comment added to schema.prisma
- [ ] Comment is clear and accurate

## Phase 2: Verification & Testing

### Subtask 2.1: Run Existing Tests
**Instructions**:
Run the existing test suite to ensure the constraint doesn't break any existing functionality:

```bash
cd /home/pbrown/SkuInventory
npm test
```

Focus on BOM-related tests:
```bash
npm test -- --filter="bom"
```

**Completion Criteria**:
- [ ] All existing tests pass
- [ ] BOM-related tests pass

### Subtask 2.2: Manual Database Constraint Verification
**Instructions**:
Manually verify the constraint works by attempting to violate it:

1. Start a test database session
2. Create a SKU with an active BOM version
3. Attempt to directly insert a second active BOM for the same SKU:
   ```sql
   -- This should FAIL with a unique constraint violation
   INSERT INTO "BOMVersion" ("id", "skuId", "versionName", "effectiveStartDate", "isActive", "createdById", "createdAt", "updatedAt")
   VALUES (gen_random_uuid(), '<existing-sku-id>', 'Test V2', CURRENT_DATE, true, '<user-id>', NOW(), NOW());
   ```
4. Verify the error message mentions `one_active_bom_per_sku`
5. Clean up any test data

**Completion Criteria**:
- [ ] Constraint correctly rejects duplicate active BOMs for same SKU
- [ ] Error message identifies the constraint name
- [ ] Test data cleaned up

### Subtask 2.3: Build and TypeScript Verification
**Instructions**:
Run build and TypeScript checks to ensure no compilation issues:

```bash
cd /home/pbrown/SkuInventory
npm run build
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] `npm run build` completes without errors
- [ ] `npx tsc --noEmit` completes without errors
- [ ] `npm run lint` completes without errors (or only pre-existing warnings)

---

## Summary of Deliverables
**Files Created**: 1
- `prisma/migrations/[timestamp]_add_single_active_bom_constraint/migration.sql`

**Files Modified**: 1
- `prisma/schema.prisma` (comment only - optional documentation)

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 0 -> Phase 1 -> Phase 2)
2. Phase 0 verification is CRITICAL - do not proceed if violations exist
3. Use test database (port 2346) for Phase 0 and Phase 2 manual verification
4. The migration should be applied to both test and production databases

## Test Strategy Note
- Use Vitest for running existing tests
- Manual verification against test database for constraint behavior
- No new automated tests required (constraint is database-level enforcement)

## Technical Notes

### Why Partial Unique Index?
A partial unique index `WHERE "isActive" = true` allows:
- Multiple inactive BOMs per SKU (expected - version history)
- Only ONE active BOM per SKU (enforced by constraint)

### Error Handling
When the constraint is violated, PostgreSQL returns error code `23505` (unique_violation). The existing try/catch blocks in the API routes will catch this and return a 500 error. The application-level deactivation logic should prevent this from ever occurring in normal operation - the constraint is a safety net.

### Rollback
If the migration needs to be rolled back:
```sql
DROP INDEX IF EXISTS "one_active_bom_per_sku";
```

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Phase 0 (Verification) | 10m |
| Phase 1 (Migration) | 15m |
| Phase 2 (Testing) | 30m |
| **Total** | **~1 hour** |

---

## Acceptance Criteria (from Issue)
- [ ] Migration created that adds partial unique index on BOMVersion(skuId) WHERE isActive = true
- [ ] Migration applies successfully to development database
- [ ] Existing tests pass
- [ ] Manual test confirms attempting to have two active BOMs for same SKU fails at database level
- [ ] `npm run build` and `npx tsc --noEmit` complete without errors
