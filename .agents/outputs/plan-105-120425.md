# Implementation Plan
**Generated**: 2025-12-04T15:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: Issue #105 - Slack webhook integration and admin UI
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #105
**Priority**: Medium
**Parent Issue**: #11 (Low-stock alerts for reorder statuses)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: None (new files, minimal existing code modification)

### Issue Validation
**Status**: Valid
**Dependency (#104)**: CLOSED - Database schema and core alert service already implemented
**Recent Changes**: Issue #104 added AlertConfig and ComponentAlertState models, plus evaluateLowStockAlerts() service

### Current State Assessment
- **Database**: AlertConfig model exists with slackWebhookUrl, emailAddresses, enableSlack, enableEmail, alertMode fields
- **Services**: `src/services/lowstock-alert.ts` exists with getAlertConfig(), upsertAlertConfig(), evaluateLowStockAlerts()
- **Types**: `src/types/lowstock-alert.ts` exists with AlertConfigResponse, AlertConfigInput types
- **Missing**: Slack webhook client, API routes for alert config, admin UI page, AlertConfigForm component

### Dependencies & Blockers
1. Issue #104 (CLOSED) - Database schema exists
2. No external dependencies needed - using native fetch for Slack webhook

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 6-8 hours
**Risk**: Low - follows established patterns in codebase

### Patterns Identified
**Primary**: `src/app/api/shopify/connection/route.ts` - API route pattern for external integrations
**Secondary**: `src/components/features/ShopifyConnectionForm.tsx` - Form pattern with test connection button
**Tertiary**: `src/app/(dashboard)/settings/page.tsx` - Settings page pattern

### Ripple Effect Analysis
**Files Identified**: 7 files to create, 1 file to modify

**Files to Create:**
- `src/lib/slack.ts` - Slack webhook client
- `src/app/api/settings/alerts/route.ts` - Alert config API (GET, PATCH)
- `src/app/api/settings/alerts/test/route.ts` - Test webhook endpoint
- `src/app/(dashboard)/settings/alerts/page.tsx` - Alert settings page
- `src/components/features/AlertConfigForm.tsx` - Alert config form component

**Files to Modify:**
- `src/app/(dashboard)/layout.tsx` - Add "Alerts" link to navigation (optional - accessible via Settings menu)

---

## Executive Summary

This implementation adds Slack webhook integration for low-stock alerts with an admin UI. The work involves: (1) creating a Slack webhook client that posts Block Kit formatted messages, (2) building API routes for alert configuration CRUD and webhook testing, and (3) creating an admin settings page with form components for managing webhook URLs and alert preferences.

## Phase 0: Environment Verification

### Subtask 0.1: Verify Database Schema Ready
**Instructions**:
1. Confirm AlertConfig model exists in Prisma schema
2. Verify existing types in `src/types/lowstock-alert.ts`
3. Ensure lowstock-alert service functions are available

**Validation**:
```bash
grep -A 20 "model AlertConfig" /home/pbrown/SkuInventory/prisma/schema.prisma
```

**Completion Criteria**:
- [ ] AlertConfig model confirmed with slackWebhookUrl field
- [ ] Types for AlertConfigResponse exist

---

## Phase 1: Slack Webhook Client

### Subtask 1.1: Create Slack Webhook Client Library
**File**: `/home/pbrown/SkuInventory/src/lib/slack.ts`
**Pattern**: Follow `src/lib/crypto.ts` for utility structure
**Instructions**:

Create a new file with the following structure:
```typescript
/**
 * Slack webhook client for sending low-stock alerts
 * Uses Slack Block Kit for rich message formatting
 */

// Types
export interface SlackMessage {
  blocks: SlackBlock[]
  text?: string // Fallback text for notifications
}

export interface SlackBlock {
  type: string
  text?: { type: string; text: string; emoji?: boolean }
  fields?: Array<{ type: string; text: string }>
  accessory?: unknown
}

export interface LowStockAlertData {
  componentName: string
  skuCode: string
  brandName: string
  currentStatus: 'warning' | 'critical'
  quantityOnHand: number
  reorderPoint: number
  leadTimeDays: number
  componentId: string
  baseUrl: string
}

export class SlackWebhookError extends Error {
  constructor(
    message: string,
    public statusCode?: number
  ) {
    super(message)
    this.name = 'SlackWebhookError'
  }
}

// Validate Slack webhook URL format
export function isValidSlackWebhookUrl(url: string): boolean {
  // Must start with https://hooks.slack.com/
  return /^https:\/\/hooks\.slack\.com\/services\/[A-Z0-9]+\/[A-Z0-9]+\/[a-zA-Z0-9]+$/.test(url)
}

// Format single alert into Slack Block Kit message
export function formatLowStockAlert(data: LowStockAlertData): SlackMessage {
  const severityEmoji = data.currentStatus === 'critical' ? ':red_circle:' : ':warning:'
  const severityText = data.currentStatus === 'critical' ? 'Critical' : 'Warning'
  const componentUrl = `${data.baseUrl}/components/${data.componentId}`

  return {
    text: `Low Stock Alert - ${severityText}: ${data.componentName} (${data.skuCode})`,
    blocks: [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `${severityEmoji} Low Stock Alert - ${severityText}`,
          emoji: true,
        },
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Component:*\n<${componentUrl}|${data.componentName} (${data.skuCode})>`,
          },
          {
            type: 'mrkdwn',
            text: `*Brand:*\n${data.brandName}`,
          },
          {
            type: 'mrkdwn',
            text: `*On Hand:*\n${data.quantityOnHand} units`,
          },
          {
            type: 'mrkdwn',
            text: `*Reorder Point:*\n${data.reorderPoint} units`,
          },
        ],
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Lead Time:*\n${data.leadTimeDays} days`,
          },
          {
            type: 'mrkdwn',
            text: `*Status:*\n${severityEmoji} ${severityText}`,
          },
        ],
      },
      {
        type: 'divider',
      },
    ],
  }
}

// Format test message
export function formatTestMessage(): SlackMessage {
  return {
    text: 'Trevor Inventory - Test Connection',
    blocks: [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: ':white_check_mark: Slack Connection Test',
          emoji: true,
        },
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: 'Your Slack webhook is configured correctly! You will receive low-stock alerts through this channel.',
        },
      },
    ],
  }
}

// Send message to Slack webhook
export async function sendSlackMessage(
  webhookUrl: string,
  message: SlackMessage
): Promise<void> {
  if (!isValidSlackWebhookUrl(webhookUrl)) {
    throw new SlackWebhookError('Invalid Slack webhook URL format')
  }

  const response = await fetch(webhookUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(message),
  })

  if (!response.ok) {
    const text = await response.text().catch(() => 'Unknown error')
    throw new SlackWebhookError(
      `Slack webhook failed: ${text}`,
      response.status
    )
  }
}

// Send multiple alerts as a single digest message
export function formatDigestMessage(
  alerts: LowStockAlertData[],
  baseUrl: string
): SlackMessage {
  const criticals = alerts.filter((a) => a.currentStatus === 'critical')
  const warnings = alerts.filter((a) => a.currentStatus === 'warning')

  const blocks: SlackBlock[] = [
    {
      type: 'header',
      text: {
        type: 'plain_text',
        text: ':package: Low Stock Alert Digest',
        emoji: true,
      },
    },
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*${alerts.length} components need attention*\n:red_circle: ${criticals.length} Critical | :warning: ${warnings.length} Warning`,
      },
    },
    { type: 'divider' },
  ]

  // Add critical items first (max 10)
  for (const alert of criticals.slice(0, 10)) {
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `:red_circle: *<${baseUrl}/components/${alert.componentId}|${alert.componentName}>* (${alert.skuCode})\nOn Hand: ${alert.quantityOnHand} | Reorder: ${alert.reorderPoint}`,
      },
    })
  }

  // Add warning items (max 10)
  for (const alert of warnings.slice(0, 10)) {
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `:warning: *<${baseUrl}/components/${alert.componentId}|${alert.componentName}>* (${alert.skuCode})\nOn Hand: ${alert.quantityOnHand} | Reorder: ${alert.reorderPoint}`,
      },
    })
  }

  if (alerts.length > 20) {
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `_...and ${alerts.length - 20} more items. View all in the <${baseUrl}/components|inventory dashboard>._`,
      },
    })
  }

  return {
    text: `Low Stock Digest: ${criticals.length} critical, ${warnings.length} warning`,
    blocks,
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint -- src/lib/slack.ts
```

**Completion Criteria**:
- [ ] File created at `src/lib/slack.ts`
- [ ] isValidSlackWebhookUrl validates webhook URL format
- [ ] formatLowStockAlert creates Block Kit message
- [ ] formatTestMessage creates test message
- [ ] sendSlackMessage sends POST to webhook
- [ ] formatDigestMessage creates digest for multiple alerts
- [ ] TypeScript compiles without errors

---

## Phase 2: API Routes

### Subtask 2.1: Create Alert Config API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/settings/alerts/route.ts`
**Pattern**: Follow `src/app/api/settings/route.ts` and `src/app/api/shopify/connection/route.ts`
**Instructions**:

Create API route with GET and PATCH handlers:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import {
  success,
  unauthorized,
  forbidden,
  serverError,
  validationError,
} from '@/lib/api-response'
import {
  getAlertConfig,
  upsertAlertConfig,
} from '@/services/lowstock-alert'
import { updateAlertConfigSchema } from '@/types/lowstock-alert'

// GET /api/settings/alerts - Get alert config (admin only)
export async function GET() {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return unauthorized()
    }

    if (session.user.role !== 'admin') {
      return forbidden()
    }

    const config = await getAlertConfig(session.user.selectedCompanyId)

    // Mask webhook URL for security (show only last 8 chars)
    const maskedConfig = config
      ? {
          ...config,
          slackWebhookUrl: config.slackWebhookUrl
            ? `****${config.slackWebhookUrl.slice(-8)}`
            : null,
          hasWebhook: !!config.slackWebhookUrl,
        }
      : null

    return success({ config: maskedConfig })
  } catch (error) {
    console.error('Error fetching alert config:', error)
    return serverError()
  }
}

// PATCH /api/settings/alerts - Update alert config (admin only)
export async function PATCH(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return unauthorized()
    }

    if (session.user.role !== 'admin') {
      return forbidden()
    }

    const body = await request.json()
    const validation = updateAlertConfigSchema.safeParse(body)

    if (!validation.success) {
      return validationError(validation.error)
    }

    const config = await upsertAlertConfig(
      session.user.selectedCompanyId,
      validation.data
    )

    // Mask webhook URL in response
    const maskedConfig = {
      ...config,
      slackWebhookUrl: config.slackWebhookUrl
        ? `****${config.slackWebhookUrl.slice(-8)}`
        : null,
      hasWebhook: !!config.slackWebhookUrl,
    }

    return success({ config: maskedConfig, message: 'Alert settings updated' })
  } catch (error) {
    console.error('Error updating alert config:', error)
    return serverError()
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] GET returns masked config (admin only)
- [ ] PATCH updates config with validation
- [ ] Webhook URL is masked in responses (security)
- [ ] Auth checks in place

### Subtask 2.2: Create Test Webhook API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/settings/alerts/test/route.ts`
**Pattern**: Follow `src/app/api/shopify/connection/test/route.ts`
**Instructions**:

Create POST endpoint to test webhook connection:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import {
  success,
  unauthorized,
  forbidden,
  serverError,
} from '@/lib/api-response'
import { getAlertConfig } from '@/services/lowstock-alert'
import {
  sendSlackMessage,
  formatTestMessage,
  isValidSlackWebhookUrl,
  SlackWebhookError,
} from '@/lib/slack'

// POST /api/settings/alerts/test - Test Slack webhook (admin only)
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return unauthorized()
    }

    if (session.user.role !== 'admin') {
      return forbidden()
    }

    // Check for provided URL or use stored
    const body = await request.json().catch(() => ({}))
    let webhookUrl: string | null = null

    if (body.webhookUrl) {
      // Use provided URL for testing before saving
      webhookUrl = body.webhookUrl
    } else {
      // Use stored config
      const config = await getAlertConfig(session.user.selectedCompanyId)
      webhookUrl = config?.slackWebhookUrl ?? null
    }

    if (!webhookUrl) {
      return success({
        success: false,
        error: 'No webhook URL configured',
      })
    }

    if (!isValidSlackWebhookUrl(webhookUrl)) {
      return success({
        success: false,
        error: 'Invalid Slack webhook URL format. URL must start with https://hooks.slack.com/services/',
      })
    }

    try {
      await sendSlackMessage(webhookUrl, formatTestMessage())
      return success({
        success: true,
        message: 'Test message sent successfully',
      })
    } catch (error) {
      const message =
        error instanceof SlackWebhookError
          ? error.message
          : 'Failed to send test message'
      return success({
        success: false,
        error: message,
      })
    }
  } catch (error) {
    console.error('Error testing Slack webhook:', error)
    return serverError()
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] POST sends test message to webhook
- [ ] Supports testing with provided URL (before saving)
- [ ] Supports testing with stored URL
- [ ] Returns success/error response
- [ ] Admin-only access enforced

---

## Phase 3: Update lowstock-alert Types

### Subtask 3.1: Add Webhook URL Validation to Types
**File**: `/home/pbrown/SkuInventory/src/types/lowstock-alert.ts`
**Pattern**: Follow existing schema structure
**Instructions**:

Add Slack webhook URL validation and update schema:
```typescript
// Add to the existing file:

// Slack webhook URL validation (must be https://hooks.slack.com/...)
const slackWebhookUrlSchema = z
  .string()
  .url()
  .max(500)
  .refine(
    (url) => url.startsWith('https://hooks.slack.com/services/'),
    { message: 'Slack webhook URL must start with https://hooks.slack.com/services/' }
  )
  .optional()
  .nullable()

// Update alertConfigSchema to use the refined validation
export const alertConfigSchema = z.object({
  slackWebhookUrl: slackWebhookUrlSchema,
  emailAddresses: z.array(z.string().email()).default([]),
  enableSlack: z.boolean().default(false),
  enableEmail: z.boolean().default(false),
  alertMode: alertModeSchema.default('daily_digest'),
})
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Webhook URL schema validates format
- [ ] Existing types remain compatible
- [ ] TypeScript compiles

---

## Phase 4: Admin UI Components

### Subtask 4.1: Create Alert Config Form Component
**File**: `/home/pbrown/SkuInventory/src/components/features/AlertConfigForm.tsx`
**Pattern**: Follow `src/components/features/ShopifyConnectionForm.tsx`
**Instructions**:

Create comprehensive form component:
```typescript
'use client'

import { useState, useEffect } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  CheckCircle,
  XCircle,
  Loader2,
  Bell,
  BellOff,
  MessageSquare,
} from 'lucide-react'
import { toast } from 'sonner'

interface AlertConfig {
  id: string
  companyId: string
  slackWebhookUrl: string | null
  hasWebhook: boolean
  emailAddresses: string[]
  enableSlack: boolean
  enableEmail: boolean
  alertMode: 'daily_digest' | 'per_transition'
  lastDigestSent: string | null
}

interface AlertConfigFormProps {
  config: AlertConfig | null
  onRefresh: () => void
}

export function AlertConfigForm({ config, onRefresh }: AlertConfigFormProps) {
  const [webhookUrl, setWebhookUrl] = useState('')
  const [enableSlack, setEnableSlack] = useState(config?.enableSlack ?? false)
  const [alertMode, setAlertMode] = useState<'daily_digest' | 'per_transition'>(
    config?.alertMode ?? 'daily_digest'
  )
  const [isSaving, setIsSaving] = useState(false)
  const [isTesting, setIsTesting] = useState(false)
  const [testResult, setTestResult] = useState<{
    success: boolean
    message?: string
    error?: string
  } | null>(null)

  // Sync form state when config changes
  useEffect(() => {
    if (config) {
      setEnableSlack(config.enableSlack)
      setAlertMode(config.alertMode)
    }
  }, [config])

  const handleTestWebhook = async () => {
    setIsTesting(true)
    setTestResult(null)

    try {
      const body = webhookUrl ? { webhookUrl } : {}
      const res = await fetch('/api/settings/alerts/test', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      })

      if (res.status === 403) {
        toast.error('You do not have permission to test webhooks')
        return
      }

      const data = await res.json()

      if (data.error) {
        toast.error(data.error)
        return
      }

      setTestResult(data.data)
      if (data.data?.success) {
        toast.success('Test message sent to Slack!')
      } else {
        toast.error(data.data?.error || 'Test failed')
      }
    } catch {
      toast.error('Failed to test webhook')
    } finally {
      setIsTesting(false)
    }
  }

  const handleSave = async () => {
    setIsSaving(true)

    try {
      const payload: Record<string, unknown> = {
        enableSlack,
        alertMode,
      }

      // Only include webhook URL if user entered one
      if (webhookUrl) {
        payload.slackWebhookUrl = webhookUrl
      }

      const res = await fetch('/api/settings/alerts', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      })

      if (res.status === 403) {
        toast.error('You do not have permission to update settings')
        return
      }

      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.message || 'Failed to save')
      }

      toast.success('Alert settings saved')
      setWebhookUrl('') // Clear webhook field
      setTestResult(null)
      onRefresh()
    } catch (err) {
      toast.error(err instanceof Error ? err.message : 'Failed to save settings')
    } finally {
      setIsSaving(false)
    }
  }

  const isLoading = isSaving || isTesting
  const hasStoredWebhook = config?.hasWebhook ?? false
  const canTest = webhookUrl || hasStoredWebhook
  const canSave = webhookUrl || hasStoredWebhook

  return (
    <div className="space-y-6">
      {/* Status Card */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="flex items-center gap-2">
              {enableSlack ? (
                <Bell className="h-5 w-5 text-green-600" />
              ) : (
                <BellOff className="h-5 w-5 text-muted-foreground" />
              )}
              Slack Alerts
            </CardTitle>
            <Badge variant={enableSlack && hasStoredWebhook ? 'default' : 'secondary'}>
              {enableSlack && hasStoredWebhook ? 'Enabled' : 'Disabled'}
            </Badge>
          </div>
          <CardDescription>
            {enableSlack && hasStoredWebhook
              ? 'Low-stock alerts will be sent to your Slack channel'
              : 'Configure a webhook to receive alerts in Slack'}
          </CardDescription>
        </CardHeader>
        {config && (
          <CardContent>
            <div className="grid gap-2 text-sm">
              <div className="flex justify-between">
                <span className="text-muted-foreground">Alert Mode</span>
                <span className="capitalize">
                  {config.alertMode.replace('_', ' ')}
                </span>
              </div>
              {config.lastDigestSent && (
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Last Digest Sent</span>
                  <span>{new Date(config.lastDigestSent).toLocaleString()}</span>
                </div>
              )}
            </div>
          </CardContent>
        )}
      </Card>

      {/* Configuration Card */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <MessageSquare className="h-5 w-5" />
            Slack Configuration
          </CardTitle>
          <CardDescription>
            Enter your Slack incoming webhook URL to receive alerts
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Enable Toggle */}
          <div className="flex items-center space-x-2">
            <input
              id="enableSlack"
              type="checkbox"
              className="h-4 w-4 rounded border-gray-300"
              checked={enableSlack}
              onChange={(e) => setEnableSlack(e.target.checked)}
              disabled={isLoading}
            />
            <div>
              <Label htmlFor="enableSlack" className="font-normal">
                Enable Slack Alerts
              </Label>
              <p className="text-xs text-muted-foreground">
                Receive low-stock notifications in your Slack workspace
              </p>
            </div>
          </div>

          {/* Webhook URL */}
          <div className="space-y-2">
            <Label htmlFor="webhookUrl">Webhook URL</Label>
            <Input
              id="webhookUrl"
              type="password"
              placeholder={
                hasStoredWebhook
                  ? `****${config?.slackWebhookUrl || ''}`
                  : 'https://hooks.slack.com/services/...'
              }
              value={webhookUrl}
              onChange={(e) => setWebhookUrl(e.target.value)}
              disabled={isLoading}
            />
            <p className="text-xs text-muted-foreground">
              {hasStoredWebhook
                ? 'A webhook URL is stored. Enter a new URL to update it.'
                : 'Create an incoming webhook in your Slack workspace settings'}
            </p>
          </div>

          {/* Alert Mode */}
          <div className="space-y-2">
            <Label htmlFor="alertMode">Alert Mode</Label>
            <Select
              value={alertMode}
              onValueChange={(value) =>
                setAlertMode(value as 'daily_digest' | 'per_transition')
              }
              disabled={isLoading}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="daily_digest">
                  Daily Digest - Single summary each day
                </SelectItem>
                <SelectItem value="per_transition">
                  Immediate - Alert on each status change
                </SelectItem>
              </SelectContent>
            </Select>
            <p className="text-xs text-muted-foreground">
              Daily digest sends one summary; immediate alerts on each state transition
            </p>
          </div>

          {/* Test Result Display */}
          {testResult && (
            <div
              className={`rounded-md p-4 ${
                testResult.success
                  ? 'bg-green-50 border border-green-200'
                  : 'bg-destructive/10 border border-destructive/20'
              }`}
            >
              <div className="flex items-start gap-3">
                {testResult.success ? (
                  <CheckCircle className="h-5 w-5 text-green-600 mt-0.5" />
                ) : (
                  <XCircle className="h-5 w-5 text-destructive mt-0.5" />
                )}
                <div>
                  <p
                    className={`font-medium ${
                      testResult.success ? 'text-green-800' : 'text-destructive'
                    }`}
                  >
                    {testResult.success ? 'Test Successful' : 'Test Failed'}
                  </p>
                  <p className="mt-1 text-sm">
                    {testResult.success
                      ? testResult.message
                      : testResult.error}
                  </p>
                </div>
              </div>
            </div>
          )}

          {/* Action Buttons */}
          <div className="flex flex-wrap gap-2 pt-4">
            <Button
              type="button"
              variant="outline"
              onClick={handleTestWebhook}
              disabled={!canTest || isLoading}
            >
              {isTesting ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Testing...
                </>
              ) : (
                'Test Webhook'
              )}
            </Button>

            <Button
              type="button"
              onClick={handleSave}
              disabled={!canSave || isLoading}
            >
              {isSaving ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Saving...
                </>
              ) : (
                'Save Settings'
              )}
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Email Configuration Card (Placeholder) */}
      <Card className="opacity-50">
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle>Email Alerts</CardTitle>
            <Badge variant="secondary">Coming Soon</Badge>
          </div>
          <CardDescription>
            Email alert configuration will be available in a future update
          </CardDescription>
        </CardHeader>
      </Card>
    </div>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint -- src/components/features/AlertConfigForm.tsx
```

**Completion Criteria**:
- [ ] Form renders with all fields
- [ ] Enable/disable toggle works
- [ ] Webhook URL input (password masked)
- [ ] Alert mode selector works
- [ ] Test webhook button sends test message
- [ ] Save button persists settings
- [ ] Status card shows current configuration
- [ ] TypeScript compiles

### Subtask 4.2: Create Alert Settings Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/alerts/page.tsx`
**Pattern**: Follow `src/app/(dashboard)/settings/page.tsx`
**Instructions**:

Create the settings page:
```typescript
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useSession } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import { AlertConfigForm } from '@/components/features/AlertConfigForm'

interface AlertConfig {
  id: string
  companyId: string
  slackWebhookUrl: string | null
  hasWebhook: boolean
  emailAddresses: string[]
  enableSlack: boolean
  enableEmail: boolean
  alertMode: 'daily_digest' | 'per_transition'
  lastDigestSent: string | null
}

export default function AlertSettingsPage() {
  const { data: session, status } = useSession()
  const router = useRouter()
  const [config, setConfig] = useState<AlertConfig | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchConfig = useCallback(async () => {
    try {
      setIsLoading(true)
      const res = await fetch('/api/settings/alerts')

      if (res.status === 403) {
        router.push('/')
        return
      }

      if (!res.ok) {
        throw new Error('Failed to load settings')
      }

      const data = await res.json()
      setConfig(data?.data?.config)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }, [router])

  // Check auth and redirect non-admins
  useEffect(() => {
    if (status === 'loading') return

    if (!session?.user) {
      router.push('/login')
      return
    }

    if (session.user.role !== 'admin') {
      router.push('/')
      return
    }

    fetchConfig()
  }, [session, status, router, fetchConfig])

  // Refetch when company changes
  useEffect(() => {
    if (session?.user?.selectedCompanyId) {
      fetchConfig()
    }
  }, [session?.user?.selectedCompanyId, fetchConfig])

  if (status === 'loading' || isLoading) {
    return (
      <div className="space-y-6">
        <div>
          <h1 className="text-3xl font-bold">Alert Settings</h1>
          <p className="text-muted-foreground">
            Configure low-stock alert notifications
          </p>
        </div>
        <div className="py-10 text-center text-muted-foreground">
          Loading settings...
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="space-y-6">
        <div>
          <h1 className="text-3xl font-bold">Alert Settings</h1>
          <p className="text-muted-foreground">
            Configure low-stock alert notifications
          </p>
        </div>
        <div className="rounded-md bg-destructive/10 p-4 text-destructive">
          {error}
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold">Alert Settings</h1>
        <p className="text-muted-foreground">
          Configure low-stock alert notifications for Slack and email
        </p>
      </div>

      <div className="max-w-3xl">
        <AlertConfigForm config={config} onRefresh={fetchConfig} />
      </div>
    </div>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Page accessible at /settings/alerts
- [ ] Admin-only access (redirects non-admins)
- [ ] Fetches and displays config
- [ ] Refetches when company changes
- [ ] Shows loading and error states

---

## Phase 5: Add Slack Delivery to Alert Service

### Subtask 5.1: Add sendSlackAlerts Function to lowstock-alert Service
**File**: `/home/pbrown/SkuInventory/src/services/lowstock-alert.ts`
**Pattern**: Follow existing service patterns
**Instructions**:

Add the Slack delivery function at the end of the existing file:
```typescript
// Add these imports at the top
import {
  sendSlackMessage,
  formatLowStockAlert,
  formatDigestMessage,
  type LowStockAlertData,
} from '@/lib/slack'

// Add this function at the end of the file:

/**
 * Send low-stock alerts via Slack webhook
 * Used by scheduler to deliver alerts
 */
export async function sendSlackAlerts(
  companyId: string,
  alerts: ComponentAlertNeeded[],
  baseUrl: string
): Promise<{ sent: number; errors: string[] }> {
  const config = await getAlertConfig(companyId)

  if (!config || !config.enableSlack || !config.slackWebhookUrl) {
    return { sent: 0, errors: [] }
  }

  const errors: string[] = []

  // Convert alerts to LowStockAlertData format
  const alertData: LowStockAlertData[] = alerts.map((alert) => ({
    componentName: alert.componentName,
    skuCode: alert.skuCode,
    brandName: alert.brandName,
    currentStatus: alert.currentStatus as 'warning' | 'critical',
    quantityOnHand: alert.quantityOnHand,
    reorderPoint: alert.reorderPoint,
    leadTimeDays: alert.leadTimeDays,
    componentId: alert.componentId,
    baseUrl,
  }))

  try {
    if (config.alertMode === 'daily_digest') {
      // Send single digest message
      const message = formatDigestMessage(alertData, baseUrl)
      await sendSlackMessage(config.slackWebhookUrl, message)
      await updateLastDigestSent(companyId)
      return { sent: alerts.length, errors: [] }
    } else {
      // Send individual alerts (per_transition mode)
      let sent = 0
      for (const data of alertData) {
        try {
          const message = formatLowStockAlert(data)
          await sendSlackMessage(config.slackWebhookUrl, message)
          sent++
        } catch (error) {
          errors.push(
            `Failed to send alert for ${data.componentName}: ${error instanceof Error ? error.message : 'Unknown error'}`
          )
        }
      }
      return { sent, errors }
    }
  } catch (error) {
    errors.push(
      `Slack delivery failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    )
    return { sent: 0, errors }
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] sendSlackAlerts function added
- [ ] Respects enableSlack toggle
- [ ] Handles both alertMode options
- [ ] Returns sent count and errors
- [ ] Updates lastDigestSent for digest mode

---

## Phase 6: Validation & Testing

### Subtask 6.1: Full Build Verification
**Instructions**:
1. Run TypeScript check
2. Run lint
3. Run build

**Validation**:
```bash
npx tsc --noEmit
npm run lint
npm run build
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run lint` passes with no errors
- [ ] `npm run build` completes successfully

### Subtask 6.2: Manual Testing Checklist
**Instructions**:
1. Start dev server: `npm run dev`
2. Login as admin user
3. Navigate to /settings/alerts
4. Test each feature

**Test Cases**:
- [ ] Page loads and shows form
- [ ] Non-admin users are redirected
- [ ] Can enter webhook URL
- [ ] Can toggle enable/disable
- [ ] Can select alert mode
- [ ] Test webhook button sends test message (requires valid Slack webhook)
- [ ] Save settings persists changes
- [ ] Webhook URL is masked in display

---

## Summary of Deliverables

**Files Created**: 5
- `src/lib/slack.ts` - Slack webhook client
- `src/app/api/settings/alerts/route.ts` - GET/PATCH alert config
- `src/app/api/settings/alerts/test/route.ts` - POST test webhook
- `src/app/(dashboard)/settings/alerts/page.tsx` - Admin UI page
- `src/components/features/AlertConfigForm.tsx` - Form component

**Files Modified**: 2
- `src/types/lowstock-alert.ts` - Add webhook URL validation
- `src/services/lowstock-alert.ts` - Add sendSlackAlerts function

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 0 -> 6)
2. Complete each phase fully before moving to next
3. Run validation commands after each subtask
4. Test completion criteria before marking done
5. Follow reference patterns exactly (especially ShopifyConnectionForm.tsx)

## Test Strategy Note

- Manual testing via browser at /settings/alerts
- Slack webhook testing requires a real Slack workspace webhook URL
- Use Slack's test/sandbox workspace if available

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 10m |
| **Total** | **30m** |
