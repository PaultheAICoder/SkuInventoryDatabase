# Implementation Plan: Implement Actual Database Integration Tests

**Generated**: 2025-12-03T03:00:00Z
**Task ID**: Issue #40
**Estimated Build Time**: 5-6 hours
**Complexity**: Medium

## Executive Summary

Convert 96 existing documentation-style integration tests to actual database-connected tests. The infrastructure is 80% complete - we need to add NextAuth session mocking and database cleanup utilities, then systematically convert each test file from `expect(true).toBe(true)` patterns to real API route invocations with database assertions.

## Ripple Effect Validation

**Scout's file count verified**:
- 27 API routes use `getServerSession()` - all need to be mockable
- 5 integration test files to convert (96 tests total)
- 2-3 new helper files to create
- CI workflow needs integration test step added

**No additional files found beyond Scout's report.**

## Schema Verification

**Verified via grep**:
- `User` model has: `id`, `email`, `name`, `role`, `companyId` (matching test session interface)
- `Company` model has: `id`, `name`, `settings`
- `Brand` model has: `id`, `companyId`, `name`
- Test users in seed: `admin@tonsil.tech`, `ops@tonsil.tech`, `viewer@tonsil.tech`

## Phase 0: Foundation - Session Mocking & Test Context

### Subtask 0.1: Create NextAuth Session Mock Helper

**File**: `/home/pbrown/SkuInventory/tests/helpers/auth-mock.ts` (NEW)

**Pattern Reference**: `/home/pbrown/SkuInventory/tests/unit/inventory-delete.test.ts:7-15` (vi.mock pattern)

**Instructions**:

1. Create a new file that provides session mocking utilities for integration tests
2. Use Vitest's `vi.mock()` to mock `next-auth` module
3. Provide helper functions to set different user sessions (admin, ops, viewer)
4. Support custom company context for multi-tenant testing

**Code Template**:
```typescript
/**
 * NextAuth Session Mocking for Integration Tests
 * Mocks getServerSession to return configurable test sessions
 */
import { vi, beforeEach } from 'vitest'
import type { Session } from 'next-auth'

// Default test session (admin user)
let currentSession: Session | null = null

// Mock next-auth module
vi.mock('next-auth', async () => {
  const actual = await vi.importActual('next-auth')
  return {
    ...actual,
    getServerSession: vi.fn(() => currentSession),
  }
})

// Type-safe session structure matching src/lib/auth.ts
export interface TestUserSession {
  user: {
    id: string
    email: string
    name: string
    role: 'admin' | 'ops' | 'viewer'
    companyId: string
    companyName: string
  }
}

/**
 * Set the current mock session for tests
 * Call in beforeEach or at the start of a test
 */
export function setTestSession(session: TestUserSession | null): void {
  currentSession = session as Session | null
}

/**
 * Clear the current mock session (simulate logged out)
 */
export function clearTestSession(): void {
  currentSession = null
}

/**
 * Pre-built test sessions matching seed.ts users
 * IDs and companyId are populated from database in beforeAll
 */
export const TEST_SESSIONS = {
  admin: null as TestUserSession | null,
  ops: null as TestUserSession | null,
  viewer: null as TestUserSession | null,
}

/**
 * Initialize test sessions from database
 * Call once in beforeAll for integration test suites
 */
export async function initializeTestSessions(prisma: PrismaClient): Promise<void> {
  const [admin, ops, viewer, company] = await Promise.all([
    prisma.user.findUnique({ where: { email: 'admin@tonsil.tech' } }),
    prisma.user.findUnique({ where: { email: 'ops@tonsil.tech' } }),
    prisma.user.findUnique({ where: { email: 'viewer@tonsil.tech' } }),
    prisma.company.findFirst({ where: { name: 'Tonsil Tech' } }),
  ])

  if (!admin || !ops || !viewer || !company) {
    throw new Error('Test users or company not found. Run npm run db:seed first.')
  }

  TEST_SESSIONS.admin = {
    user: {
      id: admin.id,
      email: admin.email,
      name: admin.name,
      role: admin.role as 'admin',
      companyId: company.id,
      companyName: company.name,
    },
  }

  TEST_SESSIONS.ops = {
    user: {
      id: ops.id,
      email: ops.email,
      name: ops.name,
      role: ops.role as 'ops',
      companyId: company.id,
      companyName: company.name,
    },
  }

  TEST_SESSIONS.viewer = {
    user: {
      id: viewer.id,
      email: viewer.email,
      name: viewer.name,
      role: viewer.role as 'viewer',
      companyId: company.id,
      companyName: company.name,
    },
  }
}
```

**Completion Criteria**:
- [ ] File compiles without TypeScript errors
- [ ] `setTestSession()` and `clearTestSession()` exported
- [ ] `TEST_SESSIONS` object with admin/ops/viewer placeholders
- [ ] `initializeTestSessions()` function to populate from DB

---

### Subtask 0.2: Create Integration Test Context Helper

**File**: `/home/pbrown/SkuInventory/tests/helpers/integration-context.ts` (NEW)

**Pattern Reference**: `/home/pbrown/SkuInventory/tests/helpers/db.ts` (existing db utilities)

**Instructions**:

1. Create helper to invoke API route handlers directly (not via HTTP)
2. Provide database cleanup helper that runs before each test
3. Create factory for test data that properly sets brand/company context

**Code Template**:
```typescript
/**
 * Integration Test Context
 * Provides utilities for testing API routes with real database
 */
import { NextRequest } from 'next/server'
import { PrismaClient } from '@prisma/client'
import { getTestPrisma, cleanupTestData } from './db'

let prisma: PrismaClient | null = null

/**
 * Get shared Prisma instance for integration tests
 */
export function getIntegrationPrisma(): PrismaClient {
  if (!prisma) {
    prisma = getTestPrisma()
  }
  return prisma
}

/**
 * Clean test data before each test
 * Preserves seed data (users, company, brand)
 */
export async function cleanupBeforeTest(): Promise<void> {
  const db = getIntegrationPrisma()
  await cleanupTestData(db)
}

/**
 * Create a mock NextRequest for route handler testing
 */
export function createTestRequest(
  path: string,
  options: {
    method?: 'GET' | 'POST' | 'PATCH' | 'DELETE'
    body?: Record<string, unknown>
    searchParams?: Record<string, string>
  } = {}
): NextRequest {
  const { method = 'GET', body, searchParams = {} } = options

  const url = new URL(path, 'http://localhost:4500')
  Object.entries(searchParams).forEach(([key, value]) => {
    url.searchParams.set(key, value)
  })

  const init: RequestInit = {
    method,
    headers: { 'Content-Type': 'application/json' },
  }

  if (body && method !== 'GET') {
    init.body = JSON.stringify(body)
  }

  return new NextRequest(url, init)
}

/**
 * Parse route handler response for assertions
 */
export async function parseRouteResponse<T>(response: Response): Promise<{
  status: number
  data: T | null
  error: string | null
}> {
  const status = response.status
  const json = await response.json().catch(() => null)

  return {
    status,
    data: json?.data ?? json,
    error: json?.error ?? null,
  }
}

/**
 * Create test component in database with proper brand context
 */
export async function createTestComponentInDb(
  companyId: string,
  overrides: Partial<{
    name: string
    skuCode: string
    category: string
    reorderPoint: number
  }> = {}
): Promise<{ id: string; name: string; skuCode: string }> {
  const db = getIntegrationPrisma()

  // Get the company's first brand
  const brand = await db.brand.findFirst({
    where: { company: { id: companyId } },
  })

  if (!brand) {
    throw new Error('No brand found for company')
  }

  // Get admin user for createdById
  const admin = await db.user.findFirst({
    where: { companyId, role: 'admin' },
  })

  const timestamp = Date.now()
  const component = await db.component.create({
    data: {
      brandId: brand.id,
      name: overrides.name ?? `Test Component ${timestamp}`,
      skuCode: overrides.skuCode ?? `TC-${timestamp}`,
      category: overrides.category ?? 'Test',
      unitOfMeasure: 'each',
      costPerUnit: 10.0,
      reorderPoint: overrides.reorderPoint ?? 100,
      leadTimeDays: 7,
      createdById: admin?.id ?? brand.id, // fallback
      updatedById: admin?.id ?? brand.id,
    },
  })

  return { id: component.id, name: component.name, skuCode: component.skuCode }
}

/**
 * Create test SKU in database with proper brand context
 */
export async function createTestSKUInDb(
  companyId: string,
  overrides: Partial<{
    name: string
    internalCode: string
    salesChannel: string
  }> = {}
): Promise<{ id: string; name: string; internalCode: string }> {
  const db = getIntegrationPrisma()

  const brand = await db.brand.findFirst({
    where: { company: { id: companyId } },
  })

  if (!brand) {
    throw new Error('No brand found for company')
  }

  const admin = await db.user.findFirst({
    where: { companyId, role: 'admin' },
  })

  const timestamp = Date.now()
  const sku = await db.sKU.create({
    data: {
      brandId: brand.id,
      name: overrides.name ?? `Test SKU ${timestamp}`,
      internalCode: overrides.internalCode ?? `SKU-${timestamp}`,
      salesChannel: overrides.salesChannel ?? 'Amazon',
      createdById: admin?.id ?? brand.id,
      updatedById: admin?.id ?? brand.id,
    },
  })

  return { id: sku.id, name: sku.name, internalCode: sku.internalCode }
}
```

**Completion Criteria**:
- [ ] File compiles without TypeScript errors
- [ ] `getIntegrationPrisma()` returns PrismaClient
- [ ] `cleanupBeforeTest()` clears test data
- [ ] `createTestRequest()` creates valid NextRequest
- [ ] `createTestComponentInDb()` creates component with brand context
- [ ] `createTestSKUInDb()` creates SKU with brand context

---

### Subtask 0.3: Create Integration Test Setup File

**File**: `/home/pbrown/SkuInventory/tests/setup.integration.ts` (NEW)

**Pattern Reference**: `/home/pbrown/SkuInventory/tests/setup.ts`

**Instructions**:

1. Create integration-specific setup that initializes test sessions
2. Set up beforeAll/afterAll hooks for database connection
3. Export re-usable setup for all integration test files

**Code Template**:
```typescript
/**
 * Integration Test Setup
 * Run once before all integration tests
 */
import '@testing-library/jest-dom'
import { beforeAll, afterAll } from 'vitest'
import { getIntegrationPrisma } from './helpers/integration-context'
import { initializeTestSessions } from './helpers/auth-mock'
import { disconnectTestDb } from './helpers/db'

beforeAll(async () => {
  // Initialize session mocks with real user IDs from database
  const prisma = getIntegrationPrisma()
  await initializeTestSessions(prisma)
})

afterAll(async () => {
  await disconnectTestDb()
})
```

**Completion Criteria**:
- [ ] File compiles without TypeScript errors
- [ ] beforeAll initializes test sessions
- [ ] afterAll disconnects database

---

### Subtask 0.4: Update Vitest Integration Config

**File**: `/home/pbrown/SkuInventory/vitest.integration.config.ts` (MODIFY)

**Current Content** (lines 1-18):
```typescript
import { defineConfig } from 'vitest/config'
import path from 'path'

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: ['./tests/setup.ts'],
    include: ['tests/integration/**/*.{test,spec}.{js,ts}'],
    testTimeout: 30000,
    hookTimeout: 30000,
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
```

**Instructions**:

1. Update setupFiles to use integration-specific setup
2. Keep existing timeout and environment settings

**Change**:
```typescript
setupFiles: ['./tests/setup.integration.ts'],
```

**Completion Criteria**:
- [ ] Config points to new setup file
- [ ] `npm run test:integration` runs without setup errors

---

## Phase 1: Convert Auth Integration Tests

### Subtask 1.1: Convert auth.test.ts - Unauthenticated Access Tests

**File**: `/home/pbrown/SkuInventory/tests/integration/auth.test.ts` (MODIFY)

**Pattern Reference**: `/home/pbrown/SkuInventory/src/app/api/components/route.ts:20-25` (auth check pattern)

**Instructions**:

1. Import the session mocking helpers and test context
2. Replace `expect(true).toBe(true)` with actual API route calls
3. Test that unauthenticated requests return 401
4. Test that viewer role gets 403 for write operations
5. Test that admin gets 200 for settings endpoints

**Conversion Template for Each Test Block**:

```typescript
import { describe, it, expect, beforeAll, beforeEach, afterAll } from 'vitest'
import { setTestSession, clearTestSession, TEST_SESSIONS, initializeTestSessions } from '../helpers/auth-mock'
import { getIntegrationPrisma, cleanupBeforeTest, createTestRequest, parseRouteResponse } from '../helpers/integration-context'
import { disconnectTestDb } from '../helpers/db'

// Import route handlers directly
import { GET as getComponents, POST as createComponent } from '@/app/api/components/route'
import { GET as getSettings, PATCH as updateSettings } from '@/app/api/settings/route'

describe('API Authentication', () => {
  beforeAll(async () => {
    const prisma = getIntegrationPrisma()
    await initializeTestSessions(prisma)
  })

  beforeEach(async () => {
    await cleanupBeforeTest()
    clearTestSession()
  })

  afterAll(async () => {
    await disconnectTestDb()
  })

  describe('Unauthenticated Access', () => {
    it('GET /api/components returns 401 when not authenticated', async () => {
      clearTestSession()

      const request = createTestRequest('/api/components')
      const response = await getComponents(request)
      const result = await parseRouteResponse(response)

      expect(result.status).toBe(401)
      expect(result.error).toBeTruthy()
    })

    it('POST /api/components returns 401 when not authenticated', async () => {
      clearTestSession()

      const request = createTestRequest('/api/components', {
        method: 'POST',
        body: { name: 'Test', skuCode: 'TEST-001', costPerUnit: 10 },
      })
      const response = await createComponent(request)
      const result = await parseRouteResponse(response)

      expect(result.status).toBe(401)
    })
  })

  describe('Role-Based Authorization', () => {
    it('viewer cannot create components (403)', async () => {
      setTestSession(TEST_SESSIONS.viewer!)

      const request = createTestRequest('/api/components', {
        method: 'POST',
        body: { name: 'Test', skuCode: 'TEST-001', costPerUnit: 10 },
      })
      const response = await createComponent(request)
      const result = await parseRouteResponse(response)

      // Note: Some routes return 401 for role check, others 403
      expect([401, 403]).toContain(result.status)
    })

    it('admin can access settings (200)', async () => {
      setTestSession(TEST_SESSIONS.admin!)

      const request = createTestRequest('/api/settings')
      const response = await getSettings()
      const result = await parseRouteResponse(response)

      expect(result.status).toBe(200)
    })

    it('ops cannot access settings (403)', async () => {
      setTestSession(TEST_SESSIONS.ops!)

      const request = createTestRequest('/api/settings')
      const response = await getSettings()
      const result = await parseRouteResponse(response)

      expect(result.status).toBe(403)
    })
  })
})
```

**Key Endpoints to Test** (from Scout's list):
- GET /api/components - 401 unauthenticated
- POST /api/components - 401 unauthenticated, 403 viewer
- GET /api/settings - 401 unauthenticated, 403 non-admin
- PATCH /api/settings - 401 unauthenticated, 403 non-admin

**Completion Criteria**:
- [ ] All 8 tests converted from documentation to implementation
- [ ] Tests use session mocking to simulate different roles
- [ ] Tests assert correct HTTP status codes
- [ ] `npm run test:integration -- auth.test.ts` passes

---

## Phase 2: Convert Tenant Scoping Tests

### Subtask 2.1: Convert tenant-scoping.test.ts - Component Isolation

**File**: `/home/pbrown/SkuInventory/tests/integration/tenant-scoping.test.ts` (MODIFY)

**Pattern Reference**: `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts` (tenant check pattern)

**Instructions**:

1. Create a second company and user for cross-tenant testing
2. Create test components in each company
3. Verify that users cannot see/access other companies' components

**Multi-Tenant Test Setup**:

```typescript
import { describe, it, expect, beforeAll, beforeEach, afterAll } from 'vitest'
import { setTestSession, clearTestSession, TEST_SESSIONS, TestUserSession } from '../helpers/auth-mock'
import { getIntegrationPrisma, cleanupBeforeTest, createTestRequest, parseRouteResponse, createTestComponentInDb } from '../helpers/integration-context'
import { hash } from 'bcryptjs'

// Import route handlers
import { GET as getComponents } from '@/app/api/components/route'
import { GET as getComponentById } from '@/app/api/components/[id]/route'

describe('Tenant Scoping', () => {
  let otherCompanySession: TestUserSession
  let otherCompanyId: string

  beforeAll(async () => {
    const prisma = getIntegrationPrisma()

    // Create second company for multi-tenant testing
    const otherCompany = await prisma.company.create({
      data: {
        name: 'Other Company Test',
        settings: {},
      },
    })
    otherCompanyId = otherCompany.id

    // Create brand for other company
    const otherBrand = await prisma.brand.create({
      data: {
        companyId: otherCompany.id,
        name: 'Other Brand Test',
      },
    })

    // Create user for other company
    const passwordHash = await hash('password123', 12)
    const otherUser = await prisma.user.create({
      data: {
        companyId: otherCompany.id,
        email: 'other@test.com',
        passwordHash,
        name: 'Other User',
        role: 'admin',
      },
    })

    otherCompanySession = {
      user: {
        id: otherUser.id,
        email: otherUser.email,
        name: otherUser.name,
        role: 'admin',
        companyId: otherCompany.id,
        companyName: otherCompany.name,
      },
    }
  })

  beforeEach(async () => {
    await cleanupBeforeTest()
  })

  afterAll(async () => {
    const prisma = getIntegrationPrisma()
    // Clean up test company
    await prisma.user.deleteMany({ where: { companyId: otherCompanyId } })
    await prisma.brand.deleteMany({ where: { companyId: otherCompanyId } })
    await prisma.company.delete({ where: { id: otherCompanyId } })
  })

  describe('Component Tenant Isolation', () => {
    it('user cannot see components from other company', async () => {
      const prisma = getIntegrationPrisma()

      // Create component in original company
      const component = await createTestComponentInDb(TEST_SESSIONS.admin!.user.companyId)

      // Try to access as other company user
      setTestSession(otherCompanySession)

      const request = createTestRequest('/api/components')
      const response = await getComponents(request)
      const result = await parseRouteResponse<{ data: Array<{ id: string }> }>(response)

      expect(result.status).toBe(200)
      // Should not include the component from other company
      const componentIds = result.data?.map((c: { id: string }) => c.id) ?? []
      expect(componentIds).not.toContain(component.id)
    })

    it('accessing component from other company returns 404', async () => {
      // Create component in original company
      const component = await createTestComponentInDb(TEST_SESSIONS.admin!.user.companyId)

      // Try to access by ID as other company user
      setTestSession(otherCompanySession)

      const request = createTestRequest(`/api/components/${component.id}`)
      const response = await getComponentById(request, { params: { id: component.id } })
      const result = await parseRouteResponse(response)

      // Should return 404, not 403 (prevents information leakage)
      expect(result.status).toBe(404)
    })
  })
})
```

**Key Tenant Tests** (17 total):
- Component list filtering by company
- Component detail 404 for cross-tenant access
- SKU list filtering by company
- SKU detail 404 for cross-tenant access
- BOM version tenant inheritance
- Transaction company scoping
- Settings company scoping
- User company scoping
- Build transaction SKU validation
- Receipt transaction component validation

**Completion Criteria**:
- [ ] Multi-tenant test context created
- [ ] All 17 tests converted to real database assertions
- [ ] Cross-tenant access correctly returns 404
- [ ] `npm run test:integration -- tenant-scoping.test.ts` passes

---

## Phase 3: Convert Transaction Tests

### Subtask 3.1: Convert transactions.test.ts - Receipt Transactions

**File**: `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts` (MODIFY)

**Pattern Reference**: `/home/pbrown/SkuInventory/src/app/api/transactions/receipt/route.ts`

**Instructions**:

1. Test receipt transaction creates positive quantity change
2. Test receipt with updateComponentCost updates component
3. Test insufficient inventory check for builds
4. Test transaction role restrictions

**Transaction Test Examples**:

```typescript
import { describe, it, expect, beforeAll, beforeEach, afterAll } from 'vitest'
import { setTestSession, TEST_SESSIONS } from '../helpers/auth-mock'
import { getIntegrationPrisma, cleanupBeforeTest, createTestRequest, parseRouteResponse, createTestComponentInDb } from '../helpers/integration-context'

import { POST as createReceipt } from '@/app/api/transactions/receipt/route'
import { POST as createAdjustment } from '@/app/api/transactions/adjustment/route'

describe('Transaction Flows', () => {
  beforeEach(async () => {
    await cleanupBeforeTest()
    setTestSession(TEST_SESSIONS.admin!)
  })

  describe('Receipt Transaction', () => {
    it('creates receipt with positive quantity change', async () => {
      const component = await createTestComponentInDb(TEST_SESSIONS.admin!.user.companyId)

      const request = createTestRequest('/api/transactions/receipt', {
        method: 'POST',
        body: {
          componentId: component.id,
          quantity: 50,
          supplier: 'Test Supplier',
          date: new Date().toISOString().split('T')[0],
        },
      })

      const response = await createReceipt(request)
      const result = await parseRouteResponse(response)

      expect(result.status).toBe(201)

      // Verify quantity in database
      const prisma = getIntegrationPrisma()
      const quantity = await prisma.transactionLine.aggregate({
        where: { componentId: component.id },
        _sum: { quantityChange: true },
      })

      expect(Number(quantity._sum.quantityChange)).toBe(50)
    })

    it('viewer cannot create receipt (403)', async () => {
      const component = await createTestComponentInDb(TEST_SESSIONS.admin!.user.companyId)

      setTestSession(TEST_SESSIONS.viewer!)

      const request = createTestRequest('/api/transactions/receipt', {
        method: 'POST',
        body: {
          componentId: component.id,
          quantity: 50,
          supplier: 'Test Supplier',
          date: new Date().toISOString().split('T')[0],
        },
      })

      const response = await createReceipt(request)
      const result = await parseRouteResponse(response)

      expect([401, 403]).toContain(result.status)
    })
  })

  describe('Adjustment Transaction', () => {
    it('negative adjustment decreases inventory', async () => {
      const component = await createTestComponentInDb(TEST_SESSIONS.admin!.user.companyId)

      // First add some inventory
      const receiptRequest = createTestRequest('/api/transactions/receipt', {
        method: 'POST',
        body: {
          componentId: component.id,
          quantity: 100,
          supplier: 'Test Supplier',
          date: new Date().toISOString().split('T')[0],
        },
      })
      await createReceipt(receiptRequest)

      // Now create negative adjustment
      const adjustmentRequest = createTestRequest('/api/transactions/adjustment', {
        method: 'POST',
        body: {
          componentId: component.id,
          quantity: -30,
          reason: 'Damaged goods',
          date: new Date().toISOString().split('T')[0],
        },
      })

      const response = await createAdjustment(adjustmentRequest)
      const result = await parseRouteResponse(response)

      expect(result.status).toBe(201)

      // Verify final quantity
      const prisma = getIntegrationPrisma()
      const quantity = await prisma.transactionLine.aggregate({
        where: { componentId: component.id },
        _sum: { quantityChange: true },
      })

      expect(Number(quantity._sum.quantityChange)).toBe(70) // 100 - 30
    })
  })
})
```

**Key Transaction Tests** (21 total):
- Receipt creates positive quantity change
- Receipt validation (required fields)
- Receipt with cost update
- Adjustment positive/negative
- Adjustment requires reason
- Build consumes components per BOM
- Build insufficient inventory check
- Build allowInsufficientInventory flag
- Build with company settings override
- Transaction role restrictions (viewer blocked)
- Transaction audit trail (createdById)

**Completion Criteria**:
- [ ] All 21 tests converted with real database operations
- [ ] Quantity calculations verified via Prisma aggregate
- [ ] Role restrictions tested
- [ ] `npm run test:integration -- transactions.test.ts` passes

---

## Phase 4: Convert Settings Tests

### Subtask 4.1: Convert settings.test.ts

**File**: `/home/pbrown/SkuInventory/tests/integration/settings.test.ts` (MODIFY)

**Pattern Reference**: `/home/pbrown/SkuInventory/src/app/api/settings/route.ts`

**Instructions**:

1. Test GET returns merged settings with defaults
2. Test PATCH updates settings
3. Test admin-only access
4. Test settings affect business logic (e.g., allowNegativeInventory)

**Settings Test Examples**:

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { setTestSession, TEST_SESSIONS } from '../helpers/auth-mock'
import { getIntegrationPrisma, cleanupBeforeTest, createTestRequest, parseRouteResponse } from '../helpers/integration-context'

import { GET as getSettings, PATCH as updateSettings } from '@/app/api/settings/route'

describe('Settings API', () => {
  beforeEach(async () => {
    await cleanupBeforeTest()
    setTestSession(TEST_SESSIONS.admin!)
  })

  describe('GET /api/settings', () => {
    it('returns company settings merged with defaults', async () => {
      const response = await getSettings()
      const result = await parseRouteResponse<{
        data: { settings: { allowNegativeInventory: boolean; defaultLeadTimeDays: number } }
      }>(response)

      expect(result.status).toBe(200)
      expect(result.data?.settings).toBeDefined()
      expect(typeof result.data?.settings.allowNegativeInventory).toBe('boolean')
      expect(typeof result.data?.settings.defaultLeadTimeDays).toBe('number')
    })

    it('returns 403 for non-admin users', async () => {
      setTestSession(TEST_SESSIONS.ops!)

      const response = await getSettings()
      const result = await parseRouteResponse(response)

      expect(result.status).toBe(403)
    })
  })

  describe('PATCH /api/settings', () => {
    it('updates settings and persists them', async () => {
      const request = createTestRequest('/api/settings', {
        method: 'PATCH',
        body: { allowNegativeInventory: true },
      })

      const response = await updateSettings(request)
      const result = await parseRouteResponse(response)

      expect(result.status).toBe(200)

      // Verify in database
      const prisma = getIntegrationPrisma()
      const company = await prisma.company.findFirst({
        where: { id: TEST_SESSIONS.admin!.user.companyId },
      })

      expect((company?.settings as Record<string, unknown>)?.allowNegativeInventory).toBe(true)
    })
  })
})
```

**Key Settings Tests** (21 total):
- GET returns settings with defaults
- GET admin-only restriction
- PATCH updates settings
- PATCH validation errors
- allowNegativeInventory default is false
- allowNegativeInventory effect on builds
- defaultLeadTimeDays default is 7
- defaultLeadTimeDays effect on component creation
- reorderWarningMultiplier effect on status
- dateFormat options
- currencySymbol default
- decimalPlaces valid range

**Completion Criteria**:
- [ ] All 21 tests converted to real database operations
- [ ] Settings persistence verified via Prisma query
- [ ] Admin-only access enforced
- [ ] `npm run test:integration -- settings.test.ts` passes

---

## Phase 5: Convert Import/Export Tests

### Subtask 5.1: Convert import-export.test.ts

**File**: `/home/pbrown/SkuInventory/tests/integration/import-export.test.ts` (MODIFY)

**Pattern Reference**: `/home/pbrown/SkuInventory/src/app/api/import/components/route.ts`

**Instructions**:

1. Test CSV import creates database records
2. Test export reflects database state
3. Test round-trip export/import
4. Test tenant scoping on import/export

**Import/Export Test Examples**:

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { setTestSession, TEST_SESSIONS } from '../helpers/auth-mock'
import { getIntegrationPrisma, cleanupBeforeTest, createTestRequest, parseRouteResponse, createTestComponentInDb } from '../helpers/integration-context'

import { POST as importComponents } from '@/app/api/import/components/route'
import { GET as exportComponents } from '@/app/api/export/components/route'

describe('Import/Export API', () => {
  beforeEach(async () => {
    await cleanupBeforeTest()
    setTestSession(TEST_SESSIONS.admin!)
  })

  describe('POST /api/import/components', () => {
    it('creates components from valid CSV', async () => {
      const csvContent = `Name,SKU Code,Category,Cost Per Unit
Import Widget,IMP-001,Test,25.00
Import Gadget,IMP-002,Test,15.00`

      const request = createTestRequest('/api/import/components', {
        method: 'POST',
        body: { csvContent },
      })

      const response = await importComponents(request)
      const result = await parseRouteResponse<{
        total: number
        successful: number
        failed: number
      }>(response)

      expect(result.status).toBe(200)
      expect(result.data?.successful).toBe(2)

      // Verify in database
      const prisma = getIntegrationPrisma()
      const imported = await prisma.component.findMany({
        where: { skuCode: { in: ['IMP-001', 'IMP-002'] } },
      })

      expect(imported.length).toBe(2)
    })

    it('returns errors for invalid rows', async () => {
      const csvContent = `Name,SKU Code,Category
,MISSING-NAME,Test
Has Name,,Test`

      const request = createTestRequest('/api/import/components', {
        method: 'POST',
        body: { csvContent },
      })

      const response = await importComponents(request)
      const result = await parseRouteResponse<{
        total: number
        successful: number
        failed: number
      }>(response)

      expect(result.data?.failed).toBeGreaterThan(0)
    })
  })

  describe('GET /api/export/components', () => {
    it('exports components as CSV', async () => {
      // Create test component
      await createTestComponentInDb(TEST_SESSIONS.admin!.user.companyId, {
        name: 'Export Widget',
        skuCode: 'EXP-001',
      })

      const request = createTestRequest('/api/export/components')
      const response = await exportComponents(request)

      expect(response.status).toBe(200)
      expect(response.headers.get('content-type')).toContain('text/csv')

      const csvContent = await response.text()
      expect(csvContent).toContain('Export Widget')
      expect(csvContent).toContain('EXP-001')
    })

    it('only exports components from user company', async () => {
      // Create component in main company
      await createTestComponentInDb(TEST_SESSIONS.admin!.user.companyId, {
        name: 'My Widget',
        skuCode: 'MY-001',
      })

      const request = createTestRequest('/api/export/components')
      const response = await exportComponents(request)
      const csvContent = await response.text()

      expect(csvContent).toContain('MY-001')
      // Should not contain components from other companies (if any exist)
    })
  })
})
```

**Key Import/Export Tests** (29 total):
- Import creates database records
- Import validates each row
- Import handles duplicates
- Import respects tenant scoping
- Import role restriction (viewer blocked)
- Export returns CSV format
- Export includes calculated fields
- Export CSV escaping
- Export tenant scoping
- SKU import/export
- Transaction export
- Template download
- Round-trip compatibility

**Completion Criteria**:
- [ ] All 29 tests converted to real database operations
- [ ] Import creates records in database
- [ ] Export reflects database state
- [ ] Tenant scoping verified
- [ ] `npm run test:integration -- import-export.test.ts` passes

---

## Phase 6: CI Workflow Integration

### Subtask 6.1: Update CI Workflow for Integration Tests

**File**: `/home/pbrown/SkuInventory/.github/workflows/test.yml` (MODIFY)

**Current Location**: After line 61 (after unit tests, before e2e job)

**Instructions**:

1. Add integration test step after unit tests
2. Use TEST_DATABASE_URL environment variable
3. Run seed before integration tests

**Add After Line 61**:
```yaml
      - name: Run integration tests
        run: npm run test:integration -- --run
        env:
          TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/trevor_test
          NEXTAUTH_SECRET: test-secret-for-ci
```

**Completion Criteria**:
- [ ] CI workflow includes integration test step
- [ ] Integration tests run after unit tests
- [ ] Database environment correctly configured
- [ ] CI passes with all tests

---

### Subtask 6.2: Add Integration Test CI Script

**File**: `/home/pbrown/SkuInventory/package.json` (MODIFY)

**Instructions**:

1. Add `test:integration:ci` script for CI-specific run
2. Ensure proper exit codes for CI

**Add to scripts section**:
```json
"test:integration:ci": "vitest run --config vitest.integration.config.ts --reporter=verbose"
```

**Completion Criteria**:
- [ ] Script added to package.json
- [ ] Script runs without interactive mode
- [ ] Verbose output for CI debugging

---

## Summary of Deliverables

**Files Created**: 3
- `/home/pbrown/SkuInventory/tests/helpers/auth-mock.ts`
- `/home/pbrown/SkuInventory/tests/helpers/integration-context.ts`
- `/home/pbrown/SkuInventory/tests/setup.integration.ts`

**Files Modified**: 7
- `/home/pbrown/SkuInventory/tests/integration/auth.test.ts`
- `/home/pbrown/SkuInventory/tests/integration/tenant-scoping.test.ts`
- `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`
- `/home/pbrown/SkuInventory/tests/integration/settings.test.ts`
- `/home/pbrown/SkuInventory/tests/integration/import-export.test.ts`
- `/home/pbrown/SkuInventory/vitest.integration.config.ts`
- `/home/pbrown/SkuInventory/.github/workflows/test.yml`

---

## Validation Commands

After each phase, run:

```bash
# TypeScript check
npx tsc --noEmit

# Run specific integration test file
npm run test:integration -- auth.test.ts --run

# Run all integration tests
npm run test:integration -- --run

# Full test suite
npm run test:all
```

---

## Acceptance Criteria Checklist

From Issue #40:
- [ ] Test database setup/teardown utilities implemented (Phase 0)
- [ ] Transaction rollback between tests prevents state leakage (cleanupBeforeTest)
- [ ] Test fixtures created for common scenarios (createTestComponentInDb, createTestSKUInDb)
- [ ] NextAuth getServerSession mocked for test users (auth-mock.ts)
- [ ] Different user roles supported (admin, ops, viewer)
- [ ] Tenant/company scoping handled in test context
- [ ] auth.test.ts: Verify unauthenticated requests return 401
- [ ] tenant-scoping.test.ts: Verify cross-tenant access returns 404
- [ ] transactions.test.ts: Verify inventory updates after transactions
- [ ] settings.test.ts: Verify settings affect business logic
- [ ] import-export.test.ts: Verify CSV import creates database records
- [ ] All 96 integration tests pass with real database connections
- [ ] CI workflow runs integration tests with database service
- [ ] Test execution time remains reasonable (<2 minutes)

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 0 -> Phase 1 -> ... -> Phase 6)
2. Complete Phase 0 fully before converting any test files
3. After each helper file, verify TypeScript compiles
4. After each test file conversion, run that specific test file
5. Run `npm run test:integration -- --run` after all conversions
6. Run full test suite before marking complete: `npm run test:all`

**Important Notes**:
- Session mocking must happen BEFORE route imports (hoisting)
- Use `vi.mock()` at module level, not inside tests
- Each test should clean up after itself via `cleanupBeforeTest()`
- Multi-tenant tests need separate company/brand/user created in beforeAll

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Scout Review | 8m |
| Pattern Research | 12m |
| Schema Verification | 5m |
| Plan Writing | 25m |
| **Total** | **50m** |

---

AGENT_RETURN: plan-40-120325
