# Implementation Plan
**Generated**: 2024-12-04
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #169
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #169
**Priority**: Medium

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="import"` for import-related tests

### Issue Validation
**Status**: Valid
**Recent Changes**: No recent commits affecting import templates

### Current State Assessment
- **Existing components**:
  - `src/services/import.ts` - Contains `generateComponentTemplate()` and `generateSKUTemplate()` functions (static, no reference data)
  - `src/app/api/import/template/[type]/route.ts` - Template download endpoint (calls service functions)
  - `src/app/api/import/components/route.ts` - Component import endpoint (uses session's selectedCompanyId/selectedBrandId)
  - `src/app/api/import/skus/route.ts` - SKU import endpoint (uses session's selectedCompanyId/selectedBrandId)
- **Database**: Uses existing Company, Brand, Location, Category models - no schema changes needed
- **API Routes**: All import routes use `getServerSession` for authentication
- **Types**: `src/types/component.ts` and `src/types/sku.ts` have schemas but no company/brand/location fields in import schemas

### Dependencies & Blockers
1. No blockers identified
2. All required models (Company, Brand, Location, Category) exist in Prisma schema
3. The template route already has access to session data for company scoping

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 6-8 hours
**Risk**: Low - Mostly additive changes to existing patterns

### Patterns Identified
**Primary**: `src/app/api/import/initial-inventory/route.ts` - Shows lookup pattern by name/code
**Secondary**: `src/app/api/brands/route.ts` - Shows how to fetch brands with company scope

### Ripple Effect Analysis
**Files Identified**: 7
- `src/services/import.ts` - Add new columns to templates, add lookup types
- `src/app/api/import/template/[type]/route.ts` - Fetch reference data, generate enhanced templates
- `src/app/api/import/components/route.ts` - Validate and lookup company/brand/location/category by name
- `src/app/api/import/skus/route.ts` - Validate and lookup company/brand by name
- `tests/unit/csv-import.test.ts` - Update unit tests for new fields
- `tests/integration/import-export.test.ts` - Update integration tests for new fields

---

## Executive Summary
Update CSV import templates for Components and SKUs to include Company, Brand, Location, and Category columns. Templates will include a commented reference section listing all valid options. Import routes will be enhanced to validate and lookup these entities by name rather than requiring database IDs.

## Phase 1: Service Layer - Template Generation Enhancement

### Subtask 1.1: Add Types for Reference Data
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing interface patterns in the file
**Instructions**:
1. Add new interface for reference data that will be passed to template generators:
```typescript
export interface TemplateReferenceData {
  companies: { name: string }[]
  brands: { name: string; companyName: string }[]
  locations: { name: string; companyName: string }[]
  categories: { name: string }[]
}
```
2. Add new interface for extended component import data:
```typescript
export interface ComponentImportWithLookups {
  name: string
  skuCode: string
  company?: string    // Company name for lookup
  brand?: string      // Brand name for lookup
  location?: string   // Location name for lookup (optional)
  category?: string
  unitOfMeasure: string
  costPerUnit: number
  reorderPoint: number
  leadTimeDays: number
  notes: string | null
}
```
3. Add new interface for extended SKU import data:
```typescript
export interface SKUImportWithLookups {
  name: string
  internalCode: string
  company?: string    // Company name for lookup
  brand?: string      // Brand name for lookup
  salesChannel: 'Amazon' | 'Shopify' | 'TikTok' | 'Generic'
  notes: string | null
}
```
**Completion Criteria**:
- [ ] Interfaces compile without errors
- [ ] `npx tsc --noEmit` passes

### Subtask 1.2: Update Component Import Schema
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing `componentImportSchema` pattern (lines 97-106)
**Instructions**:
1. Add optional company, brand, location fields to `componentImportSchema`:
```typescript
const componentImportSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  sku_code: z.string().min(1, 'SKU code is required'),
  company: z.string().optional().transform((v) => v || undefined),
  brand: z.string().optional().transform((v) => v || undefined),
  location: z.string().optional().transform((v) => v || undefined),
  category: z.string().optional().transform((v) => v || null),
  unit_of_measure: z.string().optional().default('each'),
  cost_per_unit: z.string().optional().transform((v) => (v ? parseFloat(v) : 0)),
  reorder_point: z.string().optional().transform((v) => (v ? parseInt(v, 10) : 0)),
  lead_time_days: z.string().optional().transform((v) => (v ? parseInt(v, 10) : 0)),
  notes: z.string().optional().transform((v) => v || null),
})
```
**Completion Criteria**:
- [ ] Schema updated with new fields
- [ ] `npx tsc --noEmit` passes

### Subtask 1.3: Update SKU Import Schema
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing `skuImportSchema` pattern (lines 109-114)
**Instructions**:
1. Add optional company, brand fields to `skuImportSchema`:
```typescript
const skuImportSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  internal_code: z.string().min(1, 'Internal code is required'),
  company: z.string().optional().transform((v) => v || undefined),
  brand: z.string().optional().transform((v) => v || undefined),
  sales_channel: z.enum(['Amazon', 'Shopify', 'TikTok', 'Generic']),
  notes: z.string().optional().transform((v) => v || null),
})
```
**Completion Criteria**:
- [ ] Schema updated with new fields
- [ ] `npx tsc --noEmit` passes

### Subtask 1.4: Update importComponentRow Function
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing `importComponentRow` function (lines 148-193)
**Instructions**:
1. Update the function to pass through the new lookup fields:
```typescript
function importComponentRow(
  record: Record<string, string>,
  rowNumber: number
): ImportResult<ComponentImportWithLookups> {
  try {
    const csvParsed = componentImportSchema.parse(record)

    const componentData: ComponentImportWithLookups = {
      name: csvParsed.name,
      skuCode: csvParsed.sku_code,
      company: csvParsed.company,
      brand: csvParsed.brand,
      location: csvParsed.location,
      category: csvParsed.category,
      unitOfMeasure: csvParsed.unit_of_measure,
      costPerUnit: csvParsed.cost_per_unit,
      reorderPoint: csvParsed.reorder_point,
      leadTimeDays: csvParsed.lead_time_days,
      notes: csvParsed.notes,
    }

    return {
      success: true,
      rowNumber,
      data: componentData,
      errors: [],
    }
  } catch (err) {
    // ... existing error handling
  }
}
```
2. Update the return type and remove createComponentSchema validation (validation happens in API route)
**Completion Criteria**:
- [ ] Function returns new type with lookup fields
- [ ] `npx tsc --noEmit` passes

### Subtask 1.5: Update importSKURow Function
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing `importSKURow` function (lines 198-240)
**Instructions**:
1. Update the function to pass through the new lookup fields:
```typescript
function importSKURow(
  record: Record<string, string>,
  rowNumber: number
): ImportResult<SKUImportWithLookups> {
  try {
    const csvParsed = skuImportSchema.parse(record)

    const skuData: SKUImportWithLookups = {
      name: csvParsed.name,
      internalCode: csvParsed.internal_code,
      company: csvParsed.company,
      brand: csvParsed.brand,
      salesChannel: csvParsed.sales_channel,
      notes: csvParsed.notes,
    }

    return {
      success: true,
      rowNumber,
      data: skuData,
      errors: [],
    }
  } catch (err) {
    // ... existing error handling
  }
}
```
**Completion Criteria**:
- [ ] Function returns new type with lookup fields
- [ ] `npx tsc --noEmit` passes

### Subtask 1.6: Update processComponentImport Return Type
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing function (lines 295-323)
**Instructions**:
1. Update the return type signature:
```typescript
export function processComponentImport(
  csvContent: string
): ImportSummary<ComponentImportWithLookups> {
  // ... existing implementation works as-is
}
```
**Completion Criteria**:
- [ ] Return type updated
- [ ] `npx tsc --noEmit` passes

### Subtask 1.7: Update processSKUImport Return Type
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing function (lines 328-356)
**Instructions**:
1. Update the return type signature:
```typescript
export function processSKUImport(
  csvContent: string
): ImportSummary<SKUImportWithLookups> {
  // ... existing implementation works as-is
}
```
**Completion Criteria**:
- [ ] Return type updated
- [ ] `npx tsc --noEmit` passes

### Subtask 1.8: Update generateComponentTemplate Function
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing function (lines 394-418)
**Instructions**:
1. Add reference data parameter and generate enhanced template:
```typescript
export function generateComponentTemplate(referenceData?: TemplateReferenceData): string {
  const headers = [
    'Name',
    'SKU Code',
    'Company',
    'Brand',
    'Location',
    'Category',
    'Unit of Measure',
    'Cost Per Unit',
    'Reorder Point',
    'Lead Time (Days)',
    'Notes',
  ]

  const exampleRow = [
    'Example Component',
    'COMP-001',
    referenceData?.companies[0]?.name || 'Company Name',
    referenceData?.brands[0]?.name || 'Brand Name',
    referenceData?.locations[0]?.name || '',
    'Electronics',
    'each',
    '10.50',
    '100',
    '7',
    'Sample component for import',
  ]

  const lines = [headers.join(','), exampleRow.join(',')]

  // Add reference section if data provided
  if (referenceData) {
    lines.push('')
    lines.push('# === VALID OPTIONS REFERENCE (delete these lines before importing) ===')
    lines.push('#')
    lines.push('# COMPANIES:')
    for (const company of referenceData.companies) {
      lines.push(`#   ${company.name}`)
    }
    lines.push('#')
    lines.push('# BRANDS (Company -> Brand):')
    for (const brand of referenceData.brands) {
      lines.push(`#   ${brand.companyName} -> ${brand.name}`)
    }
    lines.push('#')
    lines.push('# LOCATIONS (Company -> Location):')
    for (const location of referenceData.locations) {
      lines.push(`#   ${location.companyName} -> ${location.name}`)
    }
    lines.push('#')
    lines.push('# CATEGORIES:')
    for (const category of referenceData.categories) {
      lines.push(`#   ${category.name}`)
    }
    lines.push('# ===================================================================')
  }

  return lines.join('\n')
}
```
**Completion Criteria**:
- [ ] Function accepts optional reference data
- [ ] Template includes new columns
- [ ] Reference section appended when data provided
- [ ] `npx tsc --noEmit` passes

### Subtask 1.9: Update generateSKUTemplate Function
**File**: `/home/pbrown/SkuInventory/src/services/import.ts`
**Pattern**: Follow existing function (lines 423-429)
**Instructions**:
1. Add reference data parameter and generate enhanced template:
```typescript
export function generateSKUTemplate(referenceData?: TemplateReferenceData): string {
  const headers = ['Name', 'Internal Code', 'Company', 'Brand', 'Sales Channel', 'Notes']

  const exampleRow = [
    'Example SKU',
    'SKU-001',
    referenceData?.companies[0]?.name || 'Company Name',
    referenceData?.brands[0]?.name || 'Brand Name',
    'Amazon',
    'Sample SKU for import',
  ]

  const lines = [headers.join(','), exampleRow.join(',')]

  // Add reference section if data provided
  if (referenceData) {
    lines.push('')
    lines.push('# === VALID OPTIONS REFERENCE (delete these lines before importing) ===')
    lines.push('#')
    lines.push('# COMPANIES:')
    for (const company of referenceData.companies) {
      lines.push(`#   ${company.name}`)
    }
    lines.push('#')
    lines.push('# BRANDS (Company -> Brand):')
    for (const brand of referenceData.brands) {
      lines.push(`#   ${brand.companyName} -> ${brand.name}`)
    }
    lines.push('#')
    lines.push('# SALES CHANNELS:')
    lines.push('#   Amazon, Shopify, TikTok, Generic')
    lines.push('# ===================================================================')
  }

  return lines.join('\n')
}
```
**Completion Criteria**:
- [ ] Function accepts optional reference data
- [ ] Template includes new columns
- [ ] Reference section appended when data provided
- [ ] `npx tsc --noEmit` passes

## Phase 2: API Routes - Template Download Enhancement

### Subtask 2.1: Update Template Route to Fetch Reference Data
**File**: `/home/pbrown/SkuInventory/src/app/api/import/template/[type]/route.ts`
**Pattern**: Follow `src/app/api/brands/route.ts` for querying brands
**Instructions**:
1. Import prisma and TemplateReferenceData type
2. Add function to fetch reference data for the user's accessible companies:
```typescript
import { prisma } from '@/lib/db'
import {
  generateComponentTemplate,
  generateSKUTemplate,
  generateInitialInventoryTemplate,
  type TemplateReferenceData,
} from '@/services/import'

async function fetchReferenceData(userId: string, selectedCompanyId: string): Promise<TemplateReferenceData> {
  // Get user's accessible companies
  const userCompanies = await prisma.userCompany.findMany({
    where: { userId },
    include: { company: true },
  })

  const companyIds = userCompanies.map(uc => uc.companyId)
  // Also include the user's primary company
  const user = await prisma.user.findUnique({ where: { id: userId } })
  if (user && !companyIds.includes(user.companyId)) {
    companyIds.push(user.companyId)
  }

  // Fetch all reference data in parallel
  const [companies, brands, locations, categories] = await Promise.all([
    prisma.company.findMany({
      where: { id: { in: companyIds } },
      select: { name: true },
      orderBy: { name: 'asc' },
    }),
    prisma.brand.findMany({
      where: { companyId: { in: companyIds }, isActive: true },
      select: { name: true, company: { select: { name: true } } },
      orderBy: [{ company: { name: 'asc' } }, { name: 'asc' }],
    }),
    prisma.location.findMany({
      where: { companyId: { in: companyIds }, isActive: true },
      select: { name: true, company: { select: { name: true } } },
      orderBy: [{ company: { name: 'asc' } }, { name: 'asc' }],
    }),
    prisma.category.findMany({
      where: { companyId: selectedCompanyId, isActive: true },
      select: { name: true },
      orderBy: { name: 'asc' },
    }),
  ])

  return {
    companies: companies.map(c => ({ name: c.name })),
    brands: brands.map(b => ({ name: b.name, companyName: b.company.name })),
    locations: locations.map(l => ({ name: l.name, companyName: l.company.name })),
    categories: categories.map(c => ({ name: c.name })),
  }
}
```
3. Update GET handler to fetch and pass reference data:
```typescript
export async function GET(request: NextRequest, { params }: RouteParams) {
  const session = await getServerSession(authOptions)
  if (!session?.user) {
    return unauthorized()
  }

  if (session.user.role === 'viewer') {
    return unauthorized('Viewers cannot access import templates')
  }

  const { type } = await params

  // Fetch reference data for components and skus templates
  let referenceData: TemplateReferenceData | undefined
  if (type === 'components' || type === 'skus') {
    referenceData = await fetchReferenceData(session.user.id, session.user.selectedCompanyId)
  }

  let csvContent: string
  let filename: string

  switch (type) {
    case 'components':
      csvContent = generateComponentTemplate(referenceData)
      filename = 'component-import-template.csv'
      break
    case 'skus':
      csvContent = generateSKUTemplate(referenceData)
      filename = 'sku-import-template.csv'
      break
    case 'initial-inventory':
      csvContent = generateInitialInventoryTemplate()
      filename = 'initial-inventory-import-template.csv'
      break
    default:
      return notFound('Template type')
  }

  return new NextResponse(csvContent, {
    headers: {
      'Content-Type': 'text/csv',
      'Content-Disposition': `attachment; filename="${filename}"`,
    },
  })
}
```
**Completion Criteria**:
- [ ] Reference data fetched for components/skus templates
- [ ] Template includes reference section
- [ ] `npm run build` passes
- [ ] `npx tsc --noEmit` passes

## Phase 3: API Routes - Component Import Enhancement

### Subtask 3.1: Add Lookup Maps Type and Pre-fetch Function
**File**: `/home/pbrown/SkuInventory/src/app/api/import/components/route.ts`
**Pattern**: Follow `src/app/api/import/initial-inventory/route.ts` lookup pattern
**Instructions**:
1. Add type for lookup maps:
```typescript
interface LookupMaps {
  companies: Map<string, string>  // name -> id
  brands: Map<string, { id: string; companyId: string }>  // "companyName|brandName" -> { id, companyId }
  locations: Map<string, { id: string; companyId: string }>  // "companyName|locationName" -> { id, companyId }
  categories: Map<string, string>  // name (lowercase) -> name (original case)
}
```
2. Add function to pre-fetch all lookup data:
```typescript
async function buildLookupMaps(userId: string, selectedCompanyId: string): Promise<LookupMaps> {
  // Get user's accessible companies
  const userCompanies = await prisma.userCompany.findMany({
    where: { userId },
    select: { companyId: true },
  })
  const companyIds = [selectedCompanyId, ...userCompanies.map(uc => uc.companyId)]
  const uniqueCompanyIds = [...new Set(companyIds)]

  const [companies, brands, locations, categories] = await Promise.all([
    prisma.company.findMany({
      where: { id: { in: uniqueCompanyIds } },
      select: { id: true, name: true },
    }),
    prisma.brand.findMany({
      where: { companyId: { in: uniqueCompanyIds }, isActive: true },
      select: { id: true, name: true, companyId: true, company: { select: { name: true } } },
    }),
    prisma.location.findMany({
      where: { companyId: { in: uniqueCompanyIds }, isActive: true },
      select: { id: true, name: true, companyId: true, company: { select: { name: true } } },
    }),
    prisma.category.findMany({
      where: { companyId: selectedCompanyId, isActive: true },
      select: { name: true },
    }),
  ])

  return {
    companies: new Map(companies.map(c => [c.name.toLowerCase(), c.id])),
    brands: new Map(brands.map(b => [
      `${b.company.name.toLowerCase()}|${b.name.toLowerCase()}`,
      { id: b.id, companyId: b.companyId }
    ])),
    locations: new Map(locations.map(l => [
      `${l.company.name.toLowerCase()}|${l.name.toLowerCase()}`,
      { id: l.id, companyId: l.companyId }
    ])),
    categories: new Map(categories.map(c => [c.name.toLowerCase(), c.name])),
  }
}
```
**Completion Criteria**:
- [ ] Lookup maps type defined
- [ ] Pre-fetch function implemented
- [ ] `npx tsc --noEmit` passes

### Subtask 3.2: Update Component Import Route Handler
**File**: `/home/pbrown/SkuInventory/src/app/api/import/components/route.ts`
**Pattern**: Follow existing route handler with enhanced lookup
**Instructions**:
1. Update imports to use new type:
```typescript
import { processComponentImport, type ImportSummary, type ComponentImportWithLookups } from '@/services/import'
```
2. Update the POST handler to use lookups:
```typescript
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    if (session.user.role === 'viewer') {
      return unauthorized('Viewers cannot import data')
    }

    const selectedCompanyId = session.user.selectedCompanyId
    let defaultBrandId = session.user.selectedBrandId

    if (!defaultBrandId) {
      const brand = await prisma.brand.findFirst({
        where: { companyId: selectedCompanyId, isActive: true },
      })
      if (!brand) {
        return error('No active brand found for selected company', 400)
      }
      defaultBrandId = brand.id
    }

    // Parse CSV content
    const contentType = request.headers.get('content-type') || ''
    let csvContent: string

    if (contentType.includes('multipart/form-data')) {
      const formData = await request.formData()
      const file = formData.get('file') as File | null
      if (!file) {
        return error('No file provided', 400)
      }
      csvContent = await file.text()
    } else {
      csvContent = await request.text()
    }

    if (!csvContent.trim()) {
      return error('Empty file provided', 400)
    }

    // Pre-fetch all lookup data (avoid N+1 queries)
    const lookupMaps = await buildLookupMaps(session.user.id, selectedCompanyId)

    // Process CSV
    const importSummary: ImportSummary<ComponentImportWithLookups> = processComponentImport(csvContent)

    const result: ComponentImportResult = {
      total: importSummary.total,
      imported: 0,
      skipped: 0,
      errors: [],
    }

    // Import successful rows
    for (const row of importSummary.results) {
      if (!row.success || !row.data) {
        result.skipped++
        result.errors.push({
          rowNumber: row.rowNumber,
          name: '',
          errors: row.errors,
        })
        continue
      }

      const componentData = row.data

      try {
        // Resolve company (use provided or default to selected)
        let companyId = selectedCompanyId
        if (componentData.company) {
          const resolvedCompanyId = lookupMaps.companies.get(componentData.company.toLowerCase())
          if (!resolvedCompanyId) {
            result.skipped++
            result.errors.push({
              rowNumber: row.rowNumber,
              name: componentData.name,
              errors: [`Company "${componentData.company}" not found. Valid options are listed in the template.`],
            })
            continue
          }
          companyId = resolvedCompanyId
        }

        // Resolve brand (use provided or default)
        let brandId = defaultBrandId
        if (componentData.brand) {
          // Find brand for the resolved company
          const companyName = componentData.company ||
            Array.from(lookupMaps.companies.entries()).find(([_, id]) => id === companyId)?.[0] || ''
          const brandKey = `${companyName.toLowerCase()}|${componentData.brand.toLowerCase()}`
          const resolvedBrand = lookupMaps.brands.get(brandKey)
          if (!resolvedBrand) {
            result.skipped++
            result.errors.push({
              rowNumber: row.rowNumber,
              name: componentData.name,
              errors: [`Brand "${componentData.brand}" not found for company. Valid options are listed in the template.`],
            })
            continue
          }
          brandId = resolvedBrand.id
          // Verify brand belongs to resolved company
          if (resolvedBrand.companyId !== companyId) {
            result.skipped++
            result.errors.push({
              rowNumber: row.rowNumber,
              name: componentData.name,
              errors: [`Brand "${componentData.brand}" does not belong to the specified company.`],
            })
            continue
          }
        }

        // Resolve location (optional)
        let locationId: string | undefined
        if (componentData.location) {
          const companyName = componentData.company ||
            Array.from(lookupMaps.companies.entries()).find(([_, id]) => id === companyId)?.[0] || ''
          const locationKey = `${companyName.toLowerCase()}|${componentData.location.toLowerCase()}`
          const resolvedLocation = lookupMaps.locations.get(locationKey)
          if (!resolvedLocation) {
            result.skipped++
            result.errors.push({
              rowNumber: row.rowNumber,
              name: componentData.name,
              errors: [`Location "${componentData.location}" not found for company. Valid options are listed in the template.`],
            })
            continue
          }
          locationId = resolvedLocation.id
        }

        // Resolve category (use canonical casing from database)
        let category = componentData.category
        if (category) {
          const canonicalCategory = lookupMaps.categories.get(category.toLowerCase())
          if (canonicalCategory) {
            category = canonicalCategory
          }
          // Note: Categories can be free-text, so we don't fail on unknown categories
        }

        // Check for duplicate
        const existing = await prisma.component.findFirst({
          where: {
            companyId,
            OR: [{ name: componentData.name }, { skuCode: componentData.skuCode }],
          },
        })

        if (existing) {
          result.skipped++
          result.errors.push({
            rowNumber: row.rowNumber,
            name: componentData.name,
            errors: [
              existing.name === componentData.name
                ? `Component with name "${componentData.name}" already exists`
                : `Component with SKU code "${componentData.skuCode}" already exists`,
            ],
          })
          continue
        }

        // Create component
        await prisma.component.create({
          data: {
            brandId,
            companyId,
            name: componentData.name,
            skuCode: componentData.skuCode,
            category: category ?? null,
            unitOfMeasure: componentData.unitOfMeasure ?? 'each',
            costPerUnit: new Prisma.Decimal(componentData.costPerUnit ?? 0),
            reorderPoint: componentData.reorderPoint ?? 0,
            leadTimeDays: componentData.leadTimeDays ?? 0,
            notes: componentData.notes ?? null,
            createdById: session.user.id,
            updatedById: session.user.id,
          },
        })

        result.imported++
      } catch (err) {
        result.skipped++
        result.errors.push({
          rowNumber: row.rowNumber,
          name: componentData.name,
          errors: [err instanceof Error ? err.message : 'Database error'],
        })
      }
    }

    return success(result)
  } catch (err) {
    console.error('Error importing components:', err)
    return serverError()
  }
}
```
**Completion Criteria**:
- [ ] Lookups resolve company/brand/location by name
- [ ] Clear error messages for invalid lookups
- [ ] `npm run build` passes
- [ ] `npx tsc --noEmit` passes

## Phase 4: API Routes - SKU Import Enhancement

### Subtask 4.1: Update SKU Import Route Handler
**File**: `/home/pbrown/SkuInventory/src/app/api/import/skus/route.ts`
**Pattern**: Follow component import route pattern
**Instructions**:
1. Add same lookup types and buildLookupMaps function (can be simplified to just companies and brands)
2. Update imports:
```typescript
import { processSKUImport, type ImportSummary, type SKUImportWithLookups } from '@/services/import'
```
3. Update POST handler similar to components route but for SKUs:
```typescript
// Add LookupMaps type (same as components)
// Add buildLookupMaps function (simpler - just companies and brands)

async function buildLookupMaps(userId: string, selectedCompanyId: string): Promise<LookupMaps> {
  const userCompanies = await prisma.userCompany.findMany({
    where: { userId },
    select: { companyId: true },
  })
  const companyIds = [selectedCompanyId, ...userCompanies.map(uc => uc.companyId)]
  const uniqueCompanyIds = [...new Set(companyIds)]

  const [companies, brands] = await Promise.all([
    prisma.company.findMany({
      where: { id: { in: uniqueCompanyIds } },
      select: { id: true, name: true },
    }),
    prisma.brand.findMany({
      where: { companyId: { in: uniqueCompanyIds }, isActive: true },
      select: { id: true, name: true, companyId: true, company: { select: { name: true } } },
    }),
  ])

  return {
    companies: new Map(companies.map(c => [c.name.toLowerCase(), c.id])),
    brands: new Map(brands.map(b => [
      `${b.company.name.toLowerCase()}|${b.name.toLowerCase()}`,
      { id: b.id, companyId: b.companyId }
    ])),
  }
}

export async function POST(request: NextRequest) {
  // ... authentication checks (same as before)

  // Pre-fetch lookup data
  const lookupMaps = await buildLookupMaps(session.user.id, selectedCompanyId)

  // Process CSV
  const importSummary: ImportSummary<SKUImportWithLookups> = processSKUImport(csvContent)

  // ... for each row:
  // - Resolve company from lookupMaps.companies
  // - Resolve brand from lookupMaps.brands
  // - Clear error messages if not found
  // - Create SKU with resolved companyId and brandId
}
```
**Completion Criteria**:
- [ ] Lookups resolve company/brand by name
- [ ] Clear error messages for invalid lookups
- [ ] `npm run build` passes
- [ ] `npx tsc --noEmit` passes

## Phase 5: Unit Tests

### Subtask 5.1: Update CSV Import Unit Tests
**File**: `/home/pbrown/SkuInventory/tests/unit/csv-import.test.ts`
**Pattern**: Follow existing test patterns
**Instructions**:
1. Add tests for new fields in component import:
```typescript
describe('processComponentImport with lookup fields', () => {
  it('parses CSV with company, brand, location columns', () => {
    const csv = `Name,SKU Code,Company,Brand,Location,Category
Widget A,WIDGET-001,Acme Corp,Main Brand,Warehouse 1,Electronics`

    const result = processComponentImport(csv)

    expect(result.successful).toBe(1)
    expect(result.results[0].data).toMatchObject({
      name: 'Widget A',
      skuCode: 'WIDGET-001',
      company: 'Acme Corp',
      brand: 'Main Brand',
      location: 'Warehouse 1',
      category: 'Electronics',
    })
  })

  it('handles missing optional lookup fields', () => {
    const csv = `Name,SKU Code,Category
Widget B,WIDGET-002,Electronics`

    const result = processComponentImport(csv)

    expect(result.successful).toBe(1)
    expect(result.results[0].data?.company).toBeUndefined()
    expect(result.results[0].data?.brand).toBeUndefined()
    expect(result.results[0].data?.location).toBeUndefined()
  })
})
```
2. Add tests for new fields in SKU import:
```typescript
describe('processSKUImport with lookup fields', () => {
  it('parses CSV with company, brand columns', () => {
    const csv = `Name,Internal Code,Company,Brand,Sales Channel
Product X,PROD-X,Acme Corp,Main Brand,Amazon`

    const result = processSKUImport(csv)

    expect(result.successful).toBe(1)
    expect(result.results[0].data).toMatchObject({
      name: 'Product X',
      internalCode: 'PROD-X',
      company: 'Acme Corp',
      brand: 'Main Brand',
      salesChannel: 'Amazon',
    })
  })

  it('handles missing optional lookup fields', () => {
    const csv = `Name,Internal Code,Sales Channel
Product Y,PROD-Y,Shopify`

    const result = processSKUImport(csv)

    expect(result.successful).toBe(1)
    expect(result.results[0].data?.company).toBeUndefined()
    expect(result.results[0].data?.brand).toBeUndefined()
  })
})
```
3. Add tests for template generation with reference data:
```typescript
describe('template generation with reference data', () => {
  it('generates component template with reference section', () => {
    const referenceData = {
      companies: [{ name: 'Acme Corp' }],
      brands: [{ name: 'Main Brand', companyName: 'Acme Corp' }],
      locations: [{ name: 'Warehouse 1', companyName: 'Acme Corp' }],
      categories: [{ name: 'Electronics' }],
    }

    const template = generateComponentTemplate(referenceData)

    expect(template).toContain('Company,Brand,Location,Category')
    expect(template).toContain('# COMPANIES:')
    expect(template).toContain('Acme Corp')
    expect(template).toContain('# BRANDS (Company -> Brand):')
    expect(template).toContain('Acme Corp -> Main Brand')
  })

  it('generates SKU template with reference section', () => {
    const referenceData = {
      companies: [{ name: 'Acme Corp' }],
      brands: [{ name: 'Main Brand', companyName: 'Acme Corp' }],
      locations: [],
      categories: [],
    }

    const template = generateSKUTemplate(referenceData)

    expect(template).toContain('Company,Brand,Sales Channel')
    expect(template).toContain('# COMPANIES:')
    expect(template).toContain('Acme Corp')
  })

  it('generates template without reference section when no data provided', () => {
    const template = generateComponentTemplate()

    expect(template).not.toContain('# ===')
    expect(template).toContain('Name,SKU Code')
  })
})
```
**Completion Criteria**:
- [ ] All new tests pass
- [ ] `npm test -- --testPathPattern="csv-import"` passes

### Subtask 5.2: Update Integration Tests
**File**: `/home/pbrown/SkuInventory/tests/integration/import-export.test.ts`
**Pattern**: Follow existing integration test patterns
**Instructions**:
1. Add test for template download with reference data:
```typescript
it('component template includes reference data section', async () => {
  setTestSession(TEST_SESSIONS.admin!)

  const request = createTestRequest('/api/import/template/components')
  const response = await getTemplate(request, { params: Promise.resolve({ type: 'components' }) })

  expect(response.status).toBe(200)
  const csv = await response.text()
  expect(csv).toContain('Company')
  expect(csv).toContain('Brand')
  expect(csv).toContain('Location')
  expect(csv).toContain('# VALID OPTIONS REFERENCE')
})

it('SKU template includes reference data section', async () => {
  setTestSession(TEST_SESSIONS.admin!)

  const request = createTestRequest('/api/import/template/skus')
  const response = await getTemplate(request, { params: Promise.resolve({ type: 'skus' }) })

  expect(response.status).toBe(200)
  const csv = await response.text()
  expect(csv).toContain('Company')
  expect(csv).toContain('Brand')
  expect(csv).toContain('# VALID OPTIONS REFERENCE')
})
```
2. Add test for component import with company/brand lookup:
```typescript
it('imports components with company and brand names', async () => {
  setTestSession(TEST_SESSIONS.admin!)
  const prisma = getIntegrationPrisma()

  // Get actual company and brand names from test session
  const company = await prisma.company.findUnique({
    where: { id: TEST_SESSIONS.admin!.user.companyId },
  })
  const brand = await prisma.brand.findFirst({
    where: { companyId: TEST_SESSIONS.admin!.user.companyId, isActive: true },
  })

  const csv = `Name,SKU Code,Company,Brand,Category
Lookup Component,LOOKUP-001,${company!.name},${brand!.name},Test Category`

  const request = new Request('http://localhost/api/import/components', {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: csv,
  })

  const response = await importComponents(request as never)
  const result = await response.json()

  expect(response.status).toBe(200)
  expect(result.data.imported).toBe(1)

  // Verify component was created with correct brand
  const component = await prisma.component.findFirst({
    where: { skuCode: 'LOOKUP-001' },
  })
  expect(component).not.toBeNull()
  expect(component!.brandId).toBe(brand!.id)
})

it('returns clear error for invalid company name', async () => {
  setTestSession(TEST_SESSIONS.admin!)

  const csv = `Name,SKU Code,Company,Brand,Category
Bad Company Component,BADCO-001,Nonexistent Company,Some Brand,Electronics`

  const request = new Request('http://localhost/api/import/components', {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain' },
    body: csv,
  })

  const response = await importComponents(request as never)
  const result = await response.json()

  expect(response.status).toBe(200)
  expect(result.data.imported).toBe(0)
  expect(result.data.skipped).toBe(1)
  expect(result.data.errors[0].errors[0]).toContain('Company "Nonexistent Company" not found')
})
```
**Completion Criteria**:
- [ ] All integration tests pass
- [ ] `npm test -- --testPathPattern="import-export"` passes

## Phase 6: Final Validation

### Subtask 6.1: Run All Tests and Build
**Instructions**:
1. Run type check: `npx tsc --noEmit`
2. Run build: `npm run build`
3. Run lint: `npm run lint`
4. Run affected tests: `npm test -- --testPathPattern="import"`
5. Run full test suite: `npm test`
**Completion Criteria**:
- [ ] All commands pass without errors or warnings

---

## Summary of Deliverables
**Files Created**: 0
**Files Modified**: 6
- `src/services/import.ts` - Add types, update schemas, enhance template generators
- `src/app/api/import/template/[type]/route.ts` - Fetch reference data for templates
- `src/app/api/import/components/route.ts` - Add lookup validation logic
- `src/app/api/import/skus/route.ts` - Add lookup validation logic
- `tests/unit/csv-import.test.ts` - Add unit tests for new functionality
- `tests/integration/import-export.test.ts` - Add integration tests

## Handoff to Build Agent
1. Execute subtasks in exact order
2. Complete Phase 1 fully before Phase 2
3. Test completion criteria before next subtask
4. Follow reference patterns exactly
5. Run `npx tsc --noEmit` after each subtask to catch type errors early

## Test Strategy Note
- Use Vitest for unit tests
- Run `npm test -- --testPathPattern="import"` for targeted testing
- Run full test suite before marking complete

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 25m |
| **Total** | **45m** |
