# Implementation Plan
**Generated**: 2025-12-04T15:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #20 - Multi-brand UI support (brand selector and scoping)
**Estimated Build Time**: 8-10 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #20
**Priority**: Medium (v2 label, depends on completed #24)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="brand|Brand|selector"` or None

### Issue Validation
**Status**: Valid
**Recent Changes**: #24 (company selector) was recently completed (issues #77, #82, #87, #96 closed). The company selector provides the parent-level pattern we will follow for brand selection within a company.

### Current State Assessment

**Existing components:**
- `CompanySelector` component exists at `/home/pbrown/SkuInventory/src/components/features/CompanySelector.tsx` - serves as reference pattern
- Brand model exists in Prisma schema with `companyId`, `name`, `isActive` fields
- Component and SKU models have `brandId` field for brand scoping
- Component and SKU models also have `companyId` field (added in issue #77)

**Database:**
- Brand table exists with proper relations to Company
- Components/SKUs have both `brandId` and `companyId` fields
- No UserBrand preference table exists (may need to add or use session storage)

**API Routes:**
- Current routes use `prisma.brand.findFirst({ where: { companyId: selectedCompanyId, isActive: true } })` to auto-select first active brand
- 4 routes explicitly fetch brand for creation: `/api/components/route.ts`, `/api/skus/route.ts`, `/api/import/components/route.ts`, `/api/import/skus/route.ts`
- All list/query routes scope by `companyId` not `brandId` currently

**Session:**
- Session includes `selectedCompanyId` and `selectedCompanyName`
- No `selectedBrandId` or brand list currently in session

### Dependencies & Blockers

1. **Prerequisite #24 (Multi-company support)**: COMPLETED - Company selector implemented
2. **Prerequisite #2 (Tenant scoping)**: COMPLETED - Tenant scoping fixes applied

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 8-10 hours
**Risk**: Low-Medium (follows established company selector pattern)

### Patterns Identified

**Primary**: `/home/pbrown/SkuInventory/src/components/features/CompanySelector.tsx` - Copy this pattern for BrandSelector
**Secondary**: `/home/pbrown/SkuInventory/src/app/api/companies/switch/route.ts` - Copy for brand switching API
**Tertiary**: `/home/pbrown/SkuInventory/src/hooks/useCompanyChange.ts` - Create similar useBrandChange hook

### Ripple Effect Analysis

**Files Identified**: 34+ files

**Session/Auth Layer:**
- `/home/pbrown/SkuInventory/src/lib/auth.ts` - Add brand info to session (selectedBrandId, selectedBrandName, brands array)
- `/home/pbrown/SkuInventory/src/types/index.ts` - Add SessionBrand type

**API Routes needing brand parameter:**
Creation routes (currently use findFirst for brand):
- `/home/pbrown/SkuInventory/src/app/api/components/route.ts` (POST)
- `/home/pbrown/SkuInventory/src/app/api/skus/route.ts` (POST)
- `/home/pbrown/SkuInventory/src/app/api/import/components/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/import/skus/route.ts`

Query/list routes (add brand scoping):
- `/home/pbrown/SkuInventory/src/app/api/components/route.ts` (GET)
- `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/skus/route.ts` (GET)
- `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/skus/[id]/bom-versions/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/export/components/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/export/skus/route.ts`

New files to create:
- `/home/pbrown/SkuInventory/src/app/api/brands/switch/route.ts`
- `/home/pbrown/SkuInventory/src/components/features/BrandSelector.tsx`
- `/home/pbrown/SkuInventory/src/hooks/useBrandChange.ts`

**UI Components:**
- `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx` - Add BrandSelector below CompanySelector

**Pages with data fetching (need brand refetch on change):**
- `/home/pbrown/SkuInventory/src/app/(dashboard)/page.tsx`
- `/home/pbrown/SkuInventory/src/app/(dashboard)/components/page.tsx`
- `/home/pbrown/SkuInventory/src/app/(dashboard)/skus/page.tsx`
- `/home/pbrown/SkuInventory/src/app/(dashboard)/transactions/page.tsx`

---

## Executive Summary

This feature adds brand selection UI within the currently selected company, following the same pattern as the recently completed company selector (#24). Users will see a brand dropdown in the sidebar (below the company selector) that allows switching between brands within their selected company. All API routes will respect the selected brand context, scoping Components, SKUs, and related entities to the chosen brand.

## Phase 1: Session and Types Layer

### Subtask 1.1: Add Brand types to session types
**File**: `/home/pbrown/SkuInventory/src/types/index.ts`
**Pattern**: Follow SessionCompany type at line 69-73
**Instructions**:
1. Add SessionBrand interface after SessionCompany:
```typescript
// Brand info for session
export interface SessionBrand {
  id: string
  name: string
}
```
2. Update SessionUser interface to include brand fields:
```typescript
// Add after selectedCompanyName line 86
selectedBrandId: string | null  // Currently selected brand (null if company has no brands)
selectedBrandName: string | null  // Currently selected brand name
brands: SessionBrand[]  // Brands for the selected company
```
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] SessionBrand interface exists
- [ ] SessionUser includes brand fields
- [ ] TypeScript compiles without errors

### Subtask 1.2: Update auth module with brand session support
**File**: `/home/pbrown/SkuInventory/src/lib/auth.ts`
**Pattern**: Follow existing company session pattern at lines 75-102 and 107-130
**Instructions**:
1. In the `authorize` function, after fetching userCompanies (line 31-38), add brand fetch for the user's primary company:
```typescript
// After line 39 (before if(!user || !user.isActive))
// Fetch brands for the user's primary company
const brands = await prisma.brand.findMany({
  where: {
    companyId: user.companyId,
    isActive: true,
  },
  select: { id: true, name: true },
  orderBy: { name: 'asc' },
})
```
2. Update the return object (around line 92-102) to include:
```typescript
brands: brands.map(b => ({ id: b.id, name: b.name })),
selectedBrandId: brands[0]?.id ?? null,
selectedBrandName: brands[0]?.name ?? null,
```
3. Update JWT callback (line 107-131) to handle brand fields:
```typescript
// After line 116
token.brands = user.brands
token.selectedBrandId = user.selectedBrandId
token.selectedBrandName = user.selectedBrandName

// In the trigger === 'update' block, add brand update handling:
if (trigger === 'update' && session?.selectedBrandId !== undefined) {
  // Verify brand belongs to selected company
  const hasAccess = (token.brands as Array<{ id: string }>)?.some(
    b => b.id === session.selectedBrandId
  )
  if (hasAccess || session.selectedBrandId === null) {
    token.selectedBrandId = session.selectedBrandId
    token.selectedBrandName = session.selectedBrandName
  }
}

// Handle brand refresh when company changes
if (trigger === 'update' && session?.brands !== undefined) {
  token.brands = session.brands
  token.selectedBrandId = session.selectedBrandId
  token.selectedBrandName = session.selectedBrandName
}
```
4. Update session callback (line 135-146) to include brand fields:
```typescript
session.user.brands = token.brands as Array<{ id: string; name: string }>
session.user.selectedBrandId = token.selectedBrandId as string | null
session.user.selectedBrandName = token.selectedBrandName as string | null
```
5. Update NextAuth User interface declaration (line 151-160):
```typescript
interface User {
  // ... existing fields
  brands: Array<{ id: string; name: string }>
  selectedBrandId: string | null
  selectedBrandName: string | null
}
```
6. Update Session interface (line 162-172) to include brand fields
7. Update JWT interface (line 175-185) to include brand fields

**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] Brand fields added to authorize return
- [ ] JWT callback handles brand updates
- [ ] Session callback exposes brand fields
- [ ] All NextAuth type declarations updated
- [ ] TypeScript compiles

## Phase 2: API Routes

### Subtask 2.1: Create brand switch API endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/brands/switch/route.ts` (NEW)
**Pattern**: Copy from `/home/pbrown/SkuInventory/src/app/api/companies/switch/route.ts`
**Instructions**:
1. Create new file with this content:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { z } from 'zod'
import { authOptions, logSecurityEvent } from '@/lib/auth'
import { prisma } from '@/lib/db'
import {
  success,
  unauthorized,
  forbidden,
  parseBody,
  serverError,
} from '@/lib/api-response'

// Request body schema
const switchBrandSchema = z.object({
  brandId: z.string().uuid('Invalid brand ID').nullable(),
})

// POST /api/brands/switch - Switch active brand within current company
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    const bodyResult = await parseBody(request, switchBrandSchema)
    if (bodyResult.error) return bodyResult.error

    const { brandId } = bodyResult.data
    const selectedCompanyId = session.user.selectedCompanyId

    // If brandId is null, user is deselecting brand (show all brands data)
    if (brandId === null) {
      await logSecurityEvent({
        companyId: selectedCompanyId,
        userId: session.user.id,
        eventType: 'brand_switch',
        details: {
          fromBrandId: session.user.selectedBrandId,
          fromBrandName: session.user.selectedBrandName,
          toBrandId: null,
          toBrandName: null,
        },
      })

      return success({
        selectedBrandId: null,
        selectedBrandName: null,
        message: 'Brand deselected - showing all brands',
      })
    }

    // Verify brand exists and belongs to user's selected company
    const brand = await prisma.brand.findFirst({
      where: {
        id: brandId,
        companyId: selectedCompanyId,
        isActive: true,
      },
      select: { id: true, name: true },
    })

    if (!brand) {
      return forbidden('Brand not found or does not belong to selected company')
    }

    // Log the brand switch event
    await logSecurityEvent({
      companyId: selectedCompanyId,
      userId: session.user.id,
      eventType: 'brand_switch',
      details: {
        fromBrandId: session.user.selectedBrandId,
        fromBrandName: session.user.selectedBrandName,
        toBrandId: brand.id,
        toBrandName: brand.name,
      },
    })

    return success({
      selectedBrandId: brand.id,
      selectedBrandName: brand.name,
      message: `Switched to ${brand.name}`,
    })
  } catch (error) {
    console.error('Error switching brand:', error)
    return serverError()
  }
}
```
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] File created at correct path
- [ ] Handles null brandId case
- [ ] Validates brand belongs to selected company
- [ ] Logs security event
- [ ] TypeScript compiles

### Subtask 2.2: Update company switch to refresh brands
**File**: `/home/pbrown/SkuInventory/src/app/api/companies/switch/route.ts`
**Pattern**: Existing file, add brand refresh
**Instructions**:
1. After verifying company access (around line 53-54), fetch brands for new company:
```typescript
// After line 54
// Fetch brands for the new company
const brands = await prisma.brand.findMany({
  where: {
    companyId: company.id,
    isActive: true,
  },
  select: { id: true, name: true },
  orderBy: { name: 'asc' },
})

const selectedBrandId = brands[0]?.id ?? null
const selectedBrandName = brands[0]?.name ?? null
```
2. Update the return success object (around line 74-78) to include brand info:
```typescript
return success({
  selectedCompanyId: company.id,
  selectedCompanyName: company.name,
  brands: brands.map(b => ({ id: b.id, name: b.name })),
  selectedBrandId,
  selectedBrandName,
  message: `Switched to ${company.name}`,
})
```
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] Brands fetched for new company
- [ ] Brand data included in response
- [ ] TypeScript compiles

## Phase 3: UI Components

### Subtask 3.1: Create useBrandChange hook
**File**: `/home/pbrown/SkuInventory/src/hooks/useBrandChange.ts` (NEW)
**Pattern**: Copy from `/home/pbrown/SkuInventory/src/hooks/useCompanyChange.ts`
**Instructions**:
1. Create new file:
```typescript
'use client'

import { useSession } from 'next-auth/react'
import { useEffect, useRef, useCallback } from 'react'

/**
 * Hook to detect brand changes and trigger a callback
 * Use this in client components that need to refetch data when brand changes
 */
export function useBrandChange(onBrandChange: () => void) {
  const { data: session } = useSession()
  const prevBrandId = useRef<string | null | undefined>(undefined)
  const stableCallback = useCallback(onBrandChange, [onBrandChange])

  useEffect(() => {
    const currentBrandId = session?.user?.selectedBrandId

    // Skip on initial mount
    if (prevBrandId.current === undefined) {
      prevBrandId.current = currentBrandId
      return
    }

    // Detect change
    if (currentBrandId !== prevBrandId.current) {
      prevBrandId.current = currentBrandId
      stableCallback()
    }
  }, [session?.user?.selectedBrandId, stableCallback])
}

/**
 * Hook to get the current selected brand ID
 * Returns undefined if session is not loaded, null if no brand selected
 */
export function useSelectedBrandId(): string | null | undefined {
  const { data: session } = useSession()
  return session?.user?.selectedBrandId
}
```
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] File created
- [ ] useBrandChange hook works like useCompanyChange
- [ ] useSelectedBrandId helper available
- [ ] TypeScript compiles

### Subtask 3.2: Create BrandSelector component
**File**: `/home/pbrown/SkuInventory/src/components/features/BrandSelector.tsx` (NEW)
**Pattern**: Copy from `/home/pbrown/SkuInventory/src/components/features/CompanySelector.tsx`
**Instructions**:
1. Create new file with this content:
```typescript
'use client'

import { useSession } from 'next-auth/react'
import { useState } from 'react'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Tag } from 'lucide-react'
import { toast } from 'sonner'

export function BrandSelector() {
  const { data: session, update: updateSession } = useSession()
  const [isLoading, setIsLoading] = useState(false)

  // Don't render if user has no brands or only one brand
  if (!session?.user?.brands || session.user.brands.length <= 1) {
    return null
  }

  const handleBrandChange = async (brandId: string) => {
    // Skip if selecting the same brand
    if (brandId === session.user.selectedBrandId) return

    // Handle "all" option
    const actualBrandId = brandId === 'all' ? null : brandId

    setIsLoading(true)
    try {
      const res = await fetch('/api/brands/switch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ brandId: actualBrandId }),
      })

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.error || 'Failed to switch brand')
      }

      const data = await res.json()

      // Update session with new brand info
      await updateSession({
        selectedBrandId: data.data.selectedBrandId,
        selectedBrandName: data.data.selectedBrandName,
      })

      toast.success('Brand switched', {
        description: data.data.selectedBrandName
          ? `Switched to ${data.data.selectedBrandName}`
          : 'Showing all brands',
      })
    } catch (error) {
      console.error('Error switching brand:', error)
      toast.error('Failed to switch brand', {
        description: error instanceof Error ? error.message : 'Please try again.',
      })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="px-4 py-2 border-b">
      <Select
        value={session.user.selectedBrandId ?? 'all'}
        onValueChange={handleBrandChange}
        disabled={isLoading}
      >
        <SelectTrigger className="w-full">
          <Tag className="h-4 w-4 mr-2 shrink-0" />
          <SelectValue placeholder="Select brand" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">All Brands</SelectItem>
          {session.user.brands.map((brand) => (
            <SelectItem key={brand.id} value={brand.id}>
              {brand.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  )
}
```
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] Component renders brand dropdown
- [ ] Handles brand switch API call
- [ ] Updates session on successful switch
- [ ] Shows "All Brands" option
- [ ] Only renders when multiple brands exist
- [ ] TypeScript compiles

### Subtask 3.3: Add BrandSelector to dashboard layout
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx`
**Pattern**: Follow CompanySelector placement at line 81
**Instructions**:
1. Add import at top (around line 26):
```typescript
import { BrandSelector } from '@/components/features/BrandSelector'
```
2. Add BrandSelector immediately after CompanySelector (after line 81):
```tsx
<CompanySelector />
<BrandSelector />
```
**Validation**: `npm run build`
**Completion Criteria**:
- [ ] BrandSelector imported
- [ ] BrandSelector renders below CompanySelector
- [ ] Build passes

## Phase 4: API Route Brand Scoping

### Subtask 4.1: Update components list/create API with brand scoping
**File**: `/home/pbrown/SkuInventory/src/app/api/components/route.ts`
**Instructions**:

For GET (list):
1. Add optional brand scoping to where clause (around line 40-50):
```typescript
// Get selected brand (may be null for "all brands")
const selectedBrandId = session.user.selectedBrandId

// Build where clause - scope by companyId and optionally brandId
const where: Prisma.ComponentWhereInput = {
  companyId: selectedCompanyId,
  // Only add brandId filter if a specific brand is selected
  ...(selectedBrandId && { brandId: selectedBrandId }),
  ...(isActive !== undefined && { isActive }),
  // ... rest of existing where clause
}
```

For POST (create):
1. Update brand selection to use session brand (around line 169-175):
```typescript
// Use selected brand from session, or fall back to first active brand
let brandId = session.user.selectedBrandId

if (!brandId) {
  // Fall back to first active brand if none selected
  const brand = await prisma.brand.findFirst({
    where: { companyId: selectedCompanyId, isActive: true },
  })
  if (!brand) {
    return serverError('No active brand found for selected company')
  }
  brandId = brand.id
}
```
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] GET respects selectedBrandId filter
- [ ] POST uses selectedBrandId for creation
- [ ] Falls back to first brand if none selected
- [ ] TypeScript compiles

### Subtask 4.2: Update SKUs list/create API with brand scoping
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/route.ts`
**Instructions**: Same pattern as 4.1 - add brand scoping to GET and POST
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] GET respects selectedBrandId filter
- [ ] POST uses selectedBrandId for creation
- [ ] TypeScript compiles

### Subtask 4.3: Update dashboard API with brand scoping
**File**: `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts`
**Instructions**:
1. Add brand scoping to component query (around line 87-88):
```typescript
const selectedBrandId = session.user.selectedBrandId

const components = await prisma.component.findMany({
  where: {
    companyId: selectedCompanyId,
    isActive: true,
    ...(selectedBrandId && { brandId: selectedBrandId }),
  },
  // ...
})
```
2. Add brand scoping to SKU query (around line 141-142):
```typescript
const skus = await prisma.sKU.findMany({
  where: {
    companyId: selectedCompanyId,
    isActive: true,
    ...(selectedBrandId && { brandId: selectedBrandId }),
  },
  // ...
})
```
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] Components query scoped by brand
- [ ] SKUs query scoped by brand
- [ ] TypeScript compiles

### Subtask 4.4: Update component detail API with brand validation
**File**: `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts`
**Instructions**:
1. GET: The existing query already filters by companyId which is correct. Components belong to brands, and brands belong to companies, so company scoping is sufficient for authorization.
2. However, add brand check if selectedBrandId is set (around line 137-141):
```typescript
const selectedBrandId = session.user.selectedBrandId

const component = await prisma.component.findFirst({
  where: {
    id,
    companyId: selectedCompanyId,
    ...(selectedBrandId && { brandId: selectedBrandId }),
  },
  // ... existing include
})
```
This ensures users only see components from their selected brand.
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] GET respects brand filter
- [ ] TypeScript compiles

### Subtask 4.5: Update SKU detail API with brand validation
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
**Instructions**: Same pattern as 4.4
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] GET respects brand filter
- [ ] TypeScript compiles

### Subtask 4.6: Update import routes with brand scoping
**Files**:
- `/home/pbrown/SkuInventory/src/app/api/import/components/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/import/skus/route.ts`

**Instructions**: For each file, update the brand selection logic (around lines 37-46) to use session brand first:
```typescript
// Use selected brand from session, or fall back to first active brand
let brandId = session.user.selectedBrandId

if (!brandId) {
  const brand = await prisma.brand.findFirst({
    where: { companyId: selectedCompanyId, isActive: true },
  })
  if (!brand) {
    return error('No active brand found for selected company', 400)
  }
  brandId = brand.id
}
```
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] Both import routes use session brand
- [ ] TypeScript compiles

### Subtask 4.7: Update export routes with brand scoping
**Files**:
- `/home/pbrown/SkuInventory/src/app/api/export/components/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/export/skus/route.ts`

**Instructions**: Add brand filter to export queries
**Validation**: `npx tsc --noEmit`
**Completion Criteria**:
- [ ] Export routes respect brand filter
- [ ] TypeScript compiles

## Phase 5: Page Data Refetch on Brand Change

### Subtask 5.1: Update dashboard page to refetch on brand change
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/page.tsx`
**Instructions**:
1. Update the useEffect dependency array (around line 82-85) to include selectedBrandId:
```typescript
useEffect(() => {
  // ... existing fetchDashboard code
  if (session?.user?.selectedCompanyId) {
    fetchDashboard()
  }
}, [timeFilter, session?.user?.selectedCompanyId, session?.user?.selectedBrandId])
```
**Validation**: `npm run build`
**Completion Criteria**:
- [ ] Dashboard refetches when brand changes
- [ ] Build passes

### Subtask 5.2: Update CompanySelector to reset brand on company switch
**File**: `/home/pbrown/SkuInventory/src/components/features/CompanySelector.tsx`
**Instructions**:
1. Update the handleCompanyChange function (around line 44-47) to include brand data from response:
```typescript
// Update session with new company info AND new brand info
await updateSession({
  selectedCompanyId: data.data.selectedCompanyId,
  selectedCompanyName: data.data.selectedCompanyName,
  brands: data.data.brands,
  selectedBrandId: data.data.selectedBrandId,
  selectedBrandName: data.data.selectedBrandName,
})
```
**Validation**: `npm run build`
**Completion Criteria**:
- [ ] Company switch updates brand session data
- [ ] Brand resets to first brand of new company
- [ ] Build passes

## Phase 6: Seed Data Enhancement (Optional)

### Subtask 6.1: Update seed to create multiple brands
**File**: `/home/pbrown/SkuInventory/prisma/seed.ts`
**Pattern**: Follow existing brand upsert pattern at lines 27-40
**Instructions**:
1. After creating the Tonsil Tech brand, add a second brand:
```typescript
// Create second brand for testing multi-brand
const brand2 = await prisma.brand.upsert({
  where: {
    companyId_name: {
      companyId: company.id,
      name: 'Mela Vitamins',
    },
  },
  update: {},
  create: {
    companyId: company.id,
    name: 'Mela Vitamins',
  },
})
console.log('Created brand:', brand2.name)
```
**Validation**: `npm run build`
**Completion Criteria**:
- [ ] Seed creates multiple brands
- [ ] Build passes

---

## Summary of Deliverables

**Files Created**: 4
- `/home/pbrown/SkuInventory/src/app/api/brands/switch/route.ts`
- `/home/pbrown/SkuInventory/src/components/features/BrandSelector.tsx`
- `/home/pbrown/SkuInventory/src/hooks/useBrandChange.ts`
- `/home/pbrown/SkuInventory/.agents/outputs/plan-20-120425.md`

**Files Modified**: 15+
- `/home/pbrown/SkuInventory/src/types/index.ts`
- `/home/pbrown/SkuInventory/src/lib/auth.ts`
- `/home/pbrown/SkuInventory/src/app/api/companies/switch/route.ts`
- `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx`
- `/home/pbrown/SkuInventory/src/app/(dashboard)/page.tsx`
- `/home/pbrown/SkuInventory/src/components/features/CompanySelector.tsx`
- `/home/pbrown/SkuInventory/src/app/api/components/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/skus/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/import/components/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/import/skus/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/export/components/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/export/skus/route.ts`
- `/home/pbrown/SkuInventory/prisma/seed.ts`

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5 -> Phase 6)
2. Complete each subtask fully before moving to next
3. Run validation commands after each subtask
4. Test completion criteria before proceeding
5. Follow reference patterns exactly (CompanySelector is the primary pattern)

## Test Strategy Note

- Use manual testing to verify:
  - Brand selector appears when multiple brands exist
  - Brand selector is hidden when only one brand exists
  - Switching brands updates dashboard/list views
  - Creating components/SKUs uses selected brand
  - Exports respect brand filter
- Use Vitest for any unit tests if needed
- E2E testing with Playwright if configured

## UI Acceptance Criteria
- [ ] BrandSelector visible in sidebar on desktop (1024px+)
- [ ] BrandSelector visible in sidebar on tablet (768px-1023px)
- [ ] BrandSelector visible in mobile sidebar (<768px)
- [ ] BrandSelector shows "All Brands" option
- [ ] BrandSelector only renders when >1 brand exists
- [ ] Switching brand updates data display

## Performance Metrics
| Phase | Estimated Duration |
|-------|----------|
| Phase 1: Session/Types | 1-1.5h |
| Phase 2: API Routes | 1.5-2h |
| Phase 3: UI Components | 1.5-2h |
| Phase 4: API Scoping | 2-2.5h |
| Phase 5: Page Refetch | 0.5-1h |
| Phase 6: Seed Data | 0.5h |
| **Total** | **8-10h** |
