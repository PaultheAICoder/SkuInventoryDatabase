# Implementation Plan
**Generated**: 2025-12-06T16:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #193
**Estimated Build Time**: 2-3 hours
**Complexity**: Low

## Investigation Summary

### Request Analysis
**Type**: Bug Fix
**Source**: GitHub Issue #193
**Priority**: Medium

### Task Classification
**Category**: BUG_FIX
**Test Strategy**: TARGETED
**Suggested Filter**: `--testPathPattern="inventory-delete"`

### Issue Validation
**Status**: Valid
**Recent Changes**: Multiple commits to inventory.ts in past 60 days (mostly unrelated feature additions), no recent changes to `canDeleteComponent` function

### Current State Assessment

**The Bug**: The `canDeleteComponent` function at `src/services/inventory.ts:625-635` only checks if a component is used in **active** BOMs. It fails to check:
1. **TransactionLine** references - Components used in historical transactions
2. **Inactive BOMLine** references - Components in historical/inactive BOMs
3. **Lot** references - Components that have lots assigned

**Current Implementation** (lines 624-635):
```typescript
export async function canDeleteComponent(componentId: string): Promise<boolean> {
  const activeBomLineCount = await prisma.bOMLine.count({
    where: {
      componentId,
      bomVersion: {
        isActive: true,
      },
    },
  })
  return activeBomLineCount === 0
}
```

**Database Constraints (from schema.prisma)**:
- `TransactionLine.component` (line 321): NO `onDelete: Cascade` - FK violation on delete
- `BOMLine.component` (line 411): NO `onDelete: Cascade` - FK violation on delete
- `Lot.component` (line 211): NO `onDelete: Cascade` - FK violation on delete
- `ComponentAlertState.component` (line 491): Has `onDelete: Cascade` - OK

**API Route Location**: `src/app/api/components/[id]/route.ts:357-400` (DELETE handler)

### Dependencies & Blockers
None - All required models and queries are already available.

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Simple
**Effort**: 2-3 hours
**Risk**: Low - straightforward query additions with existing patterns

### Patterns Identified
**Primary**: `src/services/location.ts:63-79` - `canDeactivateLocation` returns `{ canDeactivate: boolean; reason?: string }`
**Secondary**: `src/app/api/brands/[id]/route.ts:243` - Error message includes count of blocking items

### Ripple Effect Analysis
**Files Identified**: 3 files
- `src/services/inventory.ts` - Modify `canDeleteComponent` function signature and logic
- `src/app/api/components/[id]/route.ts` - Update DELETE handler to use new return type
- `tests/unit/inventory-delete.test.ts` - Update tests for new function behavior

---

## Executive Summary

Fix the foreign key crash when deleting components by enhancing `canDeleteComponent` to check ALL blocking references (TransactionLines, ALL BOMLines, and Lots). Change the function to return a detailed result object with reason string, and update the API route to display helpful error messages to users.

## Phase 1: Service Layer - Enhance canDeleteComponent

### Subtask 1.1: Update canDeleteComponent Function Signature and Logic
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Follow `canDeactivateLocation` in `/home/pbrown/SkuInventory/src/services/location.ts:63-79`
**Location**: Lines 622-635

**Instructions**:
1. Change return type from `Promise<boolean>` to `Promise<{ canDelete: boolean; reason?: string }>`
2. Add check for `TransactionLine` count (any component with transaction history cannot be deleted)
3. Add check for ALL `BOMLine` count (not just active BOMs - any BOM reference blocks deletion)
4. Add check for `Lot` count (components with lots cannot be deleted)
5. Return detailed reason explaining which constraint is blocking

**New Implementation Logic**:
```typescript
export async function canDeleteComponent(
  componentId: string
): Promise<{ canDelete: boolean; reason?: string }> {
  // Check 1: Transaction history - most common blocker
  const transactionLineCount = await prisma.transactionLine.count({
    where: { componentId },
  })
  if (transactionLineCount > 0) {
    return {
      canDelete: false,
      reason: `Cannot deactivate component with ${transactionLineCount} transaction record(s). Historical data must be preserved.`,
    }
  }

  // Check 2: BOM references (active AND inactive)
  const bomLineCount = await prisma.bOMLine.count({
    where: { componentId },
  })
  if (bomLineCount > 0) {
    return {
      canDelete: false,
      reason: `Cannot deactivate component used in ${bomLineCount} BOM(s). Remove from all BOMs first.`,
    }
  }

  // Check 3: Lot references
  const lotCount = await prisma.lot.count({
    where: { componentId },
  })
  if (lotCount > 0) {
    return {
      canDelete: false,
      reason: `Cannot deactivate component with ${lotCount} lot(s). Delete lots first.`,
    }
  }

  return { canDelete: true }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Function returns `{ canDelete: boolean; reason?: string }` object
- [ ] TransactionLine check added (blocks if count > 0)
- [ ] BOMLine check added (all BOMs, not just active)
- [ ] Lot check added (blocks if count > 0)
- [ ] TypeScript compiles without errors

## Phase 2: API Route - Update DELETE Handler

### Subtask 2.1: Update Component DELETE Handler
**File**: `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts`
**Pattern**: Follow existing `conflict()` usage at line 384
**Location**: Lines 381-385

**Instructions**:
1. Update the call to `canDeleteComponent` to destructure new return type
2. Use the `reason` property in the `conflict()` response

**Before** (lines 381-385):
```typescript
    // Check if used in active BOMs
    const canDelete = await canDeleteComponent(id)
    if (!canDelete) {
      return conflict('Cannot deactivate component that is used in active BOMs')
    }
```

**After**:
```typescript
    // Check if component can be safely deactivated (not used in transactions, BOMs, or lots)
    const deleteCheck = await canDeleteComponent(id)
    if (!deleteCheck.canDelete) {
      return conflict(deleteCheck.reason ?? 'Cannot deactivate component due to existing references')
    }
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] DELETE handler uses new return type from `canDeleteComponent`
- [ ] Error message displays the specific reason from the function
- [ ] TypeScript compiles without errors
- [ ] Build succeeds

## Phase 3: Tests - Update Unit Tests

### Subtask 3.1: Update inventory-delete.test.ts
**File**: `/home/pbrown/SkuInventory/tests/unit/inventory-delete.test.ts`
**Pattern**: Follow existing test structure

**Instructions**:
1. Update mock to include `transactionLine.count` and `lot.count`
2. Update all test assertions to expect `{ canDelete: boolean; reason?: string }` object
3. Add new test cases for:
   - Component with transaction lines (should return canDelete: false with reason)
   - Component with lots (should return canDelete: false with reason)
   - Component in inactive BOMs only (should NOW return canDelete: false - behavior change)
4. Update existing test that expects "true when component is only in inactive BOMs" - this is now expected to FAIL and should be updated to expect false

**Mock Updates**:
```typescript
vi.mock('@/lib/db', () => ({
  prisma: {
    bOMLine: {
      count: vi.fn(),
    },
    transactionLine: {
      count: vi.fn(),
    },
    lot: {
      count: vi.fn(),
    },
  },
}))
```

**New Test Cases to Add**:
```typescript
it('returns canDelete: false when component has transaction history', async () => {
  vi.mocked(prisma.transactionLine.count).mockResolvedValue(5)
  vi.mocked(prisma.bOMLine.count).mockResolvedValue(0)
  vi.mocked(prisma.lot.count).mockResolvedValue(0)

  const result = await canDeleteComponent('used-in-transactions')

  expect(result.canDelete).toBe(false)
  expect(result.reason).toContain('5 transaction record(s)')
})

it('returns canDelete: false when component has lots', async () => {
  vi.mocked(prisma.transactionLine.count).mockResolvedValue(0)
  vi.mocked(prisma.bOMLine.count).mockResolvedValue(0)
  vi.mocked(prisma.lot.count).mockResolvedValue(3)

  const result = await canDeleteComponent('has-lots')

  expect(result.canDelete).toBe(false)
  expect(result.reason).toContain('3 lot(s)')
})

it('returns canDelete: false when component is in ANY BOM (active or inactive)', async () => {
  vi.mocked(prisma.transactionLine.count).mockResolvedValue(0)
  vi.mocked(prisma.bOMLine.count).mockResolvedValue(2)
  vi.mocked(prisma.lot.count).mockResolvedValue(0)

  const result = await canDeleteComponent('in-any-bom')

  expect(result.canDelete).toBe(false)
  expect(result.reason).toContain('2 BOM(s)')
})
```

**Validation Commands**:
```bash
npm test -- --testPathPattern="inventory-delete"
```

**Completion Criteria**:
- [ ] Mock includes all three Prisma models (transactionLine, bOMLine, lot)
- [ ] All existing tests updated to use new return type structure
- [ ] New test case for transaction line blocking
- [ ] New test case for lot blocking
- [ ] Test for inactive BOMs updated to expect `canDelete: false`
- [ ] All tests pass

---

## Summary of Deliverables
**Files Created**: 0
**Files Modified**: 3
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Enhanced `canDeleteComponent` function
- `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts` - Updated DELETE handler
- `/home/pbrown/SkuInventory/tests/unit/inventory-delete.test.ts` - Updated and expanded tests

## Handoff to Build Agent
1. Execute subtasks in exact order (1.1 -> 2.1 -> 3.1)
2. Service layer changes must be complete before API route changes
3. Verify TypeScript compiles after each subtask
4. Run targeted tests after Phase 3

## Test Strategy Note
- Use Vitest for unit tests
- Run targeted tests: `npm test -- --testPathPattern="inventory-delete"`
- Full build verification: `npm run build`

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 8m |
| Validation | 4m |
| Planning | 6m |
| **Total** | **18m** |
