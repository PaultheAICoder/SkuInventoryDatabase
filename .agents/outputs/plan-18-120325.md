# Implementation Plan
**Generated**: 2025-12-03
**Task ID**: Issue #18 - Dashboard time filter and component on-hand trend sparkline
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Executive Summary

This plan implements a dashboard time filter (7/30/90 days dropdown) to filter recent transactions and adds sparkline charts to component detail pages showing on-hand quantity trends over time. The implementation leverages the existing recharts library (v3.5.1) and follows established patterns from DefectTrendChart.tsx. Changes are additive with no breaking modifications to existing APIs.

## Ripple Effect Validation

**Scout's Analysis Confirmed**:
- `ComponentDetailResponse` type: 2 files reference it (types/component.ts, components/[id]/page.tsx) - VERIFIED
- `/api/dashboard` endpoint: 2 files reference it (page.tsx, route.ts) - VERIFIED
- `/api/components/${id}` endpoint: 2 files reference it (page.tsx, edit/page.tsx) - VERIFIED

**Impact**: Low ripple effect. All changes are additive (optional fields, new query parameters).

## Schema Verification (COMPLETED)

**Transaction Model** (verified at prisma/schema.prisma:128-157):
- `date`: DateTime @db.Date - Transaction date (use for filtering)
- `createdAt`: DateTime @default(now()) - Audit timestamp
- Index: `@@index([companyId, createdAt(sort: Desc)])`

**TransactionLine Model** (verified at prisma/schema.prisma:159-169):
- `componentId`: String - Component reference
- `quantityChange`: Decimal @db.Decimal(10, 4) - Quantity delta

**Note**: Dashboard currently uses `createdAt` for ordering. Time filter should filter by `date` field (transaction date) for business logic consistency.

---

## Phase 0: No Untangling Required

Scout analysis confirms code is straightforward. No complex logic to untangle.

---

## Phase 1: Dashboard Time Filter Component

### Subtask 1.1: Create DashboardTimeFilter Component

**File**: `/home/pbrown/SkuInventory/src/components/features/DashboardTimeFilter.tsx`
**Type**: NEW FILE
**Pattern Reference**: `/home/pbrown/SkuInventory/src/components/ui/select.tsx` (lines 1-153)

**Instructions**:
1. Create a new component using shadcn/ui Select
2. Props interface:
   ```typescript
   interface DashboardTimeFilterProps {
     value: number | null  // null = "All"
     onChange: (days: number | null) => void
   }
   ```
3. Options: 7 days, 30 days, 90 days, All (null)
4. Use Select, SelectTrigger, SelectContent, SelectItem from ui/select
5. Include clear label "Time Range:" before the dropdown
6. Make component responsive - full width on mobile, auto width on desktop

**Code Structure**:
```typescript
'use client'

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'

interface DashboardTimeFilterProps {
  value: number | null
  onChange: (days: number | null) => void
}

const TIME_OPTIONS = [
  { value: '7', label: 'Last 7 days' },
  { value: '30', label: 'Last 30 days' },
  { value: '90', label: 'Last 90 days' },
  { value: 'all', label: 'All time' },
]

export function DashboardTimeFilter({ value, onChange }: DashboardTimeFilterProps) {
  // Implementation using Select component
  // Convert value to string for Select, handle 'all' as null
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Component renders dropdown with 4 options
- [ ] onChange fires with correct number or null
- [ ] No TypeScript errors
- [ ] Responsive design (no hidden elements)

---

### Subtask 1.2: Add Time Filter to Dashboard Page

**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/page.tsx`
**Type**: MODIFY
**Pattern Reference**: Current file structure (lines 54-75 for state/fetch pattern)

**Instructions**:
1. Import DashboardTimeFilter component
2. Add state: `const [timeFilter, setTimeFilter] = useState<number | null>(30)` (default 30 days)
3. Update useEffect dependency array to include timeFilter
4. Update fetch URL to include days parameter:
   ```typescript
   const url = timeFilter ? `/api/dashboard?days=${timeFilter}` : '/api/dashboard'
   ```
5. Add DashboardTimeFilter to header section between title and DashboardStats
6. Position filter in header area with flex layout:
   ```tsx
   <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
     <div>
       <h1>...</h1>
       <p>...</p>
     </div>
     <DashboardTimeFilter value={timeFilter} onChange={setTimeFilter} />
   </div>
   ```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
npm run build
```

**Completion Criteria**:
- [ ] Time filter visible in dashboard header
- [ ] Changing filter triggers API refetch
- [ ] Filter visible on ALL screen sizes
- [ ] Loading state shows during refetch

---

### Subtask 1.3: Add Date Filtering to Dashboard API

**File**: `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts`
**Type**: MODIFY
**Pattern Reference**: `/home/pbrown/SkuInventory/src/services/analytics.ts` (lines 23-38 for date filtering)

**Instructions**:
1. Extract `days` query parameter from request URL:
   ```typescript
   const { searchParams } = new URL(request.url)
   const daysParam = searchParams.get('days')
   const days = daysParam ? parseInt(daysParam, 10) : null
   ```
2. Calculate startDate if days is provided:
   ```typescript
   const startDate = days
     ? new Date(Date.now() - days * 24 * 60 * 60 * 1000)
     : null
   ```
3. Update recentTransactions query (around line 170):
   ```typescript
   const recentTransactions = await prisma.transaction.findMany({
     where: {
       companyId: session.user.companyId,
       ...(startDate && { date: { gte: startDate } }),
     },
     orderBy: { createdAt: 'desc' },
     take: 10,
     // ... rest of include
   })
   ```
4. No change to response type - backward compatible

**Validation**:
```bash
npx tsc --noEmit
npm run lint
# Manual test: curl http://172.16.20.50:4545/api/dashboard?days=7
```

**Completion Criteria**:
- [ ] API accepts optional `days` query parameter
- [ ] Transactions filtered by date when days provided
- [ ] Returns all transactions when days not provided (backward compatible)
- [ ] No TypeScript errors

---

## Phase 2: Sparkline Component

### Subtask 2.1: Create ComponentSparkline Component

**File**: `/home/pbrown/SkuInventory/src/components/features/ComponentSparkline.tsx`
**Type**: NEW FILE
**Pattern Reference**: `/home/pbrown/SkuInventory/src/components/features/DefectTrendChart.tsx` (lines 1-119)

**Instructions**:
1. Create minimal sparkline using recharts LineChart
2. Props interface:
   ```typescript
   interface TrendDataPoint {
     date: string
     quantityOnHand: number
   }

   interface ComponentSparklineProps {
     data: TrendDataPoint[]
     height?: number  // default 80
     isLoading?: boolean
   }
   ```
3. Use ResponsiveContainer for responsive sizing
4. Minimal chart - no axes labels, no legend, just the line
5. Include tooltip showing date and quantity on hover
6. Loading state: skeleton placeholder
7. Empty state: "No trend data" message

**Code Structure**:
```typescript
'use client'

import { LineChart, Line, ResponsiveContainer, Tooltip } from 'recharts'

interface TrendDataPoint {
  date: string
  quantityOnHand: number
}

interface ComponentSparklineProps {
  data: TrendDataPoint[]
  height?: number
  isLoading?: boolean
}

export function ComponentSparkline({
  data,
  height = 80,
  isLoading = false
}: ComponentSparklineProps) {
  if (isLoading) {
    return <div className="h-20 animate-pulse bg-muted rounded" />
  }

  if (data.length === 0) {
    return (
      <div className="h-20 flex items-center justify-center text-sm text-muted-foreground">
        No trend data available
      </div>
    )
  }

  return (
    <ResponsiveContainer width="100%" height={height}>
      <LineChart data={data}>
        <Line
          type="monotone"
          dataKey="quantityOnHand"
          stroke="#3b82f6"
          strokeWidth={2}
          dot={false}
        />
        <Tooltip
          content={/* Custom tooltip */}
        />
      </LineChart>
    </ResponsiveContainer>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Component renders sparkline chart
- [ ] Tooltip shows date and quantity on hover
- [ ] Loading state displays skeleton
- [ ] Empty state displays message
- [ ] Responsive sizing works

---

### Subtask 2.2: Create Sparkline Time Filter Component

**File**: `/home/pbrown/SkuInventory/src/components/features/SparklineTimeFilter.tsx`
**Type**: NEW FILE
**Pattern Reference**: Similar to DashboardTimeFilter but smaller/inline

**Instructions**:
1. Create a smaller inline time filter for sparkline area
2. Props:
   ```typescript
   interface SparklineTimeFilterProps {
     value: number
     onChange: (days: number) => void
   }
   ```
3. Options: 7, 30, 90 days only (no "All" - always need bounded range for trend)
4. Use button group style (not dropdown) for compact display
5. Styled as small pill buttons

**Code Structure**:
```typescript
'use client'

interface SparklineTimeFilterProps {
  value: number
  onChange: (days: number) => void
}

const OPTIONS = [
  { value: 7, label: '7d' },
  { value: 30, label: '30d' },
  { value: 90, label: '90d' },
]

export function SparklineTimeFilter({ value, onChange }: SparklineTimeFilterProps) {
  return (
    <div className="flex gap-1">
      {OPTIONS.map((opt) => (
        <button
          key={opt.value}
          onClick={() => onChange(opt.value)}
          className={/* active/inactive styles */}
        >
          {opt.label}
        </button>
      ))}
    </div>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Three button options render (7d, 30d, 90d)
- [ ] Active state visually distinct
- [ ] onChange fires with correct value
- [ ] Compact, inline display

---

## Phase 3: Trend Data Types and API

### Subtask 3.1: Extend ComponentDetailResponse Type

**File**: `/home/pbrown/SkuInventory/src/types/component.ts`
**Type**: MODIFY
**Line Reference**: 64-85 (ComponentDetailResponse interface)

**Instructions**:
1. Add trend data type near top of file:
   ```typescript
   export interface ComponentTrendPoint {
     date: string
     quantityOnHand: number
   }
   ```
2. Extend ComponentDetailResponse to include optional trend field (after recentTransactions):
   ```typescript
   export interface ComponentDetailResponse extends ComponentResponse {
     // ... existing fields
     recentTransactions: Array<{...}>
     trend?: ComponentTrendPoint[]  // NEW - optional for backward compatibility
   }
   ```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] ComponentTrendPoint type exported
- [ ] ComponentDetailResponse includes optional trend field
- [ ] No breaking changes to existing type consumers

---

### Subtask 3.2: Add Trend Calculation Logic to Component API

**File**: `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts`
**Type**: MODIFY
**Pattern Reference**: `/home/pbrown/SkuInventory/src/services/inventory.ts` (getComponentQuantity pattern)

**Instructions**:
1. Add imports at top:
   ```typescript
   import type { ComponentTrendPoint } from '@/types/component'
   ```

2. Extract `trendDays` query parameter in GET handler:
   ```typescript
   const { searchParams } = new URL(request.url)
   const trendDaysParam = searchParams.get('trendDays')
   const trendDays = trendDaysParam ? parseInt(trendDaysParam, 10) : null
   ```

3. Add trend calculation function (after main component fetch, before return):
   ```typescript
   // Calculate trend data if requested
   let trend: ComponentTrendPoint[] | undefined
   if (trendDays) {
     const startDate = new Date(Date.now() - trendDays * 24 * 60 * 60 * 1000)
     trend = await calculateComponentTrend(id, startDate, trendDays)
   }
   ```

4. Add helper function in same file:
   ```typescript
   async function calculateComponentTrend(
     componentId: string,
     startDate: Date,
     days: number
   ): Promise<ComponentTrendPoint[]> {
     // Get all transactions for this component up to today
     const transactions = await prisma.transactionLine.findMany({
       where: { componentId },
       include: { transaction: { select: { date: true } } },
       orderBy: { transaction: { date: 'asc' } },
     })

     // Calculate cumulative quantity at each date point
     // Group by date and compute running total
     // Sample to ~30 points if more data points exist
     // Return array of { date: string, quantityOnHand: number }
   }
   ```

5. Include trend in response object:
   ```typescript
   return success({
     // ... existing fields
     recentTransactions: ...,
     ...(trend && { trend }),  // Only include if calculated
   })
   ```

**Algorithm for Trend Calculation**:
1. Get all transaction lines for component (ordered by date)
2. Calculate running total of quantityChange
3. Group by date (aggregate multiple transactions on same day)
4. Generate date points from startDate to today
5. For each date point, find the cumulative quantity as of that date
6. Return array limited to ~30 points (sample if more)

**Validation**:
```bash
npx tsc --noEmit
npm run lint
# Manual test: curl http://172.16.20.50:4545/api/components/[id]?trendDays=30
```

**Completion Criteria**:
- [ ] API accepts optional `trendDays` query parameter
- [ ] Trend data calculated correctly (cumulative quantities)
- [ ] Response includes trend array when trendDays provided
- [ ] No trend data when trendDays not provided (backward compatible)
- [ ] Performance acceptable (<500ms for typical datasets)

---

## Phase 4: Component Detail Integration

### Subtask 4.1: Add Sparkline to Component Detail Page

**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/components/[id]/page.tsx`
**Type**: MODIFY
**Line Reference**: 140-163 (Inventory card)

**Instructions**:
1. Add imports:
   ```typescript
   import { ComponentSparkline } from '@/components/features/ComponentSparkline'
   import { SparklineTimeFilter } from '@/components/features/SparklineTimeFilter'
   ```

2. Add state for sparkline time filter:
   ```typescript
   const [sparklineDays, setSparklineDays] = useState(30)
   ```

3. Update fetch URL to include trendDays:
   ```typescript
   const res = await fetch(`/api/components/${id}?trendDays=${sparklineDays}`)
   ```

4. Add sparklineDays to useEffect dependency array

5. Modify Inventory card (lines 141-163) to include sparkline section:
   ```tsx
   <Card>
     <CardHeader>
       <div className="flex items-center justify-between">
         <CardTitle>Inventory</CardTitle>
         <SparklineTimeFilter value={sparklineDays} onChange={setSparklineDays} />
       </div>
     </CardHeader>
     <CardContent>
       <div className="space-y-4">
         {/* Existing quantity display */}
         <div>
           <p className="text-sm text-muted-foreground">Quantity on Hand</p>
           <p className="text-3xl font-bold">{component.quantityOnHand.toLocaleString()}</p>
         </div>

         {/* NEW: Sparkline section */}
         <div>
           <p className="text-sm text-muted-foreground mb-2">Trend</p>
           <ComponentSparkline
             data={component.trend || []}
             isLoading={isLoading}
           />
         </div>

         {/* Existing reorder/lead time grid */}
         <div className="grid grid-cols-2 gap-4">
           ...
         </div>
       </div>
     </CardContent>
   </Card>
   ```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
npm run build
```

**Completion Criteria**:
- [ ] Sparkline renders in Inventory card
- [ ] Time filter buttons work (7d/30d/90d)
- [ ] Changing time filter refetches component data
- [ ] Loading state during fetch
- [ ] Sparkline visible on ALL screen sizes

---

## Phase 5: Tests

### Subtask 5.1: Add Trend Calculation Unit Tests

**File**: `/home/pbrown/SkuInventory/tests/unit/component-trend.test.ts`
**Type**: NEW FILE
**Pattern Reference**: `/home/pbrown/SkuInventory/tests/unit/analytics-service.test.ts`

**Instructions**:
1. Create unit tests for trend calculation logic:
   - Test cumulative quantity calculation
   - Test date grouping
   - Test empty transaction history
   - Test single transaction
   - Test multiple transactions on same day
   - Test sampling logic for large datasets

**Test Cases**:
```typescript
import { describe, it, expect } from 'vitest'

describe('Component Trend Calculation', () => {
  describe('Cumulative Quantity', () => {
    it('should calculate running total correctly', () => {
      // Given transactions: +100, -30, +50
      // Expected: 100, 70, 120
    })

    it('should handle empty history', () => {
      // No transactions -> empty trend array
    })

    it('should aggregate same-day transactions', () => {
      // Two transactions on same date should combine
    })
  })

  describe('Date Range', () => {
    it('should filter by start date', () => {
      // Only include dates within range
    })

    it('should include all dates in range', () => {
      // Generate points for each day in range
    })
  })
})
```

**Validation**:
```bash
npm test -- --testPathPattern="component-trend"
```

**Completion Criteria**:
- [ ] Tests cover cumulative calculation
- [ ] Tests cover date range filtering
- [ ] Tests cover edge cases (empty, single, large datasets)
- [ ] All tests pass

---

### Subtask 5.2: Add Dashboard Time Filter Tests

**File**: `/home/pbrown/SkuInventory/tests/unit/dashboard-filter.test.ts`
**Type**: NEW FILE
**Pattern Reference**: `/home/pbrown/SkuInventory/tests/unit/analytics-service.test.ts`

**Instructions**:
1. Test date calculation from days parameter:
   ```typescript
   describe('Dashboard Date Filtering', () => {
     it('should calculate correct start date for 7 days', () => {
       const days = 7
       const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)
       // Verify date is ~7 days ago
     })

     it('should calculate correct start date for 30 days', () => {...})
     it('should calculate correct start date for 90 days', () => {...})
     it('should return null for no days parameter', () => {...})
   })
   ```

**Validation**:
```bash
npm test -- --testPathPattern="dashboard-filter"
```

**Completion Criteria**:
- [ ] Tests cover all time periods (7/30/90)
- [ ] Tests cover null/undefined handling
- [ ] All tests pass

---

## Summary of Deliverables

### Files Created: 4
| File | Purpose |
|------|---------|
| `/home/pbrown/SkuInventory/src/components/features/DashboardTimeFilter.tsx` | Dashboard time filter dropdown |
| `/home/pbrown/SkuInventory/src/components/features/ComponentSparkline.tsx` | Sparkline chart component |
| `/home/pbrown/SkuInventory/src/components/features/SparklineTimeFilter.tsx` | Inline time filter buttons |
| `/home/pbrown/SkuInventory/tests/unit/component-trend.test.ts` | Trend calculation tests |
| `/home/pbrown/SkuInventory/tests/unit/dashboard-filter.test.ts` | Dashboard filter tests |

### Files Modified: 4
| File | Changes |
|------|---------|
| `/home/pbrown/SkuInventory/src/app/(dashboard)/page.tsx` | Add time filter state, UI, and API param |
| `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts` | Add days query param and date filtering |
| `/home/pbrown/SkuInventory/src/types/component.ts` | Add ComponentTrendPoint and extend response |
| `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts` | Add trendDays param and trend calculation |
| `/home/pbrown/SkuInventory/src/app/(dashboard)/components/[id]/page.tsx` | Add sparkline UI and state |

---

## UI Acceptance Criteria

### Dashboard Time Filter
- [ ] Element visible in header on desktop (1024px+)
- [ ] Element visible in header on tablet (768px-1023px)
- [ ] Element visible in header on mobile (<768px)
- [ ] Element is interactive (clickable)
- [ ] No `lg:hidden` or `md:hidden` classes used

### Component Sparkline
- [ ] Sparkline visible in Inventory card on desktop
- [ ] Sparkline visible in Inventory card on tablet
- [ ] Sparkline visible in Inventory card on mobile
- [ ] Time filter buttons are clickable on all sizes
- [ ] Uses ResponsiveContainer for automatic scaling

---

## Acceptance Criteria Mapping (from Issue #18)

| AC | Implementation |
|----|----------------|
| Dashboard time filter (7/30/90 days, All) | Subtasks 1.1, 1.2, 1.3 |
| Component sparkline with time window | Subtasks 2.1, 2.2, 3.2, 4.1 |
| Transaction-based trends | Subtask 3.2 (cumulative calculation from TransactionLine) |
| Tests cover trend generation | Subtasks 5.1, 5.2 |
| Performance (no N+1 queries) | Subtask 3.2 uses single query with groupBy/aggregate |

---

## Handoff to Build Agent

1. Execute subtasks in exact order (1.1 -> 1.2 -> 1.3 -> 2.1 -> 2.2 -> 3.1 -> 3.2 -> 4.1 -> 5.1 -> 5.2)
2. Complete each phase fully before moving to next
3. Run validation commands after each subtask
4. Follow reference patterns exactly (DefectTrendChart for sparkline, analytics.ts for date filtering)
5. Ensure all UI elements are visible on all screen sizes
6. Run full test suite before marking complete: `npm test && npm run lint && npm run build`

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Scout Review | 3m |
| Pattern Research | 12m |
| Schema Verification | 5m |
| Plan Writing | 25m |
| **Total** | **45m** |

---

AGENT_RETURN: plan-18-120325
