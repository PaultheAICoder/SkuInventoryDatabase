# Implementation Plan
**Generated**: 2025-12-17T08:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #298
**Estimated Build Time**: 3-4 hours
**Complexity**: Low

## Investigation Summary

### Request Analysis
**Type**: Refactoring
**Source**: GitHub Issue #298
**Priority**: Medium

### Task Classification
**Category**: REFACTORING
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="sku"` - run SKU-related tests

### Issue Validation
**Status**: Valid
**Recent Changes**: Files have been modified in last 30 days but changes are unrelated (companyId scoping, JWT validation)

### Current State Assessment
- **Existing components**:
  - `src/app/(dashboard)/skus/page.tsx` - contains local `getSKUs` function (lines 24-106)
  - `src/app/api/skus/route.ts` - contains inline SKU query logic (lines 22-119)
  - `src/services/sku.ts` - DOES NOT EXIST (needs to be created)
- **Database**: No changes needed - uses existing SKU model
- **API Routes**: `GET /api/skus` - will be modified to use service
- **Types**: `src/types/sku.ts` - already has `SKUResponse` interface

### Dependencies & Blockers
None identified. All required services already exist:
- `src/services/bom.ts` - `calculateBOMUnitCosts`, `calculateMaxBuildableUnitsForSKUs`
- `src/services/finished-goods.ts` - `getSkuQuantities`

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Simple
**Effort**: 3-4 hours
**Risk**: Low - this is pure refactoring with existing tests

### Patterns Identified
**Primary**: `src/services/inventory.ts` - service function patterns
**Secondary**: `src/services/bom.ts` - how to use Prisma with typed params

### Ripple Effect Analysis
**Files Identified**: 4

| File | Why Affected |
|------|--------------|
| `src/services/sku.ts` | NEW FILE - create service |
| `src/app/(dashboard)/skus/page.tsx` | Replace local `getSKUs` with service call |
| `src/app/api/skus/route.ts` | Replace inline query with service call |
| `tests/integration/sku-api.test.ts` | Verify existing tests pass (no changes needed) |

---

## Executive Summary
Create a new `getSkusWithCosts` service function in `src/services/sku.ts` that consolidates the duplicated SKU querying logic from the dashboard page and API route. Both locations will be updated to use this single source of truth, ensuring consistent filtering, sorting, pagination, and cost/buildable calculations.

## Key Differences to Reconcile

The API route and page have slightly different implementations:

| Feature | Page | API Route | Service Decision |
|---------|------|-----------|------------------|
| Brand Filter | Not used | `selectedBrandId` filter | Include as optional param |
| isActive Filter | Not used | Supports filter | Include as optional param |
| Finished Goods Qty | Not included | Included | Include (page was missing this) |
| Return Structure | `{ data, meta }` | Uses `paginated()` | Return raw `{ data, meta }` |

---

## Phase 1: Create Service Function

### Subtask 1.1: Create src/services/sku.ts with getSkusWithCosts function

**File**: `src/services/sku.ts` (NEW FILE)
**Pattern**: Follow `src/services/inventory.ts` (lines 17-34) for function structure

**Instructions**:
1. Create new file `src/services/sku.ts`
2. Import required dependencies:
   ```typescript
   import { prisma } from '@/lib/db'
   import { Prisma } from '@prisma/client'
   import { calculateBOMUnitCosts, calculateMaxBuildableUnitsForSKUs } from './bom'
   import { getSkuQuantities } from './finished-goods'
   import type { SKUResponse } from '@/types/sku'
   ```
3. Define the params interface:
   ```typescript
   export interface GetSkusWithCostsParams {
     companyId: string
     brandId?: string // Optional brand filter
     page: number
     pageSize: number
     search?: string
     salesChannel?: string
     isActive?: boolean
     sortBy: 'name' | 'internalCode' | 'salesChannel' | 'createdAt'
     sortOrder: 'asc' | 'desc'
     locationId?: string // For filtering buildable/FG quantities
   }
   ```
4. Define the return type:
   ```typescript
   export interface GetSkusWithCostsResult {
     data: SKUResponse[]
     meta: {
       total: number
       page: number
       pageSize: number
     }
   }
   ```
5. Implement `getSkusWithCosts` function consolidating logic from both sources:
   - Build where clause with all filters (companyId, brandId, salesChannel, search, isActive)
   - Query SKUs with pagination, sorting, and include active BOM
   - Calculate BOM costs, buildable units, and finished goods quantities in parallel
   - Transform to SKUResponse format
   - Return data with meta

**Reference Code Pattern** (from API route lines 43-117):
```typescript
export async function getSkusWithCosts(params: GetSkusWithCostsParams): Promise<GetSkusWithCostsResult> {
  const { companyId, brandId, page, pageSize, search, salesChannel, isActive, sortBy, sortOrder, locationId } = params

  // Build where clause - scope by companyId and optionally brandId
  const where: Prisma.SKUWhereInput = {
    companyId,
    ...(brandId && { brandId }),
    ...(isActive !== undefined && { isActive }),
    ...(salesChannel && { salesChannel }),
    ...(search && {
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { internalCode: { contains: search, mode: 'insensitive' } },
      ],
    }),
  }

  // Get total count
  const total = await prisma.sKU.count({ where })

  // Get SKUs with active BOM
  const skus = await prisma.sKU.findMany({
    where,
    skip: (page - 1) * pageSize,
    take: pageSize,
    orderBy: { [sortBy]: sortOrder },
    include: {
      createdBy: { select: { id: true, name: true } },
      bomVersions: {
        where: { isActive: true },
        take: 1,
        select: {
          id: true,
          versionName: true,
        },
      },
    },
  })

  // Get BOM costs and buildable units
  const skuIds = skus.map((s) => s.id)
  const activeBomIds = skus
    .filter((s) => s.bomVersions[0])
    .map((s) => s.bomVersions[0].id)

  const [bomCosts, buildableUnits, finishedGoodsQtys] = await Promise.all([
    activeBomIds.length > 0 ? calculateBOMUnitCosts(activeBomIds, companyId) : new Map<string, number>(),
    skuIds.length > 0 ? calculateMaxBuildableUnitsForSKUs(skuIds, companyId, locationId) : new Map<string, number | null>(),
    skuIds.length > 0 ? getSkuQuantities(skuIds, companyId, locationId) : new Map<string, number>(),
  ])

  // Transform response
  const data: SKUResponse[] = skus.map((sku) => {
    const activeBom = sku.bomVersions[0]
    const unitCost = activeBom ? bomCosts.get(activeBom.id) ?? 0 : null

    return {
      id: sku.id,
      name: sku.name,
      internalCode: sku.internalCode,
      salesChannel: sku.salesChannel,
      externalIds: sku.externalIds as Record<string, string>,
      notes: sku.notes,
      isActive: sku.isActive,
      createdAt: sku.createdAt.toISOString(),
      updatedAt: sku.updatedAt.toISOString(),
      createdBy: sku.createdBy,
      activeBom: activeBom
        ? {
            id: activeBom.id,
            versionName: activeBom.versionName,
            unitCost: unitCost?.toFixed(4) ?? '0.0000',
          }
        : null,
      maxBuildableUnits: buildableUnits.get(sku.id) ?? null,
      finishedGoodsQuantity: finishedGoodsQtys.get(sku.id) ?? 0,
    }
  })

  return { data, meta: { total, page, pageSize } }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File `src/services/sku.ts` exists
- [ ] Function `getSkusWithCosts` is exported
- [ ] TypeScript compiles without errors
- [ ] Function accepts all required params (companyId, page, pageSize, sortBy, sortOrder)
- [ ] Function accepts optional params (brandId, search, salesChannel, isActive, locationId)
- [ ] Function returns `{ data, meta }` structure

---

## Phase 2: Update API Route

### Subtask 2.1: Update GET handler in /api/skus/route.ts to use service

**File**: `src/app/api/skus/route.ts`
**Pattern**: Follow existing route structure, replace inline query with service call

**Instructions**:
1. Add import for the new service at top of file:
   ```typescript
   import { getSkusWithCosts } from '@/services/sku'
   ```
2. Remove imports that are now handled by service (lines 6, 17-18):
   - Remove: `import { calculateBOMUnitCosts, calculateMaxBuildableUnitsForSKUs } from '@/services/bom'`
   - Remove: `import { getSkuQuantities } from '@/services/finished-goods'`
3. In the GET function, replace lines 43-117 (the inline query logic) with:
   ```typescript
   const result = await getSkusWithCosts({
     companyId: selectedCompanyId,
     brandId: selectedBrandId ?? undefined,
     page,
     pageSize,
     search,
     salesChannel,
     isActive,
     sortBy,
     sortOrder,
     locationId,
   })

   return paginated(result.data, result.meta.total, result.meta.page, result.meta.pageSize)
   ```
4. Keep the session validation, query parsing, and error handling

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
npm test -- --filter="sku"
```

**Completion Criteria**:
- [ ] GET handler uses `getSkusWithCosts` service
- [ ] Inline query logic (lines 43-117) is removed
- [ ] Imports cleaned up (bom and finished-goods imports removed)
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] Existing tests pass

---

## Phase 3: Update Dashboard Page

### Subtask 3.1: Update SKUsPage to use service

**File**: `src/app/(dashboard)/skus/page.tsx`
**Pattern**: Follow existing page structure, replace local `getSKUs` with service call

**Instructions**:
1. Add import for the new service:
   ```typescript
   import { getSkusWithCosts } from '@/services/sku'
   ```
2. Remove imports no longer needed (lines 10-12):
   - Remove: `import { prisma } from '@/lib/db'`
   - Remove: `import { Prisma } from '@prisma/client'`
   - Remove: `import { calculateBOMUnitCosts, calculateMaxBuildableUnitsForSKUs } from '@/services/bom'`
3. Remove the local `getSKUs` function (lines 24-106) entirely
4. Update the page component to call the service directly:
   ```typescript
   // Inside SKUsPage function, after params extraction:
   const selectedCompanyId = session.user.selectedCompanyId
   const selectedBrandId = session.user.selectedBrandId

   const { data: skus, meta } = await getSkusWithCosts({
     companyId: selectedCompanyId,
     brandId: selectedBrandId ?? undefined,
     page: parseInt(params.page || '1', 10),
     pageSize: parseInt(params.pageSize || '50', 10),
     search: params.search,
     salesChannel: params.salesChannel,
     sortBy: (params.sortBy || 'createdAt') as 'name' | 'internalCode' | 'salesChannel' | 'createdAt',
     sortOrder: (params.sortOrder || 'desc') as 'asc' | 'desc',
     locationId: params.locationId,
   })
   ```

**NOTE**: The page currently DOES NOT have brand filtering. By using the service, we will ADD brand filtering to the page (consistent with API). This is an improvement.

**NOTE**: The page currently DOES NOT return `finishedGoodsQuantity`. The SKUTable component expects it (line 218). By using the service, this bug is fixed.

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Page uses `getSkusWithCosts` service
- [ ] Local `getSKUs` function is removed
- [ ] Unused imports removed (prisma, Prisma, bom services)
- [ ] Brand filtering is now applied (was missing before)
- [ ] `finishedGoodsQuantity` is now returned (fixes UI bug)
- [ ] TypeScript compiles without errors
- [ ] Build succeeds

---

## Phase 4: Verification

### Subtask 4.1: Run full validation suite

**Instructions**:
1. Run TypeScript check:
   ```bash
   npx tsc --noEmit
   ```
2. Run build:
   ```bash
   npm run build
   ```
3. Run lint:
   ```bash
   npm run lint
   ```
4. Run SKU tests:
   ```bash
   npm test -- --filter="sku"
   ```

**Completion Criteria**:
- [ ] All commands pass without errors
- [ ] No new warnings introduced

---

## Summary of Deliverables

**Files Created**: 1
- `src/services/sku.ts`

**Files Modified**: 2
- `src/app/api/skus/route.ts`
- `src/app/(dashboard)/skus/page.tsx`

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4)
2. Create `src/services/sku.ts` first before modifying consumers
3. Test completion criteria before each next subtask
4. Follow reference patterns exactly
5. Ensure brand filtering and finishedGoodsQuantity are working after migration

## Test Strategy Note

- Use Vitest for unit/integration tests
- Run `npm test -- --filter="sku"` to target SKU-related tests
- Existing `tests/integration/sku-api.test.ts` should pass without modification

## Side Effects / Improvements

This refactoring will fix two latent issues:
1. **Brand Filtering on Page**: The dashboard page did not apply brand filtering. After this change, it will (consistent with API).
2. **Missing finishedGoodsQuantity**: The dashboard page did not return `finishedGoodsQuantity`, but the SKUTable component expects it. This will be fixed.

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Investigation | 12m |
| Validation | 3m |
| Planning | 10m |
| **Total** | **25m** |
