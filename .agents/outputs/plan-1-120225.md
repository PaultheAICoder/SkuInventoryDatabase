# Implementation Plan: User Feedback Submission System with AI-Powered Clarification

**Generated**: 2025-12-02T20:20:00Z
**Task ID**: GitHub Issue #1
**Estimated Build Time**: 10-14 hours
**Complexity**: Medium

## Executive Summary

This feature adds an AI-powered feedback submission system allowing users to submit bug reports or feature requests directly from the application. The system uses Claude API to generate 3 targeted clarifying questions based on the user's initial description, then formats and creates a GitHub issue using the existing bug.md or feature.md templates. The feature is standalone with no impact on existing code.

## Schema Verification

**Database**: No database changes required (feedback is immediately submitted to GitHub).
**Environment Variables**: New `ANTHROPIC_API_KEY` required.
**Dependencies**: New `@anthropic-ai/sdk` package required.

## Ripple Effect Analysis

**Verified**: No existing feedback-related code in codebase (grep confirmed 0 matches).
**Impact**: Isolated feature - modifies only layout.tsx header section (lines 114-119).

---

## Phase 0: Dependencies and Environment Setup

### Subtask 0.1: Install @anthropic-ai/sdk Package

**File**: `/home/pbrown/SkuInventory/package.json`
**Instructions**:
1. Run `npm install @anthropic-ai/sdk` to add the Anthropic SDK
2. Verify installation completed without errors
3. Verify package appears in package.json dependencies

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npm install @anthropic-ai/sdk
cat /home/pbrown/SkuInventory/package.json | grep anthropic
```

**Completion Criteria**:
- [ ] Package installed successfully
- [ ] Package appears in dependencies section of package.json
- [ ] No npm errors

---

### Subtask 0.2: Add Textarea UI Component

**File**: `/home/pbrown/SkuInventory/src/components/ui/textarea.tsx` (NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/components/ui/input.tsx` (lines 1-24)
**Instructions**:
1. Create new textarea component following shadcn/ui pattern
2. Use same className patterns as Input component
3. Use forwardRef for proper ref forwarding

**Code Template**:
```tsx
import * as React from 'react'
import { cn } from '@/lib/utils'

export type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = 'Textarea'

export { Textarea }
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] TypeScript compiles without errors
- [ ] Component follows Input.tsx pattern exactly

---

### Subtask 0.3: Update Environment Schema

**File**: `/home/pbrown/SkuInventory/src/lib/env.ts`
**Pattern**: Follow existing schema pattern (lines 3-8)
**Instructions**:
1. Add `ANTHROPIC_API_KEY` to envSchema with `.optional()` to prevent build failures
2. Make it optional so app can build/run without the key (graceful fallback)

**Code Change** (modify envSchema on lines 3-8):
```typescript
const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  NEXTAUTH_SECRET: z.string().min(1),
  NEXTAUTH_URL: z.string().url().optional(),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  ANTHROPIC_API_KEY: z.string().min(1).optional(),
})
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Schema updated with ANTHROPIC_API_KEY
- [ ] TypeScript compiles without errors
- [ ] App still builds without the env var set (optional)

---

### Subtask 0.4: Update .env.example

**File**: `/home/pbrown/SkuInventory/.env.example`
**Instructions**:
1. Add `ANTHROPIC_API_KEY` placeholder with explanation comment

**Code to Add** (at end of file):
```bash
# Anthropic API Key for AI-powered feedback clarification
# Get your key at: https://console.anthropic.com/
ANTHROPIC_API_KEY=sk-ant-your-key-here
```

**Completion Criteria**:
- [ ] Placeholder added to .env.example
- [ ] Clear instructions in comments

---

## Phase 1: Types Layer

### Subtask 1.1: Create Feedback Types

**File**: `/home/pbrown/SkuInventory/src/types/feedback.ts` (NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/types/component.ts` for schema/type structure
**Instructions**:
1. Create Zod schemas for API request validation
2. Create TypeScript interfaces for API responses
3. Define FeedbackType and FeedbackStep types

**Code Template**:
```typescript
import { z } from 'zod'

// Feedback type enum
export type FeedbackType = 'bug' | 'feature'

// Feedback dialog step enum
export type FeedbackStep = 'select-type' | 'describe' | 'clarify' | 'submitting' | 'success' | 'error'

// Clarify request schema
export const clarifyRequestSchema = z.object({
  type: z.enum(['bug', 'feature']),
  description: z.string().min(10, 'Description must be at least 10 characters').max(2000),
})

export type ClarifyRequestInput = z.infer<typeof clarifyRequestSchema>

// Clarify response interface
export interface ClarifyResponse {
  questions: string[]
}

// Submit feedback request schema
export const submitFeedbackSchema = z.object({
  type: z.enum(['bug', 'feature']),
  description: z.string().min(10).max(2000),
  answers: z.array(z.string()).length(3, 'Must provide exactly 3 answers'),
})

export type SubmitFeedbackInput = z.infer<typeof submitFeedbackSchema>

// Submit feedback response interface
export interface SubmitFeedbackResponse {
  issueUrl: string
  issueNumber: number
}

// Rate limit tracking (in-memory, per session)
export interface RateLimitEntry {
  userId: string
  count: number
  resetAt: Date
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Types file created
- [ ] Zod schemas validate correctly
- [ ] TypeScript compiles without errors

---

## Phase 2: Lib/Utility Layer

### Subtask 2.1: Create Claude API Client Wrapper

**File**: `/home/pbrown/SkuInventory/src/lib/claude.ts` (NEW)
**Instructions**:
1. Initialize Anthropic client with API key from env
2. Create helper function for generating clarifying questions
3. Include proper error handling and fallback
4. Type-safe response parsing

**Code Template**:
```typescript
import Anthropic from '@anthropic-ai/sdk'

// Initialize client lazily to handle missing API key gracefully
let client: Anthropic | null = null

function getClient(): Anthropic | null {
  if (!process.env.ANTHROPIC_API_KEY) {
    console.warn('ANTHROPIC_API_KEY not set - AI clarification will be unavailable')
    return null
  }

  if (!client) {
    client = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    })
  }

  return client
}

export interface GenerateQuestionsParams {
  type: 'bug' | 'feature'
  description: string
}

export interface GenerateQuestionsResult {
  questions: string[]
  error?: string
}

/**
 * Generate 3 clarifying questions for a feedback submission using Claude API.
 * Returns default questions if API is unavailable or errors.
 */
export async function generateClarifyingQuestions(
  params: GenerateQuestionsParams
): Promise<GenerateQuestionsResult> {
  const { type, description } = params

  const anthropic = getClient()

  // Fallback questions if API unavailable
  const fallbackQuestions = type === 'bug'
    ? [
        'What steps can we follow to reproduce this issue?',
        'What did you expect to happen instead?',
        'When did you first notice this problem?',
      ]
    : [
        'What problem would this feature solve for you?',
        'How would you ideally use this feature?',
        'How important is this feature to your workflow?',
      ]

  if (!anthropic) {
    return { questions: fallbackQuestions }
  }

  try {
    const systemPrompt = type === 'bug'
      ? `You are helping gather information about a software bug report. Based on the user's initial description, generate exactly 3 specific, targeted clarifying questions that would help developers understand and fix the issue. Focus on: reproduction steps, expected vs actual behavior, and environment/context. Each question should be concise (under 100 characters). Return ONLY the 3 questions, one per line, without numbering or bullets.`
      : `You are helping gather information about a software feature request. Based on the user's initial description, generate exactly 3 specific, targeted clarifying questions that would help developers understand and implement the feature. Focus on: use cases, expected behavior, and priority/importance. Each question should be concise (under 100 characters). Return ONLY the 3 questions, one per line, without numbering or bullets.`

    const message = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 300,
      messages: [
        {
          role: 'user',
          content: `${type === 'bug' ? 'Bug Report' : 'Feature Request'}: ${description}`,
        },
      ],
      system: systemPrompt,
    })

    // Extract text from response
    const textContent = message.content.find((block) => block.type === 'text')
    if (!textContent || textContent.type !== 'text') {
      return { questions: fallbackQuestions }
    }

    // Parse questions from response (one per line)
    const questions = textContent.text
      .split('\n')
      .map((q) => q.trim())
      .filter((q) => q.length > 0 && q.length < 150)
      .slice(0, 3)

    // Ensure we have exactly 3 questions
    if (questions.length < 3) {
      return { questions: fallbackQuestions }
    }

    return { questions }
  } catch (error) {
    console.error('Error generating clarifying questions:', error)
    return {
      questions: fallbackQuestions,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Client wrapper created
- [ ] Fallback questions work when API unavailable
- [ ] TypeScript compiles without errors

---

## Phase 3: API Routes

### Subtask 3.1: Create Clarify API Endpoint

**File**: `/home/pbrown/SkuInventory/src/app/api/feedback/clarify/route.ts` (NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts` (lines 46-51 for auth, 204-207 for error handling)
**Instructions**:
1. Create POST endpoint that accepts type and description
2. Require authentication via getServerSession
3. Call Claude API wrapper to generate questions
4. Return questions array
5. Use parseBody helper for Zod validation

**Code Template**:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { success, unauthorized, serverError, parseBody } from '@/lib/api-response'
import { generateClarifyingQuestions } from '@/lib/claude'
import { clarifyRequestSchema, type ClarifyResponse } from '@/types/feedback'

// POST /api/feedback/clarify - Generate clarifying questions
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    const { data, error } = await parseBody(request, clarifyRequestSchema)
    if (error) {
      return error
    }

    const result = await generateClarifyingQuestions({
      type: data.type,
      description: data.description,
    })

    const response: ClarifyResponse = {
      questions: result.questions,
    }

    return success(response)
  } catch (error) {
    console.error('Error in feedback clarify endpoint:', error)
    return serverError()
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] API route created at correct path
- [ ] Authentication required
- [ ] Zod validation works
- [ ] Returns 3 questions on success

---

### Subtask 3.2: Create Feedback Submit API Endpoint

**File**: `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts` (NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts` for structure
**Instructions**:
1. Create POST endpoint for submitting feedback
2. Require authentication
3. Format issue body using bug.md or feature.md template structure
4. Execute gh CLI to create GitHub issue
5. Return issue URL and number
6. Implement rate limiting (5 per hour per user)

**Code Template**:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { success, unauthorized, serverError, error, parseBody } from '@/lib/api-response'
import { submitFeedbackSchema, type SubmitFeedbackResponse } from '@/types/feedback'
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)

// Simple in-memory rate limiting (resets on server restart)
const rateLimitMap = new Map<string, { count: number; resetAt: Date }>()
const RATE_LIMIT = 5
const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000 // 1 hour

function checkRateLimit(userId: string): boolean {
  const now = new Date()
  const entry = rateLimitMap.get(userId)

  if (!entry || entry.resetAt < now) {
    rateLimitMap.set(userId, { count: 1, resetAt: new Date(now.getTime() + RATE_LIMIT_WINDOW_MS) })
    return true
  }

  if (entry.count >= RATE_LIMIT) {
    return false
  }

  entry.count++
  return true
}

function formatBugBody(description: string, answers: string[]): string {
  return `## Reported Issue
**What's broken**: ${description}
**Expected behavior**: ${answers[1] || 'Not specified'}
**Severity**: Medium

## Error Details
**Error Type**: User-reported bug
**Error Message**: See description above
**Location**: User feedback submission
**URL/Route**: N/A

## Clarifying Questions & Answers
**Q1**: What steps can we follow to reproduce this issue?
**A1**: ${answers[0] || 'Not provided'}

**Q2**: What did you expect to happen instead?
**A2**: ${answers[1] || 'Not provided'}

**Q3**: When did you first notice this problem?
**A3**: ${answers[2] || 'Not provided'}

## Verification Checkpoint
- [ ] **Last Verified**: Pending investigation
- [ ] **File paths verified**: No
- [ ] **Checked for previous partial fixes**: No
- [ ] **Reproduction confirmed today**: No

## How to Reproduce
See user's answer to Q1 above.

## Investigation Notes
- Error pattern detected: User-reported issue
- Likely affected components: TBD
- Related files to check: TBD

## Next Steps
- Investigate root cause (not just symptom)
- Add regression test to prevent recurrence
- Ensure minimal, surgical fix`
}

function formatFeatureBody(description: string, answers: string[]): string {
  return `## Feature Description
${description}

## User Stories

### Primary User Story
**As a** user
**I want to** ${description.toLowerCase()}
**So that** ${answers[0] || 'it improves my workflow'}

## Clarifying Questions & Answers
**Q1**: What problem would this feature solve for you?
**A1**: ${answers[0] || 'Not provided'}

**Q2**: How would you ideally use this feature?
**A2**: ${answers[1] || 'Not provided'}

**Q3**: How important is this feature to your workflow?
**A3**: ${answers[2] || 'Not provided'}

## Requirements

### Functional Requirements
- [ ] Implement core feature as described
- [ ] Handle edge cases appropriately
- [ ] Follow existing code patterns

### Non-Functional Requirements
- [ ] Performance: Maintain current app performance
- [ ] Privacy: Handle user data appropriately
- [ ] Reliability: Include proper error handling

## Technical Context

### Affected Areas
- **Database**: TBD during implementation
- **Backend**: TBD during implementation
- **Frontend**: TBD during implementation
- **External APIs**: None expected

### Related Features
To be determined during planning.

### Data Involved
- **New Tables**: TBD
- **Modified Tables**: TBD
- **Relationships**: TBD

### Dependencies
- **Prerequisites**: None identified
- **Blocks**: None

## Acceptance Criteria
- [ ] Feature works as described
- [ ] No TypeScript errors
- [ ] All tests passing
- [ ] Build completes successfully

## Verification Checkpoint
- [ ] **Last Verified**: N/A - new feature
- [ ] **Pattern references verified**: No
- [ ] **Similar feature identified**: TBD
- [ ] **Dependencies confirmed**: No

## Notes
- Estimated complexity: TBD
- May require phasing: TBD
- Design pattern to follow: TBD`
}

// POST /api/feedback - Submit feedback and create GitHub issue
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    // Rate limiting
    if (!checkRateLimit(session.user.id)) {
      return error('Rate limit exceeded. Please wait before submitting more feedback.', 429, 'TooManyRequests')
    }

    const { data, error: parseError } = await parseBody(request, submitFeedbackSchema)
    if (parseError) {
      return parseError
    }

    const { type, description, answers } = data

    // Format issue body based on type
    const issueBody = type === 'bug'
      ? formatBugBody(description, answers)
      : formatFeatureBody(description, answers)

    // Create title from description (truncate if needed)
    const title = description.length > 80
      ? description.substring(0, 77) + '...'
      : description

    // Label based on type
    const label = type === 'bug' ? 'bug' : 'enhancement'

    // Create GitHub issue using gh CLI
    // Escape quotes and newlines in the body for shell safety
    const escapedBody = issueBody.replace(/"/g, '\\"').replace(/\n/g, '\\n')
    const escapedTitle = title.replace(/"/g, '\\"')

    const command = `gh issue create --title "${escapedTitle}" --body "${escapedBody}" --label "${label}"`

    const { stdout, stderr } = await execAsync(command, {
      cwd: process.cwd(),
      timeout: 30000, // 30 second timeout
    })

    if (stderr && !stderr.includes('Creating issue')) {
      console.error('gh issue create stderr:', stderr)
    }

    // Parse issue URL from stdout (gh outputs the URL)
    const issueUrl = stdout.trim()
    const issueNumberMatch = issueUrl.match(/\/issues\/(\d+)$/)
    const issueNumber = issueNumberMatch ? parseInt(issueNumberMatch[1], 10) : 0

    const response: SubmitFeedbackResponse = {
      issueUrl,
      issueNumber,
    }

    return success(response)
  } catch (err) {
    console.error('Error creating GitHub issue:', err)

    // Handle specific errors
    if (err instanceof Error && err.message.includes('gh: command not found')) {
      return error('GitHub CLI not available on server', 500, 'ServiceUnavailable')
    }

    return serverError('Failed to create GitHub issue. Please try again.')
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] API route created at correct path
- [ ] Authentication required
- [ ] Rate limiting works (5 per hour)
- [ ] Issue created successfully via gh CLI
- [ ] Returns issue URL and number

---

## Phase 4: Frontend Components

### Subtask 4.1: Create FeedbackButton Component

**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackButton.tsx` (NEW)
**Pattern**: Follow existing button usage in layout.tsx (lines 63-70)
**Instructions**:
1. Create simple button component with MessageSquare icon
2. Accept onClick prop to trigger dialog
3. Use shadcn Button component

**Code Template**:
```tsx
'use client'

import { Button } from '@/components/ui/button'
import { MessageSquare } from 'lucide-react'

interface FeedbackButtonProps {
  onClick: () => void
}

export function FeedbackButton({ onClick }: FeedbackButtonProps) {
  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={onClick}
      title="Submit Feedback"
      aria-label="Submit Feedback"
    >
      <MessageSquare className="h-5 w-5" />
    </Button>
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Component created
- [ ] Uses shadcn Button
- [ ] Has proper accessibility attributes
- [ ] TypeScript compiles

---

### Subtask 4.2: Create FeedbackDialog Component

**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx` (NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/components/features/AdjustmentDialog.tsx` (full file) and `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx` (lines 57-90 for useEffect pattern)
**Instructions**:
1. Create multi-step dialog: select-type -> describe -> clarify -> submitting -> success/error
2. Manage form state for type, description, answers
3. Call /api/feedback/clarify for questions
4. Call /api/feedback to submit
5. Show loading states during API calls
6. Use toast for success/error notifications
7. Reset form on close

**Code Template**:
```tsx
'use client'

import { useState, useEffect } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { toast } from 'sonner'
import { Bug, Lightbulb, CheckCircle, AlertCircle, Loader2 } from 'lucide-react'
import type { FeedbackType, FeedbackStep } from '@/types/feedback'

interface FeedbackDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function FeedbackDialog({ open, onOpenChange }: FeedbackDialogProps) {
  const [step, setStep] = useState<FeedbackStep>('select-type')
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const [feedbackType, setFeedbackType] = useState<FeedbackType | ''>('')
  const [description, setDescription] = useState('')
  const [questions, setQuestions] = useState<string[]>([])
  const [answers, setAnswers] = useState<string[]>(['', '', ''])
  const [issueUrl, setIssueUrl] = useState('')

  // Reset form when dialog closes
  useEffect(() => {
    if (!open) {
      // Small delay to allow animation to complete
      const timer = setTimeout(() => {
        setStep('select-type')
        setFeedbackType('')
        setDescription('')
        setQuestions([])
        setAnswers(['', '', ''])
        setIssueUrl('')
        setError(null)
      }, 200)
      return () => clearTimeout(timer)
    }
  }, [open])

  const handleTypeSelect = (type: FeedbackType) => {
    setFeedbackType(type)
    setStep('describe')
  }

  const handleDescriptionSubmit = async () => {
    if (description.length < 10) {
      setError('Please provide more detail (at least 10 characters)')
      return
    }

    setIsLoading(true)
    setError(null)

    try {
      const res = await fetch('/api/feedback/clarify', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: feedbackType,
          description,
        }),
      })

      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.message || 'Failed to get clarifying questions')
      }

      const data = await res.json()
      setQuestions(data.data.questions)
      setStep('clarify')
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  const handleSubmit = async () => {
    // Validate all answers provided
    if (answers.some((a) => a.trim().length === 0)) {
      setError('Please answer all questions')
      return
    }

    setIsLoading(true)
    setError(null)
    setStep('submitting')

    try {
      const res = await fetch('/api/feedback', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: feedbackType,
          description,
          answers,
        }),
      })

      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.message || 'Failed to submit feedback')
      }

      const data = await res.json()
      setIssueUrl(data.data.issueUrl)
      setStep('success')
      toast.success('Feedback submitted!', {
        description: `Issue #${data.data.issueNumber} created successfully.`,
      })
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
      setStep('error')
      toast.error('Submission failed', {
        description: err instanceof Error ? err.message : 'Please try again.',
      })
    } finally {
      setIsLoading(false)
    }
  }

  const handleBack = () => {
    if (step === 'describe') {
      setStep('select-type')
      setFeedbackType('')
    } else if (step === 'clarify') {
      setStep('describe')
    } else if (step === 'error') {
      setStep('clarify')
    }
    setError(null)
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        {/* Step 1: Select Type */}
        {step === 'select-type' && (
          <>
            <DialogHeader>
              <DialogTitle>Submit Feedback</DialogTitle>
              <DialogDescription>
                Help us improve! What type of feedback do you have?
              </DialogDescription>
            </DialogHeader>

            <div className="grid gap-4 py-4">
              <button
                type="button"
                onClick={() => handleTypeSelect('bug')}
                className="flex items-center gap-4 rounded-lg border p-4 text-left hover:bg-muted transition-colors"
              >
                <Bug className="h-8 w-8 text-destructive" />
                <div>
                  <p className="font-medium">Report a Bug</p>
                  <p className="text-sm text-muted-foreground">
                    Something isn&apos;t working as expected
                  </p>
                </div>
              </button>

              <button
                type="button"
                onClick={() => handleTypeSelect('feature')}
                className="flex items-center gap-4 rounded-lg border p-4 text-left hover:bg-muted transition-colors"
              >
                <Lightbulb className="h-8 w-8 text-yellow-500" />
                <div>
                  <p className="font-medium">Request a Feature</p>
                  <p className="text-sm text-muted-foreground">
                    Suggest a new feature or improvement
                  </p>
                </div>
              </button>
            </div>
          </>
        )}

        {/* Step 2: Describe Issue */}
        {step === 'describe' && (
          <>
            <DialogHeader>
              <DialogTitle>
                {feedbackType === 'bug' ? 'Describe the Bug' : 'Describe Your Feature Request'}
              </DialogTitle>
              <DialogDescription>
                {feedbackType === 'bug'
                  ? 'Tell us what went wrong. Be as specific as possible.'
                  : 'Tell us about the feature you\'d like to see.'}
              </DialogDescription>
            </DialogHeader>

            <div className="grid gap-4 py-4">
              {error && (
                <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
                  {error}
                </div>
              )}

              <div className="grid gap-2">
                <Label htmlFor="description">Description *</Label>
                <Textarea
                  id="description"
                  placeholder={
                    feedbackType === 'bug'
                      ? 'When I try to... the app shows... instead of...'
                      : 'I would like to be able to...'
                  }
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  className="min-h-[120px]"
                />
                <p className="text-xs text-muted-foreground">
                  {description.length}/2000 characters (minimum 10)
                </p>
              </div>
            </div>

            <DialogFooter>
              <Button type="button" variant="outline" onClick={handleBack}>
                Back
              </Button>
              <Button
                type="button"
                onClick={handleDescriptionSubmit}
                disabled={isLoading || description.length < 10}
              >
                {isLoading ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Getting Questions...
                  </>
                ) : (
                  'Continue'
                )}
              </Button>
            </DialogFooter>
          </>
        )}

        {/* Step 3: Answer Clarifying Questions */}
        {step === 'clarify' && (
          <>
            <DialogHeader>
              <DialogTitle>A Few Quick Questions</DialogTitle>
              <DialogDescription>
                Help us understand your {feedbackType === 'bug' ? 'issue' : 'request'} better.
              </DialogDescription>
            </DialogHeader>

            <div className="grid gap-4 py-4 max-h-[400px] overflow-y-auto">
              {error && (
                <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
                  {error}
                </div>
              )}

              {questions.map((question, index) => (
                <div key={index} className="grid gap-2">
                  <Label htmlFor={`answer-${index}`} className="text-sm font-medium">
                    {question}
                  </Label>
                  <Textarea
                    id={`answer-${index}`}
                    placeholder="Your answer..."
                    value={answers[index]}
                    onChange={(e) => {
                      const newAnswers = [...answers]
                      newAnswers[index] = e.target.value
                      setAnswers(newAnswers)
                    }}
                    className="min-h-[80px]"
                  />
                </div>
              ))}
            </div>

            <DialogFooter>
              <Button type="button" variant="outline" onClick={handleBack}>
                Back
              </Button>
              <Button
                type="button"
                onClick={handleSubmit}
                disabled={isLoading || answers.some((a) => a.trim().length === 0)}
              >
                Submit Feedback
              </Button>
            </DialogFooter>
          </>
        )}

        {/* Step 4: Submitting */}
        {step === 'submitting' && (
          <>
            <DialogHeader>
              <DialogTitle>Submitting Feedback</DialogTitle>
              <DialogDescription>
                Creating your GitHub issue...
              </DialogDescription>
            </DialogHeader>

            <div className="flex flex-col items-center justify-center py-8">
              <Loader2 className="h-12 w-12 animate-spin text-primary" />
              <p className="mt-4 text-sm text-muted-foreground">Please wait...</p>
            </div>
          </>
        )}

        {/* Step 5: Success */}
        {step === 'success' && (
          <>
            <DialogHeader>
              <DialogTitle>Thank You!</DialogTitle>
              <DialogDescription>
                Your feedback has been submitted successfully.
              </DialogDescription>
            </DialogHeader>

            <div className="flex flex-col items-center justify-center py-8">
              <CheckCircle className="h-12 w-12 text-green-500" />
              <p className="mt-4 text-center text-sm text-muted-foreground">
                A GitHub issue has been created for your feedback.
              </p>
              {issueUrl && (
                <a
                  href={issueUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="mt-2 text-sm text-primary hover:underline"
                >
                  View Issue
                </a>
              )}
            </div>

            <DialogFooter>
              <Button type="button" onClick={() => onOpenChange(false)}>
                Close
              </Button>
            </DialogFooter>
          </>
        )}

        {/* Step 6: Error */}
        {step === 'error' && (
          <>
            <DialogHeader>
              <DialogTitle>Submission Failed</DialogTitle>
              <DialogDescription>
                We couldn&apos;t submit your feedback.
              </DialogDescription>
            </DialogHeader>

            <div className="flex flex-col items-center justify-center py-8">
              <AlertCircle className="h-12 w-12 text-destructive" />
              <p className="mt-4 text-center text-sm text-destructive">
                {error || 'An unexpected error occurred. Please try again.'}
              </p>
            </div>

            <DialogFooter>
              <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
                Cancel
              </Button>
              <Button type="button" onClick={handleBack}>
                Try Again
              </Button>
            </DialogFooter>
          </>
        )}
      </DialogContent>
    </Dialog>
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Dialog component created
- [ ] All 6 steps render correctly
- [ ] API calls work (clarify and submit)
- [ ] Loading states show properly
- [ ] Toast notifications work
- [ ] Form resets on close
- [ ] TypeScript compiles

---

## Phase 5: Integration

### Subtask 5.1: Add FeedbackButton to Dashboard Layout

**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx`
**Pattern**: Existing header structure (lines 114-119)
**Instructions**:
1. Import FeedbackButton and FeedbackDialog components
2. Add state for dialog open/close
3. Add FeedbackButton to mobile header (right side)
4. Render FeedbackDialog

**Changes Required**:

1. Add imports at top (after line 21):
```tsx
import { FeedbackButton } from '@/components/features/FeedbackButton'
import { FeedbackDialog } from '@/components/features/FeedbackDialog'
```

2. Add state in component (after line 36):
```tsx
const [feedbackOpen, setFeedbackOpen] = useState(false)
```

3. Modify mobile header section (lines 114-119) to add FeedbackButton:
```tsx
{/* Mobile header */}
<header className="sticky top-0 z-30 flex h-16 items-center justify-between gap-4 border-b bg-background px-4 lg:hidden">
  <div className="flex items-center gap-4">
    <Button variant="ghost" size="icon" onClick={() => setSidebarOpen(true)}>
      <Menu className="h-5 w-5" />
    </Button>
    <span className="font-semibold">Inventory Tracker</span>
  </div>
  <FeedbackButton onClick={() => setFeedbackOpen(true)} />
</header>
```

4. Add FeedbackDialog before closing div of layout (before line 124):
```tsx
<FeedbackDialog open={feedbackOpen} onOpenChange={setFeedbackOpen} />
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Imports added correctly
- [ ] State added for dialog control
- [ ] FeedbackButton visible in mobile header
- [ ] FeedbackDialog renders when button clicked
- [ ] TypeScript compiles
- [ ] Build succeeds

---

## Phase 6: Verification and Testing

### Subtask 6.1: Manual End-to-End Testing

**Instructions**:
1. Start development server
2. Navigate to app on mobile viewport
3. Click feedback button in header
4. Test bug report flow:
   - Select "Report a Bug"
   - Enter description (at least 10 chars)
   - Click Continue - verify questions appear
   - Answer all 3 questions
   - Submit - verify issue created
   - Click "View Issue" to verify GitHub issue
5. Test feature request flow similarly
6. Test rate limiting (submit 5+ times rapidly)
7. Test error handling (disconnect network during submit)

**Validation Commands**:
```bash
npm run dev
# Then manually test in browser at https://172.16.20.50:4543
```

**Completion Criteria**:
- [ ] Bug report creates GitHub issue with "bug" label
- [ ] Feature request creates GitHub issue with "enhancement" label
- [ ] Questions are relevant to submission type
- [ ] Rate limiting blocks after 5 submissions
- [ ] Error messages display correctly
- [ ] Success toast appears
- [ ] Dialog resets on close

---

### Subtask 6.2: Final Build and Lint Verification

**Instructions**:
1. Run TypeScript check
2. Run build
3. Run lint
4. Verify no errors or warnings

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
cd /home/pbrown/SkuInventory && npm run build
cd /home/pbrown/SkuInventory && npm run lint
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` succeeds with no errors
- [ ] `npm run lint` passes with no errors or warnings

---

## Summary of Deliverables

**Files to Create (7)**:
| File | Type | Description |
|------|------|-------------|
| `/home/pbrown/SkuInventory/src/components/ui/textarea.tsx` | UI Component | Multi-line text input |
| `/home/pbrown/SkuInventory/src/types/feedback.ts` | Types | Zod schemas and TypeScript interfaces |
| `/home/pbrown/SkuInventory/src/lib/claude.ts` | Utility | Claude API client wrapper |
| `/home/pbrown/SkuInventory/src/app/api/feedback/clarify/route.ts` | API Route | Generate clarifying questions |
| `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts` | API Route | Submit feedback, create GitHub issue |
| `/home/pbrown/SkuInventory/src/components/features/FeedbackButton.tsx` | Component | Trigger button |
| `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx` | Component | Multi-step dialog |

**Files to Modify (3)**:
| File | Change |
|------|--------|
| `/home/pbrown/SkuInventory/package.json` | Add @anthropic-ai/sdk dependency |
| `/home/pbrown/SkuInventory/src/lib/env.ts` | Add ANTHROPIC_API_KEY to schema |
| `/home/pbrown/SkuInventory/.env.example` | Add ANTHROPIC_API_KEY placeholder |
| `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx` | Add FeedbackButton to header |

**Total**: 7 new files, 4 modified files

---

## Handoff to Build Agent

1. **Execute subtasks in exact order** - Dependencies build on each other
2. **Phase 0 MUST complete before Phase 1** - npm install and env setup required first
3. **Test completion criteria before next subtask** - Run validation commands after each subtask
4. **Follow reference patterns exactly** - Copy structure from referenced files
5. **Use absolute paths** - All file paths are absolute as shown

**Critical Notes**:
- The ANTHROPIC_API_KEY environment variable must be set in .env for AI clarification to work
- Without the API key, fallback questions will be used (system still functional)
- Rate limiting is in-memory and resets on server restart
- GitHub CLI must be authenticated on the server for issue creation to work

---

## Acceptance Criteria Checklist

- [ ] Feedback button visible in mobile header
- [ ] Clicking button opens dialog with bug/feature selection
- [ ] User can enter description (textarea component)
- [ ] Claude API returns 3 relevant clarifying questions (or fallback questions)
- [ ] Questions are specific to the submission type and content
- [ ] User can answer all questions
- [ ] Submitting creates GitHub issue with formatted content
- [ ] Issue follows bug.md or feature.md template format
- [ ] User sees success confirmation with issue URL
- [ ] User sees error message if submission fails
- [ ] All API calls require authentication
- [ ] Graceful fallback if Claude API unavailable
- [ ] Rate limiting prevents abuse (max 5 submissions per hour per user)
- [ ] `npm run build` completes without errors
- [ ] `npx tsc --noEmit` completes without errors

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Scout Review | 3m |
| Pattern Research | 5m |
| Schema Verification | 2m |
| Plan Writing | 12m |
| **Total** | **22m** |

---

**AGENT_RETURN**: plan-1-120225
