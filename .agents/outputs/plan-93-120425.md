# Implementation Plan
**Generated**: 2025-12-04T10:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: Issue #93
**Estimated Build Time**: 8-10 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #93 (Parent #10)
**Priority**: High

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="shopify-sync"` or None (run full test suite after completion)

### Issue Validation
**Status**: Valid
**Recent Changes**: Recent Shopify connection and mapping routes added per Issues #89, #90, #91, #92

### Current State Assessment
- **Existing components**:
  - `ShopifyClient` in `src/services/shopify.ts` - fully implemented with pagination, rate limiting, fetchOrders()
  - `ShopifyConnection` model - stores shop credentials, lastSyncAt, syncStatus
  - `ShopifyOrder` model - stores synced orders with status enum (pending/approved/posted/skipped/error)
  - `ShopifyOrderLine` model - stores line items with mapping status (mapped/unmapped/not_found)
  - `SkuChannelMapping` model - maps external variant IDs to internal SKUs
  - Connection CRUD at `/api/shopify/connection/route.ts`
  - Mapping CRUD at `/api/shopify/mappings/route.ts`
  - Test connection at `/api/shopify/connection/test/route.ts`
- **Database**: Models exist in schema, no migrations needed
- **API Routes**: Sync and orders endpoints need to be created
- **Types**: Shopify types exist in `src/types/shopify.ts`

### Dependencies & Blockers
1. ShopifyClient.fetchOrders() exists and handles pagination
2. Crypto utilities for token decryption exist
3. SkuChannelMapping lookup by variant_id needs implementation

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 8-10 hours
**Risk**: Medium (sync logic has many edge cases)

### Patterns Identified
**Primary**: `src/app/api/shopify/connection/test/route.ts` - pattern for getting connection, decrypting token, using ShopifyClient
**Secondary**: `src/app/api/shopify/mappings/route.ts` - pattern for listing with pagination, filtering

### Ripple Effect Analysis
**Files Identified**: 6 new files, 1 modified file
- `src/services/shopify-sync.ts` - NEW (core sync logic)
- `src/types/shopify-sync.ts` - NEW (sync types and schemas)
- `src/app/api/shopify/sync/route.ts` - NEW (trigger sync endpoint)
- `src/app/api/shopify/orders/route.ts` - NEW (list orders endpoint)
- `src/app/api/shopify/orders/[id]/route.ts` - NEW (single order endpoint)
- `tests/unit/shopify-sync.test.ts` - NEW (unit tests)
- `src/types/shopify.ts` - MODIFY (may need to add order types if missing)

---

## Executive Summary

Create the core order sync service that fetches orders from Shopify API, stores them idempotently in the database, resolves SKU mappings using SkuChannelMapping, and flags orders with unmapped SKUs for review. This includes a sync trigger endpoint (POST /api/shopify/sync), order listing endpoint (GET /api/shopify/orders), and single order details endpoint (GET /api/shopify/orders/[id]).

---

## Phase 1: Types and Schemas

### Subtask 1.1: Create Shopify Sync Types
**File**: `/home/pbrown/SkuInventory/src/types/shopify-sync.ts`
**Pattern**: Follow `src/types/channel-mapping.ts` for schema definitions
**Instructions**:

1. Create Zod schemas for sync request/response:
```typescript
import { z } from 'zod'

// Sync trigger request schema
export const syncRequestSchema = z.object({
  createdAtMin: z.string().datetime().optional(),
  createdAtMax: z.string().datetime().optional(),
  fullSync: z.boolean().optional().default(false),
})

export type SyncRequestInput = z.infer<typeof syncRequestSchema>

// Order list query schema
export const orderListQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  pageSize: z.coerce.number().int().positive().max(100).default(50),
  status: z.enum(['pending', 'approved', 'posted', 'skipped', 'error']).optional(),
  search: z.string().optional(),
  hasUnmappedLines: z.string().transform(val => val === 'true').optional(),
})

export type OrderListQuery = z.infer<typeof orderListQuerySchema>
```

2. Create response interfaces:
```typescript
export interface SyncResult {
  ordersProcessed: number
  ordersCreated: number
  ordersUpdated: number
  linesProcessed: number
  linesMapped: number
  linesUnmapped: number
  errors: Array<{ orderId: string; error: string }>
  syncDuration: number // milliseconds
}

export interface OrderResponse {
  id: string
  shopifyOrderId: string
  shopifyOrderNumber: string
  orderDate: string
  fulfillmentStatus: string | null
  financialStatus: string | null
  status: 'pending' | 'approved' | 'posted' | 'skipped' | 'error'
  errorMessage: string | null
  syncedAt: string
  processedAt: string | null
  hasUnmappedLines: boolean
  lines: OrderLineResponse[]
}

export interface OrderLineResponse {
  id: string
  shopifyLineId: string
  shopifyVariantId: string | null
  shopifySku: string | null
  title: string
  quantity: number
  price: string
  mappedSkuId: string | null
  mappedSku: { id: string; name: string; internalCode: string } | null
  mappingStatus: 'mapped' | 'unmapped' | 'not_found'
}
```

**Validation commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] syncRequestSchema validates date ranges and fullSync flag
- [ ] orderListQuerySchema validates pagination and filtering
- [ ] Response types match Prisma model fields
- [ ] TypeScript compiles without errors

---

## Phase 2: Sync Service

### Subtask 2.1: Create Shopify Sync Service
**File**: `/home/pbrown/SkuInventory/src/services/shopify-sync.ts`
**Pattern**: Follow `src/services/inventory.ts` for service structure
**Instructions**:

1. Create helper function to get connection with decrypted token:
```typescript
import { prisma } from '@/lib/db'
import { decryptToken } from '@/lib/crypto'
import { ShopifyClient } from '@/services/shopify'
import type { ShopifyOrderResponse, ShopifyLineItem } from '@/types/shopify'
import type { SyncResult } from '@/types/shopify-sync'
import { Prisma, ShopifyOrderStatus } from '@prisma/client'

/**
 * Get an active Shopify connection for a company
 * Returns connection with decrypted access token, or null if not found/inactive
 */
export async function getActiveConnection(companyId: string): Promise<{
  connection: { id: string; shopName: string; companyId: string }
  client: ShopifyClient
} | null> {
  const connection = await prisma.shopifyConnection.findUnique({
    where: { companyId },
    select: {
      id: true,
      shopName: true,
      companyId: true,
      accessToken: true,
      isActive: true,
    },
  })

  if (!connection || !connection.isActive || !connection.accessToken) {
    return null
  }

  try {
    const decryptedToken = decryptToken(connection.accessToken)
    const client = new ShopifyClient(connection.shopName, decryptedToken)
    return {
      connection: {
        id: connection.id,
        shopName: connection.shopName,
        companyId: connection.companyId,
      },
      client,
    }
  } catch {
    return null
  }
}
```

2. Create mapping lookup function:
```typescript
/**
 * Look up internal SKU ID for a Shopify variant ID
 * Returns the mapped SKU ID and status
 */
export async function lookupSkuMapping(
  companyId: string,
  variantId: string | null
): Promise<{ skuId: string | null; status: 'mapped' | 'unmapped' | 'not_found' }> {
  if (!variantId) {
    return { skuId: null, status: 'unmapped' }
  }

  const mapping = await prisma.skuChannelMapping.findUnique({
    where: {
      companyId_channelType_externalId: {
        companyId,
        channelType: 'shopify',
        externalId: variantId,
      },
    },
    select: { skuId: true, isActive: true },
  })

  if (!mapping) {
    return { skuId: null, status: 'not_found' }
  }

  if (!mapping.isActive) {
    return { skuId: null, status: 'not_found' }
  }

  return { skuId: mapping.skuId, status: 'mapped' }
}
```

3. Create main sync function:
```typescript
/**
 * Sync orders from Shopify for a company
 * - Fetches orders within date range
 * - Upserts orders (idempotent by shopifyOrderId)
 * - Maps line items to internal SKUs
 * - Sets order status based on mapping results
 */
export async function syncOrders(params: {
  companyId: string
  createdAtMin?: string
  createdAtMax?: string
  fullSync?: boolean
}): Promise<SyncResult> {
  const { companyId, createdAtMin, createdAtMax, fullSync } = params
  const startTime = Date.now()

  const result: SyncResult = {
    ordersProcessed: 0,
    ordersCreated: 0,
    ordersUpdated: 0,
    linesProcessed: 0,
    linesMapped: 0,
    linesUnmapped: 0,
    errors: [],
    syncDuration: 0,
  }

  // Get active connection
  const activeConnection = await getActiveConnection(companyId)
  if (!activeConnection) {
    throw new Error('No active Shopify connection found')
  }

  const { connection, client } = activeConnection

  // Update sync status to 'syncing'
  await prisma.shopifyConnection.update({
    where: { id: connection.id },
    data: { syncStatus: 'syncing' },
  })

  try {
    // Build fetch params
    const fetchParams: { status: 'any'; created_at_min?: string; created_at_max?: string } = {
      status: 'any',
    }

    if (createdAtMin) fetchParams.created_at_min = createdAtMin
    if (createdAtMax) fetchParams.created_at_max = createdAtMax

    // If not fullSync and no date range, use lastSyncAt
    if (!fullSync && !createdAtMin && !createdAtMax) {
      const conn = await prisma.shopifyConnection.findUnique({
        where: { id: connection.id },
        select: { lastSyncAt: true },
      })
      if (conn?.lastSyncAt) {
        fetchParams.created_at_min = conn.lastSyncAt.toISOString()
      }
    }

    // Fetch orders from Shopify
    const orders = await client.fetchOrders(fetchParams)

    // Process each order
    for (const order of orders) {
      try {
        await processOrder(connection.id, companyId, order, result)
        result.ordersProcessed++
      } catch (error) {
        result.errors.push({
          orderId: String(order.id),
          error: error instanceof Error ? error.message : 'Unknown error',
        })
      }
    }

    // Update connection with sync completion
    await prisma.shopifyConnection.update({
      where: { id: connection.id },
      data: {
        lastSyncAt: new Date(),
        syncStatus: 'idle',
      },
    })
  } catch (error) {
    // Update connection with error status
    await prisma.shopifyConnection.update({
      where: { id: connection.id },
      data: { syncStatus: 'error' },
    })
    throw error
  }

  result.syncDuration = Date.now() - startTime
  return result
}
```

4. Create order processing function:
```typescript
/**
 * Process a single Shopify order
 * - Upserts order record
 * - Processes line items with mapping lookup
 * - Determines order status based on line mappings
 */
async function processOrder(
  connectionId: string,
  companyId: string,
  shopifyOrder: ShopifyOrderResponse,
  result: SyncResult
): Promise<void> {
  const shopifyOrderId = String(shopifyOrder.id)

  // Check if order exists
  const existingOrder = await prisma.shopifyOrder.findUnique({
    where: {
      connectionId_shopifyOrderId: {
        connectionId,
        shopifyOrderId,
      },
    },
    select: { id: true },
  })

  const isUpdate = !!existingOrder

  // Process line items first to determine status
  const lineData: Array<{
    shopifyLineId: string
    shopifyVariantId: string | null
    shopifySku: string | null
    title: string
    quantity: number
    price: Prisma.Decimal
    mappedSkuId: string | null
    mappingStatus: string
  }> = []

  let hasUnmappedLines = false

  for (const lineItem of shopifyOrder.line_items) {
    const variantId = lineItem.variant_id ? String(lineItem.variant_id) : null
    const mapping = await lookupSkuMapping(companyId, variantId)

    if (mapping.status !== 'mapped') {
      hasUnmappedLines = true
      result.linesUnmapped++
    } else {
      result.linesMapped++
    }
    result.linesProcessed++

    lineData.push({
      shopifyLineId: String(lineItem.id),
      shopifyVariantId: variantId,
      shopifySku: lineItem.sku || null,
      title: lineItem.title,
      quantity: lineItem.quantity,
      price: new Prisma.Decimal(lineItem.price),
      mappedSkuId: mapping.skuId,
      mappingStatus: mapping.status,
    })
  }

  // Determine initial order status
  const orderStatus: ShopifyOrderStatus = hasUnmappedLines ? 'pending' : 'pending'

  if (existingOrder) {
    // Update existing order
    await prisma.$transaction(async (tx) => {
      // Delete existing lines
      await tx.shopifyOrderLine.deleteMany({
        where: { orderId: existingOrder.id },
      })

      // Update order
      await tx.shopifyOrder.update({
        where: { id: existingOrder.id },
        data: {
          shopifyOrderNumber: shopifyOrder.name,
          orderDate: new Date(shopifyOrder.created_at),
          fulfillmentStatus: shopifyOrder.fulfillment_status || null,
          financialStatus: shopifyOrder.financial_status,
          rawData: shopifyOrder as unknown as Prisma.JsonObject,
          syncedAt: new Date(),
          // Only update status if still pending
          ...(hasUnmappedLines ? {} : {}),
        },
      })

      // Create new lines
      await tx.shopifyOrderLine.createMany({
        data: lineData.map((line) => ({
          orderId: existingOrder.id,
          ...line,
        })),
      })
    })
    result.ordersUpdated++
  } else {
    // Create new order
    await prisma.shopifyOrder.create({
      data: {
        connectionId,
        shopifyOrderId,
        shopifyOrderNumber: shopifyOrder.name,
        orderDate: new Date(shopifyOrder.created_at),
        fulfillmentStatus: shopifyOrder.fulfillment_status || null,
        financialStatus: shopifyOrder.financial_status,
        status: orderStatus,
        rawData: shopifyOrder as unknown as Prisma.JsonObject,
        syncedAt: new Date(),
        lines: {
          createMany: {
            data: lineData,
          },
        },
      },
    })
    result.ordersCreated++
  }
}
```

**Validation commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] getActiveConnection retrieves and decrypts token
- [ ] lookupSkuMapping finds mappings by variant_id
- [ ] syncOrders handles pagination via ShopifyClient
- [ ] processOrder is idempotent (upsert behavior)
- [ ] Line item mapping status correctly set
- [ ] Connection syncStatus updated (syncing -> idle/error)
- [ ] TypeScript compiles without errors

---

## Phase 3: Sync API Endpoint

### Subtask 3.1: Create Sync Trigger Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/shopify/sync/route.ts`
**Pattern**: Follow `src/app/api/shopify/connection/test/route.ts`
**Instructions**:

1. Create POST handler for sync trigger (admin only):
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { syncOrders } from '@/services/shopify-sync'
import { syncRequestSchema } from '@/types/shopify-sync'

// POST /api/shopify/sync - Trigger order sync (admin only)
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const body = await request.json()
    const validation = syncRequestSchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    const { createdAtMin, createdAtMax, fullSync } = validation.data

    try {
      const result = await syncOrders({
        companyId: session.user.selectedCompanyId,
        createdAtMin,
        createdAtMax,
        fullSync,
      })

      return NextResponse.json({
        data: result,
        message: `Sync completed: ${result.ordersProcessed} orders processed`,
      })
    } catch (error) {
      console.error('Sync error:', error)

      if (error instanceof Error && error.message.includes('No active Shopify connection')) {
        return NextResponse.json(
          { error: 'No active Shopify connection configured' },
          { status: 400 }
        )
      }

      return NextResponse.json(
        { error: 'Sync failed', details: error instanceof Error ? error.message : 'Unknown error' },
        { status: 500 }
      )
    }
  } catch (error) {
    console.error('Error in sync endpoint:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```

**Validation commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] POST endpoint requires admin role
- [ ] Validates sync request parameters
- [ ] Returns SyncResult on success
- [ ] Handles no-connection error gracefully
- [ ] Build completes without errors

---

## Phase 4: Orders API Endpoints

### Subtask 4.1: Create Orders List Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/shopify/orders/route.ts`
**Pattern**: Follow `src/app/api/shopify/mappings/route.ts`
**Instructions**:

1. Create GET handler for listing synced orders:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'
import { orderListQuerySchema } from '@/types/shopify-sync'

// GET /api/shopify/orders - List synced orders (admin and ops)
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Viewer role cannot access orders
    if (session.user.role === 'viewer') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const searchParams = Object.fromEntries(request.nextUrl.searchParams)
    const validation = orderListQuerySchema.safeParse(searchParams)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Invalid query parameters', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    const { page, pageSize, status, search, hasUnmappedLines } = validation.data
    const selectedCompanyId = session.user.selectedCompanyId

    // Get connection for this company
    const connection = await prisma.shopifyConnection.findUnique({
      where: { companyId: selectedCompanyId },
      select: { id: true },
    })

    if (!connection) {
      return NextResponse.json({
        data: [],
        meta: { page, pageSize, total: 0, totalPages: 0 },
      })
    }

    // Build where clause
    const where: Prisma.ShopifyOrderWhereInput = {
      connectionId: connection.id,
    }

    if (status) {
      where.status = status
    }

    if (search) {
      where.OR = [
        { shopifyOrderNumber: { contains: search, mode: 'insensitive' } },
        { shopifyOrderId: { contains: search } },
      ]
    }

    // Handle hasUnmappedLines filter
    if (hasUnmappedLines !== undefined) {
      if (hasUnmappedLines) {
        where.lines = {
          some: {
            mappingStatus: { in: ['unmapped', 'not_found'] },
          },
        }
      } else {
        where.lines = {
          every: {
            mappingStatus: 'mapped',
          },
        }
      }
    }

    // Get total count
    const total = await prisma.shopifyOrder.count({ where })

    // Get orders with lines
    const orders = await prisma.shopifyOrder.findMany({
      where,
      select: {
        id: true,
        shopifyOrderId: true,
        shopifyOrderNumber: true,
        orderDate: true,
        fulfillmentStatus: true,
        financialStatus: true,
        status: true,
        errorMessage: true,
        syncedAt: true,
        processedAt: true,
        lines: {
          select: {
            id: true,
            shopifyLineId: true,
            shopifyVariantId: true,
            shopifySku: true,
            title: true,
            quantity: true,
            price: true,
            mappedSkuId: true,
            mappingStatus: true,
          },
        },
      },
      orderBy: { orderDate: 'desc' },
      skip: (page - 1) * pageSize,
      take: pageSize,
    })

    // Transform response
    const data = orders.map((order) => ({
      ...order,
      orderDate: order.orderDate.toISOString(),
      syncedAt: order.syncedAt.toISOString(),
      processedAt: order.processedAt?.toISOString() || null,
      hasUnmappedLines: order.lines.some(
        (l) => l.mappingStatus === 'unmapped' || l.mappingStatus === 'not_found'
      ),
      lines: order.lines.map((line) => ({
        ...line,
        price: line.price.toString(),
      })),
    }))

    return NextResponse.json({
      data,
      meta: {
        page,
        pageSize,
        total,
        totalPages: Math.ceil(total / pageSize),
      },
    })
  } catch (error) {
    console.error('Error listing orders:', error)
    return NextResponse.json({ error: 'Failed to list orders' }, { status: 500 })
  }
}
```

**Validation commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] GET endpoint allows admin and ops roles
- [ ] Pagination works correctly
- [ ] Status filter works
- [ ] Search by order number works
- [ ] hasUnmappedLines filter works
- [ ] Response includes lines with mapping status

### Subtask 4.2: Create Single Order Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/shopify/orders/[id]/route.ts`
**Pattern**: Follow `src/app/api/shopify/mappings/[id]/route.ts`
**Instructions**:

1. Create GET handler for single order details:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'

// GET /api/shopify/orders/[id] - Get order details (admin and ops)
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Viewer role cannot access orders
    if (session.user.role === 'viewer') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id } = await params
    const selectedCompanyId = session.user.selectedCompanyId

    // Get connection for this company
    const connection = await prisma.shopifyConnection.findUnique({
      where: { companyId: selectedCompanyId },
      select: { id: true },
    })

    if (!connection) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 })
    }

    // Get order with lines and mapped SKU details
    const order = await prisma.shopifyOrder.findFirst({
      where: {
        id,
        connectionId: connection.id,
      },
      select: {
        id: true,
        shopifyOrderId: true,
        shopifyOrderNumber: true,
        orderDate: true,
        fulfillmentStatus: true,
        financialStatus: true,
        status: true,
        errorMessage: true,
        rawData: true,
        syncedAt: true,
        processedAt: true,
        transactionId: true,
        lines: {
          select: {
            id: true,
            shopifyLineId: true,
            shopifyVariantId: true,
            shopifySku: true,
            title: true,
            quantity: true,
            price: true,
            mappedSkuId: true,
            mappingStatus: true,
          },
        },
      },
    })

    if (!order) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 })
    }

    // Fetch mapped SKU details for lines that have mappings
    const mappedSkuIds = order.lines
      .map((l) => l.mappedSkuId)
      .filter((id): id is string => id !== null)

    const skus = mappedSkuIds.length > 0
      ? await prisma.sKU.findMany({
          where: { id: { in: mappedSkuIds } },
          select: { id: true, name: true, internalCode: true },
        })
      : []

    const skuMap = new Map(skus.map((s) => [s.id, s]))

    // Transform response
    const data = {
      ...order,
      orderDate: order.orderDate.toISOString(),
      syncedAt: order.syncedAt.toISOString(),
      processedAt: order.processedAt?.toISOString() || null,
      hasUnmappedLines: order.lines.some(
        (l) => l.mappingStatus === 'unmapped' || l.mappingStatus === 'not_found'
      ),
      lines: order.lines.map((line) => ({
        ...line,
        price: line.price.toString(),
        mappedSku: line.mappedSkuId ? skuMap.get(line.mappedSkuId) || null : null,
      })),
    }

    return NextResponse.json({ data })
  } catch (error) {
    console.error('Error fetching order:', error)
    return NextResponse.json({ error: 'Failed to fetch order' }, { status: 500 })
  }
}
```

2. Create PATCH handler for updating order status:
```typescript
import { z } from 'zod'

const updateOrderStatusSchema = z.object({
  status: z.enum(['pending', 'approved', 'skipped']),
})

// PATCH /api/shopify/orders/[id] - Update order status (admin only)
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id } = await params
    const body = await request.json()
    const validation = updateOrderStatusSchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    const selectedCompanyId = session.user.selectedCompanyId

    // Get connection for this company
    const connection = await prisma.shopifyConnection.findUnique({
      where: { companyId: selectedCompanyId },
      select: { id: true },
    })

    if (!connection) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 })
    }

    // Check if order exists and belongs to this connection
    const existingOrder = await prisma.shopifyOrder.findFirst({
      where: {
        id,
        connectionId: connection.id,
      },
    })

    if (!existingOrder) {
      return NextResponse.json({ error: 'Order not found' }, { status: 404 })
    }

    // Update order status
    const updatedOrder = await prisma.shopifyOrder.update({
      where: { id },
      data: { status: validation.data.status },
      select: {
        id: true,
        status: true,
      },
    })

    return NextResponse.json({
      data: updatedOrder,
      message: 'Order status updated',
    })
  } catch (error) {
    console.error('Error updating order:', error)
    return NextResponse.json({ error: 'Failed to update order' }, { status: 500 })
  }
}
```

**Validation commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] GET returns order with all line details
- [ ] Lines include mapped SKU information
- [ ] PATCH allows status updates (admin only)
- [ ] Both endpoints scope by company connection
- [ ] Build completes without errors

---

## Phase 5: Unit Tests

### Subtask 5.1: Create Shopify Sync Service Tests
**File**: `/home/pbrown/SkuInventory/tests/unit/shopify-sync.test.ts`
**Pattern**: Follow `tests/unit/shopify-client.test.ts`
**Instructions**:

1. Create tests for sync service functions:
```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { lookupSkuMapping } from '@/services/shopify-sync'

// Mock prisma
vi.mock('@/lib/db', () => ({
  prisma: {
    skuChannelMapping: {
      findUnique: vi.fn(),
    },
    shopifyConnection: {
      findUnique: vi.fn(),
      update: vi.fn(),
    },
    shopifyOrder: {
      findUnique: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
    },
    shopifyOrderLine: {
      deleteMany: vi.fn(),
      createMany: vi.fn(),
    },
    $transaction: vi.fn((fn) => fn({
      shopifyOrder: { update: vi.fn() },
      shopifyOrderLine: { deleteMany: vi.fn(), createMany: vi.fn() },
    })),
  },
}))

describe('lookupSkuMapping', () => {
  it('returns unmapped for null variantId', async () => {
    const result = await lookupSkuMapping('company-1', null)
    expect(result).toEqual({ skuId: null, status: 'unmapped' })
  })

  // Add more test cases for:
  // - Found mapping returns mapped status
  // - Inactive mapping returns not_found
  // - Missing mapping returns not_found
})

// Additional test suites for:
// - getActiveConnection
// - syncOrders (with mocked ShopifyClient)
// - processOrder
```

**Validation commands**:
```bash
npm test -- --filter="shopify-sync"
```

**Completion Criteria**:
- [ ] lookupSkuMapping tests cover all status cases
- [ ] Tests mock Prisma correctly
- [ ] All tests pass

---

## Phase 6: Final Validation

### Subtask 6.1: Run Full Build and Tests
**Instructions**:

1. Run TypeScript check:
```bash
npx tsc --noEmit
```

2. Run linter:
```bash
npm run lint
```

3. Run build:
```bash
npm run build
```

4. Run all tests:
```bash
npm test
```

**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Linter passes
- [ ] Build completes successfully
- [ ] All tests pass

---

## Summary of Deliverables

**Files Created**: 5
- `src/types/shopify-sync.ts` - Sync types and Zod schemas
- `src/services/shopify-sync.ts` - Core sync service logic
- `src/app/api/shopify/sync/route.ts` - POST trigger endpoint
- `src/app/api/shopify/orders/route.ts` - GET list endpoint
- `src/app/api/shopify/orders/[id]/route.ts` - GET/PATCH single order

**Files Modified**: 0

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 6)
2. Complete each phase fully before starting next
3. Test completion criteria before moving to next subtask
4. Follow reference patterns from existing Shopify routes exactly
5. Ensure all validation commands pass before moving on

---

## Test Strategy Note

- Use Vitest for unit tests
- Mock Prisma client for service tests
- Mock ShopifyClient for sync tests
- Integration tests can be added later with test database

---

## API Endpoints Summary

| Method | Endpoint | Role | Description |
|--------|----------|------|-------------|
| POST | /api/shopify/sync | admin | Trigger order sync |
| GET | /api/shopify/orders | admin, ops | List synced orders |
| GET | /api/shopify/orders/[id] | admin, ops | Get order details |
| PATCH | /api/shopify/orders/[id] | admin | Update order status |

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 10m |
| **Total** | **30m** |
