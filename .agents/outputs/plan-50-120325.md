# Implementation Plan
**Generated**: 2025-12-03T18:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: Issue #50 - Defect Rate Alerts and Thresholds
**Estimated Build Time**: 10-12 hours
**Complexity**: High

## Investigation Summary

### Request Analysis
**Type**: Feature (Enhancement)
**Source**: GitHub Issue #50
**Priority**: Medium

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--testPathPattern="alert|threshold|defect"` or None (no tests exist yet)

### Issue Validation
**Status**: Valid
**Recent Changes**: Issue #46 (Defect Analytics Dashboard) completed on 2025-12-03, providing data foundation

### Current State Assessment

**Existing Components (from Issue #46)**:
- `/home/pbrown/SkuInventory/src/services/analytics.ts` - Defect analytics service with `getDefectAnalytics()`, `calculateSummary()`, `calculateBySKU()`, `calculateByBOMVersion()`
- `/home/pbrown/SkuInventory/src/app/api/analytics/defects/route.ts` - API endpoint for defect analytics
- `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsDashboard.tsx` - Main dashboard component
- `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsSummary.tsx` - Summary stats display
- `/home/pbrown/SkuInventory/src/types/analytics.ts` - Types for defect analytics

**Database Models**:
- `Transaction` model has `defectCount`, `defectNotes`, `affectedUnits` fields
- `BOMVersion` model has `qualityMetadata` JSON field (currently unused, could store thresholds)
- `Company` model has `settings` JSON field (used for company-wide settings)

**Issue #11 (Low-stock alerts) Status**: OPEN - NO notification infrastructure exists
- No email/Slack integration implemented
- No alert tables or services exist
- Must build notification system from scratch

**API Routes Involved**:
- `/api/transactions/build` - Where alert evaluation should hook in
- `/api/analytics/defects` - Existing defect data endpoint
- New: `/api/alerts/defects` - For alert management

### Dependencies & Blockers

1. **No notification infrastructure** - Issue #11 is still open, no email/Slack services exist
2. **Decision needed**: In-app notifications only (MVP) vs full notification system
3. **Threshold storage**: Can use existing `qualityMetadata` on BOMVersion or new settings

**Can Proceed?**: YES (with in-app alerts as MVP; email/Slack deferred to Issue #11)

### Complexity Assessment
**Complexity**: High
**Effort**: 10-12 hours
**Risk**: Medium (new feature, multiple database changes, UI additions)

### Patterns Identified

**Primary**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
- `calculateReorderStatus()` pattern for threshold evaluation
- `checkInsufficientInventory()` pattern for returning structured violation data

**Secondary**: `/home/pbrown/SkuInventory/src/types/settings.ts`
- `companySettingsSchema` pattern for company-wide threshold defaults

**UI Pattern**: `/home/pbrown/SkuInventory/src/components/features/CriticalComponentsList.tsx`
- Display pattern for alerts with status badges and action hints

### Ripple Effect Analysis

**Files Identified**: 12+ files affected

**New Files to Create**:
- `src/types/alert.ts` - Alert types and schemas
- `src/services/alert.ts` - Alert evaluation and CRUD service
- `src/app/api/alerts/defects/route.ts` - Alert API endpoints
- `src/app/api/alerts/defects/[id]/route.ts` - Alert detail/acknowledge endpoint
- `src/components/features/DefectAlertsList.tsx` - Alert display component
- `src/components/features/DefectThresholdConfig.tsx` - Threshold configuration UI
- `prisma/migrations/YYYYMMDDHHMMSS_add_defect_alerts/migration.sql` - Schema changes

**Files to Modify**:
- `prisma/schema.prisma` - Add DefectThreshold and DefectAlert models
- `src/types/settings.ts` - Add global defect threshold defaults
- `src/services/inventory.ts` - Hook alert evaluation into `createBuildTransaction()`
- `src/components/features/DefectAnalyticsDashboard.tsx` - Add alerts section
- `src/app/(dashboard)/layout.tsx` - Add alert indicator to navigation (optional)

---

## Executive Summary

This feature adds configurable defect rate thresholds with automatic alert generation when builds exceed thresholds. The implementation creates new database models for thresholds (per-SKU and global) and alert history, a service for evaluating defect rates against thresholds on each build transaction, and UI components for configuration and alert display integrated into the existing analytics dashboard. Email/Slack notifications are deferred to Issue #11; this implementation provides in-app alerts only.

---

## Phase 0: Database Schema Design

### Subtask 0.1: Add DefectThreshold Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing model structure (Company, BOMVersion)
**Instructions**:
1. Add `DefectThreshold` model after BOMLine model:
```prisma
model DefectThreshold {
  id               String   @id @default(uuid())
  companyId        String
  company          Company  @relation(fields: [companyId], references: [id])
  skuId            String?  // null = global threshold for company
  sku              SKU?     @relation(fields: [skuId], references: [id])
  defectRateLimit  Decimal  @db.Decimal(5, 2)  // e.g., 5.00 = 5%
  affectedRateLimit Decimal? @db.Decimal(5, 2) // optional secondary threshold
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  createdById      String
  createdBy        User     @relation("ThresholdCreatedBy", fields: [createdById], references: [id])

  alerts           DefectAlert[]

  @@unique([companyId, skuId])  // One threshold per SKU per company, or one global
  @@index([companyId, isActive])
}
```

2. Add `DefectAlert` model for alert history:
```prisma
model DefectAlert {
  id               String    @id @default(uuid())
  thresholdId      String
  threshold        DefectThreshold @relation(fields: [thresholdId], references: [id])
  transactionId    String
  transaction      Transaction @relation(fields: [transactionId], references: [id])
  skuId            String
  sku              SKU       @relation(fields: [skuId], references: [id])
  defectRate       Decimal   @db.Decimal(5, 2)
  thresholdValue   Decimal   @db.Decimal(5, 2)
  severity         String    @db.VarChar(20)  // 'warning' | 'critical'
  acknowledgedAt   DateTime?
  acknowledgedById String?
  acknowledgedBy   User?     @relation("AlertAcknowledgedBy", fields: [acknowledgedById], references: [id])
  createdAt        DateTime  @default(now())

  @@index([thresholdId, createdAt(sort: Desc)])
  @@index([skuId, createdAt(sort: Desc)])
  @@index([acknowledgedAt])
}
```

3. Update related models with reverse relations:
   - Add `defectThresholds DefectThreshold[]` to Company
   - Add `defectThreshold DefectThreshold?` and `defectAlerts DefectAlert[]` to SKU
   - Add `defectAlerts DefectAlert[]` to Transaction
   - Add `thresholdsCreated DefectThreshold[] @relation("ThresholdCreatedBy")` to User
   - Add `alertsAcknowledged DefectAlert[] @relation("AlertAcknowledgedBy")` to User

**Validation**:
```bash
npx prisma format
npx prisma validate
```
**Completion Criteria**:
- [ ] Schema validates without errors
- [ ] DefectThreshold model has all fields
- [ ] DefectAlert model has all fields
- [ ] All reverse relations added

### Subtask 0.2: Generate and Run Migration
**File**: `/home/pbrown/SkuInventory/prisma/migrations/`
**Instructions**:
1. Generate migration:
```bash
npx prisma migrate dev --name add_defect_alerts
```
2. Verify migration SQL is correct
3. Generate Prisma client:
```bash
npx prisma generate
```

**Completion Criteria**:
- [ ] Migration runs successfully
- [ ] No errors in generated SQL
- [ ] Prisma client regenerated

---

## Phase 1: Types Layer

### Subtask 1.1: Create Alert Types
**File**: `/home/pbrown/SkuInventory/src/types/alert.ts` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/types/analytics.ts`
**Instructions**:
1. Create new file with:
```typescript
import { z } from 'zod'

// Threshold configuration schema
export const defectThresholdSchema = z.object({
  skuId: z.string().uuid().optional().nullable(), // null = global
  defectRateLimit: z.coerce.number().min(0).max(100),
  affectedRateLimit: z.coerce.number().min(0).max(100).optional().nullable(),
  isActive: z.boolean().default(true),
})

export const createThresholdSchema = defectThresholdSchema
export const updateThresholdSchema = defectThresholdSchema.partial()

export type CreateThresholdInput = z.infer<typeof createThresholdSchema>
export type UpdateThresholdInput = z.infer<typeof updateThresholdSchema>

// Alert severity
export type AlertSeverity = 'warning' | 'critical'

// Threshold response
export interface DefectThresholdResponse {
  id: string
  companyId: string
  skuId: string | null
  skuName: string | null
  skuCode: string | null
  defectRateLimit: number
  affectedRateLimit: number | null
  isActive: boolean
  createdAt: string
  updatedAt: string
  createdBy: { id: string; name: string }
}

// Alert response
export interface DefectAlertResponse {
  id: string
  thresholdId: string
  transactionId: string
  skuId: string
  skuName: string
  skuCode: string
  defectRate: number
  thresholdValue: number
  severity: AlertSeverity
  acknowledgedAt: string | null
  acknowledgedBy: { id: string; name: string } | null
  createdAt: string
  transaction: {
    id: string
    date: string
    unitsBuild: number
    defectCount: number
  }
}

// Alert query schema
export const alertQuerySchema = z.object({
  skuId: z.string().uuid().optional(),
  acknowledged: z.enum(['true', 'false', 'all']).default('all'),
  severity: z.enum(['warning', 'critical', 'all']).default('all'),
  limit: z.coerce.number().int().positive().max(100).default(50),
})

export type AlertQuery = z.infer<typeof alertQuerySchema>

// Acknowledge schema
export const acknowledgeAlertSchema = z.object({
  alertIds: z.array(z.string().uuid()).min(1),
})

export type AcknowledgeAlertInput = z.infer<typeof acknowledgeAlertSchema>
```

**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Types compile without errors
- [ ] All schemas defined with proper validation
- [ ] Response types match Prisma models

### Subtask 1.2: Update Settings Types with Global Threshold Defaults
**File**: `/home/pbrown/SkuInventory/src/types/settings.ts`
**Pattern**: Follow existing `companySettingsSchema` structure
**Instructions**:
1. Add new fields to `companySettingsSchema`:
```typescript
// Add after reorderWarningMultiplier:
defectRateWarningThreshold: z.coerce.number().min(0).max(100).default(5),
defectRateCriticalThreshold: z.coerce.number().min(0).max(100).default(10),
enableDefectAlerts: z.boolean().default(true),
```

2. Update `DEFAULT_SETTINGS`:
```typescript
defectRateWarningThreshold: 5,
defectRateCriticalThreshold: 10,
enableDefectAlerts: true,
```

**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Settings schema updated
- [ ] Default values added
- [ ] No type errors

---

## Phase 2: Service Layer

### Subtask 2.1: Create Alert Service
**File**: `/home/pbrown/SkuInventory/src/services/alert.ts` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/analytics.ts`
**Instructions**:
1. Create new file with functions:
   - `evaluateDefectThreshold(transactionId, skuId, defectRate, companyId)` - Check if threshold exceeded
   - `createDefectAlert(params)` - Create alert record
   - `getDefectThresholds(companyId)` - List thresholds
   - `getDefectAlerts(companyId, query)` - List alerts with filters
   - `acknowledgeAlerts(alertIds, userId)` - Acknowledge alerts
   - `createThreshold(companyId, input, userId)` - Create new threshold
   - `updateThreshold(thresholdId, input, userId)` - Update threshold
   - `deleteThreshold(thresholdId)` - Delete threshold

2. Implement `evaluateDefectThreshold`:
```typescript
export async function evaluateDefectThreshold(params: {
  transactionId: string
  skuId: string
  defectRate: number
  companyId: string
  unitsBuild: number
  defectCount: number
}): Promise<DefectAlert | null> {
  const { transactionId, skuId, defectRate, companyId } = params

  // Get applicable threshold (SKU-specific first, then global)
  const threshold = await prisma.defectThreshold.findFirst({
    where: {
      companyId,
      isActive: true,
      OR: [
        { skuId },
        { skuId: null }  // Global fallback
      ]
    },
    orderBy: { skuId: 'desc' }  // SKU-specific first (not null before null)
  })

  if (!threshold) return null

  const thresholdValue = threshold.defectRateLimit.toNumber()
  if (defectRate <= thresholdValue) return null

  // Determine severity
  const settings = await getCompanySettings(companyId)
  const severity = defectRate >= settings.defectRateCriticalThreshold ? 'critical' : 'warning'

  // Create alert
  return prisma.defectAlert.create({
    data: {
      thresholdId: threshold.id,
      transactionId,
      skuId,
      defectRate: new Prisma.Decimal(defectRate),
      thresholdValue: threshold.defectRateLimit,
      severity,
    }
  })
}
```

**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] All service functions implemented
- [ ] Proper Prisma queries
- [ ] Error handling included
- [ ] Types match

### Subtask 2.2: Hook Alert Evaluation into Build Transactions
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: After line 541 in `createBuildTransaction()`, before final return
**Instructions**:
1. Import alert service at top:
```typescript
import { evaluateDefectThreshold } from './alert'
```

2. Add alert evaluation after transaction creation (around line 540):
```typescript
// After: const transaction = await prisma.transaction.create(...)

// Evaluate defect threshold if defects were recorded
if (defectCount && defectCount > 0 && unitsToBuild > 0) {
  const defectRate = (defectCount / unitsToBuild) * 100
  try {
    await evaluateDefectThreshold({
      transactionId: transaction.id,
      skuId,
      defectRate,
      companyId,
      unitsBuild: unitsToBuild,
      defectCount,
    })
  } catch (error) {
    // Log but don't fail the build transaction
    console.error('Error evaluating defect threshold:', error)
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Import added
- [ ] Alert evaluation called after build
- [ ] Error handling prevents build failure
- [ ] Build passes

---

## Phase 3: API Routes

### Subtask 3.1: Create Defect Alerts API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/alerts/defects/route.ts` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/analytics/defects/route.ts`
**Instructions**:
1. Create directory and file
2. Implement GET (list alerts) and POST (create threshold):
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { success, unauthorized, serverError, parseQuery, parseBody, created } from '@/lib/api-response'
import { alertQuerySchema, createThresholdSchema } from '@/types/alert'
import { getDefectAlerts, getDefectThresholds, createThreshold } from '@/services/alert'

// GET /api/alerts/defects - Get alerts and/or thresholds
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) return unauthorized()

    const { searchParams } = new URL(request.url)

    // Check if requesting thresholds
    if (searchParams.get('thresholds') === 'true') {
      const thresholds = await getDefectThresholds(session.user.companyId)
      return success({ thresholds })
    }

    // Otherwise return alerts
    const queryResult = parseQuery(searchParams, alertQuerySchema)
    if (queryResult.error) return queryResult.error

    const alerts = await getDefectAlerts(session.user.companyId, queryResult.data)
    return success({ alerts })
  } catch (error) {
    console.error('Error fetching defect alerts:', error)
    return serverError()
  }
}

// POST /api/alerts/defects - Create threshold (admin only)
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) return unauthorized()
    if (session.user.role !== 'admin') {
      return unauthorized('Admin access required')
    }

    const bodyResult = await parseBody(request, createThresholdSchema)
    if (bodyResult.error) return bodyResult.error

    const threshold = await createThreshold(
      session.user.companyId,
      bodyResult.data,
      session.user.id
    )
    return created({ threshold })
  } catch (error) {
    console.error('Error creating threshold:', error)
    return serverError()
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] GET returns alerts and thresholds
- [ ] POST creates threshold (admin only)
- [ ] Proper auth checks
- [ ] Error handling

### Subtask 3.2: Create Alert Acknowledge/Detail Route
**File**: `/home/pbrown/SkuInventory/src/app/api/alerts/defects/[id]/route.ts` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/transactions/[id]/route.ts`
**Instructions**:
1. Create directory and file
2. Implement GET (single alert), PATCH (acknowledge), DELETE (threshold):
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { success, unauthorized, notFound, serverError } from '@/lib/api-response'
import { acknowledgeAlerts, getAlertById, updateThreshold, deleteThreshold } from '@/services/alert'

// PATCH /api/alerts/defects/[id] - Acknowledge alert or update threshold
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) return unauthorized()
    if (session.user.role === 'viewer') {
      return unauthorized('Insufficient permissions')
    }

    const body = await request.json()

    // Check if acknowledging alert or updating threshold
    if (body.acknowledge) {
      await acknowledgeAlerts([params.id], session.user.id)
      return success({ message: 'Alert acknowledged' })
    }

    // Otherwise update threshold (admin only)
    if (session.user.role !== 'admin') {
      return unauthorized('Admin access required')
    }

    const threshold = await updateThreshold(params.id, body, session.user.id)
    return success({ threshold })
  } catch (error) {
    console.error('Error updating alert/threshold:', error)
    return serverError()
  }
}

// DELETE /api/alerts/defects/[id] - Delete threshold (admin only)
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) return unauthorized()
    if (session.user.role !== 'admin') {
      return unauthorized('Admin access required')
    }

    await deleteThreshold(params.id)
    return success({ message: 'Threshold deleted' })
  } catch (error) {
    console.error('Error deleting threshold:', error)
    return serverError()
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] PATCH handles acknowledge and update
- [ ] DELETE removes threshold
- [ ] Proper role checks
- [ ] Build passes

---

## Phase 4: Frontend Components

### Subtask 4.1: Create Defect Alerts List Component
**File**: `/home/pbrown/SkuInventory/src/components/features/DefectAlertsList.tsx` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/components/features/CriticalComponentsList.tsx`
**Instructions**:
1. Create component displaying active alerts:
   - Show alert list with severity badges (warning/critical)
   - Display SKU name, defect rate, threshold, date
   - Include "Acknowledge" button
   - Link to transaction detail
   - Empty state when no alerts

2. Key props:
```typescript
interface DefectAlertsListProps {
  alerts: DefectAlertResponse[]
  onAcknowledge: (alertId: string) => Promise<void>
  isLoading: boolean
}
```

3. Use shadcn/ui components: Card, Table, Badge, Button

**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Component renders alert list
- [ ] Severity badges with appropriate colors
- [ ] Acknowledge action works
- [ ] Responsive layout

### Subtask 4.2: Create Defect Threshold Configuration Component
**File**: `/home/pbrown/SkuInventory/src/components/features/DefectThresholdConfig.tsx` (NEW FILE)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/components/features/SettingsForm.tsx`
**Instructions**:
1. Create component for threshold configuration:
   - List existing thresholds (global and per-SKU)
   - Form to create new threshold
   - Edit/delete existing thresholds
   - SKU selector for per-SKU thresholds

2. Key features:
   - Admin only (check role before rendering)
   - Validation for threshold values (0-100%)
   - Toggle for active/inactive

**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] List thresholds with CRUD
- [ ] Form validation works
- [ ] Admin-only access
- [ ] Proper error handling

### Subtask 4.3: Integrate Alerts Section into Analytics Dashboard
**File**: `/home/pbrown/SkuInventory/src/components/features/DefectAnalyticsDashboard.tsx`
**Pattern**: Follow existing dashboard sections
**Instructions**:
1. Add state for alerts:
```typescript
const [alerts, setAlerts] = useState<DefectAlertResponse[]>([])
const [thresholds, setThresholds] = useState<DefectThresholdResponse[]>([])
const [showAlerts, setShowAlerts] = useState(true)
```

2. Fetch alerts on load:
```typescript
const fetchAlerts = useCallback(async () => {
  const res = await fetch('/api/alerts/defects?acknowledged=false&limit=10')
  if (res.ok) {
    const data = await res.json()
    setAlerts(data.data.alerts)
  }
}, [])
```

3. Add alerts section after header, before filters:
```tsx
{/* Active Alerts Section */}
{alerts.length > 0 && (
  <DefectAlertsList
    alerts={alerts}
    onAcknowledge={handleAcknowledge}
    isLoading={isLoading}
  />
)}
```

4. Add threshold config tab/section for admins

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Alerts display in dashboard
- [ ] Acknowledge updates list
- [ ] Admin sees config option
- [ ] Build passes

---

## Phase 5: Update Settings UI

### Subtask 5.1: Add Default Threshold Settings to Settings Form
**File**: `/home/pbrown/SkuInventory/src/components/features/SettingsForm.tsx`
**Instructions**:
1. Add new form fields for:
   - `enableDefectAlerts` (checkbox)
   - `defectRateWarningThreshold` (number input, %)
   - `defectRateCriticalThreshold` (number input, %)

2. Add new section "Quality Alerts" after existing settings

3. Validation: warning < critical, both 0-100

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] New fields render
- [ ] Validation works
- [ ] Settings save correctly
- [ ] Build passes

---

## Phase 6: Testing and Validation

### Subtask 6.1: Manual End-to-End Testing
**Instructions**:
1. Create a threshold (global or per-SKU)
2. Create a build transaction with defects exceeding threshold
3. Verify alert appears in dashboard
4. Acknowledge the alert
5. Verify alert moves to acknowledged state
6. Test threshold CRUD (create, update, delete)
7. Test role-based access (admin vs ops vs viewer)

**Completion Criteria**:
- [ ] Alert triggers on threshold breach
- [ ] Alert displays correctly
- [ ] Acknowledge works
- [ ] Admin-only features protected
- [ ] No console errors

### Subtask 6.2: Build and Lint Verification
**Instructions**:
```bash
npm run build
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Build passes without errors
- [ ] No TypeScript errors
- [ ] No lint warnings

---

## Summary of Deliverables

**Files Created**: 8
- `prisma/migrations/YYYYMMDDHHMMSS_add_defect_alerts/migration.sql`
- `src/types/alert.ts`
- `src/services/alert.ts`
- `src/app/api/alerts/defects/route.ts`
- `src/app/api/alerts/defects/[id]/route.ts`
- `src/components/features/DefectAlertsList.tsx`
- `src/components/features/DefectThresholdConfig.tsx`
- (migration auto-generated)

**Files Modified**: 5
- `prisma/schema.prisma`
- `src/types/settings.ts`
- `src/services/inventory.ts`
- `src/components/features/DefectAnalyticsDashboard.tsx`
- `src/components/features/SettingsForm.tsx`

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6)
2. Complete Phase 0 (database) fully before Phase 1
3. Run validation commands after each subtask
4. Follow reference patterns exactly
5. Test completion criteria before proceeding

## Test Strategy Note
- Vitest for unit tests (if time permits)
- Manual E2E testing required (Phase 6)
- No Playwright tests specified (focus on core functionality)

## Deferred Items (Issue #11)
- Email notifications
- Slack webhook integration
- Notification preferences per user
- Alert digest/throttling

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 20m |
| **Total** | **55m** |
