# Implementation Plan
**Generated**: 2025-12-04T09:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: Issue #92 - Add company management admin page (CRUD)
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #92 (Parent Issue #24)
**Priority**: High - Foundation for multi-tenant company administration

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED - Affected modules
**Suggested Filter**: None - Manual testing of CRUD operations recommended

### Issue Validation
**Status**: Valid
**Recent Changes**: Multi-company infrastructure added in recent commits (Issue #77, #82, #87, #96)

### Current State Assessment
- **Existing components**:
  - Company model exists in Prisma schema (lines 13-36)
  - User management pages exist as reference pattern (`/settings/users/*`)
  - Location management pages exist as secondary reference (`/settings/locations/*`)
  - Company switch API route exists at `/api/companies/switch/route.ts`
- **Database**: Company model fully defined with all relations
- **API Routes**: Only `/api/companies/switch` exists - main CRUD routes needed
- **Types**: No `src/types/company.ts` exists - needs to be created

### Dependencies & Blockers
1. Company model exists in schema - **READY**
2. User management patterns exist - **READY**
3. No blocking dependencies

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 6-8 hours
**Risk**: Low - Following established patterns

### Patterns Identified
**Primary**:
- User management: `src/app/(dashboard)/settings/users/page.tsx` (line 1-133)
- UserTable: `src/components/features/UserTable.tsx` (line 1-212)
- UserForm: `src/components/features/UserForm.tsx` (line 1-206)
- User API: `src/app/api/users/route.ts` (line 1-177)
- User types: `src/types/user.ts` (line 1-58)

**Secondary**:
- Location management: `src/app/(dashboard)/settings/locations/*`
- LocationTable: `src/components/features/LocationTable.tsx`
- LocationForm: `src/components/features/LocationForm.tsx`
- Location API: `src/app/api/locations/route.ts`

### Ripple Effect Analysis
**Files Identified**: 1 modification, 8 new files
- `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx` - Add navigation link (MODIFY)
- `/home/pbrown/SkuInventory/src/types/company.ts` - New types file (CREATE)
- `/home/pbrown/SkuInventory/src/app/api/companies/route.ts` - List/create API (CREATE)
- `/home/pbrown/SkuInventory/src/app/api/companies/[id]/route.ts` - Get/update/delete API (CREATE)
- `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/companies/page.tsx` - List page (CREATE)
- `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/companies/new/page.tsx` - Create page (CREATE)
- `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/companies/[id]/edit/page.tsx` - Edit page (CREATE)
- `/home/pbrown/SkuInventory/src/components/features/CompanyTable.tsx` - Table component (CREATE)
- `/home/pbrown/SkuInventory/src/components/features/CompanyForm.tsx` - Form component (CREATE)

---

## Executive Summary
Create a complete company management admin page with CRUD functionality. This includes API endpoints for listing, creating, updating, and deleting companies, along with React components for the list table and create/edit forms. The implementation follows the established user management patterns with admin-only access control. Companies with associated users, brands, or data cannot be deleted, ensuring data integrity.

---

## Phase 1: Types Layer

### Subtask 1.1: Create Company Types and Schemas
**File**: `/home/pbrown/SkuInventory/src/types/company.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/types/user.ts` (lines 1-58) and `/home/pbrown/SkuInventory/src/types/location.ts` (lines 1-61)
**Instructions**:
1. Create the file with Zod schemas for create and update operations
2. Create list query schema with pagination and sorting
3. Define CompanyResponse interface with user and brand counts

```typescript
import { z } from 'zod'

// Company create schema (admin only)
export const createCompanySchema = z.object({
  name: z.string().min(1, 'Name is required').max(100, 'Name must be 100 characters or less'),
})

export type CreateCompanyInput = z.infer<typeof createCompanySchema>

// Company update schema (admin only)
export const updateCompanySchema = z.object({
  name: z.string().min(1, 'Name is required').max(100, 'Name must be 100 characters or less').optional(),
})

export type UpdateCompanyInput = z.infer<typeof updateCompanySchema>

// Company list query schema
export const companyListQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  pageSize: z.coerce.number().int().positive().max(100).default(50),
  search: z.string().optional(),
  sortBy: z.enum(['name', 'createdAt', 'updatedAt']).default('name'),
  sortOrder: z.enum(['asc', 'desc']).default('asc'),
})

export type CompanyListQuery = z.infer<typeof companyListQuerySchema>

// Company response type (what API returns)
export interface CompanyResponse {
  id: string
  name: string
  userCount: number
  brandCount: number
  createdAt: string
  updatedAt: string
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created at `/home/pbrown/SkuInventory/src/types/company.ts`
- [ ] Zod schemas defined for create, update, and list query
- [ ] CompanyResponse interface includes id, name, userCount, brandCount, createdAt, updatedAt
- [ ] TypeScript compiles without errors

---

## Phase 2: API Routes

### Subtask 2.1: Create Companies List/Create API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/companies/route.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/users/route.ts` (lines 1-177)
**Instructions**:
1. Implement GET handler for listing all companies (admin only, NOT scoped by selectedCompanyId since this is a global admin view)
2. Implement POST handler for creating new companies
3. Include user and brand counts in response
4. Enforce name uniqueness

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'
import { createCompanySchema, companyListQuerySchema } from '@/types/company'

// GET /api/companies - List all companies (admin only)
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const searchParams = Object.fromEntries(request.nextUrl.searchParams)
    const validation = companyListQuerySchema.safeParse(searchParams)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Invalid query parameters', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    const { page, pageSize, search, sortBy, sortOrder } = validation.data

    // Build where clause - NO company scoping for this global admin view
    const where: Prisma.CompanyWhereInput = {}

    if (search) {
      where.name = { contains: search, mode: 'insensitive' }
    }

    // Get total count
    const total = await prisma.company.count({ where })

    // Get companies with counts
    const companies = await prisma.company.findMany({
      where,
      select: {
        id: true,
        name: true,
        createdAt: true,
        updatedAt: true,
        _count: {
          select: {
            users: true,
            brands: true,
          },
        },
      },
      orderBy: {
        [sortBy]: sortOrder,
      },
      skip: (page - 1) * pageSize,
      take: pageSize,
    })

    return NextResponse.json({
      data: companies.map((company) => ({
        id: company.id,
        name: company.name,
        userCount: company._count.users,
        brandCount: company._count.brands,
        createdAt: company.createdAt.toISOString(),
        updatedAt: company.updatedAt.toISOString(),
      })),
      meta: {
        page,
        pageSize,
        total,
        totalPages: Math.ceil(total / pageSize),
      },
    })
  } catch (error) {
    console.error('Error listing companies:', error)
    return NextResponse.json({ error: 'Failed to list companies' }, { status: 500 })
  }
}

// POST /api/companies - Create company (admin only)
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const body = await request.json()
    const validation = createCompanySchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    const { name } = validation.data

    // Check if name already exists (enforced by DB but check for better error)
    const existingCompany = await prisma.company.findUnique({
      where: { name },
    })

    if (existingCompany) {
      return NextResponse.json(
        { error: 'A company with this name already exists' },
        { status: 409 }
      )
    }

    // Create company
    const company = await prisma.company.create({
      data: {
        name,
      },
      select: {
        id: true,
        name: true,
        createdAt: true,
        updatedAt: true,
      },
    })

    return NextResponse.json(
      {
        data: {
          id: company.id,
          name: company.name,
          userCount: 0,
          brandCount: 0,
          createdAt: company.createdAt.toISOString(),
          updatedAt: company.updatedAt.toISOString(),
        },
        message: 'Company created successfully',
      },
      { status: 201 }
    )
  } catch (error) {
    console.error('Error creating company:', error)
    return NextResponse.json({ error: 'Failed to create company' }, { status: 500 })
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] GET endpoint returns paginated list of companies with user/brand counts
- [ ] POST endpoint creates new company with unique name validation
- [ ] Admin-only access enforced on both endpoints
- [ ] TypeScript compiles without errors
- [ ] Build passes

### Subtask 2.2: Create Company Individual API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/companies/[id]/route.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/users/[id]/route.ts` (lines 1-223)
**Instructions**:
1. Implement GET handler for fetching single company
2. Implement PATCH handler for updating company name
3. Implement DELETE handler that prevents deletion of companies with users/brands/data
4. Check if company is the user's current company before deletion

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { updateCompanySchema } from '@/types/company'

// GET /api/companies/[id] - Get company details (admin only)
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id } = await params

    const company = await prisma.company.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        createdAt: true,
        updatedAt: true,
        _count: {
          select: {
            users: true,
            brands: true,
          },
        },
      },
    })

    if (!company) {
      return NextResponse.json({ error: 'Company not found' }, { status: 404 })
    }

    return NextResponse.json({
      data: {
        id: company.id,
        name: company.name,
        userCount: company._count.users,
        brandCount: company._count.brands,
        createdAt: company.createdAt.toISOString(),
        updatedAt: company.updatedAt.toISOString(),
      },
    })
  } catch (error) {
    console.error('Error fetching company:', error)
    return NextResponse.json({ error: 'Failed to fetch company' }, { status: 500 })
  }
}

// PATCH /api/companies/[id] - Update company (admin only)
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id } = await params
    const body = await request.json()

    const validation = updateCompanySchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    // Check if company exists
    const existingCompany = await prisma.company.findUnique({
      where: { id },
    })

    if (!existingCompany) {
      return NextResponse.json({ error: 'Company not found' }, { status: 404 })
    }

    // Check name uniqueness if being changed
    if (validation.data.name && validation.data.name !== existingCompany.name) {
      const nameExists = await prisma.company.findUnique({
        where: { name: validation.data.name },
      })

      if (nameExists) {
        return NextResponse.json(
          { error: 'A company with this name already exists' },
          { status: 409 }
        )
      }
    }

    // Prepare update data
    const updateData: Parameters<typeof prisma.company.update>[0]['data'] = {}

    if (validation.data.name) updateData.name = validation.data.name

    // Update company
    const company = await prisma.company.update({
      where: { id },
      data: updateData,
      select: {
        id: true,
        name: true,
        createdAt: true,
        updatedAt: true,
        _count: {
          select: {
            users: true,
            brands: true,
          },
        },
      },
    })

    return NextResponse.json({
      data: {
        id: company.id,
        name: company.name,
        userCount: company._count.users,
        brandCount: company._count.brands,
        createdAt: company.createdAt.toISOString(),
        updatedAt: company.updatedAt.toISOString(),
      },
      message: 'Company updated successfully',
    })
  } catch (error) {
    console.error('Error updating company:', error)
    return NextResponse.json({ error: 'Failed to update company' }, { status: 500 })
  }
}

// DELETE /api/companies/[id] - Delete company (admin only)
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const { id } = await params

    // Check if company exists
    const existingCompany = await prisma.company.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            users: true,
            brands: true,
            locations: true,
            transactions: true,
            components: true,
            skus: true,
            userCompanies: true,
          },
        },
      },
    })

    if (!existingCompany) {
      return NextResponse.json({ error: 'Company not found' }, { status: 404 })
    }

    // Prevent deletion of current company
    if (id === session.user.selectedCompanyId) {
      return NextResponse.json(
        { error: 'Cannot delete the company you are currently viewing' },
        { status: 400 }
      )
    }

    // Check if company has any associated data
    const totalCount =
      existingCompany._count.users +
      existingCompany._count.brands +
      existingCompany._count.locations +
      existingCompany._count.transactions +
      existingCompany._count.components +
      existingCompany._count.skus +
      existingCompany._count.userCompanies

    if (totalCount > 0) {
      const details = []
      if (existingCompany._count.users > 0) details.push(`${existingCompany._count.users} users`)
      if (existingCompany._count.brands > 0) details.push(`${existingCompany._count.brands} brands`)
      if (existingCompany._count.locations > 0) details.push(`${existingCompany._count.locations} locations`)
      if (existingCompany._count.userCompanies > 0) details.push(`${existingCompany._count.userCompanies} user assignments`)

      return NextResponse.json(
        {
          error: `Cannot delete company with associated data: ${details.join(', ')}. Remove all associated data first.`
        },
        { status: 400 }
      )
    }

    // Delete company (hard delete since it has no data)
    await prisma.company.delete({
      where: { id },
    })

    return NextResponse.json({ message: 'Company deleted successfully' })
  } catch (error) {
    console.error('Error deleting company:', error)
    return NextResponse.json({ error: 'Failed to delete company' }, { status: 500 })
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] GET endpoint returns company details with counts
- [ ] PATCH endpoint updates company name with uniqueness check
- [ ] DELETE endpoint prevents deletion of companies with associated data
- [ ] DELETE endpoint prevents deletion of current company
- [ ] Admin-only access enforced on all endpoints
- [ ] TypeScript compiles without errors
- [ ] Build passes

---

## Phase 3: UI Components

### Subtask 3.1: Create CompanyTable Component
**File**: `/home/pbrown/SkuInventory/src/components/features/CompanyTable.tsx`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/components/features/UserTable.tsx` (lines 1-212) and `/home/pbrown/SkuInventory/src/components/features/LocationTable.tsx` (lines 1-250)
**Instructions**:
1. Create table component to display companies
2. Include edit action in dropdown menu
3. Include delete action with confirmation dialog
4. Show user and brand counts in columns
5. Disable delete for companies with data (show different message)

```typescript
'use client'

import { useState } from 'react'
import Link from 'next/link'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import { MoreHorizontal, Edit, Trash2 } from 'lucide-react'
import type { CompanyResponse } from '@/types/company'

interface CompanyTableProps {
  companies: CompanyResponse[]
  currentCompanyId: string
  onRefresh: () => void
}

export function CompanyTable({ companies, currentCompanyId, onRefresh }: CompanyTableProps) {
  const [companyToDelete, setCompanyToDelete] = useState<CompanyResponse | null>(null)
  const [isDeleting, setIsDeleting] = useState(false)
  const [actionError, setActionError] = useState<string | null>(null)

  const handleDelete = async () => {
    if (!companyToDelete) return

    setIsDeleting(true)
    setActionError(null)
    try {
      const res = await fetch(`/api/companies/${companyToDelete.id}`, {
        method: 'DELETE',
      })

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.error || 'Failed to delete company')
      }

      onRefresh()
    } catch (error) {
      setActionError(error instanceof Error ? error.message : 'Failed to delete company')
    } finally {
      setIsDeleting(false)
      setCompanyToDelete(null)
    }
  }

  const canDelete = (company: CompanyResponse) => {
    return company.userCount === 0 && company.brandCount === 0 && company.id !== currentCompanyId
  }

  if (companies.length === 0) {
    return (
      <div className="py-10 text-center text-muted-foreground">
        No companies found.
      </div>
    )
  }

  return (
    <>
      {actionError && (
        <div className="mb-4 rounded-md bg-destructive/10 p-3 text-sm text-destructive">
          {actionError}
        </div>
      )}

      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Name</TableHead>
              <TableHead>Users</TableHead>
              <TableHead>Brands</TableHead>
              <TableHead>Created</TableHead>
              <TableHead className="w-[70px]" />
            </TableRow>
          </TableHeader>
          <TableBody>
            {companies.map((company) => (
              <TableRow key={company.id}>
                <TableCell className="font-medium">
                  {company.name}
                  {company.id === currentCompanyId && (
                    <Badge variant="secondary" className="ml-2">Current</Badge>
                  )}
                </TableCell>
                <TableCell>
                  <Badge variant="outline">{company.userCount}</Badge>
                </TableCell>
                <TableCell>
                  <Badge variant="outline">{company.brandCount}</Badge>
                </TableCell>
                <TableCell className="text-muted-foreground" suppressHydrationWarning>
                  {new Date(company.createdAt).toLocaleDateString()}
                </TableCell>
                <TableCell>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="icon">
                        <MoreHorizontal className="h-4 w-4" />
                        <span className="sr-only">Open menu</span>
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem asChild>
                        <Link href={`/settings/companies/${company.id}/edit`}>
                          <Edit className="mr-2 h-4 w-4" />
                          Edit
                        </Link>
                      </DropdownMenuItem>
                      {canDelete(company) ? (
                        <DropdownMenuItem
                          className="text-destructive"
                          onClick={() => setCompanyToDelete(company)}
                        >
                          <Trash2 className="mr-2 h-4 w-4" />
                          Delete
                        </DropdownMenuItem>
                      ) : (
                        <DropdownMenuItem disabled className="text-muted-foreground">
                          <Trash2 className="mr-2 h-4 w-4" />
                          {company.id === currentCompanyId
                            ? 'Cannot delete current'
                            : 'Has associated data'}
                        </DropdownMenuItem>
                      )}
                    </DropdownMenuContent>
                  </DropdownMenu>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>

      <AlertDialog open={!!companyToDelete} onOpenChange={() => setCompanyToDelete(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Company</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete <strong>{companyToDelete?.name}</strong>? This action
              cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              disabled={isDeleting}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {isDeleting ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Table displays company name, user count, brand count, created date
- [ ] Current company badge shown for selected company
- [ ] Edit action navigates to edit page
- [ ] Delete action shows confirmation dialog
- [ ] Delete disabled for companies with data or current company
- [ ] TypeScript compiles without errors

### Subtask 3.2: Create CompanyForm Component
**File**: `/home/pbrown/SkuInventory/src/components/features/CompanyForm.tsx`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/components/features/UserForm.tsx` (lines 1-206) and `/home/pbrown/SkuInventory/src/components/features/LocationForm.tsx` (lines 1-219)
**Instructions**:
1. Create form component for create/edit company
2. Simple form with just company name field
3. Handle create and edit modes
4. Navigate back to list on success

```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import type { CompanyResponse } from '@/types/company'

interface CompanyFormProps {
  company?: CompanyResponse
  onSuccess?: () => void
}

export function CompanyForm({ company, onSuccess }: CompanyFormProps) {
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const [formData, setFormData] = useState({
    name: company?.name ?? '',
  })

  const isEditing = !!company

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError(null)

    try {
      const url = isEditing ? `/api/companies/${company.id}` : '/api/companies'
      const method = isEditing ? 'PATCH' : 'POST'

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: formData.name }),
      })

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.error || 'Failed to save company')
      }

      if (onSuccess) {
        onSuccess()
      } else {
        router.push('/settings/companies')
        router.refresh()
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <Card>
        <CardHeader>
          <CardTitle>{isEditing ? 'Edit Company' : 'Create Company'}</CardTitle>
          <CardDescription>
            {isEditing
              ? 'Update company information'
              : 'Add a new company to the system'}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && (
            <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
              {error}
            </div>
          )}

          <div className="space-y-2">
            <Label htmlFor="name">Company Name *</Label>
            <Input
              id="name"
              placeholder="Acme Corporation"
              value={formData.name}
              onChange={(e) => setFormData((prev) => ({ ...prev, name: e.target.value }))}
              required
              maxLength={100}
            />
            <p className="text-xs text-muted-foreground">
              Must be unique across all companies
            </p>
          </div>

          {isEditing && (
            <div className="text-sm text-muted-foreground">
              <p>Users: {company.userCount}</p>
              <p>Brands: {company.brandCount}</p>
            </div>
          )}

          <div className="flex justify-end gap-2 pt-4">
            <Button type="button" variant="outline" onClick={() => router.back()}>
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? 'Saving...' : isEditing ? 'Save Changes' : 'Create Company'}
            </Button>
          </div>
        </CardContent>
      </Card>
    </form>
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Form has name input field with validation
- [ ] Create mode shows "Create Company" title
- [ ] Edit mode shows "Edit Company" title and current counts
- [ ] Form submits to correct API endpoint
- [ ] Error handling displays errors
- [ ] Cancel button navigates back
- [ ] TypeScript compiles without errors

---

## Phase 4: Pages

### Subtask 4.1: Create Companies List Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/companies/page.tsx`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/users/page.tsx` (lines 1-133)
**Instructions**:
1. Create list page with search functionality
2. Add "Add Company" button
3. Use CompanyTable component
4. Pass current company ID for display

```typescript
'use client'

import { useState, useEffect, useCallback } from 'react'
import Link from 'next/link'
import { useSession } from 'next-auth/react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { CompanyTable } from '@/components/features/CompanyTable'
import { Building2, Search } from 'lucide-react'
import type { CompanyResponse } from '@/types/company'

export default function CompaniesPage() {
  const { data: session } = useSession()
  const [companies, setCompanies] = useState<CompanyResponse[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [search, setSearch] = useState('')

  const fetchCompanies = useCallback(async () => {
    setIsLoading(true)
    setError(null)

    try {
      const params = new URLSearchParams()
      if (search) params.set('search', search)

      const res = await fetch(`/api/companies?${params.toString()}`)
      if (!res.ok) {
        throw new Error('Failed to load companies')
      }
      const data = await res.json().catch(() => ({}))
      setCompanies(data?.data || [])
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }, [search])

  useEffect(() => {
    fetchCompanies()
  }, [fetchCompanies])

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault()
    fetchCompanies()
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">Company Management</h1>
          <p className="text-muted-foreground">Manage companies in the system</p>
        </div>
        <Button asChild>
          <Link href="/settings/companies/new">
            <Building2 className="mr-2 h-4 w-4" />
            Add Company
          </Link>
        </Button>
      </div>

      {/* Search */}
      <div className="flex flex-wrap items-center gap-4">
        <form onSubmit={handleSearch} className="flex gap-2">
          <div className="relative">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              type="search"
              placeholder="Search companies..."
              className="pl-8 w-[250px]"
              value={search}
              onChange={(e) => setSearch(e.target.value)}
            />
          </div>
          <Button type="submit" variant="secondary">
            Search
          </Button>
        </form>
      </div>

      {/* Error State */}
      {error && (
        <div className="rounded-md bg-destructive/10 p-4 text-destructive">{error}</div>
      )}

      {/* Loading State */}
      {isLoading && (
        <div className="py-10 text-center text-muted-foreground">Loading companies...</div>
      )}

      {/* Company Table */}
      {!isLoading && !error && session?.user && (
        <CompanyTable
          companies={companies}
          currentCompanyId={session.user.selectedCompanyId}
          onRefresh={fetchCompanies}
        />
      )}
    </div>
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Page displays list of all companies
- [ ] Search functionality filters by name
- [ ] "Add Company" button navigates to new page
- [ ] CompanyTable receives correct props
- [ ] Loading and error states handled
- [ ] TypeScript compiles without errors
- [ ] Build passes

### Subtask 4.2: Create New Company Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/companies/new/page.tsx`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/users/new/page.tsx` (lines 1-26)
**Instructions**:
1. Create simple page with back button and CompanyForm

```typescript
'use client'

import Link from 'next/link'
import { Button } from '@/components/ui/button'
import { ArrowLeft } from 'lucide-react'
import { CompanyForm } from '@/components/features/CompanyForm'

export default function NewCompanyPage() {
  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Link href="/settings/companies">
          <Button variant="ghost" size="sm">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Companies
          </Button>
        </Link>
        <h1 className="text-3xl font-bold">Create Company</h1>
      </div>

      <div className="max-w-2xl">
        <CompanyForm />
      </div>
    </div>
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Page displays with back button and form
- [ ] Back button navigates to companies list
- [ ] CompanyForm rendered in create mode
- [ ] TypeScript compiles without errors
- [ ] Build passes

### Subtask 4.3: Create Edit Company Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/companies/[id]/edit/page.tsx`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/users/[id]/edit/page.tsx` (lines 1-88)
**Instructions**:
1. Create edit page that fetches company data
2. Handle loading and error states
3. Pass company data to CompanyForm

```typescript
'use client'

import { useState, useEffect } from 'react'
import Link from 'next/link'
import { useParams } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { ArrowLeft } from 'lucide-react'
import { CompanyForm } from '@/components/features/CompanyForm'
import type { CompanyResponse } from '@/types/company'

export default function EditCompanyPage() {
  const params = useParams()
  const id = params.id as string
  const [company, setCompany] = useState<CompanyResponse | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    async function fetchCompany() {
      try {
        const res = await fetch(`/api/companies/${id}`)
        if (!res.ok) {
          throw new Error('Company not found')
        }
        const data = await res.json().catch(() => ({}))
        setCompany(data?.data)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred')
      } finally {
        setIsLoading(false)
      }
    }

    fetchCompany()
  }, [id])

  if (isLoading) {
    return (
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Link href="/settings/companies">
            <Button variant="ghost" size="sm">
              <ArrowLeft className="h-4 w-4 mr-2" />
              Back to Companies
            </Button>
          </Link>
        </div>
        <div className="py-10 text-center text-muted-foreground">Loading company...</div>
      </div>
    )
  }

  if (error || !company) {
    return (
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Link href="/settings/companies">
            <Button variant="ghost" size="sm">
              <ArrowLeft className="h-4 w-4 mr-2" />
              Back to Companies
            </Button>
          </Link>
        </div>
        <div className="rounded-md bg-destructive/10 p-4 text-destructive">
          {error || 'Company not found'}
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Link href="/settings/companies">
          <Button variant="ghost" size="sm">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Companies
          </Button>
        </Link>
        <h1 className="text-3xl font-bold">Edit Company</h1>
      </div>

      <div className="max-w-2xl">
        <CompanyForm company={company} />
      </div>
    </div>
  )
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Page fetches company data by ID
- [ ] Loading state shows while fetching
- [ ] Error state shows if company not found
- [ ] CompanyForm receives company data in edit mode
- [ ] TypeScript compiles without errors
- [ ] Build passes

---

## Phase 5: Navigation Integration

### Subtask 5.1: Add Companies Link to Sidebar Navigation
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/layout.tsx`
**Pattern**: Existing navigation array structure (lines 30-41)
**Instructions**:
1. Import Building2 icon from lucide-react
2. Add Companies navigation item after Locations with adminOnly flag

Find the navigation array (around line 30-41) and add the Companies entry:

```typescript
// Add to imports:
import {
  LayoutDashboard,
  Package,
  Boxes,
  ArrowLeftRight,
  Upload,
  BarChart3,
  Settings,
  Users,
  MapPin,
  LogOut,
  Menu,
  X,
  Layers,
  Building2,  // Add this import
} from 'lucide-react'

// Modify the navigation array to add Companies after Locations:
const navigation = [
  { name: 'Dashboard', href: '/', icon: LayoutDashboard },
  { name: 'Components', href: '/components', icon: Package },
  { name: 'SKUs', href: '/skus', icon: Boxes },
  { name: 'Transactions', href: '/transactions', icon: ArrowLeftRight },
  { name: 'Lots', href: '/lots', icon: Layers },
  { name: 'Import', href: '/import', icon: Upload },
  { name: 'Analytics', href: '/analytics/defects', icon: BarChart3 },
  { name: 'Users', href: '/settings/users', icon: Users, adminOnly: true },
  { name: 'Locations', href: '/settings/locations', icon: MapPin, adminOnly: true },
  { name: 'Companies', href: '/settings/companies', icon: Building2, adminOnly: true },  // Add this line
  { name: 'Settings', href: '/settings', icon: Settings, adminOnly: true },
]
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Building2 icon imported from lucide-react
- [ ] Companies navigation item added with correct href
- [ ] adminOnly: true flag set for admin-only access
- [ ] Navigation appears after Locations in sidebar
- [ ] TypeScript compiles without errors
- [ ] Build passes

---

## Summary of Deliverables

**Files Created**: 8
- Types: 1 (`src/types/company.ts`)
- API Routes: 2 (`src/app/api/companies/route.ts`, `src/app/api/companies/[id]/route.ts`)
- Components: 2 (`src/components/features/CompanyTable.tsx`, `src/components/features/CompanyForm.tsx`)
- Pages: 3 (`src/app/(dashboard)/settings/companies/page.tsx`, `.../new/page.tsx`, `.../[id]/edit/page.tsx`)

**Files Modified**: 1
- `src/app/(dashboard)/layout.tsx` - Add navigation link

---

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 1 -> Phase 5)
2. Run TypeScript check after each subtask: `npx tsc --noEmit`
3. Run full build after API routes and pages: `npm run build`
4. Test completion criteria before next subtask
5. Follow reference patterns exactly for consistency

## Test Strategy Note
- Manual testing recommended for CRUD operations
- Verify admin-only access by testing with non-admin user
- Test deletion prevention with companies that have users/brands

## Acceptance Criteria Checklist
- [ ] Companies list page shows all companies with user/brand counts
- [ ] Admins can create new companies with unique names
- [ ] Admins can edit company names
- [ ] Admins can delete empty companies (no users/brands)
- [ ] Non-empty companies show warning and cannot be deleted
- [ ] Navigation link appears for admin users only
- [ ] All forms have proper validation
- [ ] `npm run build` passes
- [ ] `npx tsc --noEmit` passes

## Performance Metrics
| Phase | Estimated Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 20m |
| **Total Planning** | **40m** |
| **Estimated Build** | **6-8h** |
