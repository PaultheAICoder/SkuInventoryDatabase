# Implementation Plan
**Generated**: 2025-12-04 00:15:00 UTC
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #77
**Estimated Build Time**: 4-6 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Feature (Database Schema Enhancement)
**Source**: GitHub Issue #77 - "[Parent #24] Add UserCompany join table and direct companyId to Component/SKU models"
**Priority**: High (Foundation for multi-company feature; blocks issues #82, #87, #92, #94, #96)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED (schema migrations, Prisma generate, build verification)
**Suggested Filter**: None (database schema changes)

### Issue Validation
**Status**: Valid
**Recent Changes**: Schema was last modified for Location model (commit 6a431c3, 2025-12-03)
**Parent Issue**: #24 (CLOSED - decomposed into sub-issues)

### Current State Assessment

**Existing Components:**
- `User` model: Has direct `companyId` foreign key (line 76-103 in schema.prisma)
- `Company` model: Exists with `users`, `brands`, `locations`, `transactions` relations (line 13-27)
- `Component` model: Has `brandId` only, no direct `companyId` (line 125-152)
- `SKU` model: Has `brandId` only, no direct `companyId` (line 212-236)
- `UserCompany` model: Does NOT exist yet

**Database:**
- PostgreSQL via Prisma ORM
- 6 migrations exist, most recent: `20251203234127_add_location_to_transaction`
- Migration patterns established: CREATE TABLE, indexes, foreign keys

**API Routes Affected (for future issues, not this one):**
- Components: `/api/components/route.ts`, `/api/components/[id]/route.ts`
- SKUs: `/api/skus/route.ts`, `/api/skus/[id]/route.ts`
- Note: This issue only adds schema; API changes are in issue #96

**Types:**
- `src/types/component.ts` - ComponentResponse interface (no companyId field currently)
- `src/types/sku.ts` - SKUResponse interface (no companyId field currently)
- No UserCompany type exists

### Dependencies & Blockers

1. **No blockers** - This is the foundational issue
2. **Blocks**: Issues #82, #87, #92, #94, #96 all depend on this

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 4-6 hours
**Risk**: Medium (data migration for existing records)

**Risk Factors:**
- Data backfill migration must handle null companyId before making it required
- Foreign key constraints must be added after data is populated
- Need to ensure Brand.companyId matches Component/SKU companyId for integrity

### Patterns Identified

**Primary**: `/home/pbrown/SkuInventory/prisma/migrations/20251203230836_add_location_model/migration.sql`
- Shows pattern for adding new table with foreign keys and indexes
- Uses TEXT for UUIDs, TIMESTAMP(3) for dates
- Proper foreign key constraint syntax

**Secondary**: `/home/pbrown/SkuInventory/prisma/migrations/20251203192125_add_defect_alerts/migration.sql`
- Shows pattern for multi-table migration
- Demonstrates adding foreign keys with different cascade behaviors

**Prisma Schema Patterns:**
- UUID primary keys: `@id @default(uuid())`
- Composite indexes: `@@index([companyId, isActive])`
- Unique constraints: `@@unique([userId, companyId])`
- Cascade deletes: `onDelete: Cascade`

### Ripple Effect Analysis

**Files Identified**: 1 file directly modified, migration created

**Direct Changes:**
- `/home/pbrown/SkuInventory/prisma/schema.prisma` - Add UserCompany model, modify Component, SKU, User, Company models

**Generated Files (via npx prisma generate):**
- `node_modules/.prisma/client/` - Auto-generated Prisma client

**No API/Service Changes Required** for this issue (API changes are in issue #96)

---

## Executive Summary

This implementation adds the foundational database schema for multi-company user assignments:
1. Creates a new `UserCompany` join table enabling many-to-many User-Company relationships
2. Adds direct `companyId` foreign key to `Component` and `SKU` models for efficient querying
3. Runs a data migration to backfill `companyId` from Brand relationships for existing records
4. Creates `UserCompany` entries for existing users based on their current company assignment

## Phase 1: Schema Definition

### Subtask 1.1: Add UserCompany Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing model structure (Location model at lines 36-52)
**Instructions**:

1. Add the `UserCompany` model after the `User` model (around line 104):

```prisma
model UserCompany {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  companyId  String
  company    Company  @relation("UserCompanies", fields: [companyId], references: [id], onDelete: Cascade)
  role       UserRole @default(ops)
  assignedAt DateTime @default(now())

  @@unique([userId, companyId])
  @@index([userId])
  @@index([companyId])
}
```

2. Update the `User` model to add the `userCompanies` relation (add after line 102):
```prisma
  userCompanies     UserCompany[]
```

3. Update the `Company` model to add the `userCompanies` relation (add after line 26, before the closing brace):
```prisma
  userCompanies    UserCompany[] @relation("UserCompanies")
```

**Validation Commands**:
```bash
npx prisma validate
```

**Completion Criteria**:
- [ ] `UserCompany` model defined with correct fields
- [ ] `User` model has `userCompanies` relation
- [ ] `Company` model has `userCompanies` relation
- [ ] Schema validates without errors

### Subtask 1.2: Add companyId to Component Model
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow Location model's companyId pattern (lines 37-39)
**Instructions**:

1. Add `companyId` and `company` relation to Component model (add after `brandId` field at line 127):

```prisma
  companyId     String?
  company       Company?  @relation("CompanyComponents", fields: [companyId], references: [id])
```

Note: Initially nullable to allow migration to populate existing records.

2. Add index for company-based queries. Update the existing `@@index([brandId, isActive])` to also include a company index:

```prisma
  @@index([companyId, isActive])
```

3. Update the `Company` model to add the reverse relation (add after `userCompanies`):
```prisma
  components       Component[] @relation("CompanyComponents")
```

**Validation Commands**:
```bash
npx prisma validate
```

**Completion Criteria**:
- [ ] Component model has `companyId` field (nullable initially)
- [ ] Component model has `company` relation
- [ ] Company model has `components` relation
- [ ] Index added for `[companyId, isActive]`

### Subtask 1.3: Add companyId to SKU Model
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow Component pattern from Subtask 1.2
**Instructions**:

1. Add `companyId` and `company` relation to SKU model (add after `brandId` field at line 214):

```prisma
  companyId    String?
  company      Company?  @relation("CompanySKUs", fields: [companyId], references: [id])
```

Note: Initially nullable to allow migration to populate existing records.

2. Add index for company-based queries:

```prisma
  @@index([companyId, isActive])
```

3. Update the `Company` model to add the reverse relation (add after `components`):
```prisma
  skus             SKU[] @relation("CompanySKUs")
```

**Validation Commands**:
```bash
npx prisma validate
```

**Completion Criteria**:
- [ ] SKU model has `companyId` field (nullable initially)
- [ ] SKU model has `company` relation
- [ ] Company model has `skus` relation
- [ ] Index added for `[companyId, isActive]`

## Phase 2: Migration - Add Nullable Fields

### Subtask 2.1: Generate Migration for Nullable Fields
**File**: New file in `prisma/migrations/`
**Pattern**: Follow existing migration naming convention
**Instructions**:

1. Generate the migration (do NOT run it yet):
```bash
npx prisma migrate dev --create-only --name add_usercompany_and_company_refs
```

2. Review the generated migration SQL to ensure it:
   - Creates `UserCompany` table with proper columns and constraints
   - Adds nullable `companyId` column to `Component`
   - Adds nullable `companyId` column to `SKU`
   - Creates appropriate indexes
   - Adds foreign key constraints

**Expected migration SQL structure:**
```sql
-- CreateTable UserCompany
-- Add nullable companyId to Component
-- Add nullable companyId to SKU
-- CreateIndex for UserCompany
-- CreateIndex for Component.companyId
-- CreateIndex for SKU.companyId
-- AddForeignKey constraints
```

**Validation Commands**:
```bash
ls prisma/migrations/ | tail -2
cat prisma/migrations/*add_usercompany*/migration.sql
```

**Completion Criteria**:
- [ ] Migration file created
- [ ] SQL creates UserCompany table correctly
- [ ] SQL adds nullable companyId columns
- [ ] Foreign keys reference Company table

## Phase 3: Data Backfill Migration

### Subtask 3.1: Add Data Backfill SQL to Migration
**File**: The migration file created in Subtask 2.1
**Pattern**: SQL UPDATE statements with subqueries
**Instructions**:

1. Edit the generated migration file to add data backfill statements BEFORE any NOT NULL constraints or additional foreign keys.

2. Add after the CREATE TABLE and ALTER TABLE statements that add the nullable columns:

```sql
-- Backfill Component.companyId from Brand.companyId
UPDATE "Component"
SET "companyId" = (
  SELECT "companyId" FROM "Brand" WHERE "Brand"."id" = "Component"."brandId"
)
WHERE "companyId" IS NULL;

-- Backfill SKU.companyId from Brand.companyId
UPDATE "SKU"
SET "companyId" = (
  SELECT "companyId" FROM "Brand" WHERE "Brand"."id" = "SKU"."brandId"
)
WHERE "companyId" IS NULL;

-- Create UserCompany entries for existing users
INSERT INTO "UserCompany" ("id", "userId", "companyId", "role", "assignedAt")
SELECT
  gen_random_uuid()::text,
  "id",
  "companyId",
  "role",
  NOW()
FROM "User"
WHERE NOT EXISTS (
  SELECT 1 FROM "UserCompany"
  WHERE "UserCompany"."userId" = "User"."id"
  AND "UserCompany"."companyId" = "User"."companyId"
);
```

**Completion Criteria**:
- [ ] Component backfill SQL added
- [ ] SKU backfill SQL added
- [ ] UserCompany creation SQL added
- [ ] All SQL uses proper Prisma/PostgreSQL syntax

### Subtask 3.2: Run Migration
**Instructions**:

1. Run the migration:
```bash
npx prisma migrate dev
```

2. Verify the migration succeeded and data was backfilled.

**Validation Commands**:
```bash
# Check migration status
npx prisma migrate status

# Generate updated Prisma client
npx prisma generate
```

**Completion Criteria**:
- [ ] Migration runs without errors
- [ ] Prisma client regenerated
- [ ] No pending migrations

## Phase 4: Make companyId Required (Optional - may defer to later issue)

### Subtask 4.1: Update Schema to Make companyId Required
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Instructions**:

**IMPORTANT**: This subtask should only be executed AFTER verifying all existing data has companyId populated. If there's any concern about data integrity, skip this subtask and leave companyId nullable for now.

1. Change Component model's companyId from nullable to required:
```prisma
  companyId     String
  company       Company  @relation("CompanyComponents", fields: [companyId], references: [id])
```

2. Change SKU model's companyId from nullable to required:
```prisma
  companyId    String
  company      Company  @relation("CompanySKUs", fields: [companyId], references: [id])
```

3. Generate and run migration:
```bash
npx prisma migrate dev --name make_companyid_required
```

**Validation Commands**:
```bash
npx prisma validate
npx prisma migrate dev
```

**Completion Criteria**:
- [ ] Component.companyId is NOT NULL
- [ ] SKU.companyId is NOT NULL
- [ ] Migration succeeds (no null values exist)

## Phase 5: Verification

### Subtask 5.1: Verify Build and TypeScript Compilation
**Instructions**:

1. Regenerate Prisma client:
```bash
npx prisma generate
```

2. Run TypeScript compilation:
```bash
npx tsc --noEmit
```

3. Run build:
```bash
npm run build
```

4. Run lint:
```bash
npm run lint
```

**Validation Commands**:
```bash
npx prisma generate && npx tsc --noEmit && npm run build && npm run lint
```

**Completion Criteria**:
- [ ] `npx prisma generate` succeeds
- [ ] `npx tsc --noEmit` has no errors
- [ ] `npm run build` succeeds
- [ ] `npm run lint` passes

### Subtask 5.2: Verify Schema Correctness
**Instructions**:

1. Verify UserCompany model exists:
```bash
grep -A 15 "model UserCompany" prisma/schema.prisma
```

2. Verify Component has companyId:
```bash
grep -A 5 "companyId" prisma/schema.prisma | head -20
```

3. Verify Company has new relations:
```bash
grep -A 30 "model Company" prisma/schema.prisma
```

**Completion Criteria**:
- [ ] UserCompany model has all fields (id, userId, companyId, role, assignedAt)
- [ ] UserCompany has unique constraint on [userId, companyId]
- [ ] Component has companyId field and relation
- [ ] SKU has companyId field and relation
- [ ] Company has userCompanies, components, and skus relations

---

## Summary of Deliverables

**Files Created**: 1 (migration file)
**Files Modified**: 1 (`prisma/schema.prisma`)

**Schema Changes:**
| Model | Change |
|-------|--------|
| UserCompany | NEW - join table for User-Company many-to-many |
| User | ADD `userCompanies` relation |
| Company | ADD `userCompanies`, `components`, `skus` relations |
| Component | ADD `companyId`, `company` relation, index |
| SKU | ADD `companyId`, `company` relation, index |

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 (optional) -> Phase 5)
2. Phase 4 (making companyId required) can be skipped if data backfill has any issues
3. Always run `npx prisma validate` before generating migrations
4. Test completion criteria before proceeding to next subtask
5. If migration fails, check for:
   - Null companyId values in existing data
   - Missing Brand records for Components/SKUs
   - Duplicate UserCompany entries

## Test Strategy Note

- No unit tests required for this issue (schema-only changes)
- Prisma generate and build verification serve as tests
- Integration tests for querying by companyId will be added in issue #96

## Performance Metrics

| Phase | Expected Duration |
|-------|-------------------|
| Phase 1: Schema Definition | 30m |
| Phase 2: Generate Migration | 15m |
| Phase 3: Data Backfill | 30m |
| Phase 4: Make Required | 15m (optional) |
| Phase 5: Verification | 15m |
| **Total** | **1.75-2 hours** |

---

## Appendix: Complete Schema Changes

### UserCompany Model (NEW)
```prisma
model UserCompany {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  companyId  String
  company    Company  @relation("UserCompanies", fields: [companyId], references: [id], onDelete: Cascade)
  role       UserRole @default(ops)
  assignedAt DateTime @default(now())

  @@unique([userId, companyId])
  @@index([userId])
  @@index([companyId])
}
```

### Component Model Changes
```prisma
// Add after brandId (line 127-128):
  companyId     String?
  company       Company?  @relation("CompanyComponents", fields: [companyId], references: [id])

// Add new index:
  @@index([companyId, isActive])
```

### SKU Model Changes
```prisma
// Add after brandId (line 214-215):
  companyId    String?
  company      Company?  @relation("CompanySKUs", fields: [companyId], references: [id])

// Add new index:
  @@index([companyId, isActive])
```

### Company Model Changes
```prisma
// Add after existing relations (before closing brace):
  userCompanies    UserCompany[] @relation("UserCompanies")
  components       Component[] @relation("CompanyComponents")
  skus             SKU[] @relation("CompanySKUs")
```

### User Model Changes
```prisma
// Add after existing relations (before closing brace at line 103):
  userCompanies     UserCompany[]
```
