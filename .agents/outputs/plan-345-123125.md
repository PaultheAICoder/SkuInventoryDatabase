# Implementation Plan
**Generated**: 2025-12-31T12:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #345
**Parent Issue**: #338 (Complete Amazon Seller Central integration)
**Estimated Build Time**: 6-8 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: New Feature
**Source**: GitHub Issue #345
**Priority**: High (part of core Amazon integration initiative)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--testPathPattern="amazon-sp"` or None (manual testing via OAuth flow)

### Issue Validation
**Status**: Valid
**Recent Changes**: Amazon Ads integration completed (provides reference patterns)

### Current State Assessment

**Existing Components (to use as patterns)**:
- `/src/services/amazon-ads/client.ts` - OAuth + token refresh pattern (PRIMARY REFERENCE)
- `/src/services/amazon-ads/types.ts` - Type definitions pattern
- `/src/services/amazon-ads/oauth-state.ts` - State management pattern
- `/src/app/api/integrations/amazon-ads/connect/route.ts` - OAuth initiation
- `/src/app/api/integrations/amazon-ads/callback/route.ts` - OAuth callback
- `/src/app/api/integrations/amazon-ads/status/route.ts` - Status endpoint
- `/src/lib/encryption.ts` - AES-256-GCM encryption utilities

**Database**: IntegrationCredential model exists and supports:
- `integrationType` field - currently has "amazon_ads", "shopify"; will add "amazon_sp"
- Encrypted token storage via `encryptedAccessToken`, `encryptedRefreshToken`
- Multi-tenant via `companyId`, optional `brandId`
- Status tracking: "active", "expired", "revoked", "error"

**Key Differences - SP-API vs Amazon Ads API**:
| Aspect | Amazon Ads API | Amazon SP-API |
|--------|---------------|---------------|
| Auth URL | `www.amazon.com/ap/oa` | `www.amazon.com/ap/oa` (same) |
| Token URL | `api.amazon.com/auth/o2/token` | `api.amazon.com/auth/o2/token` (same) |
| API Base | `advertising-api.amazon.com` | `sellingpartnerapi-na.amazon.com` |
| Request Signing | Bearer token only | **AWS Signature V4 + Bearer token** |
| Scopes | `advertising::campaign_management` | `sellingpartnerapi::*` scopes |

**CRITICAL: AWS Signature V4 Requirement**
SP-API requires AWS Signature Version 4 signing for all API requests. This requires:
1. New dependency: `aws4` npm package (lightweight, well-maintained)
2. AWS credentials: `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`
3. Signing implementation in client

### Dependencies & Blockers

1. **aws4 Package**: Must be installed for AWS Signature V4 signing
   - Package: `aws4` (npm)
   - Used by: SP-API client for request signing
   - Alternative: `@aws-sdk/signature-v4` (heavier, more dependencies)

2. **Environment Variables Required**:
   ```
   AMAZON_SP_CLIENT_ID=           # LWA Client ID
   AMAZON_SP_CLIENT_SECRET=       # LWA Client Secret
   AMAZON_SP_REDIRECT_URI=        # OAuth callback URL
   AWS_ACCESS_KEY_ID=             # For SP-API request signing
   AWS_SECRET_ACCESS_KEY=         # For SP-API request signing
   ```

3. **Existing infrastructure ready**:
   - `CREDENTIAL_ENCRYPTION_KEY` already configured
   - IntegrationCredential model ready
   - OAuth state management pattern available

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 6-8 hours
**Risk**: Medium (new AWS signing pattern, but following established OAuth patterns)

### Patterns Identified

**Primary Pattern**: `/src/services/amazon-ads/client.ts`
- OAuth token exchange
- Token refresh middleware
- API call wrapper with auth
- Error handling patterns

**Secondary Pattern**: `/src/services/amazon-ads/types.ts`
- TypeScript type definitions
- API response types
- Error types

**Tertiary Pattern**: `/src/app/api/integrations/amazon-ads/*/route.ts`
- Route structure for connect/callback/status endpoints
- Authentication checks
- Error responses

### Ripple Effect Analysis

**Files to Create**: 6 new files
- `/src/services/amazon-sp-api/client.ts`
- `/src/services/amazon-sp-api/types.ts`
- `/src/services/amazon-sp-api/auth.ts`
- `/src/app/api/integrations/amazon-sp/connect/route.ts`
- `/src/app/api/integrations/amazon-sp/callback/route.ts`
- `/src/app/api/integrations/amazon-sp/status/route.ts`

**Files to Modify**: 1 file
- `/home/pbrown/SkuInventory/.env.example` - Add SP-API env vars documentation

**No Prisma Schema Changes Required**:
- IntegrationCredential model already supports `integrationType: 'amazon_sp'`
- Existing unique constraint `[companyId, brandId, integrationType]` allows new type

**TOTAL FILES AFFECTED**: 7 (6 new, 1 modified)

---

## Executive Summary

This plan implements Amazon SP-API (Selling Partner API) OAuth authentication and client, following the established patterns from the existing Amazon Ads integration. The key difference is SP-API requires AWS Signature V4 signing for API requests, requiring the `aws4` package. The implementation creates a parallel service structure under `/src/services/amazon-sp-api/` with OAuth flow endpoints at `/api/integrations/amazon-sp/`.

## Phase 0: Environment Dependencies

### Subtask 0.1: Install aws4 Package
**Command**: `npm install aws4 @types/aws4`
**Instructions**:
1. Install the aws4 package for AWS Signature V4 signing
2. The package is lightweight (~15KB) and has no dependencies
3. Verify installation in package.json

**Validation**:
```bash
npm install aws4 @types/aws4 --save
cat package.json | grep aws4
```

**Completion Criteria**:
- [ ] `aws4` listed in dependencies
- [ ] `@types/aws4` listed in devDependencies
- [ ] No npm errors

### Subtask 0.2: Update .env.example with SP-API Variables
**File**: `/home/pbrown/SkuInventory/.env.example`
**Pattern**: Follow existing AMAZON_ADS section format
**Instructions**:
1. Add new section after AMAZON ADS INTEGRATION section
2. Document all required environment variables
3. Include generation instructions for AWS credentials

**Add after line 82 (after AMAZON_ADS_REDIRECT_URI)**:
```bash
# ============================================================================
# AMAZON SP-API INTEGRATION (Selling Partner API)
# ============================================================================
# Amazon Selling Partner API credentials for sales and orders data
# Register app at: https://sellercentral.amazon.com/apps/develop/

# Amazon SP-API OAuth Client ID (LWA)
AMAZON_SP_CLIENT_ID=amzn1.application-oa2-client.your-client-id

# Amazon SP-API OAuth Client Secret (LWA)
AMAZON_SP_CLIENT_SECRET=your-client-secret

# Amazon SP-API OAuth Redirect URI (must match registered URI exactly)
AMAZON_SP_REDIRECT_URI=http://172.16.20.50:4545/api/integrations/amazon-sp/callback

# AWS IAM Credentials for SP-API request signing (required)
# Create IAM user with AmazonSpApiSeller policy
AWS_ACCESS_KEY_ID=AKIA...
AWS_SECRET_ACCESS_KEY=your-secret-key
```

**Completion Criteria**:
- [ ] .env.example updated with SP-API section
- [ ] All 5 new environment variables documented
- [ ] Comments include setup instructions

---

## Phase 1: Types Layer

### Subtask 1.1: Create SP-API Type Definitions
**File**: `/home/pbrown/SkuInventory/src/services/amazon-sp-api/types.ts`
**Pattern**: Follow `/src/services/amazon-ads/types.ts` structure
**Instructions**:

Create file with the following content:

```typescript
/**
 * Amazon SP-API (Selling Partner API) Types
 *
 * Type definitions for Amazon Selling Partner API integration.
 * Used for read-only access to sales and orders data.
 */

// ============================================
// OAuth & Authentication Types
// ============================================

export interface AmazonSpTokenResponse {
  access_token: string
  refresh_token?: string // May not be returned on refresh
  token_type: string // "bearer"
  expires_in: number // seconds until expiration (typically 3600)
}

export interface AmazonSpCredential {
  accessToken: string
  refreshToken: string
  expiresAt: Date
  sellerId?: string
  marketplaceId?: string
}

export interface AmazonSpOAuthState {
  state: string
  companyId: string
  brandId?: string
  createdAt: Date
}

// ============================================
// Seller Account Types
// ============================================

export interface AmazonSpSellerAccount {
  sellerId: string
  marketplaceId: string
  businessName?: string
  countryCode: string // "US"
}

// ============================================
// API Configuration Types
// ============================================

export interface SpApiConfig {
  accessToken: string
  region: 'na' | 'eu' | 'fe' // North America, Europe, Far East
  awsAccessKeyId: string
  awsSecretAccessKey: string
}

export interface SpApiRequestOptions {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE'
  path: string
  body?: unknown
  queryParams?: Record<string, string>
}

// ============================================
// API Error Types
// ============================================

export interface AmazonSpError {
  code: string
  message: string
  details?: string
}

export interface AmazonSpApiResponse<T> {
  success: boolean
  data?: T
  error?: AmazonSpError
}

// ============================================
// Rate Limiting Types
// ============================================

export interface SpApiRateLimit {
  rate: number // Requests per second
  burst: number // Max burst size
}

// ============================================
// Marketplace Constants
// ============================================

export const SP_API_REGIONS = {
  na: {
    endpoint: 'https://sellingpartnerapi-na.amazon.com',
    awsRegion: 'us-east-1',
    marketplaces: ['ATVPDKIKX0DER'], // US
  },
  eu: {
    endpoint: 'https://sellingpartnerapi-eu.amazon.com',
    awsRegion: 'eu-west-1',
    marketplaces: ['A1PA6795UKMFR9'], // DE
  },
  fe: {
    endpoint: 'https://sellingpartnerapi-fe.amazon.com',
    awsRegion: 'us-west-2',
    marketplaces: ['A1VC38T7YXB528'], // JP
  },
} as const

export type SpApiRegion = keyof typeof SP_API_REGIONS

// ============================================
// Connection Status Types (for status endpoint)
// ============================================

export interface SpApiConnectionStatus {
  id: string
  brandId: string | null
  brandName?: string
  status: 'active' | 'expired' | 'revoked' | 'error'
  sellerId?: string | null
  businessName?: string | null
  lastSyncAt?: Date | null
  lastSyncStatus?: string | null
  lastError?: string | null
  createdAt: string
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] All interface definitions compile
- [ ] No TypeScript errors
- [ ] Follows existing types.ts patterns

---

## Phase 2: Authentication Layer

### Subtask 2.1: Create OAuth State Manager
**File**: `/home/pbrown/SkuInventory/src/services/amazon-sp-api/auth.ts`
**Pattern**: Follow `/src/services/amazon-ads/oauth-state.ts`
**Instructions**:

Create file with OAuth state management (same pattern as Amazon Ads):

```typescript
/**
 * OAuth State Store for Amazon SP-API
 *
 * Manages CSRF state tokens for OAuth flow.
 * In-memory storage with automatic expiry cleanup.
 */

interface OAuthStateData {
  companyId: string
  brandId?: string
  expiresAt: Date
}

// In-memory store for OAuth state tokens (short-lived, 10 min expiry)
const stateStore = new Map<string, OAuthStateData>()

/**
 * Store a new OAuth state token
 */
export function storeOAuthState(
  state: string,
  data: Omit<OAuthStateData, 'expiresAt'>,
  expiryMinutes = 10
): void {
  const expiresAt = new Date(Date.now() + expiryMinutes * 60 * 1000)
  stateStore.set(state, { ...data, expiresAt })

  // Cleanup expired states
  cleanupExpiredStates()
}

/**
 * Retrieve and validate an OAuth state token
 * Returns the data if valid, null if invalid or expired
 */
export function retrieveOAuthState(state: string): OAuthStateData | null {
  const data = stateStore.get(state)

  if (!data) {
    return null
  }

  // Check expiry
  if (data.expiresAt < new Date()) {
    stateStore.delete(state)
    return null
  }

  // Remove used state token (one-time use)
  stateStore.delete(state)

  return data
}

/**
 * Clean up expired state tokens
 */
function cleanupExpiredStates(): void {
  const now = new Date()
  const keysToDelete: string[] = []

  stateStore.forEach((value, key) => {
    if (value.expiresAt < now) {
      keysToDelete.push(key)
    }
  })

  keysToDelete.forEach(key => stateStore.delete(key))
}
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] Compiles without errors
- [ ] Functions match Amazon Ads pattern

---

## Phase 3: Client Layer

### Subtask 3.1: Create SP-API Client
**File**: `/home/pbrown/SkuInventory/src/services/amazon-sp-api/client.ts`
**Pattern**: Follow `/src/services/amazon-ads/client.ts` structure
**Instructions**:

Create the main SP-API client with OAuth, token refresh, and AWS Signature V4 signing:

```typescript
/**
 * Amazon SP-API (Selling Partner API) Client
 *
 * Handles OAuth2 LWA authentication and API communication with Amazon SP-API.
 * Includes automatic token refresh middleware and AWS Signature V4 signing.
 *
 * Key differences from Amazon Ads API:
 * - Uses AWS Signature V4 for request signing (in addition to Bearer token)
 * - Different API endpoint (sellingpartnerapi-na.amazon.com)
 * - Different scopes (sellingpartnerapi::*)
 */

import aws4 from 'aws4'
import { encrypt, decrypt, logCredentialAccess } from '@/lib/encryption'
import { prisma } from '@/lib/db'
import type {
  AmazonSpTokenResponse,
  AmazonSpApiResponse,
  AmazonSpError,
  SP_API_REGIONS,
  SpApiRegion,
} from './types'

// ============================================
// Configuration
// ============================================

const AMAZON_AUTH_URL = 'https://www.amazon.com/ap/oa'
const AMAZON_TOKEN_URL = 'https://api.amazon.com/auth/o2/token'
const SP_API_BASE_NA = 'https://sellingpartnerapi-na.amazon.com'

// Token refresh buffer - refresh if expiring within 5 minutes
const TOKEN_REFRESH_BUFFER_MS = 5 * 60 * 1000

// Read-only scopes for sales and orders
const SP_API_SCOPES = [
  'sellingpartnerapi::migration', // Required for initial authorization
]

// ============================================
// Environment Variables
// ============================================

function getClientId(): string {
  const clientId = process.env.AMAZON_SP_CLIENT_ID
  if (!clientId) {
    throw new Error('AMAZON_SP_CLIENT_ID environment variable is required')
  }
  return clientId
}

function getClientSecret(): string {
  const clientSecret = process.env.AMAZON_SP_CLIENT_SECRET
  if (!clientSecret) {
    throw new Error('AMAZON_SP_CLIENT_SECRET environment variable is required')
  }
  return clientSecret
}

function getRedirectUri(): string {
  const redirectUri = process.env.AMAZON_SP_REDIRECT_URI
  if (!redirectUri) {
    throw new Error('AMAZON_SP_REDIRECT_URI environment variable is required')
  }
  return redirectUri
}

function getAwsCredentials(): { accessKeyId: string; secretAccessKey: string } {
  const accessKeyId = process.env.AWS_ACCESS_KEY_ID
  const secretAccessKey = process.env.AWS_SECRET_ACCESS_KEY

  if (!accessKeyId || !secretAccessKey) {
    throw new Error('AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required for SP-API')
  }

  return { accessKeyId, secretAccessKey }
}

// ============================================
// OAuth2 Methods
// ============================================

/**
 * Generate authorization URL for Amazon SP-API OAuth flow
 */
export function getAuthUrl(state: string): string {
  const params = new URLSearchParams({
    application_id: getClientId(),
    state,
    redirect_uri: getRedirectUri(),
    version: 'beta', // For self-authorization flow
  })

  return `https://sellercentral.amazon.com/apps/authorize/consent?${params.toString()}`
}

/**
 * Exchange authorization code (spapi_oauth_code) for access/refresh tokens
 */
export async function exchangeCode(code: string): Promise<AmazonSpApiResponse<AmazonSpTokenResponse>> {
  try {
    const response = await fetch(AMAZON_TOKEN_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code,
        redirect_uri: getRedirectUri(),
        client_id: getClientId(),
        client_secret: getClientSecret(),
      }),
    })

    if (!response.ok) {
      const errorText = await response.text()
      return {
        success: false,
        error: {
          code: 'TOKEN_EXCHANGE_FAILED',
          message: `Failed to exchange authorization code: ${response.status}`,
          details: errorText,
        },
      }
    }

    const data = await response.json() as AmazonSpTokenResponse
    return { success: true, data }
  } catch (error) {
    return {
      success: false,
      error: {
        code: 'TOKEN_EXCHANGE_ERROR',
        message: error instanceof Error ? error.message : 'Unknown error during token exchange',
      },
    }
  }
}

/**
 * Refresh access token using refresh token
 */
export async function refreshToken(refreshTokenValue: string): Promise<AmazonSpApiResponse<AmazonSpTokenResponse>> {
  try {
    const response = await fetch(AMAZON_TOKEN_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshTokenValue,
        client_id: getClientId(),
        client_secret: getClientSecret(),
      }),
    })

    if (!response.ok) {
      const errorText = await response.text()
      return {
        success: false,
        error: {
          code: 'TOKEN_REFRESH_FAILED',
          message: `Failed to refresh token: ${response.status}`,
          details: errorText,
        },
      }
    }

    const data = await response.json() as AmazonSpTokenResponse
    return { success: true, data }
  } catch (error) {
    return {
      success: false,
      error: {
        code: 'TOKEN_REFRESH_ERROR',
        message: error instanceof Error ? error.message : 'Unknown error during token refresh',
      },
    }
  }
}

// ============================================
// Token Management & Auto-Refresh
// ============================================

/**
 * Get valid access token, refreshing if expired or expiring soon
 * This is the automatic token refresh middleware
 */
export async function getValidAccessToken(credentialId: string): Promise<AmazonSpApiResponse<string>> {
  const credential = await prisma.integrationCredential.findUnique({
    where: { id: credentialId },
  })

  if (!credential) {
    return {
      success: false,
      error: { code: 'CREDENTIAL_NOT_FOUND', message: 'Integration credential not found' },
    }
  }

  if (credential.status === 'revoked') {
    return {
      success: false,
      error: { code: 'CREDENTIAL_REVOKED', message: 'Integration has been revoked. Please reconnect.' },
    }
  }

  // Log credential access
  logCredentialAccess({
    credentialId,
    integrationType: credential.integrationType,
    action: 'access',
  })

  // Check if token needs refresh
  const now = new Date()
  const expiresAt = credential.expiresAt
  const needsRefresh = !expiresAt || now.getTime() > expiresAt.getTime() - TOKEN_REFRESH_BUFFER_MS

  if (needsRefresh) {
    // Decrypt and refresh the token
    if (!credential.encryptedRefreshToken) {
      return {
        success: false,
        error: { code: 'NO_REFRESH_TOKEN', message: 'No refresh token available. Please reconnect.' },
      }
    }

    const decryptedRefreshToken = decrypt(credential.encryptedRefreshToken, {
      credentialId,
      integrationType: credential.integrationType,
    })

    const refreshResult = await refreshToken(decryptedRefreshToken)

    if (!refreshResult.success || !refreshResult.data) {
      // Update credential status to expired
      await prisma.integrationCredential.update({
        where: { id: credentialId },
        data: {
          status: 'expired',
          lastErrorAt: now,
          lastError: refreshResult.error?.message || 'Token refresh failed',
        },
      })

      return {
        success: false,
        error: refreshResult.error || { code: 'REFRESH_FAILED', message: 'Token refresh failed' },
      }
    }

    // Encrypt and store new tokens
    const newAccessToken = refreshResult.data.access_token
    const newRefreshToken = refreshResult.data.refresh_token || decryptedRefreshToken
    const newExpiresAt = new Date(now.getTime() + refreshResult.data.expires_in * 1000)

    await prisma.integrationCredential.update({
      where: { id: credentialId },
      data: {
        encryptedAccessToken: encrypt(newAccessToken, {
          credentialId,
          integrationType: credential.integrationType,
        }),
        encryptedRefreshToken: encrypt(newRefreshToken, {
          credentialId,
          integrationType: credential.integrationType,
        }),
        expiresAt: newExpiresAt,
        status: 'active',
        lastUsedAt: now,
        lastError: null,
        lastErrorAt: null,
      },
    })

    return { success: true, data: newAccessToken }
  }

  // Token is still valid, decrypt and return
  const accessToken = decrypt(credential.encryptedAccessToken, {
    credentialId,
    integrationType: credential.integrationType,
  })

  // Update last used timestamp
  await prisma.integrationCredential.update({
    where: { id: credentialId },
    data: { lastUsedAt: now },
  })

  return { success: true, data: accessToken }
}

// ============================================
// AWS Signature V4 Signing
// ============================================

interface SignedRequest {
  url: string
  headers: Record<string, string>
}

/**
 * Sign a request with AWS Signature V4
 * SP-API requires this for all API calls
 */
function signRequest(
  method: string,
  path: string,
  accessToken: string,
  body?: string
): SignedRequest {
  const { accessKeyId, secretAccessKey } = getAwsCredentials()

  const url = new URL(path, SP_API_BASE_NA)

  const opts = {
    host: url.hostname,
    path: url.pathname + url.search,
    method,
    service: 'execute-api',
    region: 'us-east-1',
    headers: {
      'x-amz-access-token': accessToken,
      'Content-Type': 'application/json',
      'User-Agent': 'TrevorInventory/1.0 (Language=Node.js)',
    },
    body,
  }

  // Sign the request
  aws4.sign(opts, {
    accessKeyId,
    secretAccessKey,
  })

  return {
    url: url.toString(),
    headers: opts.headers as Record<string, string>,
  }
}

// ============================================
// API Helper Methods
// ============================================

interface ApiCallOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE'
  body?: unknown
  queryParams?: Record<string, string>
}

/**
 * Make authenticated API call to Amazon SP-API
 * Includes AWS Signature V4 signing
 */
async function apiCall<T>(
  credentialId: string,
  endpoint: string,
  options: ApiCallOptions = {}
): Promise<AmazonSpApiResponse<T>> {
  const { method = 'GET', body, queryParams } = options

  // Get valid access token (auto-refresh if needed)
  const tokenResult = await getValidAccessToken(credentialId)
  if (!tokenResult.success || !tokenResult.data) {
    return {
      success: false,
      error: tokenResult.error || { code: 'TOKEN_ERROR', message: 'Failed to get access token' },
    }
  }

  // Build path with query params
  let path = endpoint
  if (queryParams && Object.keys(queryParams).length > 0) {
    const params = new URLSearchParams(queryParams)
    path = `${endpoint}?${params.toString()}`
  }

  // Sign the request
  const bodyString = body ? JSON.stringify(body) : undefined
  const signed = signRequest(method, path, tokenResult.data, bodyString)

  try {
    const response = await fetch(signed.url, {
      method,
      headers: signed.headers,
      body: bodyString,
    })

    if (!response.ok) {
      const errorText = await response.text()

      // Handle rate limiting
      if (response.status === 429) {
        return {
          success: false,
          error: {
            code: 'RATE_LIMITED',
            message: 'Rate limit exceeded. Please try again later.',
            details: errorText,
          },
        }
      }

      // Handle auth errors
      if (response.status === 401 || response.status === 403) {
        // Update credential status
        await prisma.integrationCredential.update({
          where: { id: credentialId },
          data: {
            status: 'error',
            lastErrorAt: new Date(),
            lastError: `Authentication failed: ${response.status}`,
          },
        })

        return {
          success: false,
          error: {
            code: 'AUTH_ERROR',
            message: 'Authentication failed. Token may be invalid.',
            details: errorText,
          },
        }
      }

      return {
        success: false,
        error: {
          code: 'API_ERROR',
          message: `API call failed: ${response.status}`,
          details: errorText,
        },
      }
    }

    const data = await response.json() as T
    return { success: true, data }
  } catch (error) {
    return {
      success: false,
      error: {
        code: 'API_CALL_ERROR',
        message: error instanceof Error ? error.message : 'Unknown error during API call',
      },
    }
  }
}

// ============================================
// Seller Info Methods
// ============================================

interface SellersResponse {
  payload: Array<{
    sellerId: string
    marketplaceId: string
    businessName?: string
  }>
}

/**
 * Get seller participation (marketplace info)
 * This is a good test to verify the connection works
 */
export async function getSellerInfo(credentialId: string): Promise<AmazonSpApiResponse<SellersResponse>> {
  return apiCall<SellersResponse>(credentialId, '/sellers/v1/marketplaceParticipations')
}

// ============================================
// Token Revocation
// ============================================

/**
 * Revoke access (mark credential as revoked in database)
 */
export async function revokeAccess(credentialId: string): Promise<void> {
  await prisma.integrationCredential.update({
    where: { id: credentialId },
    data: {
      status: 'revoked',
      encryptedAccessToken: '', // Clear sensitive data
      encryptedRefreshToken: null,
      expiresAt: null,
    },
  })

  logCredentialAccess({
    credentialId,
    integrationType: 'amazon_sp',
    action: 'delete',
  })
}

// ============================================
// Connection Verification
// ============================================

/**
 * Verify the connection is working by making a test API call
 */
export async function verifyConnection(credentialId: string): Promise<AmazonSpApiResponse<boolean>> {
  const result = await getSellerInfo(credentialId)

  if (result.success) {
    return { success: true, data: true }
  }

  return {
    success: false,
    error: result.error,
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] All imports resolve correctly
- [ ] AWS Signature V4 signing implemented
- [ ] Token refresh middleware complete
- [ ] No TypeScript errors
- [ ] Follows amazon-ads client patterns

---

## Phase 4: API Routes

### Subtask 4.1: Create Connect Route
**File**: `/home/pbrown/SkuInventory/src/app/api/integrations/amazon-sp/connect/route.ts`
**Pattern**: Follow `/src/app/api/integrations/amazon-ads/connect/route.ts`
**Instructions**:

```typescript
/**
 * POST /api/integrations/amazon-sp/connect
 *
 * Initiates OAuth flow for Amazon SP-API connection.
 * Admin only.
 */

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions, getSelectedCompanyRole } from '@/lib/auth'
import { randomBytes } from 'crypto'
import { getAuthUrl } from '@/services/amazon-sp-api/client'
import { storeOAuthState } from '@/services/amazon-sp-api/auth'

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check selectedCompanyId BEFORE role check to return proper 400 error
    const selectedCompanyId = session.user.selectedCompanyId
    if (!selectedCompanyId) {
      return NextResponse.json(
        { error: 'No company selected. Please refresh the page and try again.' },
        { status: 400 }
      )
    }

    // Admin only
    const companyRole = getSelectedCompanyRole(session)
    if (companyRole !== 'admin') {
      return NextResponse.json(
        { error: 'Admin permission required' },
        { status: 403 }
      )
    }

    // Parse request body
    let brandId: string | undefined
    try {
      const body = await request.json()
      brandId = body.brandId
    } catch {
      // Body is optional
    }

    const companyId = selectedCompanyId

    // Generate secure state token for CSRF protection
    const state = randomBytes(32).toString('hex')

    // Store state with company/brand context (expires in 10 minutes)
    storeOAuthState(state, { companyId, brandId })

    // Generate authorization URL
    const authUrl = getAuthUrl(state)

    return NextResponse.json({
      authUrl,
      state,
    })
  } catch (error) {
    console.error('Error initiating Amazon SP-API OAuth:', error)
    return NextResponse.json(
      { error: 'Failed to initiate connection' },
      { status: 500 }
    )
  }
}
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] Admin-only authorization check
- [ ] State token generation
- [ ] Returns authUrl

### Subtask 4.2: Create Callback Route
**File**: `/home/pbrown/SkuInventory/src/app/api/integrations/amazon-sp/callback/route.ts`
**Pattern**: Follow `/src/app/api/integrations/amazon-ads/callback/route.ts`
**Instructions**:

```typescript
/**
 * GET /api/integrations/amazon-sp/callback
 *
 * OAuth callback handler for Amazon SP-API.
 * Exchanges spapi_oauth_code for tokens and stores encrypted credentials.
 */

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { encrypt, logCredentialAudit } from '@/lib/encryption'
import { exchangeCode, getSellerInfo } from '@/services/amazon-sp-api/client'
import { retrieveOAuthState } from '@/services/amazon-sp-api/auth'

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams
  // SP-API uses spapi_oauth_code instead of code
  const code = searchParams.get('spapi_oauth_code')
  const state = searchParams.get('state')
  const sellingPartnerId = searchParams.get('selling_partner_id')
  const error = searchParams.get('error')
  const errorDescription = searchParams.get('error_description')

  // Handle OAuth errors
  if (error) {
    console.error('Amazon SP-API OAuth error:', error, errorDescription)
    return NextResponse.redirect(
      new URL(`/integrations?error=${encodeURIComponent(errorDescription || error)}`, request.url)
    )
  }

  // Validate required parameters
  if (!code || !state) {
    return NextResponse.redirect(
      new URL('/integrations?error=Missing%20authorization%20code%20or%20state', request.url)
    )
  }

  // Verify state token (CSRF protection)
  const stateData = retrieveOAuthState(state)
  if (!stateData) {
    return NextResponse.redirect(
      new URL('/integrations?error=Invalid%20or%20expired%20state%20token', request.url)
    )
  }

  const { companyId, brandId } = stateData

  try {
    // Exchange authorization code for tokens
    const tokenResult = await exchangeCode(code)

    if (!tokenResult.success || !tokenResult.data) {
      console.error('Token exchange failed:', tokenResult.error)
      return NextResponse.redirect(
        new URL(`/integrations?error=${encodeURIComponent(tokenResult.error?.message || 'Token exchange failed')}`, request.url)
      )
    }

    const { access_token, refresh_token, expires_in } = tokenResult.data

    // Require refresh token for SP-API (needed for long-term access)
    if (!refresh_token) {
      return NextResponse.redirect(
        new URL('/integrations?error=No%20refresh%20token%20received', request.url)
      )
    }

    // Calculate token expiry
    const expiresAt = new Date(Date.now() + expires_in * 1000)

    // Create credential
    const credential = await prisma.integrationCredential.create({
      data: {
        companyId,
        brandId: brandId || null,
        integrationType: 'amazon_sp',
        encryptedAccessToken: encrypt(access_token, { integrationType: 'amazon_sp' }),
        encryptedRefreshToken: encrypt(refresh_token, { integrationType: 'amazon_sp' }),
        scopes: ['sellingpartnerapi::migration'],
        expiresAt,
        status: 'active',
        externalAccountId: sellingPartnerId || null,
      },
    })

    // Get seller info to populate account name
    const sellerResult = await getSellerInfo(credential.id)

    let externalAccountName: string | null = null

    if (sellerResult.success && sellerResult.data?.payload?.[0]) {
      const seller = sellerResult.data.payload[0]
      externalAccountName = seller.businessName || `Amazon Seller (${seller.sellerId})`

      // Update credential with account info
      await prisma.integrationCredential.update({
        where: { id: credential.id },
        data: {
          externalAccountId: seller.sellerId,
          externalAccountName,
        },
      })
    }

    // Log successful credential creation
    logCredentialAudit({
      action: 'store',
      credentialId: credential.id,
      integrationType: 'amazon_sp',
      timestamp: new Date(),
      success: true,
      metadata: { sellingPartnerId, externalAccountName },
    })

    // Redirect to integrations page with success
    return NextResponse.redirect(
      new URL('/integrations?status=connected&type=amazon-sp', request.url)
    )
  } catch (error) {
    console.error('Error in Amazon SP-API callback:', error)

    // Log failed credential creation
    logCredentialAudit({
      action: 'store',
      integrationType: 'amazon_sp',
      timestamp: new Date(),
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    })

    return NextResponse.redirect(
      new URL('/integrations?error=Failed%20to%20complete%20connection', request.url)
    )
  }
}
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] Handles spapi_oauth_code parameter
- [ ] State token validation
- [ ] Token encryption
- [ ] Seller info lookup
- [ ] Error handling and redirects

### Subtask 4.3: Create Status Route
**File**: `/home/pbrown/SkuInventory/src/app/api/integrations/amazon-sp/status/route.ts`
**Pattern**: Follow `/src/app/api/integrations/amazon-ads/status/route.ts`
**Instructions**:

```typescript
/**
 * GET /api/integrations/amazon-sp/status
 *
 * Returns Amazon SP-API connection status.
 * Any authenticated user can view.
 */

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const searchParams = request.nextUrl.searchParams
    const credentialId = searchParams.get('credentialId')
    const brandId = searchParams.get('brandId')

    const companyId = session.user.selectedCompanyId

    if (!companyId) {
      return NextResponse.json({ error: 'No company selected' }, { status: 400 })
    }

    // Build where clause
    const where: {
      companyId: string
      integrationType: string
      id?: string
      brandId?: string | null
    } = {
      companyId,
      integrationType: 'amazon_sp',
    }

    if (credentialId) {
      where.id = credentialId
    }

    if (brandId) {
      where.brandId = brandId
    }

    // Get credentials with last sync info
    const credentials = await prisma.integrationCredential.findMany({
      where,
      select: {
        id: true,
        brandId: true,
        brand: {
          select: {
            id: true,
            name: true,
          },
        },
        status: true,
        externalAccountId: true,
        externalAccountName: true,
        lastUsedAt: true,
        lastErrorAt: true,
        lastError: true,
        createdAt: true,
        syncLogs: {
          orderBy: { startedAt: 'desc' },
          take: 1,
          select: {
            id: true,
            status: true,
            startedAt: true,
            completedAt: true,
            recordsProcessed: true,
            errorMessage: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    })

    return NextResponse.json({
      credentials: credentials.map(cred => ({
        id: cred.id,
        brandId: cred.brandId,
        brandName: cred.brand?.name,
        status: cred.status,
        sellerId: cred.externalAccountId,
        businessName: cred.externalAccountName,
        lastSyncAt: cred.syncLogs[0]?.completedAt || cred.syncLogs[0]?.startedAt,
        lastSyncStatus: cred.syncLogs[0]?.status || null,
        lastError: cred.lastError,
        createdAt: cred.createdAt.toISOString(),
      })),
    })
  } catch (error) {
    console.error('Error fetching Amazon SP-API status:', error)
    return NextResponse.json(
      { error: 'Failed to fetch status' },
      { status: 500 }
    )
  }
}
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] Returns credential status
- [ ] Includes sync log info
- [ ] Handles filtering by brandId

---

## Phase 5: Validation

### Subtask 5.1: TypeScript Compilation Check
**Instructions**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] No TypeScript errors

### Subtask 5.2: Build Check
**Instructions**:
```bash
npm run build
```

**Completion Criteria**:
- [ ] Build completes successfully
- [ ] No build errors

### Subtask 5.3: Lint Check
**Instructions**:
```bash
npm run lint
```

**Completion Criteria**:
- [ ] No lint errors
- [ ] No lint warnings

---

## Summary of Deliverables

**Files Created**: 6
| File | Type | Description |
|------|------|-------------|
| `/src/services/amazon-sp-api/types.ts` | TypeScript | Type definitions |
| `/src/services/amazon-sp-api/auth.ts` | TypeScript | OAuth state management |
| `/src/services/amazon-sp-api/client.ts` | TypeScript | SP-API client with OAuth + AWS signing |
| `/src/app/api/integrations/amazon-sp/connect/route.ts` | API Route | OAuth initiation |
| `/src/app/api/integrations/amazon-sp/callback/route.ts` | API Route | OAuth callback |
| `/src/app/api/integrations/amazon-sp/status/route.ts` | API Route | Connection status |

**Files Modified**: 1
| File | Change |
|------|--------|
| `.env.example` | Add SP-API environment variables |

**Dependencies Added**: 2
| Package | Purpose |
|---------|---------|
| `aws4` | AWS Signature V4 signing |
| `@types/aws4` | TypeScript types for aws4 |

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 0 through Phase 5)
2. Install dependencies first (Phase 0.1)
3. Create types before client (Phase 1 before Phase 3)
4. Test compilation after each phase
5. Follow reference patterns from amazon-ads exactly
6. Use absolute paths for all file operations

## Test Strategy Note

- This feature primarily requires manual testing via OAuth flow
- Unit tests could be added for token refresh logic but are not required for MVP
- Integration testing requires actual Amazon SP-API credentials

## Key Technical Notes

1. **SP-API vs Ads API**: Different OAuth consent URL (Seller Central vs Amazon.com)
2. **AWS Signing**: Every SP-API request needs AWS Signature V4 - this is the main difference
3. **Token Lifetime**: Access tokens expire in 1 hour, same as Ads API
4. **Scope**: SP-API uses `sellingpartnerapi::migration` for initial authorization
5. **Callback Parameter**: SP-API uses `spapi_oauth_code` not `code`

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 20m |
| **Total** | **55m** |

---

## Sources Referenced

- [SP-API Endpoints](https://developer-docs.amazon.com/sp-api/docs/sp-api-endpoints)
- [Connect to the SP-API](https://developer-docs.amazon.com/sp-api/docs/connecting-to-the-selling-partner-api)
- [Authorize Applications](https://developer-docs.amazon.com/sp-api/docs/authorizing-selling-partner-api-applications)
- [aws4 npm package](https://www.npmjs.com/package/aws4)
- [@aws-sdk/signature-v4](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/Package/-smithy-signature-v4/)
