# Implementation Plan
**Generated**: 2025-12-31T23:45:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #347
**Parent Issue**: #338 (Complete Amazon Seller Central integration)
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #347
**Priority**: High (part of parent integration story)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="amazon-ads"` or None (focused on new report service)

### Issue Validation
**Status**: Valid
**Recent Changes**:
- `b9c811a` - Amazon Ads & Shopify data ingestion foundation
- Related issues #345, #346 closed (SP-API client and Orders API)

### Current State Assessment

**Existing Components:**
- `/src/services/amazon-ads/client.ts` - COMPLETE: Has `requestReport`, `getReportStatus`, `downloadReport` methods already defined
- `/src/services/amazon-ads/types.ts` - PARTIAL: Has basic report types, needs enhancement for search term report specifics
- `/src/services/amazon-ads/sync.ts` - COMPLETE: Syncs portfolios, campaigns, ad groups - needs report sync integration
- `/src/services/csv/parser.ts` - REFERENCE: Shows pattern for storing KeywordMetric records

**Database:**
- `KeywordMetric` model exists with proper fields for PPC data
- Fields include: impressions, clicks, ctr, spend, cpc, orders, sales, roas, acos, conversionRate
- Unique constraint: `@@unique([portfolioId, campaignId, adGroupId, keyword, matchType, date, source])`
- Source field supports: `'api'`, `'csv_amazon'`, `'csv_zonguru'`, `'csv_helium10'`

**API Routes:**
- `/api/integrations/amazon-ads/sync/route.ts` - Exists for manual sync trigger
- `/api/integrations/amazon-ads/reports/route.ts` - NEEDS CREATION

**Types:**
- `ReportRequest`, `ReportResponse`, `ReportMetrics` defined in types.ts
- `KeywordMetricRow` defined in csv/types.ts - reusable pattern

### Dependencies & Blockers

1. **Environment Variables** - Already configured:
   - `AMAZON_ADS_CLIENT_ID` (existing)
   - `AMAZON_ADS_CLIENT_SECRET` (existing)
   - `AMAZON_ADS_REDIRECT_URI` (existing)

2. **Node.js zlib** - Built-in module for gzip decompression (no new dependency needed)

3. **Existing Report Methods** - Already implemented in client.ts:
   - `requestReport()` - POST to request new report
   - `getReportStatus()` - GET to poll report status
   - `downloadReport()` - Download completed report as Buffer

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 6-8 hours
**Risk**: Low-Medium (report API async polling is the main complexity)

### Patterns Identified

**Primary**: `/src/services/csv/parser.ts` (lines 258-339)
- Pattern for batch processing keyword metrics
- Deduplication logic using findFirst + upsert pattern
- Source tracking with `sourceMapping`

**Secondary**: `/src/services/amazon-ads/sync.ts`
- Sync orchestration pattern
- SyncLog creation/update
- BatchResult tracking (processed, created, updated, failed)

**Tertiary**: `/src/services/csv/mappers/amazon-search-term.ts`
- Field transformation (parsePercentage, parseCurrency, parseInteger)
- Match type normalization
- Derived metric calculation (ACOS, ROAS, CTR, CPC)

### Ripple Effect Analysis

**Files Identified**: 4 files to modify/create

| File | Action | Reason |
|------|--------|--------|
| `/src/services/amazon-ads/reports.ts` | CREATE | New report service |
| `/src/services/amazon-ads/sync.ts` | MODIFY | Add report sync to orchestration |
| `/src/services/amazon-ads/types.ts` | MODIFY | Add search term report types |
| `/src/app/api/integrations/amazon-ads/reports/route.ts` | CREATE | Report fetch endpoint |

**Dependent Callers**: None (new feature)

---

## Executive Summary

This implementation adds the Amazon Advertising Reports API integration to fetch keyword performance data (search term reports) and store it in the KeywordMetric model. The workflow follows an async pattern: request report, poll for completion, download gzipped JSON, parse, and upsert records with calculated ACOS/ROAS metrics. The existing report methods in client.ts provide the API foundation.

## Phase 1: Type Definitions

### Subtask 1.1: Extend Report Types in types.ts

**File**: `/home/pbrown/SkuInventory/src/services/amazon-ads/types.ts`
**Pattern**: Follow existing type structure in same file
**Instructions**:

1. Add search term report row interface after line 170 (after `ReportMetrics`):

```typescript
// Search Term Report Row (from Amazon Ads API)
export interface SearchTermReportRow {
  date: string // YYYY-MM-DD
  campaignName: string
  adGroupName: string
  portfolioName?: string
  keyword?: string
  searchTerm: string
  matchType: string // BROAD, PHRASE, EXACT, TARGETING_EXPRESSION
  impressions: string // API returns as string
  clicks: string
  cost: string // in account currency
  attributedOrders7d?: string
  attributedSales7d?: string
}

// Parsed report data after decompression
export interface ParsedReportData {
  rows: SearchTermReportRow[]
  totalRows: number
}

// Report sync options
export interface ReportSyncOptions {
  credentialId: string
  profileId: string
  dateRange: {
    startDate: string // YYYY-MM-DD
    endDate: string // YYYY-MM-DD
  }
  campaignType?: 'sponsoredProducts' | 'sponsoredBrands' | 'sponsoredDisplay'
  triggeredById?: string
}

// Report sync result
export interface ReportSyncResult {
  syncLogId: string
  reportId?: string
  status: 'completed' | 'failed' | 'partial'
  recordsProcessed: number
  recordsCreated: number
  recordsUpdated: number
  recordsFailed: number
  errors: string[]
  duration: number
}
```

2. Update `ReportRequest` interface (around line 128) to match Amazon Ads API v3 format:

```typescript
export interface ReportRequest {
  name?: string
  startDate: string // YYYY-MM-DD
  endDate: string // YYYY-MM-DD
  configuration: {
    adProduct: 'SPONSORED_PRODUCTS' | 'SPONSORED_BRANDS' | 'SPONSORED_DISPLAY'
    groupBy: string[]
    columns: string[]
    reportTypeId: string
    timeUnit: 'SUMMARY' | 'DAILY'
    format: 'GZIP_JSON'
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] All new types are defined
- [ ] ReportRequest matches Amazon API v3 format
- [ ] TypeScript compiles without errors

---

## Phase 2: Report Service Implementation

### Subtask 2.1: Create Report Service

**File**: `/home/pbrown/SkuInventory/src/services/amazon-ads/reports.ts`
**Pattern**: Follow `/src/services/amazon-ads/sync.ts` structure
**Instructions**:

Create new file with the following structure:

```typescript
/**
 * Amazon Ads Report Service
 *
 * Handles requesting, polling, downloading, and processing
 * search term reports from Amazon Advertising API.
 */

import { gunzipSync } from 'zlib'
import { prisma } from '@/lib/db'
import {
  requestReport,
  getReportStatus,
  downloadReport,
  getProfiles,
} from './client'
import type {
  ReportRequest,
  ReportResponse,
  SearchTermReportRow,
  ParsedReportData,
  ReportSyncOptions,
  ReportSyncResult,
} from './types'

// ============================================
// Configuration
// ============================================

const POLL_INTERVAL_MS = 5000 // 5 seconds
const MAX_POLL_ATTEMPTS = 120 // 10 minutes max wait
const BATCH_SIZE = 100

// Column sets for different report types
const SP_SEARCH_TERM_COLUMNS = [
  'date',
  'campaignName',
  'adGroupName',
  'keyword',
  'searchTerm',
  'matchType',
  'impressions',
  'clicks',
  'cost',
  'attributedOrders7d',
  'attributedSales7d',
]

// ============================================
// Report Request & Polling
// ============================================

/**
 * Request a Sponsored Products search term report
 */
export async function requestSearchTermReport(
  credentialId: string,
  profileId: string,
  startDate: string,
  endDate: string
): Promise<{ success: boolean; reportId?: string; error?: string }> {
  const reportRequest: ReportRequest = {
    name: `SP Search Term Report ${startDate} to ${endDate}`,
    startDate,
    endDate,
    configuration: {
      adProduct: 'SPONSORED_PRODUCTS',
      groupBy: ['searchTerm'],
      columns: SP_SEARCH_TERM_COLUMNS,
      reportTypeId: 'spSearchTerm',
      timeUnit: 'DAILY',
      format: 'GZIP_JSON',
    },
  }

  const result = await requestReport(credentialId, profileId, reportRequest)

  if (!result.success || !result.data) {
    return {
      success: false,
      error: result.error?.message || 'Failed to request report',
    }
  }

  return {
    success: true,
    reportId: result.data.reportId,
  }
}

/**
 * Poll for report completion
 */
export async function pollReportStatus(
  credentialId: string,
  profileId: string,
  reportId: string
): Promise<{ success: boolean; downloadUrl?: string; error?: string }> {
  for (let attempt = 0; attempt < MAX_POLL_ATTEMPTS; attempt++) {
    const result = await getReportStatus(credentialId, profileId, reportId)

    if (!result.success || !result.data) {
      return {
        success: false,
        error: result.error?.message || 'Failed to get report status',
      }
    }

    const status = result.data.status

    if (status === 'COMPLETED') {
      return {
        success: true,
        downloadUrl: result.data.location,
      }
    }

    if (status === 'FAILED') {
      return {
        success: false,
        error: result.data.statusDetails || 'Report generation failed',
      }
    }

    // Still in progress, wait and retry
    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS))
  }

  return {
    success: false,
    error: 'Report polling timed out',
  }
}

// ============================================
// Report Download & Parsing
// ============================================

/**
 * Download and decompress report data
 */
export async function downloadAndParseReport(
  downloadUrl: string
): Promise<{ success: boolean; data?: ParsedReportData; error?: string }> {
  const downloadResult = await downloadReport(downloadUrl)

  if (!downloadResult.success || !downloadResult.data) {
    return {
      success: false,
      error: downloadResult.error?.message || 'Failed to download report',
    }
  }

  try {
    // Decompress gzipped data
    const decompressed = gunzipSync(downloadResult.data)
    const jsonString = decompressed.toString('utf-8')
    const rows = JSON.parse(jsonString) as SearchTermReportRow[]

    return {
      success: true,
      data: {
        rows,
        totalRows: rows.length,
      },
    }
  } catch (error) {
    return {
      success: false,
      error: `Failed to parse report: ${error instanceof Error ? error.message : 'Unknown error'}`,
    }
  }
}

// ============================================
// Data Mapping & Storage
// ============================================

/**
 * Normalize match type from Amazon format to our standard
 */
function normalizeMatchType(matchType: string): 'exact' | 'phrase' | 'broad' | 'auto' {
  const lower = matchType.toLowerCase()
  if (lower === 'exact') return 'exact'
  if (lower === 'phrase') return 'phrase'
  if (lower === 'broad') return 'broad'
  if (lower.includes('targeting') || lower === 'auto') return 'auto'
  return 'auto'
}

/**
 * Parse string to number, handling empty strings
 */
function parseNumber(value: string | undefined, defaultValue = 0): number {
  if (!value) return defaultValue
  const num = parseFloat(value)
  return isNaN(num) ? defaultValue : num
}

/**
 * Calculate derived metrics
 */
function calculateMetrics(
  impressions: number,
  clicks: number,
  spend: number,
  orders: number,
  sales: number
): { ctr?: number; cpc?: number; acos?: number; roas?: number; conversionRate?: number } {
  return {
    ctr: impressions > 0 ? clicks / impressions : undefined,
    cpc: clicks > 0 ? spend / clicks : undefined,
    acos: sales > 0 ? spend / sales : undefined,
    roas: spend > 0 ? sales / spend : undefined,
    conversionRate: clicks > 0 ? orders / clicks : undefined,
  }
}

/**
 * Process and store report rows to KeywordMetric
 */
export async function storeReportData(
  rows: SearchTermReportRow[],
  credentialId: string
): Promise<{ created: number; updated: number; failed: number; errors: string[] }> {
  let created = 0
  let updated = 0
  let failed = 0
  const errors: string[] = []

  // Lookup maps for portfolio/campaign/adGroup IDs
  const campaignMap = new Map<string, { id: string; portfolioId: string | null }>()
  const adGroupMap = new Map<string, string>()

  // Pre-load campaigns for this credential
  const campaigns = await prisma.adCampaign.findMany({
    where: { credentialId },
    select: { id: true, name: true, portfolioId: true },
  })
  campaigns.forEach(c => campaignMap.set(c.name, { id: c.id, portfolioId: c.portfolioId }))

  // Pre-load ad groups
  const adGroups = await prisma.adGroup.findMany({
    where: { campaign: { credentialId } },
    select: { id: true, name: true, campaignId: true },
  })
  adGroups.forEach(ag => adGroupMap.set(`${ag.campaignId}:${ag.name}`, ag.id))

  // Process in batches
  for (let i = 0; i < rows.length; i += BATCH_SIZE) {
    const batch = rows.slice(i, i + BATCH_SIZE)

    for (const row of batch) {
      try {
        const keyword = row.searchTerm?.trim() || row.keyword?.trim()
        if (!keyword) {
          failed++
          continue
        }

        const matchType = normalizeMatchType(row.matchType)
        const date = new Date(row.date)
        const impressions = parseNumber(row.impressions)
        const clicks = parseNumber(row.clicks)
        const spend = parseNumber(row.cost)
        const orders = parseNumber(row.attributedOrders7d)
        const sales = parseNumber(row.attributedSales7d)

        const metrics = calculateMetrics(impressions, clicks, spend, orders, sales)

        // Lookup campaign and ad group
        const campaignInfo = campaignMap.get(row.campaignName)
        const campaignId = campaignInfo?.id || null
        const portfolioId = campaignInfo?.portfolioId || null
        const adGroupId = campaignId
          ? adGroupMap.get(`${campaignId}:${row.adGroupName}`) || null
          : null

        // Check for existing record
        const existing = await prisma.keywordMetric.findFirst({
          where: {
            keyword,
            matchType,
            date,
            source: 'api',
            portfolioId,
            campaignId,
            adGroupId,
          },
        })

        if (existing) {
          await prisma.keywordMetric.update({
            where: { id: existing.id },
            data: {
              impressions,
              clicks,
              ctr: metrics.ctr,
              spend,
              cpc: metrics.cpc,
              orders,
              sales,
              roas: metrics.roas,
              acos: metrics.acos,
              conversionRate: metrics.conversionRate,
              updatedAt: new Date(),
            },
          })
          updated++
        } else {
          await prisma.keywordMetric.create({
            data: {
              keyword,
              matchType,
              date,
              portfolioId,
              campaignId,
              adGroupId,
              impressions,
              clicks,
              ctr: metrics.ctr,
              spend,
              cpc: metrics.cpc,
              orders,
              sales,
              roas: metrics.roas,
              acos: metrics.acos,
              conversionRate: metrics.conversionRate,
              source: 'api',
              metadata: {
                originalSearchTerm: row.searchTerm,
                originalKeyword: row.keyword,
              },
            },
          })
          created++
        }
      } catch (error) {
        failed++
        errors.push(`Row error: ${error instanceof Error ? error.message : 'Unknown error'}`)
      }
    }
  }

  return { created, updated, failed, errors }
}

// ============================================
// Main Sync Orchestrator
// ============================================

/**
 * Full report sync workflow
 */
export async function syncSearchTermReport(
  options: ReportSyncOptions
): Promise<ReportSyncResult> {
  const startTime = Date.now()
  const errors: string[] = []
  let recordsProcessed = 0
  let recordsCreated = 0
  let recordsUpdated = 0
  let recordsFailed = 0
  let reportId: string | undefined

  // Create sync log
  const syncLog = await prisma.syncLog.create({
    data: {
      credentialId: options.credentialId,
      integrationType: 'amazon_ads',
      syncType: 'full',
      status: 'running',
      triggeredById: options.triggeredById,
      metadata: {
        reportType: 'spSearchTerm',
        dateRange: options.dateRange,
      },
    },
  })

  try {
    // Step 1: Request report
    const requestResult = await requestSearchTermReport(
      options.credentialId,
      options.profileId,
      options.dateRange.startDate,
      options.dateRange.endDate
    )

    if (!requestResult.success || !requestResult.reportId) {
      throw new Error(requestResult.error || 'Failed to request report')
    }

    reportId = requestResult.reportId

    // Step 2: Poll for completion
    const pollResult = await pollReportStatus(
      options.credentialId,
      options.profileId,
      reportId
    )

    if (!pollResult.success || !pollResult.downloadUrl) {
      throw new Error(pollResult.error || 'Report generation failed')
    }

    // Step 3: Download and parse
    const parseResult = await downloadAndParseReport(pollResult.downloadUrl)

    if (!parseResult.success || !parseResult.data) {
      throw new Error(parseResult.error || 'Failed to parse report')
    }

    recordsProcessed = parseResult.data.totalRows

    // Step 4: Store data
    const storeResult = await storeReportData(
      parseResult.data.rows,
      options.credentialId
    )

    recordsCreated = storeResult.created
    recordsUpdated = storeResult.updated
    recordsFailed = storeResult.failed
    errors.push(...storeResult.errors)

    // Update sync log
    const status = errors.length > 0 ? 'partial' : 'completed'
    await prisma.syncLog.update({
      where: { id: syncLog.id },
      data: {
        status,
        completedAt: new Date(),
        recordsProcessed,
        recordsCreated,
        recordsUpdated,
        recordsFailed,
        errorMessage: errors.length > 0 ? errors.slice(0, 5).join('; ') : null,
        errorDetails: { errors, reportId },
      },
    })

    return {
      syncLogId: syncLog.id,
      reportId,
      status,
      recordsProcessed,
      recordsCreated,
      recordsUpdated,
      recordsFailed,
      errors,
      duration: Date.now() - startTime,
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    errors.push(errorMessage)

    await prisma.syncLog.update({
      where: { id: syncLog.id },
      data: {
        status: 'failed',
        completedAt: new Date(),
        recordsProcessed,
        recordsCreated,
        recordsUpdated,
        recordsFailed,
        errorMessage,
        errorDetails: { errors, reportId },
      },
    })

    return {
      syncLogId: syncLog.id,
      reportId,
      status: 'failed',
      recordsProcessed,
      recordsCreated,
      recordsUpdated,
      recordsFailed,
      errors,
      duration: Date.now() - startTime,
    }
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] All imports resolve correctly
- [ ] TypeScript compiles without errors
- [ ] Lint passes

---

## Phase 3: API Route Implementation

### Subtask 3.1: Create Reports API Route

**File**: `/home/pbrown/SkuInventory/src/app/api/integrations/amazon-ads/reports/route.ts`
**Pattern**: Follow `/src/app/api/integrations/amazon-ads/sync/route.ts`
**Instructions**:

Create directory and file:

```typescript
/**
 * POST /api/integrations/amazon-ads/reports
 *
 * Triggers search term report sync for Amazon Ads.
 * Admin or Ops only.
 */

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions, getSelectedCompanyRole } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { getProfiles } from '@/services/amazon-ads/client'
import { syncSearchTermReport } from '@/services/amazon-ads/reports'

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check selectedCompanyId BEFORE role check
    const selectedCompanyId = session.user.selectedCompanyId
    if (!selectedCompanyId) {
      return NextResponse.json(
        { error: 'No company selected. Please refresh the page and try again.' },
        { status: 400 }
      )
    }

    // Admin or Ops only
    const companyRole = getSelectedCompanyRole(session)
    if (companyRole !== 'admin' && companyRole !== 'ops') {
      return NextResponse.json(
        { error: 'Admin or Ops permission required' },
        { status: 403 }
      )
    }

    const body = await request.json()
    const { credentialId, startDate, endDate } = body

    if (!credentialId) {
      return NextResponse.json(
        { error: 'credentialId is required' },
        { status: 400 }
      )
    }

    if (!startDate || !endDate) {
      return NextResponse.json(
        { error: 'startDate and endDate are required (YYYY-MM-DD format)' },
        { status: 400 }
      )
    }

    // Validate date format
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/
    if (!dateRegex.test(startDate) || !dateRegex.test(endDate)) {
      return NextResponse.json(
        { error: 'Dates must be in YYYY-MM-DD format' },
        { status: 400 }
      )
    }

    // Verify credential exists and belongs to user's company
    const credential = await prisma.integrationCredential.findUnique({
      where: { id: credentialId },
    })

    if (!credential) {
      return NextResponse.json(
        { error: 'Credential not found' },
        { status: 404 }
      )
    }

    if (credential.companyId !== selectedCompanyId) {
      return NextResponse.json(
        { error: 'Access denied' },
        { status: 403 }
      )
    }

    if (credential.integrationType !== 'amazon_ads') {
      return NextResponse.json(
        { error: 'Invalid credential type' },
        { status: 400 }
      )
    }

    if (credential.status !== 'active') {
      return NextResponse.json(
        { error: 'Credential is not active. Please reconnect.' },
        { status: 400 }
      )
    }

    // Get profile ID
    const profilesResult = await getProfiles(credentialId)
    if (!profilesResult.success || !profilesResult.data || profilesResult.data.length === 0) {
      return NextResponse.json(
        { error: 'No advertising profiles found' },
        { status: 400 }
      )
    }

    // Use US marketplace profile
    const profile = profilesResult.data.find(p => p.countryCode === 'US') || profilesResult.data[0]
    const profileId = profile.profileId.toString()

    // Start sync (runs in background after initial response)
    const syncPromise = syncSearchTermReport({
      credentialId,
      profileId,
      dateRange: { startDate, endDate },
      triggeredById: session.user.id,
    })

    // Wait briefly for sync to start
    const result = await Promise.race([
      syncPromise,
      new Promise<null>(resolve => setTimeout(() => resolve(null), 100)),
    ])

    if (result) {
      return NextResponse.json({
        syncLogId: result.syncLogId,
        reportId: result.reportId,
        status: result.status,
        message: `Report sync ${result.status}. Processed ${result.recordsProcessed} records.`,
      })
    }

    // Sync is running in background
    const recentLog = await prisma.syncLog.findFirst({
      where: {
        credentialId,
        triggeredById: session.user.id,
        status: 'running',
      },
      orderBy: { startedAt: 'desc' },
    })

    return NextResponse.json(
      {
        syncLogId: recentLog?.id,
        status: 'started',
        message: 'Report sync initiated. Check sync log for progress.',
      },
      { status: 202 }
    )
  } catch (error) {
    console.error('Error triggering report sync:', error)
    return NextResponse.json(
      { error: 'Failed to trigger report sync' },
      { status: 500 }
    )
  }
}
```

**Validation Commands**:
```bash
mkdir -p src/app/api/integrations/amazon-ads/reports
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Directory and file created
- [ ] Route compiles without errors
- [ ] Lint passes
- [ ] Authentication enforced

---

## Phase 4: Integration with Sync Service

### Subtask 4.1: Add Report Sync to Main Sync Orchestration (Optional Enhancement)

**File**: `/home/pbrown/SkuInventory/src/services/amazon-ads/sync.ts`
**Pattern**: Follow existing sync pattern
**Instructions**:

Add import at top (around line 14):
```typescript
import { syncSearchTermReport } from './reports'
```

Add optional report sync to `syncAll` function after ad groups sync (around line 100):

```typescript
    // Sync reports if date range provided
    if (options.dateRange) {
      try {
        const reportResult = await syncSearchTermReport({
          credentialId: options.credentialId,
          profileId,
          dateRange: options.dateRange,
          triggeredById: options.triggeredById,
        })

        recordsProcessed += reportResult.recordsProcessed
        recordsCreated += reportResult.recordsCreated
        recordsUpdated += reportResult.recordsUpdated
        recordsFailed += reportResult.recordsFailed

        if (reportResult.errors.length > 0) {
          errors.push(...reportResult.errors.slice(0, 5))
        }
      } catch (error) {
        errors.push(`Report sync error: ${error instanceof Error ? error.message : 'Unknown error'}`)
      }
    }
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Import added correctly
- [ ] Report sync integrated conditionally
- [ ] TypeScript compiles
- [ ] Lint passes

---

## Phase 5: Validation & Testing

### Subtask 5.1: Build Verification

**Instructions**:
```bash
# TypeScript check
npx tsc --noEmit

# Build check
npm run build

# Lint check
npm run lint
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` completes successfully
- [ ] `npm run lint` passes with no errors

### Subtask 5.2: Unit Test Creation (Optional)

**File**: `/home/pbrown/SkuInventory/tests/services/amazon-ads/reports.test.ts`
**Pattern**: Follow existing test patterns
**Instructions**:

Create basic unit tests for:
- `normalizeMatchType` function
- `parseNumber` function
- `calculateMetrics` function

**Completion Criteria**:
- [ ] Tests created
- [ ] Tests pass with `npm test`

---

## Summary of Deliverables

**Files Created**: 2
| File | Purpose |
|------|---------|
| `/src/services/amazon-ads/reports.ts` | Report sync service |
| `/src/app/api/integrations/amazon-ads/reports/route.ts` | API endpoint |

**Files Modified**: 2
| File | Changes |
|------|---------|
| `/src/services/amazon-ads/types.ts` | Add report-specific types |
| `/src/services/amazon-ads/sync.ts` | Optional: integrate report sync |

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 through Phase 5)
2. Complete each phase fully before moving to next
3. Test completion criteria before proceeding
4. Follow reference patterns exactly
5. Run validation commands after each file change

## Test Strategy Note

- **Test Type**: TARGETED (affected modules only)
- Use Vitest for unit tests
- Manual testing: Use existing Amazon Ads credential to trigger report sync via API
- Verify KeywordMetric records created with `source='api'`

## Performance Metrics

| Phase | Estimated Duration |
|-------|--------------------|
| Phase 1: Type Definitions | 30m |
| Phase 2: Report Service | 2h |
| Phase 3: API Route | 45m |
| Phase 4: Integration | 30m |
| Phase 5: Validation | 30m |
| **Total** | **4-5h** |

## Risk Considerations

1. **Report Polling Timeout**: MAX_POLL_ATTEMPTS = 120 (10 min) should be sufficient for most reports. Consider making configurable.

2. **Large Reports**: Batch processing with BATCH_SIZE = 100 prevents memory issues. May need tuning.

3. **API Rate Limits**: Current implementation doesn't add delays between batches. May need rate limiting for large date ranges.

4. **Gzip Decompression**: Node.js built-in zlib is synchronous. For very large reports, consider streaming decompression.
