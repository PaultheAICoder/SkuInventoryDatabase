# Implementation Plan
**Generated**: 2025-12-04T16:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #115
**Estimated Build Time**: 4-6 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #115
**Priority**: High (blocks API/UI sub-issues)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED (unit tests for service functions)
**Suggested Filter**: `--filter="forecast"` or `tests/unit/forecast-service.test.ts`

### Issue Validation
**Status**: Valid
**Recent Changes**: Issue #112 (types/schema) completed - ForecastConfig model and forecast.ts types exist

### Current State Assessment
- **Existing Types**: `src/types/forecast.ts` - Complete with all interfaces (ComponentForecast, ForecastConfigInput, etc.)
- **Database**: ForecastConfig model exists in Prisma schema with lookbackDays, safetyDays, excludedTransactionTypes
- **Transaction Model**: TransactionLine has componentId, quantityChange, transaction.type, transaction.createdAt
- **Component Model**: Has leadTimeDays field for reorder calculations
- **Inventory Service**: `getComponentQuantities()` available for on-hand values
- **Service File**: `src/services/forecast.ts` does NOT exist yet - needs to be created

### Dependencies & Blockers
1. **Dependency Resolved**: Issue #112 completed - types and schema available
2. **Service Pattern**: Follow `src/services/bom.ts` and `src/services/analytics.ts` patterns
3. **Quantity Function**: Use `getComponentQuantities` from `src/services/inventory.ts`

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 4-6 hours
**Risk**: Low - patterns well-established, types pre-defined

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/services/bom.ts` - Service structure, Prisma queries, batch operations
**Secondary**: `/home/pbrown/SkuInventory/src/services/analytics.ts` - Complex aggregation queries, groupBy patterns
**Types Reference**: `/home/pbrown/SkuInventory/src/types/forecast.ts` - All TypeScript interfaces

### Ripple Effect Analysis
**Files Identified**: 2 (service creation + tests)
- `src/services/forecast.ts` - NEW file to create
- `tests/unit/forecast-service.test.ts` - NEW test file to create

---

## Executive Summary
Create the core forecast service (`src/services/forecast.ts`) that calculates consumption rates from transaction history, estimates component runout dates, and generates reorder recommendations. The service will provide 5 main functions: `calculateConsumptionRate`, `calculateRunoutDate`, `calculateReorderRecommendation`, `getComponentForecasts`, and `getComponentForecastById`. All types are pre-defined in Issue #112.

---

## Phase 1: Service File Creation and Core Functions

### Subtask 1.1: Create Forecast Service File with Imports
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/bom.ts` structure
**Instructions**:
1. Create new file `src/services/forecast.ts`
2. Add imports for Prisma client, types, and inventory service:
   ```typescript
   import { prisma } from '@/lib/db'
   import { Prisma } from '@prisma/client'
   import { getComponentQuantities } from './inventory'
   import {
     ComponentForecast,
     ForecastConfigInput,
     DEFAULT_FORECAST_CONFIG,
     ForecastAssumptions,
   } from '@/types/forecast'
   ```
3. Add helper function to get or create ForecastConfig for a company:
   ```typescript
   async function getForecastConfig(companyId: string): Promise<ForecastConfigInput> {
     const config = await prisma.forecastConfig.findUnique({
       where: { companyId },
     })
     if (config) {
       return {
         lookbackDays: config.lookbackDays,
         safetyDays: config.safetyDays,
         excludedTransactionTypes: config.excludedTransactionTypes as string[],
       }
     }
     return DEFAULT_FORECAST_CONFIG
   }
   ```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created with correct imports
- [ ] `getForecastConfig` helper function implemented
- [ ] TypeScript compiles without errors

### Subtask 1.2: Implement calculateConsumptionRate Function
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Pattern**: Follow transaction aggregation in `/home/pbrown/SkuInventory/src/services/analytics.ts:41-67`
**Instructions**:
1. Add function signature:
   ```typescript
   export async function calculateConsumptionRate(
     componentId: string,
     lookbackDays: number = 30,
     excludedTypes: string[] = ['initial', 'adjustment']
   ): Promise<number>
   ```
2. Calculate date range:
   ```typescript
   const startDate = new Date()
   startDate.setDate(startDate.getDate() - lookbackDays)
   ```
3. Query transaction lines for negative quantity changes (consumption) within the lookback window:
   ```typescript
   const result = await prisma.transactionLine.aggregate({
     where: {
       componentId,
       quantityChange: { lt: 0 }, // Only consumption (negative)
       transaction: {
         status: 'approved',
         type: { notIn: excludedTypes as Prisma.TransactionType[] },
         createdAt: { gte: startDate },
       },
     },
     _sum: { quantityChange: true },
   })
   ```
4. Calculate average daily consumption:
   ```typescript
   const totalConsumed = Math.abs(result._sum.quantityChange?.toNumber() ?? 0)
   return totalConsumed / lookbackDays
   ```
5. Handle edge case of zero/sparse data gracefully (returns 0)

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Function queries transaction lines correctly
- [ ] Excludes specified transaction types
- [ ] Returns average daily consumption as a positive number
- [ ] Returns 0 for components with no consumption history

### Subtask 1.3: Implement calculateRunoutDate Function
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Instructions**:
1. Add pure function (no database access needed):
   ```typescript
   export function calculateRunoutDate(
     quantityOnHand: number,
     dailyConsumption: number
   ): { daysUntilRunout: number | null; runoutDate: Date | null } {
     // Handle zero consumption (infinite runway)
     if (dailyConsumption <= 0) {
       return { daysUntilRunout: null, runoutDate: null }
     }

     // Handle negative on-hand (already out)
     if (quantityOnHand <= 0) {
       return { daysUntilRunout: 0, runoutDate: new Date() }
     }

     const daysUntilRunout = Math.floor(quantityOnHand / dailyConsumption)
     const runoutDate = new Date()
     runoutDate.setDate(runoutDate.getDate() + daysUntilRunout)

     return { daysUntilRunout, runoutDate }
   }
   ```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Returns null for zero consumption (infinite runway)
- [ ] Returns 0/today for zero or negative on-hand
- [ ] Calculates correct days until runout
- [ ] Pure function with no side effects

### Subtask 1.4: Implement calculateReorderRecommendation Function
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Instructions**:
1. Add pure function:
   ```typescript
   export function calculateReorderRecommendation(params: {
     dailyConsumption: number
     leadTimeDays: number
     safetyDays: number
     runoutDate: Date | null
   }): { recommendedReorderQty: number; recommendedReorderDate: Date | null } {
     const { dailyConsumption, leadTimeDays, safetyDays, runoutDate } = params

     // Handle zero consumption
     if (dailyConsumption <= 0) {
       return { recommendedReorderQty: 0, recommendedReorderDate: null }
     }

     // Calculate reorder quantity: (leadTime + safety) * daily consumption
     const recommendedReorderQty = Math.ceil((leadTimeDays + safetyDays) * dailyConsumption)

     // Calculate reorder date: runoutDate - leadTimeDays
     let recommendedReorderDate: Date | null = null
     if (runoutDate) {
       recommendedReorderDate = new Date(runoutDate)
       recommendedReorderDate.setDate(recommendedReorderDate.getDate() - leadTimeDays)

       // If reorder date is in the past, set to today
       if (recommendedReorderDate < new Date()) {
         recommendedReorderDate = new Date()
       }
     }

     return { recommendedReorderQty, recommendedReorderDate }
   }
   ```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Returns 0 quantity for zero consumption
- [ ] Correctly calculates reorder quantity
- [ ] Correctly calculates reorder date
- [ ] Handles past reorder dates (sets to today)

---

## Phase 2: Batch Forecast Functions

### Subtask 2.1: Implement calculateConsumptionRates (Batch Version)
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Pattern**: Follow batch pattern in `/home/pbrown/SkuInventory/src/services/inventory.ts:120-148` (getComponentQuantities)
**Instructions**:
1. Add batch function for efficiency:
   ```typescript
   export async function calculateConsumptionRates(
     componentIds: string[],
     lookbackDays: number = 30,
     excludedTypes: string[] = ['initial', 'adjustment']
   ): Promise<Map<string, number>> {
     const startDate = new Date()
     startDate.setDate(startDate.getDate() - lookbackDays)

     const results = await prisma.transactionLine.groupBy({
       by: ['componentId'],
       where: {
         componentId: { in: componentIds },
         quantityChange: { lt: 0 },
         transaction: {
           status: 'approved',
           type: { notIn: excludedTypes as Prisma.TransactionType[] },
           createdAt: { gte: startDate },
         },
       },
       _sum: { quantityChange: true },
     })

     const consumptionRates = new Map<string, number>()

     // Initialize all to 0
     for (const id of componentIds) {
       consumptionRates.set(id, 0)
     }

     // Calculate daily rates
     for (const result of results) {
       const totalConsumed = Math.abs(result._sum.quantityChange?.toNumber() ?? 0)
       consumptionRates.set(result.componentId, totalConsumed / lookbackDays)
     }

     return consumptionRates
   }
   ```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Uses groupBy for efficient batch query
- [ ] Returns Map with all requested component IDs
- [ ] Components with no consumption return 0

### Subtask 2.2: Implement getComponentForecasts Main Function
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/bom.ts:107-168` (calculateMaxBuildableUnitsForSKUs)
**Instructions**:
1. Add main forecast function:
   ```typescript
   export async function getComponentForecasts(
     companyId: string,
     configOverride?: Partial<ForecastConfigInput>
   ): Promise<ComponentForecast[]> {
     // Get config (with overrides)
     const baseConfig = await getForecastConfig(companyId)
     const config: ForecastConfigInput = {
       ...baseConfig,
       ...configOverride,
     }

     const assumptions: ForecastAssumptions = {
       lookbackDays: config.lookbackDays,
       safetyDays: config.safetyDays,
       excludedTransactionTypes: config.excludedTransactionTypes,
     }

     // Get all active components for company
     const components = await prisma.component.findMany({
       where: {
         companyId,
         isActive: true,
       },
       select: {
         id: true,
         name: true,
         skuCode: true,
         leadTimeDays: true,
       },
     })

     if (components.length === 0) {
       return []
     }

     const componentIds = components.map(c => c.id)

     // Batch fetch quantities and consumption rates
     const [quantities, consumptionRates] = await Promise.all([
       getComponentQuantities(componentIds),
       calculateConsumptionRates(componentIds, config.lookbackDays, config.excludedTransactionTypes),
     ])

     // Build forecasts for each component
     const forecasts: ComponentForecast[] = []

     for (const component of components) {
       const quantityOnHand = quantities.get(component.id) ?? 0
       const averageDailyConsumption = consumptionRates.get(component.id) ?? 0

       const { daysUntilRunout, runoutDate } = calculateRunoutDate(
         quantityOnHand,
         averageDailyConsumption
       )

       const { recommendedReorderQty, recommendedReorderDate } = calculateReorderRecommendation({
         dailyConsumption: averageDailyConsumption,
         leadTimeDays: component.leadTimeDays,
         safetyDays: config.safetyDays,
         runoutDate,
       })

       forecasts.push({
         componentId: component.id,
         componentName: component.name,
         skuCode: component.skuCode,
         quantityOnHand,
         averageDailyConsumption,
         daysUntilRunout,
         runoutDate,
         recommendedReorderQty,
         recommendedReorderDate,
         leadTimeDays: component.leadTimeDays,
         assumptions,
       })
     }

     return forecasts
   }
   ```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Fetches all active components for company
- [ ] Uses batch queries for efficiency
- [ ] Builds complete ComponentForecast for each component
- [ ] Supports config overrides

### Subtask 2.3: Implement getComponentForecastById Single Component Version
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Instructions**:
1. Add single-component function:
   ```typescript
   export async function getComponentForecastById(
     componentId: string,
     configOverride?: Partial<ForecastConfigInput>
   ): Promise<ComponentForecast | null> {
     // Get component with company info
     const component = await prisma.component.findUnique({
       where: { id: componentId },
       select: {
         id: true,
         name: true,
         skuCode: true,
         leadTimeDays: true,
         companyId: true,
         isActive: true,
       },
     })

     if (!component || !component.isActive || !component.companyId) {
       return null
     }

     // Get config (with overrides)
     const baseConfig = await getForecastConfig(component.companyId)
     const config: ForecastConfigInput = {
       ...baseConfig,
       ...configOverride,
     }

     const assumptions: ForecastAssumptions = {
       lookbackDays: config.lookbackDays,
       safetyDays: config.safetyDays,
       excludedTransactionTypes: config.excludedTransactionTypes,
     }

     // Calculate consumption rate
     const averageDailyConsumption = await calculateConsumptionRate(
       componentId,
       config.lookbackDays,
       config.excludedTransactionTypes
     )

     // Get quantity on hand
     const quantities = await getComponentQuantities([componentId])
     const quantityOnHand = quantities.get(componentId) ?? 0

     // Calculate runout
     const { daysUntilRunout, runoutDate } = calculateRunoutDate(
       quantityOnHand,
       averageDailyConsumption
     )

     // Calculate reorder recommendation
     const { recommendedReorderQty, recommendedReorderDate } = calculateReorderRecommendation({
       dailyConsumption: averageDailyConsumption,
       leadTimeDays: component.leadTimeDays,
       safetyDays: config.safetyDays,
       runoutDate,
     })

     return {
       componentId: component.id,
       componentName: component.name,
       skuCode: component.skuCode,
       quantityOnHand,
       averageDailyConsumption,
       daysUntilRunout,
       runoutDate,
       recommendedReorderQty,
       recommendedReorderDate,
       leadTimeDays: component.leadTimeDays,
       assumptions,
     }
   }
   ```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Returns null for non-existent or inactive components
- [ ] Fetches component-specific config
- [ ] Returns complete ComponentForecast

---

## Phase 3: Unit Tests

### Subtask 3.1: Create Unit Test File with Mocks
**File**: `/home/pbrown/SkuInventory/tests/unit/forecast-service.test.ts`
**Pattern**: Follow `/home/pbrown/SkuInventory/tests/unit/bom-calculations.test.ts`
**Instructions**:
1. Create test file with Prisma mocks:
   ```typescript
   /**
    * Unit tests for forecast service functions
    * Tests consumption rate calculation, runout dates, and reorder recommendations
    */
   import { describe, it, expect, vi, beforeEach } from 'vitest'
   import { Prisma } from '@prisma/client'

   vi.mock('@/lib/db', () => ({
     prisma: {
       forecastConfig: {
         findUnique: vi.fn(),
       },
       component: {
         findMany: vi.fn(),
         findUnique: vi.fn(),
       },
       transactionLine: {
         aggregate: vi.fn(),
         groupBy: vi.fn(),
       },
     },
   }))

   vi.mock('@/services/inventory', () => ({
     getComponentQuantities: vi.fn(),
   }))

   import {
     calculateConsumptionRate,
     calculateRunoutDate,
     calculateReorderRecommendation,
     getComponentForecasts,
     getComponentForecastById,
   } from '@/services/forecast'
   import { prisma } from '@/lib/db'
   import { getComponentQuantities } from '@/services/inventory'
   ```

**Validation**:
```bash
npm test -- --run tests/unit/forecast-service.test.ts
```

**Completion Criteria**:
- [ ] Test file created with proper mocks
- [ ] Imports all functions to test

### Subtask 3.2: Add Tests for calculateRunoutDate (Pure Function)
**File**: `/home/pbrown/SkuInventory/tests/unit/forecast-service.test.ts`
**Instructions**:
1. Add test suite for calculateRunoutDate:
   ```typescript
   describe('calculateRunoutDate', () => {
     it('returns null for zero consumption (infinite runway)', () => {
       const result = calculateRunoutDate(100, 0)
       expect(result.daysUntilRunout).toBeNull()
       expect(result.runoutDate).toBeNull()
     })

     it('returns null for negative consumption', () => {
       const result = calculateRunoutDate(100, -5)
       expect(result.daysUntilRunout).toBeNull()
       expect(result.runoutDate).toBeNull()
     })

     it('returns 0 days for zero quantity on hand', () => {
       const result = calculateRunoutDate(0, 10)
       expect(result.daysUntilRunout).toBe(0)
     })

     it('returns 0 days for negative quantity on hand', () => {
       const result = calculateRunoutDate(-50, 10)
       expect(result.daysUntilRunout).toBe(0)
     })

     it('calculates correct days until runout', () => {
       const result = calculateRunoutDate(100, 10)
       expect(result.daysUntilRunout).toBe(10) // 100 / 10 = 10 days
     })

     it('floors decimal results', () => {
       const result = calculateRunoutDate(100, 7)
       expect(result.daysUntilRunout).toBe(14) // 100 / 7 = 14.28, floored to 14
     })
   })
   ```

**Validation**:
```bash
npm test -- --run tests/unit/forecast-service.test.ts
```

**Completion Criteria**:
- [ ] All edge cases tested
- [ ] Zero consumption returns null
- [ ] Calculation is correct

### Subtask 3.3: Add Tests for calculateReorderRecommendation (Pure Function)
**File**: `/home/pbrown/SkuInventory/tests/unit/forecast-service.test.ts`
**Instructions**:
1. Add test suite:
   ```typescript
   describe('calculateReorderRecommendation', () => {
     it('returns 0 quantity for zero consumption', () => {
       const result = calculateReorderRecommendation({
         dailyConsumption: 0,
         leadTimeDays: 7,
         safetyDays: 3,
         runoutDate: new Date('2025-12-20'),
       })
       expect(result.recommendedReorderQty).toBe(0)
       expect(result.recommendedReorderDate).toBeNull()
     })

     it('calculates correct reorder quantity', () => {
       const result = calculateReorderRecommendation({
         dailyConsumption: 10,
         leadTimeDays: 7,
         safetyDays: 3,
         runoutDate: new Date('2025-12-20'),
       })
       // (7 + 3) * 10 = 100
       expect(result.recommendedReorderQty).toBe(100)
     })

     it('calculates correct reorder date', () => {
       const runoutDate = new Date('2025-12-20')
       const result = calculateReorderRecommendation({
         dailyConsumption: 10,
         leadTimeDays: 7,
         safetyDays: 3,
         runoutDate,
       })
       // 2025-12-20 - 7 days = 2025-12-13
       expect(result.recommendedReorderDate?.toISOString().split('T')[0]).toBe('2025-12-13')
     })

     it('handles null runout date', () => {
       const result = calculateReorderRecommendation({
         dailyConsumption: 10,
         leadTimeDays: 7,
         safetyDays: 3,
         runoutDate: null,
       })
       expect(result.recommendedReorderDate).toBeNull()
     })

     it('ceils reorder quantity', () => {
       const result = calculateReorderRecommendation({
         dailyConsumption: 3.3,
         leadTimeDays: 7,
         safetyDays: 3,
         runoutDate: new Date('2025-12-20'),
       })
       // (7 + 3) * 3.3 = 33, ceil = 33
       expect(result.recommendedReorderQty).toBe(33)
     })
   })
   ```

**Validation**:
```bash
npm test -- --run tests/unit/forecast-service.test.ts
```

**Completion Criteria**:
- [ ] Quantity calculation tested
- [ ] Date calculation tested
- [ ] Edge cases handled

### Subtask 3.4: Add Tests for calculateConsumptionRate
**File**: `/home/pbrown/SkuInventory/tests/unit/forecast-service.test.ts`
**Instructions**:
1. Add test suite with mocked database:
   ```typescript
   describe('calculateConsumptionRate', () => {
     beforeEach(() => {
       vi.clearAllMocks()
     })

     it('returns 0 when no consumption history exists', async () => {
       vi.mocked(prisma.transactionLine.aggregate).mockResolvedValue({
         _sum: { quantityChange: null },
       } as never)

       const result = await calculateConsumptionRate('comp-1', 30, ['initial', 'adjustment'])
       expect(result).toBe(0)
     })

     it('calculates average daily consumption correctly', async () => {
       vi.mocked(prisma.transactionLine.aggregate).mockResolvedValue({
         _sum: { quantityChange: new Prisma.Decimal(-300) }, // 300 consumed over 30 days
       } as never)

       const result = await calculateConsumptionRate('comp-1', 30, ['initial', 'adjustment'])
       expect(result).toBe(10) // 300 / 30 = 10 per day
     })

     it('excludes specified transaction types', async () => {
       vi.mocked(prisma.transactionLine.aggregate).mockResolvedValue({
         _sum: { quantityChange: new Prisma.Decimal(-150) },
       } as never)

       await calculateConsumptionRate('comp-1', 30, ['initial', 'adjustment', 'receipt'])

       expect(prisma.transactionLine.aggregate).toHaveBeenCalledWith(
         expect.objectContaining({
           where: expect.objectContaining({
             transaction: expect.objectContaining({
               type: { notIn: ['initial', 'adjustment', 'receipt'] },
             }),
           }),
         })
       )
     })
   })
   ```

**Validation**:
```bash
npm test -- --run tests/unit/forecast-service.test.ts
```

**Completion Criteria**:
- [ ] Tests consumption rate calculation
- [ ] Tests exclusion of transaction types
- [ ] Tests zero history case

### Subtask 3.5: Add Tests for getComponentForecasts
**File**: `/home/pbrown/SkuInventory/tests/unit/forecast-service.test.ts`
**Instructions**:
1. Add integration-style unit test:
   ```typescript
   describe('getComponentForecasts', () => {
     beforeEach(() => {
       vi.clearAllMocks()
     })

     it('returns empty array when no active components', async () => {
       vi.mocked(prisma.forecastConfig.findUnique).mockResolvedValue(null)
       vi.mocked(prisma.component.findMany).mockResolvedValue([])

       const result = await getComponentForecasts('company-1')
       expect(result).toEqual([])
     })

     it('builds forecasts for all components', async () => {
       vi.mocked(prisma.forecastConfig.findUnique).mockResolvedValue(null)
       vi.mocked(prisma.component.findMany).mockResolvedValue([
         { id: 'comp-1', name: 'Component 1', skuCode: 'SKU-1', leadTimeDays: 7 },
         { id: 'comp-2', name: 'Component 2', skuCode: 'SKU-2', leadTimeDays: 14 },
       ] as never)

       vi.mocked(getComponentQuantities).mockResolvedValue(
         new Map([['comp-1', 100], ['comp-2', 200]])
       )

       vi.mocked(prisma.transactionLine.groupBy).mockResolvedValue([
         { componentId: 'comp-1', _sum: { quantityChange: new Prisma.Decimal(-300) } },
         { componentId: 'comp-2', _sum: { quantityChange: new Prisma.Decimal(-60) } },
       ] as never)

       const result = await getComponentForecasts('company-1')

       expect(result).toHaveLength(2)
       expect(result[0].componentId).toBe('comp-1')
       expect(result[0].averageDailyConsumption).toBe(10) // 300 / 30
       expect(result[1].componentId).toBe('comp-2')
       expect(result[1].averageDailyConsumption).toBe(2) // 60 / 30
     })
   })
   ```

**Validation**:
```bash
npm test -- --run tests/unit/forecast-service.test.ts
```

**Completion Criteria**:
- [ ] Tests empty component list
- [ ] Tests full forecast generation
- [ ] Tests config override

---

## Phase 4: Final Validation

### Subtask 4.1: Run Full TypeScript Check
**Instructions**:
1. Run TypeScript compiler:
   ```bash
   npx tsc --noEmit
   ```
2. Fix any type errors

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes without errors

### Subtask 4.2: Run Build Check
**Instructions**:
1. Run Next.js build:
   ```bash
   npm run build
   ```
2. Fix any build errors

**Completion Criteria**:
- [ ] `npm run build` passes without errors

### Subtask 4.3: Run Unit Tests
**Instructions**:
1. Run forecast service tests:
   ```bash
   npm test -- --run tests/unit/forecast-service.test.ts
   ```
2. Ensure all tests pass

**Completion Criteria**:
- [ ] All unit tests pass

### Subtask 4.4: Run Lint Check
**Instructions**:
1. Run linter:
   ```bash
   npm run lint
   ```
2. Fix any lint errors

**Completion Criteria**:
- [ ] `npm run lint` passes without errors

---

## Summary of Deliverables
**Files Created**: 2
- `src/services/forecast.ts` - Core forecast calculation service
- `tests/unit/forecast-service.test.ts` - Unit tests for forecast service

**Files Modified**: 0

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4)
2. Each phase depends on the previous phase's completion
3. Test completion criteria after each subtask
4. Follow reference patterns exactly from `/home/pbrown/SkuInventory/src/services/bom.ts`

## Test Strategy Note
- Use Vitest for unit tests (project standard)
- Mock Prisma client and inventory service
- Test pure functions directly without mocks
- Test async functions with mocked database responses

## Key Algorithms Reference
```
Average Daily Consumption = Sum(abs(consumed_qty) over lookback_window) / lookback_days
Days Until Runout = Current On-Hand / Average Daily Consumption
Runout Date = Today + Days Until Runout
Reorder Date = Runout Date - Lead Time Days
Recommended Reorder Qty = (Lead Time Days + Safety Days) * Daily Consumption
```

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 20m |
| **Total Scout-Plan** | **55m** |
| **Estimated Build Time** | **4-6h** |
