# Implementation Plan

**Issue**: #395 - Edit manually should retain natural language parsed values
**Tier**: 2 (Standard)
**Type**: Enhancement
**Est. Time**: 2-4 hours
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED

**Generated**: 2026-01-08
**Generated By**: Scout-and-Plan Agent (combined workflow)

## Summary

When users parse a transaction via natural language and click "Edit manually", the QuickEntryForm currently only receives transaction type, component/SKU ID, and sales channel via URL parameters. This enhancement will pass ALL parsed values (quantity, date, supplier, reason, location, notes) to the form so users can make quick adjustments without re-entering data.

## Current State

- `QuickEntryWrapper.tsx` manages mode switching between `form`, `conversational`, and `preview` modes
- `handleEditManually()` (lines 30-49) only passes `type`, `skuId`/`componentId`, and `channel` via URL params
- `QuickEntryForm.tsx` reads URL params in `useEffect` (lines 112-133) but only handles the above three parameters
- Form maintains separate state objects: `inboundFormData`, `outboundFormData`, `adjustmentFormData`
- Parsed data includes rich fields: `transactionType`, `itemId`, `quantity`, `salesChannel`, `supplier`, `date`, `reason`, `location`, `notes`

## Dependencies

- None - all required components and types already exist
- `ParsedTransaction` type already defined in `/home/pbrown/SkuInventory/src/types/parser.ts`

## Technical Approach

**Strategy**: Pass parsed data as props to `QuickEntryForm` instead of URL parameters.

**Rationale**:
1. URL params have length limits and encoding issues with special characters
2. Props approach is cleaner and more React-idiomatic
3. Allows passing complex data like dates without serialization issues
4. The wrapper already owns the parsed state, so lifting it into props is natural

**Type Mapping Note**:
- `ParsedTransactionType` uses `'receipt'` which maps to UI type `'inbound'`
- This mapping is already handled in `handleEditManually()` at line 35

## Changes Required

### Phase 1: Add Props Interface to QuickEntryForm

| Subtask | File | Change | Completion Criteria |
|---------|------|--------|---------------------|
| 1.1 | `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx` | Add optional `initialValues` prop interface | [ ] Interface added with all form fields |
| 1.2 | `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx` | Add `initialValues` prop to component signature | [ ] Prop accepted by component |
| 1.3 | `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx` | Update `useEffect` to initialize form state from props when provided | [ ] Form pre-fills from props |

### Phase 2: Update QuickEntryWrapper to Pass Parsed Data

| Subtask | File | Change | Completion Criteria |
|---------|------|--------|---------------------|
| 2.1 | `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx` | Change `handleEditManually()` to switch mode and pass data instead of URL navigation | [ ] No URL navigation on edit |
| 2.2 | `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx` | Add state to hold initial values for form | [ ] State variable added |
| 2.3 | `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx` | Pass `initialValues` prop to `QuickEntryForm` | [ ] Props passed correctly |

## Detailed Implementation Instructions

### Subtask 1.1: Add Initial Values Interface

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`

**Location**: After the existing interfaces (around line 42)

**Pattern Reference**: Follow existing interface patterns in the same file (lines 22-42)

**Add interface**:
```typescript
// Initial values that can be passed to pre-populate the form
export interface QuickEntryFormInitialValues {
  transactionType?: 'inbound' | 'outbound' | 'adjustment'
  // Inbound fields
  componentId?: string
  quantity?: number
  supplier?: string
  date?: string  // YYYY-MM-DD format
  locationId?: string
  notes?: string
  // Outbound fields
  skuId?: string
  salesChannel?: string
  // Adjustment fields
  adjustmentType?: 'add' | 'subtract'
  reason?: string
}
```

**Completion Criteria**:
- [ ] Interface exported from file
- [ ] All form fields covered
- [ ] All fields are optional (partial pre-fill is allowed per requirements)

---

### Subtask 1.2: Add Props to Component Signature

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`

**Location**: Line 52 - change from `export function QuickEntryForm()` to accept props

**Change**:
```typescript
interface QuickEntryFormProps {
  initialValues?: QuickEntryFormInitialValues
}

export function QuickEntryForm({ initialValues }: QuickEntryFormProps = {}) {
```

**Note**: Use default empty object to maintain backward compatibility with existing usage (transactions/new page).

**Completion Criteria**:
- [ ] Props interface added
- [ ] Component accepts optional `initialValues`
- [ ] Backward compatible - works without props

---

### Subtask 1.3: Initialize Form State from Props

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx`

**Location**: Modify the existing `useEffect` at lines 112-133 to also handle `initialValues` prop

**Changes**:

1. Add `initialValues` to useEffect dependencies
2. When `initialValues` is provided, use those values to pre-fill form state
3. Ensure URL params still work for backward compatibility (URL params should take precedence if both exist)

**Implementation approach**:
```typescript
// Initialize from URL params AND/OR initialValues prop
useEffect(() => {
  // Handle transaction type
  const typeParam = searchParams.get('type')
  const typeFromProps = initialValues?.transactionType
  const effectiveType = typeParam || typeFromProps

  if (effectiveType && ['inbound', 'outbound', 'adjustment'].includes(effectiveType)) {
    setTransactionType(effectiveType as TransactionTypeValue)
  }

  // Pre-fill inbound form from initialValues
  if (initialValues) {
    if (initialValues.componentId || initialValues.quantity || initialValues.supplier || initialValues.date || initialValues.notes) {
      setInboundFormData((prev) => ({
        ...prev,
        componentId: initialValues.componentId || prev.componentId,
        quantity: initialValues.quantity?.toString() || prev.quantity,
        supplier: initialValues.supplier || prev.supplier,
        date: initialValues.date || prev.date,
        locationId: initialValues.locationId || prev.locationId,
        notes: initialValues.notes || prev.notes,
      }))
    }

    // Pre-fill outbound form
    if (initialValues.skuId || initialValues.salesChannel || initialValues.quantity) {
      setOutboundFormData((prev) => ({
        ...prev,
        skuId: initialValues.skuId || prev.skuId,
        salesChannel: initialValues.salesChannel || prev.salesChannel,
        quantity: initialValues.quantity?.toString() || prev.quantity,
        date: initialValues.date || prev.date,
        locationId: initialValues.locationId || prev.locationId,
        notes: initialValues.notes || prev.notes,
      }))
    }

    // Pre-fill adjustment form
    if (initialValues.componentId || initialValues.reason || initialValues.quantity) {
      setAdjustmentFormData((prev) => ({
        ...prev,
        componentId: initialValues.componentId || prev.componentId,
        adjustmentType: initialValues.adjustmentType || prev.adjustmentType,
        quantity: initialValues.quantity ? Math.abs(initialValues.quantity).toString() : prev.quantity,
        reason: initialValues.reason || prev.reason,
        date: initialValues.date || prev.date,
        locationId: initialValues.locationId || prev.locationId,
        notes: initialValues.notes || prev.notes,
      }))
    }
  }

  // Keep existing URL param handling for backward compatibility...
  const channelParam = searchParams.get('channel')
  if (channelParam && !initialValues?.salesChannel) {
    setOutboundFormData((prev) => ({ ...prev, salesChannel: channelParam }))
  }
  // ... (rest of existing URL param code, with guards for initialValues)

}, [searchParams, initialValues])
```

**Completion Criteria**:
- [ ] Form pre-fills from `initialValues` prop
- [ ] Empty/undefined values show as blank (per requirements)
- [ ] URL params still work for backward compatibility
- [ ] No TypeScript errors

---

### Subtask 2.1: Update handleEditManually in Wrapper

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx`

**Location**: Lines 30-49 - replace `handleEditManually` function

**Current code**:
```typescript
const handleEditManually = () => {
  // Navigate to form mode with pre-filled data via URL params
  if (parsedResult) {
    const parsed = parsedResult.parsed
    const params = new URLSearchParams()
    params.set('type', parsed.transactionType.value)
    // ... URL param building
    router.push(`/transactions/new?${params.toString()}`)
    setMode('form')
  }
}
```

**New code**:
```typescript
const handleEditManually = () => {
  if (parsedResult) {
    const parsed = parsedResult.parsed

    // Map parsed transaction to form initial values
    const values: QuickEntryFormInitialValues = {
      transactionType: parsed.transactionType.value === 'receipt' ? 'inbound' : parsed.transactionType.value,
      quantity: parsed.quantity.value,
      date: toLocalDateString(parsed.date.value instanceof Date ? parsed.date.value : new Date(parsed.date.value)),
      notes: parsed.notes?.value || undefined,
    }

    // Add type-specific fields
    if (parsed.transactionType.value === 'receipt') {
      values.componentId = parsed.itemId.value || undefined
      values.supplier = parsed.supplier?.value || undefined
      // Location ID needs to be looked up from location name if provided
      // For now, leave location for user to select
    } else if (parsed.transactionType.value === 'outbound') {
      values.skuId = parsed.itemId.value || undefined
      values.salesChannel = parsed.salesChannel?.value || undefined
    } else if (parsed.transactionType.value === 'adjustment') {
      values.componentId = parsed.itemId.value || undefined
      values.reason = parsed.reason?.value || undefined
      // Determine if add or subtract based on context (default to subtract for adjustments)
      values.adjustmentType = 'subtract'
    }

    setFormInitialValues(values)
    setMode('form')
  }
}
```

**Completion Criteria**:
- [ ] No URL navigation (stays on same page)
- [ ] All parsed fields mapped to initial values
- [ ] Type mapping from 'receipt' to 'inbound' handled
- [ ] Seamless mode switch (no flicker)

---

### Subtask 2.2: Add State for Form Initial Values

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx`

**Location**: After line 18 (after existing state declarations)

**Add**:
```typescript
import type { QuickEntryFormInitialValues } from './QuickEntryForm'

// ... existing imports ...

export function QuickEntryWrapper() {
  const router = useRouter()
  const [mode, setMode] = useState<EntryMode>('form')
  const [parsedResult, setParsedResult] = useState<ParseTransactionResponse | null>(null)
  const [formInitialValues, setFormInitialValues] = useState<QuickEntryFormInitialValues | undefined>(undefined)
  // ... rest of state
```

**Also add**: Clear initial values when mode changes back to conversational or form is reset:
- In `handleCancel()` add: `setFormInitialValues(undefined)`
- In `handleRecordAnother()` add: `setFormInitialValues(undefined)`

**Completion Criteria**:
- [ ] State variable added
- [ ] Type imported from QuickEntryForm
- [ ] State cleared on cancel/reset

---

### Subtask 2.3: Pass Initial Values to QuickEntryForm

**File**: `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx`

**Location**: Line 190 - update the QuickEntryForm usage

**Change from**:
```typescript
<TabsContent value="form" className="space-y-4">
  <QuickEntryForm />
</TabsContent>
```

**Change to**:
```typescript
<TabsContent value="form" className="space-y-4">
  <QuickEntryForm initialValues={formInitialValues} />
</TabsContent>
```

**Completion Criteria**:
- [ ] Prop passed to component
- [ ] No TypeScript errors
- [ ] Form receives and uses initial values

---

## Validation Commands

After each phase, run these validation commands:

```bash
# TypeScript check
npx tsc --noEmit

# Build check
npm run build

# Lint check
npm run lint
```

## Manual Testing Checklist

After implementation, manually test these scenarios:

1. **Basic flow**: Enter natural language text, parse, click "Edit manually" - form should pre-fill
2. **Partial parse**: Parse text that only has some fields - empty fields should show as blank
3. **Receipt transaction**: "Received 500 bottles from XYZ supplier" - check quantity, supplier pre-fill
4. **Outbound transaction**: "Shipped 10 units to Amazon" - check quantity, channel pre-fill
5. **Adjustment transaction**: "Lost 5 units" - check quantity, type pre-fill
6. **Cancel flow**: Click "Edit manually", then cancel - should clear and return to conversational
7. **Modify pre-filled**: Change a pre-filled value and submit - should save correctly
8. **URL params still work**: Direct navigation to `/transactions/new?type=inbound&componentId=xxx` should still work

## Files Summary

**Created**: 0
**Modified**: 2
- `/home/pbrown/SkuInventory/src/components/features/QuickEntryForm.tsx` - Add interface and props
- `/home/pbrown/SkuInventory/src/components/features/QuickEntryWrapper.tsx` - Pass parsed data as props

## Risk Assessment

**Risk Level**: Low

**Potential Issues**:
1. Date format mismatch - mitigated by using `toLocalDateString()` utility
2. Location ID lookup - parsed data has location name, form needs ID. For MVP, user can select location manually. Enhancement could add location name-to-ID resolution.
3. Adjustment type inference - parser doesn't explicitly capture add/subtract, defaulting to subtract is reasonable

## Notes

- This change is backward compatible - existing URL param usage continues to work
- The approach avoids React hydration issues since no URL navigation occurs
- Consider future enhancement: Add visual indicator showing which fields were auto-filled from parsing
