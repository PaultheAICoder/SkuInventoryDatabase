# Implementation Plan
**Generated**: 2025-12-17T12:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #297
**Estimated Build Time**: 6-8 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Bug
**Source**: GitHub Issue #297
**Priority**: High (data integrity issue)

### Task Classification
**Category**: BUG_FIX
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="draft"` or `--filter="bom"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- `bd5f404` fix(issue #296): move BOM cost fetch inside transaction to prevent race condition
- Issue #296 fixed a related but distinct problem (stale cost data). Issue #297 is about stale BOM structure (which components are in the BOM).

### Current State Assessment

**The Bug**: When a draft build transaction is approved, the system queries `BOMLine` at approval time (line 427-432 of `draft-transaction.ts`), NOT the BOM as it existed when the draft was created. This means:
1. User creates draft with BOM v1 (has Component A)
2. Someone updates the SKU's BOM (now has Component B instead)
3. User approves the draft expecting Component A consumption
4. System consumes Component B - **data integrity violation**

**Affected Code**:
- `src/services/draft-transaction.ts` - `approveDraftTransaction()` function (lines 356-520)
- `src/services/draft-transaction.ts` - `createDraftTransaction()` function (lines 96-177)

**Existing Patterns**:
- Transaction model already stores `bomVersionId` - this is the correct reference point
- Draft workflow stores minimal data; actual inventory impact is deferred to approval
- `prisma/schema.prisma` uses JSON fields for snapshots (e.g., `rawData` in ShopifyOrder, `metadata` in SyncLog)

### Dependencies & Blockers
1. **Schema Change Required**: Need a new JSON column on Transaction to store BOM snapshot
2. **No blockers identified** - straightforward implementation

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 6-8 hours
**Risk**: Low - well-defined problem with clear solution

### Patterns Identified
**Primary**: `src/services/draft-transaction.ts:96-177` - createDraftTransaction for snapshot capture
**Secondary**: `src/services/inventory.ts:980-1006` - createBuildTransaction's BOM line handling

### Ripple Effect Analysis
**Files Identified**: 5 files need modification

| File | Change Type | Reason |
|------|-------------|--------|
| `prisma/schema.prisma` | Add field | New `bomSnapshot` JSON column on Transaction |
| `src/services/draft-transaction.ts` | Modify | Capture BOM snapshot on creation, use on approval |
| `src/types/draft.ts` | Add type | BOM snapshot interface for type safety |
| `src/components/features/DraftTransactionCard.tsx` | Optional | Display BOM change warning in UI |
| `src/components/features/DraftTransactionList.tsx` | Optional | Display BOM change indicator |

**No other files affected** - changes are isolated to draft workflow.

---

## Executive Summary

This fix ensures draft build transaction approvals use the exact BOM composition that existed when the draft was created, not the current BOM. The solution adds a `bomSnapshot` JSON field to the Transaction model, populated during draft creation with the BOM lines and component info. At approval time, the system uses this snapshot instead of querying current BOM data. An optional UI enhancement will warn approvers if the BOM has changed since draft creation.

---

## Phase 1: Database Schema Update

### Subtask 1.1: Add bomSnapshot Column to Transaction Model
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing JSON field patterns (e.g., `rawData`, `metadata`)
**Instructions**:
1. Add a new optional JSON field `bomSnapshot` to the Transaction model after line 307 (after `rejectReason`):
```prisma
  // BOM snapshot for draft build transactions (frozen at draft creation)
  bomSnapshot  Json?
```
2. Run migration:
```bash
cd /home/pbrown/SkuInventory && npx prisma migrate dev --name add_bom_snapshot_to_transaction
```
3. Generate client:
```bash
npx prisma generate
```

**Validation Commands**:
```bash
npx prisma migrate status
npx prisma generate
```

**Completion Criteria**:
- [ ] Migration created successfully
- [ ] Migration applied to test database
- [ ] Prisma client regenerated
- [ ] No TypeScript errors after client regeneration

---

## Phase 2: Type Definitions

### Subtask 2.1: Add BOM Snapshot Type Definition
**File**: `/home/pbrown/SkuInventory/src/types/draft.ts`
**Pattern**: Follow existing interface patterns in the file
**Instructions**:
1. Add the following interface after line 10 (after existing imports/type definitions):

```typescript
// =============================================================================
// BOM Snapshot Types (for draft build transactions)
// =============================================================================

/**
 * Snapshot of a BOM line at draft creation time
 * Captures component info and quantity to ensure approval uses frozen data
 */
export interface BOMLineSnapshot {
  componentId: string
  componentName: string
  componentSkuCode: string
  quantityPerUnit: string // Stored as string for Decimal precision
  costPerUnit: string // Stored as string for Decimal precision
}

/**
 * Full BOM snapshot captured at draft creation
 */
export interface BOMSnapshot {
  bomVersionId: string
  bomVersionName: string
  capturedAt: string // ISO timestamp
  lines: BOMLineSnapshot[]
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Types compile without errors
- [ ] Types are exported from the module

---

## Phase 3: Service Layer Updates

### Subtask 3.1: Capture BOM Snapshot During Draft Creation
**File**: `/home/pbrown/SkuInventory/src/services/draft-transaction.ts`
**Pattern**: Follow existing BOM query pattern in createBuildTransaction
**Instructions**:
1. Add import at top of file (after existing imports):
```typescript
import type { BOMSnapshot, BOMLineSnapshot } from '@/types/draft'
```

2. In `createDraftTransaction` function (around line 106-122), after determining `bomVersionId`, add BOM snapshot capture:

```typescript
  // For builds, get the active BOM version AND capture snapshot
  let bomVersionId: string | null = null
  let bomSnapshot: BOMSnapshot | null = null

  if (input.type === 'build' && input.skuId) {
    const sku = await prisma.sKU.findUnique({
      where: { id: input.skuId },
      include: {
        bomVersions: {
          where: { isActive: true },
          select: {
            id: true,
            versionName: true,
            lines: {
              include: {
                component: {
                  select: {
                    id: true,
                    name: true,
                    skuCode: true,
                    costPerUnit: true,
                  },
                },
              },
            },
          },
          take: 1,
        },
      },
    })

    if (sku?.bomVersions[0]) {
      const activeBom = sku.bomVersions[0]
      bomVersionId = activeBom.id

      // Capture BOM snapshot for approval-time integrity
      const snapshotLines: BOMLineSnapshot[] = activeBom.lines.map((line) => ({
        componentId: line.componentId,
        componentName: line.component.name,
        componentSkuCode: line.component.skuCode,
        quantityPerUnit: line.quantityPerUnit.toString(),
        costPerUnit: line.component.costPerUnit.toString(),
      }))

      bomSnapshot = {
        bomVersionId: activeBom.id,
        bomVersionName: activeBom.versionName,
        capturedAt: new Date().toISOString(),
        lines: snapshotLines,
      }
    }
  }
```

3. Update the transaction create call (around line 135) to include the snapshot:
```typescript
  const transaction = await prisma.transaction.create({
    data: {
      companyId,
      type: input.type,
      status: 'draft',
      date: input.date,
      skuId: input.type === 'build' ? input.skuId : null,
      bomVersionId,
      bomSnapshot: bomSnapshot ? JSON.parse(JSON.stringify(bomSnapshot)) : null, // Store as JSON
      locationId: locationIdToUse,
      // ... rest of existing fields unchanged
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] BOM snapshot is captured when creating build drafts
- [ ] Non-build drafts have null bomSnapshot

### Subtask 3.2: Use BOM Snapshot During Approval
**File**: `/home/pbrown/SkuInventory/src/services/draft-transaction.ts`
**Pattern**: Replace current BOM query with snapshot-based consumption
**Instructions**:
1. In `approveDraftTransaction` function (around line 356), update the draft fetch to include bomSnapshot:

The existing query already returns the draft with all fields. Since `bomSnapshot` is a Json field, it will be included automatically.

2. Replace the BOM query and consumption logic (lines 419-473) with snapshot-based logic:

```typescript
      if (draft.type === 'build' && draft.skuId && draft.bomVersionId && draft.unitsBuild) {
        // For builds, we need to create the consumption lines
        // Delete placeholder lines if any
        await tx.transactionLine.deleteMany({
          where: { transactionId: id },
        })

        // Use the BOM snapshot captured at draft creation time
        // This ensures we consume exactly what the draft creator/reviewer saw
        const bomSnapshot = draft.bomSnapshot as BOMSnapshot | null

        if (!bomSnapshot || !bomSnapshot.lines || bomSnapshot.lines.length === 0) {
          // Fallback to current BOM if no snapshot exists (legacy drafts)
          // This maintains backward compatibility
          console.warn(`Draft ${id} has no BOM snapshot, falling back to current BOM`)
          const bomLines = await tx.bOMLine.findMany({
            where: { bomVersionId: draft.bomVersionId },
            include: {
              component: { select: { id: true, costPerUnit: true } },
            },
          })

          for (const bomLine of bomLines) {
            const requiredQty = bomLine.quantityPerUnit.toNumber() * draft.unitsBuild

            await tx.transactionLine.create({
              data: {
                transactionId: id,
                componentId: bomLine.componentId,
                quantityChange: new Prisma.Decimal(-1 * requiredQty),
                costPerUnit: bomLine.component.costPerUnit,
              },
            })
          }

          const unitBomCost = bomLines.reduce((total, line) => {
            return total + line.quantityPerUnit.toNumber() * line.component.costPerUnit.toNumber()
          }, 0)

          await tx.transaction.update({
            where: { id },
            data: {
              unitBomCost: new Prisma.Decimal(unitBomCost),
              totalBomCost: new Prisma.Decimal(unitBomCost * draft.unitsBuild),
            },
          })
        } else {
          // Use snapshot data for consumption
          for (const line of bomSnapshot.lines) {
            const requiredQty = parseFloat(line.quantityPerUnit) * draft.unitsBuild

            await tx.transactionLine.create({
              data: {
                transactionId: id,
                componentId: line.componentId,
                quantityChange: new Prisma.Decimal(-1 * requiredQty),
                costPerUnit: new Prisma.Decimal(line.costPerUnit),
              },
            })
          }

          // Calculate costs from snapshot
          const unitBomCost = bomSnapshot.lines.reduce((total, line) => {
            return total + parseFloat(line.quantityPerUnit) * parseFloat(line.costPerUnit)
          }, 0)

          await tx.transaction.update({
            where: { id },
            data: {
              unitBomCost: new Prisma.Decimal(unitBomCost),
              totalBomCost: new Prisma.Decimal(unitBomCost * draft.unitsBuild),
            },
          })
        }

        // Create finished goods output (using snapshot cost)
        const unitBomCost = bomSnapshot
          ? bomSnapshot.lines.reduce((total, line) => {
              return total + parseFloat(line.quantityPerUnit) * parseFloat(line.costPerUnit)
            }, 0)
          : 0 // Will be recalculated from current BOM in fallback path

        const defaultLocationId = await getDefaultLocationId(companyId)
        await tx.finishedGoodsLine.create({
          data: {
            transactionId: id,
            skuId: draft.skuId,
            locationId: draft.locationId ?? defaultLocationId ?? '',
            quantityChange: new Prisma.Decimal(draft.unitsBuild),
            costPerUnit: new Prisma.Decimal(unitBomCost),
          },
        })
      }
```

3. Also update the inventory check to use snapshot component IDs (around line 390):

```typescript
      // For build transactions, re-validate inventory availability INSIDE transaction
      if (draft.type === 'build' && draft.bomVersionId && draft.unitsBuild) {
        const bomSnapshot = draft.bomSnapshot as BOMSnapshot | null

        // Use snapshot component IDs if available, otherwise fall back to current BOM
        if (bomSnapshot && bomSnapshot.lines.length > 0) {
          // Check inventory for snapshot components
          const componentIds = bomSnapshot.lines.map(l => l.componentId)
          const quantities = await getComponentQuantities(
            componentIds,
            companyId,
            draft.locationId ?? undefined
          )

          const insufficientItems: Array<{ componentName: string }> = []
          for (const line of bomSnapshot.lines) {
            const available = quantities.get(line.componentId) ?? 0
            const required = parseFloat(line.quantityPerUnit) * draft.unitsBuild
            if (available < required) {
              insufficientItems.push({ componentName: line.componentName })
            }
          }

          if (insufficientItems.length > 0) {
            throw new Error(
              `Insufficient inventory for: ${insufficientItems.map((i) => i.componentName).join(', ')}`
            )
          }
        } else {
          // Fallback to existing checkInsufficientInventory for legacy drafts
          const insufficientItems = await checkInsufficientInventory({
            bomVersionId: draft.bomVersionId,
            companyId,
            unitsToBuild: draft.unitsBuild,
            locationId: draft.locationId ?? undefined,
          })

          if (insufficientItems.length > 0) {
            throw new Error(
              `Insufficient inventory for: ${insufficientItems.map((i) => i.componentName).join(', ')}`
            )
          }
        }
      }
```

4. Add import for `getComponentQuantities` if not already present:
```typescript
import { checkInsufficientInventory, getComponentQuantities } from './inventory'
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] Approval uses snapshot when available
- [ ] Fallback to current BOM for legacy drafts without snapshot

---

## Phase 4: Update Response Types (Optional Enhancement)

### Subtask 4.1: Include BOM Snapshot in Draft Response
**File**: `/home/pbrown/SkuInventory/src/types/draft.ts`
**Pattern**: Follow existing response interface pattern
**Instructions**:
1. Update `DraftTransactionResponse` interface (around line 108) to include snapshot:

```typescript
export interface DraftTransactionResponse {
  id: string
  type: 'receipt' | 'build' | 'adjustment' | 'initial' | 'transfer'
  status: TransactionStatus
  date: string
  // ... existing fields ...

  // BOM snapshot for build drafts (captured at creation time)
  bomSnapshot?: BOMSnapshot | null

  lines: Array<{
    // ... existing line definition ...
  }>
}
```

2. Update `transformDraftTransaction` function in `/home/pbrown/SkuInventory/src/services/draft-transaction.ts` to include bomSnapshot:

```typescript
function transformDraftTransaction(tx: Prisma.TransactionGetPayload<{
  // ... existing includes ...
}>): DraftTransactionResponse {
  return {
    // ... existing fields ...
    bomSnapshot: tx.bomSnapshot as BOMSnapshot | null,
    // ... rest of fields ...
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Type includes bomSnapshot field
- [ ] Transform includes bomSnapshot in response

---

## Phase 5: UI Enhancement (Optional - Low Priority)

### Subtask 5.1: Add BOM Change Warning to Draft Card
**File**: `/home/pbrown/SkuInventory/src/components/features/DraftTransactionCard.tsx`
**Pattern**: Follow existing warning display pattern
**Instructions**:
1. Add logic to detect if current BOM differs from snapshot (requires API call)
2. Display warning badge if BOM has changed since draft creation
3. This is optional - the core fix (Phase 3) is sufficient for data integrity

**Note**: This is a nice-to-have UI enhancement. The core bug fix in Phase 3 ensures data integrity regardless of UI warning.

**Completion Criteria**:
- [ ] (Optional) Warning displayed when BOM has changed

---

## Phase 6: Testing

### Subtask 6.1: Manual Verification
**Instructions**:
1. Create a build draft for an SKU with a known BOM
2. Update the SKU's BOM (change components or quantities)
3. Approve the draft
4. Verify the transaction uses the ORIGINAL BOM (from snapshot), not the updated BOM
5. Check transaction lines match the snapshot

**Test Script (manual verification)**:
```bash
# Start test environment
cd /home/pbrown/SkuInventory/docker
docker compose -f docker-compose.test.yml up -d

# Access test database
docker exec inventory-db-test psql -U inventory_test -d inventory_test -c "SELECT id, type, status, \"bomSnapshot\" FROM \"Transaction\" WHERE type = 'build' AND status = 'draft' LIMIT 5;"
```

**Completion Criteria**:
- [ ] New drafts have bomSnapshot populated
- [ ] Approval uses snapshot data (not current BOM)
- [ ] Legacy drafts (no snapshot) still work via fallback
- [ ] Transaction lines match snapshot components

---

## Summary of Deliverables

**Files Created**: 0
**Files Modified**: 3-4

| File | Change |
|------|--------|
| `prisma/schema.prisma` | Add `bomSnapshot Json?` field |
| `src/types/draft.ts` | Add `BOMSnapshot`, `BOMLineSnapshot` interfaces |
| `src/services/draft-transaction.ts` | Capture snapshot on create, use on approve |
| `src/components/features/DraftTransactionCard.tsx` | (Optional) BOM change warning |

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 must complete before Phase 2-3)
2. Run migration BEFORE modifying TypeScript files
3. Test completion criteria at each phase
4. Maintain backward compatibility for existing drafts without snapshot
5. The fallback path for legacy drafts is critical - do not remove

## Test Strategy Note

- Use manual verification on test database
- Automated tests not strictly required (existing draft approval tests should still pass)
- Focus on data integrity verification

## Performance Metrics

| Phase | Estimated Duration |
|-------|-------------------|
| Investigation | 30m |
| Validation | 15m |
| Planning | 20m |
| **Total** | **65m** |

---

## Risk Assessment

**Low Risk**:
- Schema change is additive (new nullable column)
- Existing functionality maintained via fallback
- No breaking changes to API contracts

**Migration Notes**:
- Existing drafts will have `null` bomSnapshot - handled by fallback logic
- New drafts will capture snapshot automatically
- No data migration needed for historical records
