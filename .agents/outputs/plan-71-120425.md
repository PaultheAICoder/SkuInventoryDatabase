# Implementation Plan
**Generated**: 2025-12-04T12:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #71 - [Parent #9] Phase 4: Transfer transactions between locations
**Estimated Build Time**: 6-8 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #71
**Priority**: High (V2 roadmap, multi-location inventory feature)
**Parent**: #9 (Multi-location inventory and finished goods tracking)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="transfer|Transfer|transaction"` or run full integration test suite for transactions

### Issue Validation
**Status**: Valid
**Recent Changes**:
- `f808e51` - feat(issue #70): add location-aware inventory quantity queries
- `6a431c3` - feat(issue #69): add locationId to transactions and transaction services
- Issue #70 (dependency) is completed - location-aware queries are available

### Current State Assessment
- **Database Schema**: Transaction model has `locationId` field, TransactionType enum has `receipt`, `build`, `adjustment`, `initial`
- **Types**: `src/types/transaction.ts` has schemas for receipt, adjustment, initial, build - no transfer schema yet
- **Services**: `src/services/inventory.ts` has `getComponentQuantity(componentId, locationId?)` for location-aware queries
- **API Routes**: `/api/transactions/{receipt,adjustment,build,initial}` exist - no transfer route
- **UI Components**: `ReceiptDialog`, `AdjustmentDialog`, `BuildDialog` exist - no `TransferDialog`
- **Location Service**: `src/services/location.ts` has utilities for location validation

### Dependencies & Blockers
1. **Dependency Satisfied**: Issue #70 (location-aware inventory queries) is CLOSED
2. **Required**: `getComponentQuantity(componentId, locationId)` exists in `src/services/inventory.ts`
3. **Required**: Location model and API routes exist

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 6-8 hours
**Risk**: Medium (schema migration, atomic transaction handling, multiple UI/API components)

### Patterns Identified
**Primary**: `src/services/inventory.ts:createReceiptTransaction` (lines 117-204) - Transaction creation pattern with location support
**Secondary**: `src/components/features/AdjustmentDialog.tsx` - Dialog pattern with location selection
**API Pattern**: `src/app/api/transactions/receipt/route.ts` - API route with validation
**Transaction Type Config**: `src/components/features/TransactionDetail.tsx:transactionTypeConfig` - UI display config

### Ripple Effect Analysis
**Files Identified**: 15 files affected

**Files to CREATE (3)**:
1. `src/services/transfer.ts` - Transfer service
2. `src/app/api/transactions/transfer/route.ts` - Transfer API endpoint
3. `src/components/features/TransferDialog.tsx` - Transfer dialog UI

**Files to MODIFY (12)**:
1. `prisma/schema.prisma` - Add `transfer` to TransactionType enum, add `fromLocationId`/`toLocationId` fields
2. `src/types/transaction.ts` - Add transfer schema and types
3. `src/types/index.ts` - Update TransactionType type
4. `src/app/(dashboard)/transactions/page.tsx` - Add 'transfer' to TRANSACTION_TYPES filter, update `formatTransactionSummary`
5. `src/components/features/TransactionDetail.tsx` - Add transfer type config, display from/to locations
6. `src/app/api/transactions/route.ts` - Include fromLocation/toLocation in list response
7. `src/app/api/transactions/[id]/route.ts` - Include fromLocation/toLocation in detail response
8. `src/app/(dashboard)/components/[id]/page.tsx` - Add Transfer button and dialog integration
9. `src/services/analytics.ts` - Handle transfer type in analytics (if applicable)
10. `src/services/analytics-export.ts` - Handle transfer type in export (if applicable)
11. `src/app/api/export/transactions/route.ts` - Handle transfer type in CSV export
12. `tests/integration/transactions.test.ts` - Add transfer transaction tests

---

## Executive Summary

This plan implements inter-location transfer transactions for the Trevor Inventory system. Transfers atomically move inventory between locations by creating a single transaction with two transaction lines (negative at source, positive at destination). The implementation follows existing patterns for transaction types and includes full validation (location ownership, sufficient inventory, active locations).

---

## Phase 1: Database Schema Changes

### Subtask 1.1: Update Prisma Schema - Add transfer to TransactionType enum
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing enum pattern at line 179
**Instructions**:
1. Locate the `TransactionType` enum (around line 179)
2. Add `transfer` as a new enum value after `initial`:
```prisma
enum TransactionType {
  receipt
  build
  adjustment
  initial
  transfer  // NEW
}
```
**Completion Criteria**:
- [ ] `transfer` added to TransactionType enum
- [ ] No syntax errors in schema

### Subtask 1.2: Update Prisma Schema - Add fromLocationId and toLocationId to Transaction model
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing relation pattern for `locationId` at lines 196-197
**Instructions**:
1. Locate the `Transaction` model (around line 186)
2. Add `fromLocationId` and `toLocationId` fields after `locationId`:
```prisma
model Transaction {
  // ... existing fields ...
  locationId     String?
  location       Location?  @relation("TransactionLocation", fields: [locationId], references: [id])
  fromLocationId String?
  fromLocation   Location?  @relation("TransferFrom", fields: [fromLocationId], references: [id])
  toLocationId   String?
  toLocation     Location?  @relation("TransferTo", fields: [toLocationId], references: [id])
  // ... rest of fields ...
}
```
3. Add indexes for the new fields:
```prisma
  @@index([fromLocationId])
  @@index([toLocationId])
```
4. Update the `Location` model (around line 41) to add the inverse relations:
```prisma
model Location {
  // ... existing fields ...
  transactions     Transaction[] @relation("TransactionLocation")
  transfersFrom    Transaction[] @relation("TransferFrom")
  transfersTo      Transaction[] @relation("TransferTo")
  // ... rest of fields ...
}
```
**NOTE**: The existing `transactions` relation must be renamed to use the named relation `"TransactionLocation"`.
**Completion Criteria**:
- [ ] `fromLocationId` and `toLocationId` fields added to Transaction
- [ ] Relations added with correct names
- [ ] Indexes added for both new fields
- [ ] Location model updated with inverse relations
- [ ] Existing `transactions` relation on Location updated to use `@relation("TransactionLocation")`

### Subtask 1.3: Generate and Apply Prisma Migration
**Instructions**:
1. Run migration:
```bash
cd /home/pbrown/SkuInventory && npx prisma migrate dev --name add_transfer_transaction_type
```
2. Verify migration applied successfully
3. Regenerate client:
```bash
npx prisma generate
```
**Completion Criteria**:
- [ ] Migration file created in `prisma/migrations/`
- [ ] Migration applied without errors
- [ ] Prisma client regenerated
- [ ] `npx tsc --noEmit` passes

---

## Phase 2: TypeScript Types

### Subtask 2.1: Update TransactionType in src/types/index.ts
**File**: `/home/pbrown/SkuInventory/src/types/index.ts`
**Pattern**: Line 31
**Instructions**:
1. Update the `TransactionType` type to include `'transfer'`:
```typescript
// Transaction types
export type TransactionType = 'receipt' | 'build' | 'adjustment' | 'initial' | 'transfer'
```
**Completion Criteria**:
- [ ] `'transfer'` added to TransactionType
- [ ] `npx tsc --noEmit` passes

### Subtask 2.2: Add Transfer Schema and Types to src/types/transaction.ts
**File**: `/home/pbrown/SkuInventory/src/types/transaction.ts`
**Pattern**: Follow `createAdjustmentSchema` pattern (lines 17-27)
**Instructions**:
1. Add transfer transaction schema after the initial schema (around line 40):
```typescript
// Transfer transaction schema
export const createTransferSchema = z.object({
  date: z.coerce.date(),
  componentId: z.string().uuid('Invalid component ID'),
  quantity: z.coerce.number().positive('Quantity must be positive'),
  fromLocationId: z.string().uuid('Invalid from location ID'),
  toLocationId: z.string().uuid('Invalid to location ID'),
  notes: z.string().optional().nullable(),
})

export type CreateTransferInput = z.infer<typeof createTransferSchema>
```

2. Update `transactionListQuerySchema` to include `'transfer'` in the type enum (around line 79):
```typescript
  type: z.enum(['receipt', 'build', 'adjustment', 'initial', 'transfer']).optional(),
```

3. Update `TransactionResponse` interface to include fromLocation/toLocation (around line 92):
```typescript
export interface TransactionResponse {
  id: string
  type: 'receipt' | 'build' | 'adjustment' | 'initial' | 'transfer'
  date: string
  sku?: { id: string; name: string } | null
  bomVersion?: { id: string; versionName: string } | null
  locationId: string | null
  location?: { id: string; name: string } | null
  fromLocationId?: string | null
  fromLocation?: { id: string; name: string } | null
  toLocationId?: string | null
  toLocation?: { id: string; name: string } | null
  // ... rest of existing fields ...
}
```

4. Update `TransactionDetailResponse` similarly if needed.

**Completion Criteria**:
- [ ] `createTransferSchema` added
- [ ] `CreateTransferInput` type exported
- [ ] `transactionListQuerySchema` updated to include `'transfer'`
- [ ] `TransactionResponse` includes `fromLocationId`, `fromLocation`, `toLocationId`, `toLocation`
- [ ] `npx tsc --noEmit` passes

---

## Phase 3: Service Layer

### Subtask 3.1: Create Transfer Service
**File**: `/home/pbrown/SkuInventory/src/services/transfer.ts` (NEW FILE)
**Pattern**: Follow `src/services/inventory.ts:createReceiptTransaction` pattern (lines 117-204)
**Instructions**:
1. Create new file with the following content:
```typescript
import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'
import { getComponentQuantity } from './inventory'

export interface TransferResult {
  id: string
  type: 'transfer'
  date: Date
  componentId: string
  quantity: number
  fromLocationId: string
  fromLocation: { id: string; name: string }
  toLocationId: string
  toLocation: { id: string; name: string }
  notes: string | null
  createdAt: Date
  createdBy: { id: string; name: string }
  lines: Array<{
    id: string
    component: { id: string; name: string; skuCode: string }
    quantityChange: Prisma.Decimal
    costPerUnit: Prisma.Decimal | null
  }>
}

export interface TransferValidationError {
  code: 'SAME_LOCATION' | 'LOCATION_NOT_FOUND' | 'LOCATION_NOT_ACTIVE' | 'INSUFFICIENT_INVENTORY' | 'COMPONENT_NOT_FOUND'
  message: string
  details?: {
    available?: number
    required?: number
  }
}

export async function createTransferTransaction(params: {
  companyId: string
  componentId: string
  quantity: number
  fromLocationId: string
  toLocationId: string
  date: Date
  notes?: string | null
  createdById: string
}): Promise<TransferResult> {
  const {
    companyId,
    componentId,
    quantity,
    fromLocationId,
    toLocationId,
    date,
    notes,
    createdById,
  } = params

  // Validate: cannot transfer to same location
  if (fromLocationId === toLocationId) {
    throw new Error('Cannot transfer to the same location')
  }

  return prisma.$transaction(async (tx) => {
    // 1. Validate component exists and belongs to company
    const component = await tx.component.findFirst({
      where: {
        id: componentId,
        companyId,
      },
    })

    if (!component) {
      throw new Error('Component not found')
    }

    // 2. Validate both locations belong to company and are active
    const [fromLocation, toLocation] = await Promise.all([
      tx.location.findFirst({
        where: {
          id: fromLocationId,
          companyId,
          isActive: true,
        },
      }),
      tx.location.findFirst({
        where: {
          id: toLocationId,
          companyId,
          isActive: true,
        },
      }),
    ])

    if (!fromLocation) {
      throw new Error('Source location not found or not active')
    }

    if (!toLocation) {
      throw new Error('Destination location not found or not active')
    }

    // 3. Check sufficient inventory at source location
    const availableQuantity = await getComponentQuantity(componentId, fromLocationId)
    if (availableQuantity < quantity) {
      throw new Error(
        `Insufficient inventory at source location. Available: ${availableQuantity}, Required: ${quantity}`
      )
    }

    // 4. Create single transfer transaction with two lines
    const transaction = await tx.transaction.create({
      data: {
        companyId,
        type: 'transfer',
        date,
        notes,
        createdById,
        fromLocationId,
        toLocationId,
        // locationId is null for transfers - we use fromLocationId/toLocationId instead
        lines: {
          create: [
            // Line 1: Negative quantity at source (deduction)
            // Note: TransactionLine doesn't have locationId, the location context
            // comes from the transaction's fromLocationId/toLocationId
            {
              componentId,
              quantityChange: new Prisma.Decimal(-quantity),
              costPerUnit: component.costPerUnit,
            },
            // Line 2: Positive quantity at destination (addition)
            {
              componentId,
              quantityChange: new Prisma.Decimal(quantity),
              costPerUnit: component.costPerUnit,
            },
          ],
        },
      },
      include: {
        fromLocation: {
          select: { id: true, name: true },
        },
        toLocation: {
          select: { id: true, name: true },
        },
        lines: {
          include: {
            component: {
              select: { id: true, name: true, skuCode: true },
            },
          },
        },
        createdBy: {
          select: { id: true, name: true },
        },
      },
    })

    return {
      id: transaction.id,
      type: 'transfer' as const,
      date: transaction.date,
      componentId,
      quantity,
      fromLocationId: transaction.fromLocationId!,
      fromLocation: transaction.fromLocation!,
      toLocationId: transaction.toLocationId!,
      toLocation: transaction.toLocation!,
      notes: transaction.notes,
      createdAt: transaction.createdAt,
      createdBy: transaction.createdBy,
      lines: transaction.lines,
    }
  })
}
```

**IMPORTANT NOTE**: The design uses TWO transaction lines but BOTH have the same componentId. The differentiation between source and destination is tracked via `transaction.fromLocationId` and `transaction.toLocationId`. When calculating inventory by location, the query needs to be updated to account for transfer transactions specially. See Subtask 3.2.

**Completion Criteria**:
- [ ] `src/services/transfer.ts` created
- [ ] `createTransferTransaction` function implemented
- [ ] Validates same-location check
- [ ] Validates component and locations
- [ ] Validates sufficient inventory at source
- [ ] Creates atomic transaction with two lines
- [ ] Returns properly typed result
- [ ] `npx tsc --noEmit` passes

### Subtask 3.2: Update Inventory Service for Transfer-Aware Queries
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Instructions**:
The current `getComponentQuantity` function uses `transaction.locationId` to filter. For transfers, we need to handle the special case where:
- Lines in a transfer transaction are attributed to either fromLocationId or toLocationId
- Negative line = fromLocationId
- Positive line = toLocationId

**IMPORTANT**: Review the current implementation carefully. The simplest approach is that transfer transactions DON'T use the regular `locationId` field (it stays null), and the quantity calculations are correct because:
- Transfer lines have +qty and -qty for the same component
- Net effect is 0 globally (correct)
- When filtered by location, we need special handling

**Alternative Approach (Recommended)**: Store `locationId` on TransactionLine instead of just Transaction. This would require more schema changes but would be cleaner. For Phase 4, we'll use a query-based approach.

For now, update the `getComponentQuantity` function to handle transfers:
```typescript
export async function getComponentQuantity(
  componentId: string,
  locationId?: string
): Promise<number> {
  if (!locationId) {
    // Global total - sum all lines for this component
    const result = await prisma.transactionLine.aggregate({
      where: { componentId },
      _sum: { quantityChange: true },
    })
    return result._sum.quantityChange?.toNumber() ?? 0
  }

  // Location-specific total requires handling transfers specially
  // For non-transfer transactions: use transaction.locationId
  // For transfer transactions:
  //   - negative line = fromLocationId
  //   - positive line = toLocationId

  // Get regular (non-transfer) transaction lines at this location
  const regularResult = await prisma.transactionLine.aggregate({
    where: {
      componentId,
      transaction: {
        locationId,
        type: { not: 'transfer' },
      },
    },
    _sum: { quantityChange: true },
  })

  // Get transfer lines where this is the FROM location (negative = outgoing)
  const transferFromResult = await prisma.transactionLine.aggregate({
    where: {
      componentId,
      quantityChange: { lt: 0 },
      transaction: {
        type: 'transfer',
        fromLocationId: locationId,
      },
    },
    _sum: { quantityChange: true },
  })

  // Get transfer lines where this is the TO location (positive = incoming)
  const transferToResult = await prisma.transactionLine.aggregate({
    where: {
      componentId,
      quantityChange: { gt: 0 },
      transaction: {
        type: 'transfer',
        toLocationId: locationId,
      },
    },
    _sum: { quantityChange: true },
  })

  const regular = regularResult._sum.quantityChange?.toNumber() ?? 0
  const transferFrom = transferFromResult._sum.quantityChange?.toNumber() ?? 0
  const transferTo = transferToResult._sum.quantityChange?.toNumber() ?? 0

  return regular + transferFrom + transferTo
}
```

Similarly update `getComponentQuantities` function.

**Completion Criteria**:
- [ ] `getComponentQuantity` handles transfer transactions correctly
- [ ] `getComponentQuantities` handles transfer transactions correctly
- [ ] Unit tests pass (if applicable)
- [ ] `npx tsc --noEmit` passes

---

## Phase 4: API Route

### Subtask 4.1: Create Transfer API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/transfer/route.ts` (NEW FILE)
**Pattern**: Follow `src/app/api/transactions/receipt/route.ts` pattern
**Instructions**:
1. Create directory and file:
```bash
mkdir -p /home/pbrown/SkuInventory/src/app/api/transactions/transfer
```
2. Create route file with content:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { created, unauthorized, serverError, parseBody, error } from '@/lib/api-response'
import { createTransferSchema } from '@/types/transaction'
import { createTransferTransaction } from '@/services/transfer'

// POST /api/transactions/transfer - Create a transfer transaction
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    // Check role - Viewer cannot create transactions
    if (session.user.role === 'viewer') {
      return unauthorized('You do not have permission to create transactions')
    }

    const bodyResult = await parseBody(request, createTransferSchema)
    if (bodyResult.error) return bodyResult.error

    const data = bodyResult.data

    // Use selected company for scoping
    const selectedCompanyId = session.user.selectedCompanyId

    // Create the transfer transaction
    const transaction = await createTransferTransaction({
      companyId: selectedCompanyId,
      componentId: data.componentId,
      quantity: data.quantity,
      fromLocationId: data.fromLocationId,
      toLocationId: data.toLocationId,
      date: data.date,
      notes: data.notes,
      createdById: session.user.id,
    })

    return created({
      id: transaction.id,
      type: transaction.type,
      date: transaction.date.toISOString().split('T')[0],
      fromLocationId: transaction.fromLocationId,
      fromLocation: transaction.fromLocation,
      toLocationId: transaction.toLocationId,
      toLocation: transaction.toLocation,
      notes: transaction.notes,
      createdAt: transaction.createdAt.toISOString(),
      createdBy: transaction.createdBy,
      lines: transaction.lines.map((line) => ({
        id: line.id,
        component: line.component,
        quantityChange: line.quantityChange.toString(),
        costPerUnit: line.costPerUnit?.toString() ?? null,
      })),
    })
  } catch (err) {
    console.error('Error creating transfer transaction:', err)

    // Return specific error messages for known validation errors
    if (err instanceof Error) {
      if (err.message.includes('same location') ||
          err.message.includes('not found') ||
          err.message.includes('not active') ||
          err.message.includes('Insufficient inventory')) {
        return error(err.message, 400)
      }
    }

    return serverError()
  }
}
```

**Completion Criteria**:
- [ ] `src/app/api/transactions/transfer/route.ts` created
- [ ] POST handler implemented
- [ ] Authentication check
- [ ] Role check (viewer cannot create)
- [ ] Validation via Zod schema
- [ ] Error handling for known validation errors
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` passes

### Subtask 4.2: Update Transaction List API to Include Transfer Locations
**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/route.ts`
**Pattern**: Lines 57-67 (existing include)
**Instructions**:
1. Update the Prisma query include to add `fromLocation` and `toLocation`:
```typescript
include: {
  sku: { select: { id: true, name: true } },
  bomVersion: { select: { id: true, versionName: true } },
  location: { select: { id: true, name: true } },
  fromLocation: { select: { id: true, name: true } },  // ADD
  toLocation: { select: { id: true, name: true } },    // ADD
  createdBy: { select: { id: true, name: true } },
  lines: {
    include: {
      component: { select: { id: true, name: true, skuCode: true } },
    },
  },
},
```

2. Update the response mapping (around line 71) to include the new fields:
```typescript
const data: TransactionResponse[] = transactions.map((tx) => ({
  // ... existing fields ...
  fromLocationId: tx.fromLocationId,
  fromLocation: tx.fromLocation,
  toLocationId: tx.toLocationId,
  toLocation: tx.toLocation,
  // ... rest of fields ...
}))
```

**Completion Criteria**:
- [ ] `fromLocation` and `toLocation` included in query
- [ ] Response mapping includes new fields
- [ ] `npx tsc --noEmit` passes

### Subtask 4.3: Update Transaction Detail API to Include Transfer Locations
**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/[id]/route.ts`
**Pattern**: Lines 24-64 (existing include and response)
**Instructions**:
1. Update the Prisma query include to add `fromLocation` and `toLocation`:
```typescript
include: {
  // ... existing includes ...
  fromLocation: {
    select: {
      id: true,
      name: true,
      type: true,
    },
  },
  toLocation: {
    select: {
      id: true,
      name: true,
      type: true,
    },
  },
  // ... rest of includes ...
}
```

2. Update the response mapping to include the new fields:
```typescript
return NextResponse.json({
  data: {
    // ... existing fields ...
    fromLocationId: transaction.fromLocationId,
    fromLocation: transaction.fromLocation,
    toLocationId: transaction.toLocationId,
    toLocation: transaction.toLocation,
    // ... rest of fields ...
  },
})
```

**Completion Criteria**:
- [ ] `fromLocation` and `toLocation` included in detail query
- [ ] Response includes new fields
- [ ] `npx tsc --noEmit` passes

---

## Phase 5: Frontend Components

### Subtask 5.1: Create TransferDialog Component
**File**: `/home/pbrown/SkuInventory/src/components/features/TransferDialog.tsx` (NEW FILE)
**Pattern**: Follow `src/components/features/AdjustmentDialog.tsx` pattern
**Instructions**:
Create dialog component with:
- Component info display
- Quantity input (positive only)
- From location dropdown (required)
- To location dropdown (required)
- Date picker
- Notes field
- Submit to `/api/transactions/transfer`
- Show available quantity at source location

```typescript
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'

interface TransferDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  componentId: string
  componentName: string
  currentQuantity: number
}

export function TransferDialog({
  open,
  onOpenChange,
  componentId,
  componentName,
  currentQuantity,
}: TransferDialogProps) {
  const router = useRouter()
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [locations, setLocations] = useState<Array<{ id: string; name: string }>>([])
  const [isLoadingLocations, setIsLoadingLocations] = useState(false)

  const [formData, setFormData] = useState({
    date: new Date().toISOString().split('T')[0],
    quantity: '',
    fromLocationId: '',
    toLocationId: '',
    notes: '',
  })

  useEffect(() => {
    if (open) {
      fetchLocations()
      // Reset form when opening
      setFormData({
        date: new Date().toISOString().split('T')[0],
        quantity: '',
        fromLocationId: '',
        toLocationId: '',
        notes: '',
      })
      setError(null)
    }
  }, [open])

  const fetchLocations = async () => {
    setIsLoadingLocations(true)
    try {
      const res = await fetch('/api/locations?isActive=true&pageSize=50')
      if (res.ok) {
        const data = await res.json()
        setLocations(data.data || [])
      }
    } catch (err) {
      console.error('Failed to fetch locations:', err)
    } finally {
      setIsLoadingLocations(false)
    }
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError(null)

    // Client-side validation
    if (formData.fromLocationId === formData.toLocationId) {
      setError('Source and destination locations must be different')
      setIsLoading(false)
      return
    }

    try {
      const res = await fetch('/api/transactions/transfer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          componentId,
          date: formData.date,
          quantity: parseFloat(formData.quantity),
          fromLocationId: formData.fromLocationId,
          toLocationId: formData.toLocationId,
          notes: formData.notes || null,
        }),
      })

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.message || 'Failed to create transfer')
      }

      onOpenChange(false)
      router.refresh()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }

  const isFormValid =
    formData.quantity &&
    parseFloat(formData.quantity) > 0 &&
    formData.fromLocationId &&
    formData.toLocationId &&
    formData.fromLocationId !== formData.toLocationId

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Transfer Inventory</DialogTitle>
            <DialogDescription>
              Transfer <span className="font-medium">{componentName}</span> between locations
              <br />
              Total quantity on hand: <span className="font-mono">{currentQuantity}</span>
            </DialogDescription>
          </DialogHeader>

          <div className="grid gap-4 py-4">
            {error && (
              <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
                {error}
              </div>
            )}

            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="date" className="text-right">
                Date *
              </Label>
              <Input
                id="date"
                type="date"
                className="col-span-3"
                value={formData.date}
                onChange={(e) => setFormData((prev) => ({ ...prev, date: e.target.value }))}
                required
              />
            </div>

            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="fromLocation" className="text-right">
                From *
              </Label>
              <Select
                value={formData.fromLocationId}
                onValueChange={(value) => setFormData((prev) => ({ ...prev, fromLocationId: value }))}
                disabled={isLoadingLocations}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder={isLoadingLocations ? 'Loading...' : 'Select source location'} />
                </SelectTrigger>
                <SelectContent>
                  {locations
                    .filter((loc) => loc.id !== formData.toLocationId)
                    .map((loc) => (
                      <SelectItem key={loc.id} value={loc.id}>
                        {loc.name}
                      </SelectItem>
                    ))}
                </SelectContent>
              </Select>
            </div>

            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="toLocation" className="text-right">
                To *
              </Label>
              <Select
                value={formData.toLocationId}
                onValueChange={(value) => setFormData((prev) => ({ ...prev, toLocationId: value }))}
                disabled={isLoadingLocations}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder={isLoadingLocations ? 'Loading...' : 'Select destination location'} />
                </SelectTrigger>
                <SelectContent>
                  {locations
                    .filter((loc) => loc.id !== formData.fromLocationId)
                    .map((loc) => (
                      <SelectItem key={loc.id} value={loc.id}>
                        {loc.name}
                      </SelectItem>
                    ))}
                </SelectContent>
              </Select>
            </div>

            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="quantity" className="text-right">
                Quantity *
              </Label>
              <Input
                id="quantity"
                type="number"
                step="1"
                min="1"
                className="col-span-3"
                placeholder="e.g., 50"
                value={formData.quantity}
                onChange={(e) => setFormData((prev) => ({ ...prev, quantity: e.target.value }))}
                required
              />
            </div>

            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="notes" className="text-right">
                Notes
              </Label>
              <Input
                id="notes"
                className="col-span-3"
                placeholder="e.g., Moving to 3PL for fulfillment"
                value={formData.notes}
                onChange={(e) => setFormData((prev) => ({ ...prev, notes: e.target.value }))}
              />
            </div>
          </div>

          <DialogFooter>
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading || !isFormValid}>
              {isLoading ? 'Transferring...' : 'Transfer'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  )
}
```

**Completion Criteria**:
- [ ] `TransferDialog.tsx` created
- [ ] Form with date, quantity, from/to locations, notes
- [ ] Validation: from !== to, quantity > 0
- [ ] API call to `/api/transactions/transfer`
- [ ] Error display
- [ ] Success closes dialog and refreshes
- [ ] `npx tsc --noEmit` passes

### Subtask 5.2: Add TransferDialog to Component Detail Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/components/[id]/page.tsx`
**Pattern**: Follow existing `AdjustmentDialog` integration (lines 32-33, 129, 374-383)
**Instructions**:
1. Import TransferDialog:
```typescript
import { TransferDialog } from '@/components/features/TransferDialog'
```

2. Add state for transfer dialog (around line 33):
```typescript
const [transferDialogOpen, setTransferDialogOpen] = useState(false)
```

3. Add Transfer button in the button group (around line 129):
```tsx
<Button variant="outline" onClick={() => setTransferDialogOpen(true)}>
  <ArrowLeftRight className="mr-2 h-4 w-4" />
  Transfer
</Button>
```

4. Import `ArrowLeftRight` from lucide-react.

5. Add TransferDialog component at the bottom with other dialogs:
```tsx
<TransferDialog
  open={transferDialogOpen}
  onOpenChange={(open) => {
    setTransferDialogOpen(open)
    if (!open) fetchComponent()
  }}
  componentId={component.id}
  componentName={component.name}
  currentQuantity={component.quantityOnHand}
/>
```

**Completion Criteria**:
- [ ] TransferDialog imported
- [ ] State for dialog open/close
- [ ] Transfer button added to action buttons
- [ ] TransferDialog rendered with correct props
- [ ] Dialog closes and refreshes data on success
- [ ] `npx tsc --noEmit` passes

### Subtask 5.3: Update Transactions Page for Transfer Type
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/transactions/page.tsx`
**Pattern**: Lines 30-36 (TRANSACTION_TYPES), lines 127-139 (getTypeBadgeVariant), lines 142-155 (formatTransactionSummary)
**Instructions**:
1. Add `transfer` to TRANSACTION_TYPES array:
```typescript
const TRANSACTION_TYPES = [
  { value: 'all', label: 'All Types' },
  { value: 'receipt', label: 'Receipt' },
  { value: 'adjustment', label: 'Adjustment' },
  { value: 'build', label: 'Build' },
  { value: 'initial', label: 'Initial' },
  { value: 'transfer', label: 'Transfer' },  // ADD
]
```

2. Add transfer case to `getTypeBadgeVariant`:
```typescript
case 'transfer':
  return 'info'  // or 'default' - pick appropriate variant
```

3. Add transfer case to `formatTransactionSummary`:
```typescript
case 'transfer':
  return `Transfer to ${tx.toLocation?.name || 'unknown'}`
```

Note: The `TransactionResponse` type in the component should already include `toLocation` from our earlier type updates.

**Completion Criteria**:
- [ ] `transfer` added to TRANSACTION_TYPES
- [ ] Badge variant for transfer
- [ ] Summary format for transfer
- [ ] `npx tsc --noEmit` passes

### Subtask 5.4: Update TransactionDetail Component for Transfer Type
**File**: `/home/pbrown/SkuInventory/src/components/features/TransactionDetail.tsx`
**Pattern**: Lines 59-84 (transactionTypeConfig), lines 114-163 (type-specific rendering)
**Instructions**:
1. Import `ArrowLeftRight` from lucide-react.

2. Add transfer to `transactionTypeConfig`:
```typescript
transfer: {
  label: 'Transfer',
  icon: ArrowLeftRight,
  variant: 'default' as const,
  description: 'Inventory transfer between locations',
},
```

3. Update the `TransactionDetailProps` interface to include transfer type and from/to locations:
```typescript
interface TransactionDetailProps {
  transaction: {
    id: string
    type: 'receipt' | 'build' | 'adjustment' | 'initial' | 'transfer'
    // ... existing fields ...
    fromLocation?: { id: string; name: string; type?: string } | null
    toLocation?: { id: string; name: string; type?: string } | null
    // ... rest of fields ...
  }
}
```

4. Add transfer-specific info display (after adjustment section, around line 163):
```tsx
{/* Transfer-specific info */}
{transaction.type === 'transfer' && (
  <>
    <div>
      <p className="text-sm text-muted-foreground">From Location</p>
      <p className="font-medium">{transaction.fromLocation?.name || '-'}</p>
    </div>
    <div>
      <p className="text-sm text-muted-foreground">To Location</p>
      <p className="font-medium">{transaction.toLocation?.name || '-'}</p>
    </div>
  </>
)}
```

**Completion Criteria**:
- [ ] Transfer type config added
- [ ] ArrowLeftRight icon imported
- [ ] Props interface updated
- [ ] From/To location display for transfers
- [ ] `npx tsc --noEmit` passes

---

## Phase 6: Export and Analytics Updates

### Subtask 6.1: Update Transaction Export for Transfer Type
**File**: `/home/pbrown/SkuInventory/src/app/api/export/transactions/route.ts`
**Instructions**:
1. Check if the export handles all transaction types dynamically or has hardcoded logic
2. If hardcoded, add handling for `transfer` type
3. Include `fromLocation` and `toLocation` in export if relevant

**Completion Criteria**:
- [ ] Transfer transactions export correctly
- [ ] From/To locations included in export
- [ ] `npx tsc --noEmit` passes

### Subtask 6.2: Update Analytics Services (if applicable)
**Files**:
- `/home/pbrown/SkuInventory/src/services/analytics.ts`
- `/home/pbrown/SkuInventory/src/services/analytics-export.ts`
**Instructions**:
1. Review each file for transaction type filtering
2. Add `transfer` handling if needed
3. Ensure transfers don't break existing analytics

**Completion Criteria**:
- [ ] Analytics services handle transfer type gracefully
- [ ] No runtime errors with transfer transactions
- [ ] `npx tsc --noEmit` passes

---

## Phase 7: Testing

### Subtask 7.1: Add Transfer Transaction Integration Tests
**File**: `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`
**Pattern**: Follow existing test patterns in the file
**Instructions**:
Add new describe block for Transfer Transaction tests:
```typescript
describe('Transfer Transaction', () => {
  it('creates transfer with correct location deduction/addition', async () => {
    // Setup: Create component with inventory at location A
    // Act: Transfer to location B
    // Assert: Location A decreased, Location B increased
  })

  it('transfer fails with insufficient inventory at source', async () => {
    // Setup: Create component with small inventory at location A
    // Act: Try to transfer more than available
    // Assert: 400 error with insufficient inventory message
  })

  it('transfer fails when source and destination are same', async () => {
    // Setup: Create component and single location
    // Act: Try to transfer to same location
    // Assert: 400 error
  })

  it('viewer cannot create transfer (401)', async () => {
    // Setup with viewer session
    // Assert: 401 error
  })

  it('transfer validates locations belong to company', async () => {
    // Setup: Create component, try transfer to non-company location
    // Assert: 404 or appropriate error
  })
})
```

**Completion Criteria**:
- [ ] Transfer creation test
- [ ] Insufficient inventory test
- [ ] Same location validation test
- [ ] Role check test
- [ ] Company scoping test
- [ ] All tests pass: `npm test -- --filter="transfer"` or `npm test -- tests/integration/transactions.test.ts`

---

## Summary of Deliverables

**Files Created (3)**:
- `src/services/transfer.ts` - Transfer transaction service
- `src/app/api/transactions/transfer/route.ts` - Transfer API endpoint
- `src/components/features/TransferDialog.tsx` - Transfer dialog UI

**Files Modified (12)**:
- `prisma/schema.prisma` - Schema changes
- `src/types/transaction.ts` - Transfer schema and types
- `src/types/index.ts` - TransactionType update
- `src/services/inventory.ts` - Transfer-aware quantity queries
- `src/app/api/transactions/route.ts` - List API update
- `src/app/api/transactions/[id]/route.ts` - Detail API update
- `src/app/(dashboard)/transactions/page.tsx` - Transactions page update
- `src/components/features/TransactionDetail.tsx` - Detail component update
- `src/app/(dashboard)/components/[id]/page.tsx` - Component detail page update
- `src/app/api/export/transactions/route.ts` - Export update
- `src/services/analytics.ts` - Analytics update (if needed)
- `tests/integration/transactions.test.ts` - Integration tests

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 7)
2. Complete each phase fully before starting next
3. Run `npx tsc --noEmit` after each subtask
4. Run `npm run build` after completing each phase
5. Follow reference patterns exactly
6. Pay special attention to:
   - The Prisma migration naming the existing `transactions` relation on Location
   - The inventory query updates for transfer-aware calculations
   - The two-line transaction approach for atomic transfers

## Test Strategy Note
- Use Vitest for unit/integration tests
- Run `npm test` to execute test suite
- Run `npm test -- --filter="transfer"` to run only transfer-related tests

## Validation Commands Summary
```bash
# After each subtask
npx tsc --noEmit

# After each phase
npm run build

# After Phase 1 (schema changes)
npx prisma migrate dev --name add_transfer_transaction_type
npx prisma generate

# After Phase 7 (tests)
npm test
```

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Phase 1: Database | 30m |
| Phase 2: Types | 20m |
| Phase 3: Service | 60m |
| Phase 4: API | 45m |
| Phase 5: Frontend | 90m |
| Phase 6: Export/Analytics | 30m |
| Phase 7: Testing | 60m |
| **Total** | **~5.5-6.5 hours** |

---

## Risk Mitigations

1. **Schema Migration Risk**: The Location model's `transactions` relation must be renamed to use explicit relation name. Test migration on dev before applying.

2. **Inventory Query Complexity**: The transfer-aware query is more complex. Consider adding database comments explaining the logic.

3. **Atomicity**: The `prisma.$transaction()` ensures atomic transfer. No partial transfers possible.

4. **UI State**: Dialog filters locations to prevent selecting same location for from/to.
