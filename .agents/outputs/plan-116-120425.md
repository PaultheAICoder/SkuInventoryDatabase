# Implementation Plan
**Generated**: 2025-12-04 13:52:14
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: Issue #116 - Create API endpoints for forecast data and configuration
**Estimated Build Time**: 4-6 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #116
**Priority**: High (blocks UI sub-issues #4-5 and export #6)
**Parent Issue**: #13 (Consumption-based forecasting & reorder recommendations)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED - Test affected forecast API routes
**Suggested Filter**: `--testPathPattern="forecast"` (if tests exist)

### Issue Validation
**Status**: Valid - Dependencies #112 (types) and #115 (service) are CLOSED
**Recent Changes**:
- `6a91a29` feat(issue #115): implement forecast service with consumption calculation
- `6904a67` feat(issue #112): add forecast types and Prisma schema

### Current State Assessment
- **Existing Service**: `src/services/forecast.ts` - fully implemented with:
  - `getForecastConfig(companyId)` - returns config or defaults
  - `upsertForecastConfig(companyId, input)` - creates/updates config
  - `getComponentForecasts(companyId, configOverride?)` - batch forecasts
  - `getComponentForecastById(componentId, configOverride?)` - single forecast
- **Database**: `ForecastConfig` model exists in Prisma schema (lines 485-497)
- **Types**: `src/types/forecast.ts` contains all needed types and Zod schemas
- **API Routes**: Directory `src/app/api/forecasts/` does NOT exist (to be created)

### Dependencies & Blockers
1. Issue #112 (Types) - CLOSED - Complete
2. Issue #115 (Forecast Service) - CLOSED - Complete
3. No external API/env dependencies required

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 4-6 hours
**Risk**: Low - follows established patterns, service layer complete

### Patterns Identified
**Primary**: `src/app/api/components/route.ts` - GET with pagination, parseQuery pattern
**Secondary**: `src/app/api/settings/alerts/route.ts` - GET/PATCH config pattern with admin-only updates
**Dynamic Route**: `src/app/api/skus/[id]/route.ts` - params extraction pattern with RouteParams type

### Ripple Effect Analysis
**Files to Create**: 3
- `src/app/api/forecasts/route.ts` - GET list endpoint
- `src/app/api/forecasts/[componentId]/route.ts` - GET single endpoint
- `src/app/api/forecasts/config/route.ts` - GET/PUT config endpoint

**Files to Modify**: 0 (pure additions)

**TOTAL FILES AFFECTED**: 3 (all new)

---

## Executive Summary
Create three new API route files for forecasting: a paginated list endpoint for all component forecasts, a single-component detail endpoint, and a configuration management endpoint. All endpoints will leverage the existing forecast service and types. Authorization follows established patterns with admin/ops role requirements for config updates.

## Phase 1: Create Forecast List Endpoint

### Subtask 1.1: Create `/api/forecasts` Route Directory
**File**: `src/app/api/forecasts/route.ts` (NEW)
**Pattern**: Follow `src/app/api/components/route.ts` (lines 1-156)
**Instructions**:
1. Create directory: `src/app/api/forecasts/`
2. Create `route.ts` with GET handler
3. Import dependencies:
   ```typescript
   import { NextRequest } from 'next/server'
   import { getServerSession } from 'next-auth'
   import { authOptions } from '@/lib/auth'
   import { paginated, unauthorized, serverError, parseQuery } from '@/lib/api-response'
   import { forecastListQuerySchema, ComponentForecastResponse } from '@/types/forecast'
   import { getComponentForecasts, getForecastConfig } from '@/services/forecast'
   ```
4. Implement GET handler:
   - Authenticate with `getServerSession(authOptions)`
   - Return `unauthorized()` if no session
   - Parse query params using `parseQuery(searchParams, forecastListQuerySchema)`
   - Get `selectedCompanyId` from session
   - Call `getComponentForecasts(companyId, { lookbackDays, safetyDays })` if overrides provided
   - Apply sorting based on `sortBy` and `sortOrder` params
   - Apply `showOnlyAtRisk` filter (components where `recommendedReorderDate` is not null and is within lead time)
   - Transform to `ComponentForecastResponse` format (serialize dates, decimals)
   - Apply pagination (slice data array)
   - Return `paginated(data, total, page, pageSize)`

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] File created at correct path
- [ ] GET handler authenticates session
- [ ] Query params parsed with Zod schema
- [ ] Sorting works for runoutDate, consumption, name, reorderQty
- [ ] showOnlyAtRisk filter works correctly
- [ ] Pagination applied correctly
- [ ] Response matches `ComponentForecastResponse` type
- [ ] TypeScript compiles without errors

### Subtask 1.2: Implement Response Serialization Helper
**File**: `src/app/api/forecasts/route.ts`
**Instructions**:
Add a helper function to transform `ComponentForecast` to `ComponentForecastResponse`:
```typescript
function serializeForecast(f: ComponentForecast): ComponentForecastResponse {
  return {
    componentId: f.componentId,
    componentName: f.componentName,
    skuCode: f.skuCode,
    quantityOnHand: f.quantityOnHand,
    averageDailyConsumption: f.averageDailyConsumption.toFixed(4),
    daysUntilRunout: f.daysUntilRunout,
    runoutDate: f.runoutDate?.toISOString() ?? null,
    recommendedReorderQty: f.recommendedReorderQty,
    recommendedReorderDate: f.recommendedReorderDate?.toISOString() ?? null,
    leadTimeDays: f.leadTimeDays,
    assumptions: f.assumptions,
  }
}
```

**Completion Criteria**:
- [ ] Dates serialized as ISO strings or null
- [ ] Decimals serialized as strings with fixed precision
- [ ] All fields mapped correctly

## Phase 2: Create Single Forecast Endpoint

### Subtask 2.1: Create `/api/forecasts/[componentId]` Dynamic Route
**File**: `src/app/api/forecasts/[componentId]/route.ts` (NEW)
**Pattern**: Follow `src/app/api/skus/[id]/route.ts` (lines 1-131 for GET)
**Instructions**:
1. Create directory: `src/app/api/forecasts/[componentId]/`
2. Create `route.ts` with GET handler
3. Import dependencies:
   ```typescript
   import { NextRequest } from 'next/server'
   import { getServerSession } from 'next-auth'
   import { authOptions } from '@/lib/auth'
   import { success, unauthorized, notFound, serverError } from '@/lib/api-response'
   import { getComponentForecastById } from '@/services/forecast'
   import { prisma } from '@/lib/db'
   ```
4. Define `type RouteParams = { params: Promise<{ componentId: string }> }`
5. Implement GET handler:
   - Authenticate session
   - Extract `componentId` from `await params`
   - Validate component belongs to user's `selectedCompanyId`
   - Parse optional query overrides (`lookbackDays`, `safetyDays`)
   - Call `getComponentForecastById(componentId, configOverride)`
   - Return `notFound('Component')` if null
   - Serialize and return with `success(serializedForecast)`

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] File created at correct path with [componentId] folder
- [ ] RouteParams type defined correctly
- [ ] Component scoped to selectedCompanyId
- [ ] Returns 404 for invalid componentId
- [ ] Optional query overrides work
- [ ] Response properly serialized

## Phase 3: Create Forecast Config Endpoints

### Subtask 3.1: Create `/api/forecasts/config` Route
**File**: `src/app/api/forecasts/config/route.ts` (NEW)
**Pattern**: Follow `src/app/api/settings/alerts/route.ts` (lines 1-93)
**Instructions**:
1. Create directory: `src/app/api/forecasts/config/`
2. Create `route.ts` with GET and PUT handlers
3. Import dependencies:
   ```typescript
   import { NextRequest } from 'next/server'
   import { getServerSession } from 'next-auth'
   import { authOptions } from '@/lib/auth'
   import {
     success,
     unauthorized,
     forbidden,
     serverError,
     parseBody,
   } from '@/lib/api-response'
   import { getForecastConfig, upsertForecastConfig } from '@/services/forecast'
   import { updateForecastConfigSchema, ForecastConfigResponse } from '@/types/forecast'
   import { prisma } from '@/lib/db'
   ```

4. Implement GET handler:
   - Authenticate session (any authenticated user can read)
   - Get `selectedCompanyId` from session
   - Call `getForecastConfig(companyId)`
   - Fetch full config from DB if exists (for id, createdAt, updatedAt)
   - Return serialized `ForecastConfigResponse`

5. Implement PUT handler:
   - Authenticate session
   - Check role: `if (session.user.role !== 'admin') return forbidden()`
   - Parse body with `parseBody(request, updateForecastConfigSchema)`
   - Call `upsertForecastConfig(companyId, data)`
   - Fetch updated config with timestamps
   - Return serialized response with success message

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] GET returns config or defaults for any authenticated user
- [ ] PUT requires admin role (returns 403 for others)
- [ ] PUT validates input with Zod schema
- [ ] Response includes id, companyId, timestamps
- [ ] Creates default config if none exists
- [ ] Updates existing config if present

### Subtask 3.2: Implement Config Response Serialization
**File**: `src/app/api/forecasts/config/route.ts`
**Instructions**:
Add helper to fetch and serialize config with DB record:
```typescript
async function getFullConfig(companyId: string): Promise<ForecastConfigResponse> {
  const dbConfig = await prisma.forecastConfig.findUnique({
    where: { companyId },
  })

  const config = await getForecastConfig(companyId)

  return {
    id: dbConfig?.id ?? '',
    companyId,
    lookbackDays: config.lookbackDays,
    safetyDays: config.safetyDays,
    excludedTransactionTypes: config.excludedTransactionTypes,
    createdAt: dbConfig?.createdAt.toISOString() ?? new Date().toISOString(),
    updatedAt: dbConfig?.updatedAt.toISOString() ?? new Date().toISOString(),
  }
}
```

Note: When no config exists in DB (defaults returned), set id to empty string and use current timestamp. The PUT will create the record.

**Completion Criteria**:
- [ ] Returns proper ForecastConfigResponse shape
- [ ] Handles case where no DB record exists (defaults)
- [ ] Timestamps serialized as ISO strings

## Phase 4: Final Validation

### Subtask 4.1: TypeScript and Build Validation
**Instructions**:
```bash
cd /home/pbrown/SkuInventory
npx tsc --noEmit
npm run build
npm run lint
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` completes successfully
- [ ] `npm run lint` passes with no errors or warnings

### Subtask 4.2: Manual API Verification (Optional)
**Instructions**:
If dev server is running, test endpoints:
```bash
# Test GET /api/forecasts (requires auth cookie)
curl -X GET http://localhost:4545/api/forecasts

# Test GET /api/forecasts/config
curl -X GET http://localhost:4545/api/forecasts/config

# Test PUT /api/forecasts/config (admin only)
curl -X PUT http://localhost:4545/api/forecasts/config \
  -H "Content-Type: application/json" \
  -d '{"lookbackDays": 60, "safetyDays": 14}'
```

**Completion Criteria**:
- [ ] GET /api/forecasts returns paginated list or 401
- [ ] GET /api/forecasts/[componentId] returns forecast or 404
- [ ] GET /api/forecasts/config returns config
- [ ] PUT /api/forecasts/config returns 403 for non-admin

---

## Summary of Deliverables
**Files Created**: 3
1. `src/app/api/forecasts/route.ts` - List endpoint (GET)
2. `src/app/api/forecasts/[componentId]/route.ts` - Single forecast (GET)
3. `src/app/api/forecasts/config/route.ts` - Config (GET/PUT)

**Files Modified**: 0

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4)
2. Each phase builds on the previous - types/service already exist
3. Follow reference patterns EXACTLY for authentication and response formatting
4. Test completion criteria before moving to next subtask
5. Run full build validation in Phase 4

## API Endpoint Summary

| Endpoint | Method | Auth | Role | Description |
|----------|--------|------|------|-------------|
| `/api/forecasts` | GET | Required | Any | Paginated list of component forecasts |
| `/api/forecasts/[componentId]` | GET | Required | Any | Single component forecast |
| `/api/forecasts/config` | GET | Required | Any | Get forecast config (or defaults) |
| `/api/forecasts/config` | PUT | Required | Admin | Update forecast config |

## Query Parameters Reference

### GET /api/forecasts
| Param | Type | Default | Description |
|-------|------|---------|-------------|
| page | number | 1 | Page number |
| pageSize | number | 50 | Items per page (max 100) |
| lookbackDays | number | (config) | Override lookback period |
| safetyDays | number | (config) | Override safety stock days |
| sortBy | string | 'runoutDate' | Sort field: runoutDate, consumption, name, reorderQty |
| sortOrder | string | 'asc' | Sort direction: asc, desc |
| showOnlyAtRisk | boolean | false | Filter to components needing reorder |

### PUT /api/forecasts/config Body
```typescript
{
  lookbackDays?: number,   // 7-365
  safetyDays?: number,     // 0-90
  excludedTransactionTypes?: ('initial' | 'adjustment' | 'receipt' | 'transfer')[]
}
```

## Test Strategy Note
- No existing tests for forecast module
- Integration tests recommended for API routes
- Use Vitest for unit tests if added later

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Investigation | 20m |
| Validation | 5m |
| Planning | 15m |
| **Total Scout-Plan** | **40m** |
| **Estimated Build** | **4-6h** |
