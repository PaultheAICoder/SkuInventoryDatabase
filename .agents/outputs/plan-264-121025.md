# Implementation Plan
**Generated**: 2025-12-10T18:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #264
**Estimated Build Time**: 3-5 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Bug (Follow-up to #250)
**Source**: GitHub Issue #264 (User feedback - fix verification failed)
**Priority**: High (User explicitly reports issue persists after #250 fix)
**Reporter**: Trevor Baek (tbaek@vital-enterprises.com)

### Issue Description
Follow-up to issue #250. User reports:
> "This is not resolved. It still follows the exact flow and the same issue appears. I cleared cache and the issue persists."

The original issue #250 fix added session loading state handling to the SKU detail page. However, the user confirms the error still occurs with the exact same flow (navigate to SKU -> click Build -> fill form -> submit).

**Error Displayed**: "Something went wrong. An unexpected error occurred. Please try again or contact support if the problem persists."

### Task Classification
**Category**: BUG_FIX
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="build|transaction|sku"`

### Issue Validation
**Status**: Valid - additional investigation required
**Recent Changes**:
- Commit 4f3d084 (issue #250): Added session status check to SKU detail page
- Commit 11ccebb (issue #256): Extended session loading fix to 6 other dashboard pages

### What Issue #250 Fix Addressed
The original fix addressed ONE cause of the error:
1. Session loading state not being checked on the SKU detail page
2. When `router.refresh()` was called after build, session briefly entered "loading" state
3. Components accessing session data during this period could throw errors

**Files Modified in #250**:
- `src/app/(dashboard)/skus/[id]/page.tsx` - Added `status` to useSession and loading guards
- `src/app/api/transactions/build/route.ts` - Enhanced error logging
- `src/components/features/BuildDialog.tsx` - Added console error logging
- `src/app/error.tsx` - Enhanced error boundary logging

### Current State Assessment (Post-#250)

**Session Loading - FIXED**:
- All dashboard pages now properly check `status === 'loading'`
- Verified in: page.tsx, layout.tsx, settings pages, SKU detail page, etc.

**Potential Remaining Causes Identified**:

1. **Double Refresh Race Condition** (HIGH PROBABILITY)
   - File: `src/components/features/BuildDialog.tsx` (lines 240-241)
   - File: `src/app/(dashboard)/skus/[id]/page.tsx` (lines 313-316)
   - Issue: BuildDialog calls both `onOpenChange(false)` AND `router.refresh()`
   - When dialog closes, SKUDetailPage's `onOpenChange` callback also calls `handleRefresh()` -> `fetchData()`
   - Result: TWO data refresh operations happen simultaneously
   - This could cause race conditions with Next.js server component revalidation

2. **selectedCompanyId Non-Null Assertion Errors** (MEDIUM PROBABILITY)
   - Multiple API routes use `selectedCompanyId!` non-null assertion
   - If session.user.selectedCompanyId is undefined/null during race condition, throws
   - Files affected: `src/app/api/skus/[id]/route.ts` (lines 76, 79, 82, 202, 206)

3. **Server Component Hydration Mismatch** (LOW-MEDIUM PROBABILITY)
   - SKU list page (`/skus/page.tsx`) is a server component
   - SKU detail page (`/skus/[id]/page.tsx`) is a client component
   - Navigation between them during refresh could cause hydration issues
   - Safari may be more sensitive to hydration mismatches

4. **API Response Parsing on Non-200** (LOW PROBABILITY)
   - File: `src/components/features/BuildDialog.tsx` (line 216)
   - `const data = await res.json().catch(() => ({}))` - catches JSON parse errors
   - If API returns HTML error page (not JSON), this catches but may hide root cause

### Patterns Identified
**Primary Reference**: `src/components/features/ReceiptDialog.tsx`
- Similar pattern but ONLY calls `router.refresh()`, not double-refresh
- Should follow this pattern in BuildDialog

**Secondary Reference**: `src/app/(dashboard)/skus/[id]/page.tsx`
- handleRefresh uses client-side fetch only
- Should NOT need both router.refresh() AND fetchData()

### Ripple Effect Analysis
**Files Identified**: 5 primary files
- `src/components/features/BuildDialog.tsx` - Primary fix location
- `src/app/(dashboard)/skus/[id]/page.tsx` - Secondary fix location (callback pattern)
- `src/components/features/FinishedGoodsAdjustmentDialog.tsx` - Same pattern, verify
- `src/components/features/FinishedGoodsReceiptDialog.tsx` - Same pattern, verify
- `src/app/api/skus/[id]/route.ts` - Non-null assertions to review

### Dependencies & Blockers
1. None - can proceed immediately
2. Test database verified: `inventory_test` accessible

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 3-5 hours
**Risk**: Low-Medium (timing-sensitive bug, requires careful testing)

---

## Executive Summary

The issue #250 fix was necessary but not sufficient. The original fix addressed session loading state, but the error persists because of a **double-refresh race condition**: when a build completes successfully, BuildDialog calls both `onOpenChange(false)` (which triggers SKUDetailPage's `handleRefresh()` -> `fetchData()`) AND `router.refresh()` on the same event loop tick. This creates a race condition between client-side fetch and Next.js server component revalidation, which can cause errors that bubble up to the error boundary.

The fix involves:
1. Removing redundant refresh calls (choose ONE refresh strategy, not both)
2. Adding defensive checks for race conditions
3. Enhanced error handling to capture the actual root cause

---

## Phase 0: Root Cause Verification & Debugging

### Subtask 0.1: Add Detailed Timing Logs to Build Flow
**File**: `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx`
**Instructions**:
1. Add console.log statements at key points in handleSubmit to trace execution order
2. Log timestamps before `onOpenChange(false)`, before `router.refresh()`, and in catch block

```typescript
// Add at line ~240, before onOpenChange:
console.log('[BuildDialog] Build success, closing dialog at:', Date.now())

// Add at line ~241, before router.refresh:
console.log('[BuildDialog] Dialog closed, calling router.refresh at:', Date.now())

// Update catch block at line ~266:
console.error('BuildDialog submission error:', {
  error: err,
  message: err instanceof Error ? err.message : 'Unknown',
  stack: err instanceof Error ? err.stack : undefined,
  timestamp: Date.now(),
})
```

**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/skus/[id]/page.tsx`
**Instructions**:
1. Add logging to handleRefresh and the onOpenChange callback:

```typescript
// At line ~77, update handleRefresh:
const handleRefresh = () => {
  console.log('[SKUDetailPage] handleRefresh called at:', Date.now())
  fetchData()
}

// At line ~313, update onOpenChange callback:
onOpenChange={(open) => {
  console.log('[SKUDetailPage] BuildDialog onOpenChange:', open, 'at:', Date.now())
  setBuildDialogOpen(open)
  if (!open) handleRefresh()
}}
```

**Purpose**: Verify the race condition hypothesis before fixing

**Completion Criteria**:
- [ ] Logging added to BuildDialog
- [ ] Logging added to SKUDetailPage
- [ ] Can reproduce issue and see timing in console

---

## Phase 1: Fix Double-Refresh Race Condition

### Subtask 1.1: Remove Redundant router.refresh() from BuildDialog
**File**: `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx`
**Pattern**: Follow `src/components/features/ReceiptDialog.tsx` (simplified approach)
**Instructions**:

The current code at lines 240-241:
```typescript
onOpenChange(false)
router.refresh()
```

**Option A - Recommended**: Remove `router.refresh()` entirely, rely on parent's `onOpenChange` callback

Change to:
```typescript
// Just close the dialog - parent component handles refresh via onOpenChange callback
onOpenChange(false)

// Remove router.refresh() - parent handles data refresh
// router.refresh() <-- DELETE THIS LINE
```

**Rationale**:
- The parent (SKUDetailPage) already calls `handleRefresh()` when dialog closes
- Calling both causes a race condition
- ReceiptDialog uses just `router.refresh()` without parent callback, but we have parent callback so use that

**Alternative - Option B**: If parent needs server component revalidation:
- Remove `handleRefresh()` from parent callback, keep only `router.refresh()` in dialog
- This is cleaner if we need full page revalidation

For now, implement **Option A** as it's the minimal change.

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] `router.refresh()` removed from BuildDialog line 241
- [ ] TypeScript compiles without errors
- [ ] Build succeeds

### Subtask 1.2: Ensure Parent Callback is Robust
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/skus/[id]/page.tsx`
**Instructions**:
1. Update the onOpenChange callback to add error handling:

Current code at lines 313-316:
```typescript
onOpenChange={(open) => {
  setBuildDialogOpen(open)
  if (!open) handleRefresh()
}}
```

Update to:
```typescript
onOpenChange={(open) => {
  setBuildDialogOpen(open)
  if (!open) {
    // Use slight delay to ensure dialog animation completes
    // and state is stable before fetching
    setTimeout(() => handleRefresh(), 100)
  }
}}
```

**Note**: The setTimeout is a defensive measure to allow React state updates to settle. If testing shows this is unnecessary, it can be removed.

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] onOpenChange callback updated
- [ ] TypeScript compiles

### Subtask 1.3: Apply Same Pattern to Other Dialogs (If Needed)
**Files to Review**:
- `src/components/features/FinishedGoodsAdjustmentDialog.tsx` (line 111)
- `src/components/features/FinishedGoodsReceiptDialog.tsx` (line 100)

**Instructions**:
1. Check if these dialogs have the same double-refresh pattern
2. If yes, apply the same fix (remove router.refresh if parent handles refresh)

Based on current implementation:
- FinishedGoodsAdjustmentDialog: `onOpenChange(false)` then `router.refresh()` - **SAME ISSUE**
- FinishedGoodsReceiptDialog: `onOpenChange(false)` then `router.refresh()` - **SAME ISSUE**

Apply the same fix to both.

**Completion Criteria**:
- [ ] FinishedGoodsAdjustmentDialog updated
- [ ] FinishedGoodsReceiptDialog updated

---

## Phase 2: Add Defensive Session Checks

### Subtask 2.1: Add Null Check Before API Calls in SKU Route
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
**Instructions**:
1. At line ~35, after getting selectedCompanyId, add early return:

Current:
```typescript
const selectedCompanyId = session.user.selectedCompanyId
```

Add check:
```typescript
const selectedCompanyId = session.user.selectedCompanyId
if (!selectedCompanyId) {
  return error('No company selected. Please select a company from the sidebar.', 400)
}
```

This prevents the non-null assertions from throwing at lines 76, 79, 82.

2. Apply same check to lines ~149 (PATCH) and ~245 (DELETE)

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] GET handler has selectedCompanyId null check
- [ ] PATCH handler has selectedCompanyId null check
- [ ] DELETE handler has selectedCompanyId null check
- [ ] TypeScript compiles
- [ ] Build succeeds

### Subtask 2.2: Add Null Check to Build Transaction Route
**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
**Instructions**:
1. At line ~28, after getting selectedCompanyId, add check:

```typescript
const selectedCompanyId = session.user.selectedCompanyId
if (!selectedCompanyId) {
  return error('No company selected. Please select a company and try again.', 400)
}
```

**Completion Criteria**:
- [ ] Build route has null check
- [ ] TypeScript compiles

---

## Phase 3: Enhanced Error Capture

### Subtask 3.1: Add Error Context to BuildDialog Catch Block
**File**: `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx`
**Instructions**:
1. Update catch block at line ~265-267 to capture more context:

```typescript
} catch (err) {
  const errorContext = {
    error: err,
    message: err instanceof Error ? err.message : 'Unknown error',
    formData: {
      skuId: formData.skuId,
      date: formData.date,
      unitsToBuild: formData.unitsToBuild,
    },
    timestamp: new Date().toISOString(),
  }
  console.error('BuildDialog submission error:', errorContext)

  // Provide more helpful error message
  let userMessage = 'An error occurred'
  if (err instanceof Error) {
    if (err.message.includes('company')) {
      userMessage = 'Please select a company from the sidebar and try again'
    } else if (err.message.includes('network') || err.message.includes('fetch')) {
      userMessage = 'Network error. Please check your connection and try again'
    } else {
      userMessage = err.message
    }
  }
  setError(userMessage)
} finally {
  setIsLoading(false)
}
```

**Completion Criteria**:
- [ ] Enhanced error capture implemented
- [ ] User-friendly error messages added
- [ ] TypeScript compiles

---

## Phase 4: Testing

### Subtask 4.1: Manual Testing in Test Environment
**Target**: http://172.16.20.50:2345
**Instructions**:
1. Log in as a user with build permissions
2. Navigate to an SKU with an active BOM
3. Click the "Build" button
4. Fill in units to build (e.g., 5)
5. Click "Record Build"
6. Verify:
   - [ ] No error page appears
   - [ ] Dialog closes smoothly
   - [ ] Page refreshes with updated data
   - [ ] FG balance increases if outputting to FG
   - [ ] Component quantities decrease

**Additional Tests**:
7. Repeat build 5 times rapidly to test race condition handling
8. Test with Safari browser if available (or Safari-like timing with slow network)
9. Test while switching companies during build (edge case)

**Completion Criteria**:
- [ ] Build succeeds without errors
- [ ] Multiple rapid builds don't cause errors
- [ ] Data refreshes correctly after each build

### Subtask 4.2: Run Existing Tests
**Instructions**:
```bash
cd /home/pbrown/SkuInventory
npm test -- --filter="build|transaction|sku"
```

**Completion Criteria**:
- [ ] All existing tests pass
- [ ] No regressions

### Subtask 4.3: Remove Debug Logging
**Files**:
- `src/components/features/BuildDialog.tsx`
- `src/app/(dashboard)/skus/[id]/page.tsx`

**Instructions**:
1. Remove the timing console.log statements added in Phase 0
2. Keep the enhanced error logging in catch blocks (these are valuable for production)

**Completion Criteria**:
- [ ] Debug timing logs removed
- [ ] Production-worthy error logging retained

---

## Summary of Deliverables

**Files Modified**: 6
- `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx` - Remove double refresh, enhance error handling
- `/home/pbrown/SkuInventory/src/app/(dashboard)/skus/[id]/page.tsx` - Add delayed refresh callback
- `/home/pbrown/SkuInventory/src/components/features/FinishedGoodsAdjustmentDialog.tsx` - Remove double refresh
- `/home/pbrown/SkuInventory/src/components/features/FinishedGoodsReceiptDialog.tsx` - Remove double refresh
- `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts` - Add null checks
- `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts` - Add null check

**Files Created**: 0

## Handoff to Build Agent

1. Execute subtasks in order (Phase 0 -> Phase 1 -> Phase 2 -> Phase 3 -> Phase 4)
2. Phase 0 (debugging) can be skipped if confidence is high - jump to Phase 1
3. Test each phase completion before moving on
4. Run TypeScript and build checks after each file modification
5. Manual testing is CRITICAL - this is a timing-sensitive bug
6. Safari testing would be ideal given the user's reported browser

## Test Strategy Note
- Primary: Manual testing in test environment (http://172.16.20.50:2345)
- Secondary: Unit tests with `--filter="build|transaction|sku"`
- Target test database only (port 2346)

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 35m |
| Validation | 10m |
| Planning | 20m |
| **Total** | **65m** |

---

## Additional Notes

### Why the #250 Fix Was Incomplete
The #250 fix correctly identified that session loading state was unhandled, which COULD cause the error. However, it only addressed ONE scenario:
- Session entering "loading" state during router.refresh()

The fix did NOT address:
- The double-refresh itself causing race conditions
- State updates happening while data is being fetched
- Non-null assertions failing if session data is briefly incomplete

### Safari-Specific Behavior
Safari has different timing characteristics for:
- Promise resolution
- Event loop microtasks
- CSS animations and transitions

This makes Safari more likely to expose race conditions that don't manifest in Chrome/Firefox. The fixes in this plan address the root cause (double refresh) rather than trying to handle Safari-specific timing.

### Why setTimeout in Callback?
The `setTimeout(() => handleRefresh(), 100)` is a defensive pattern that:
1. Allows React state updates from `setBuildDialogOpen(false)` to propagate
2. Ensures dialog close animation completes
3. Prevents calling fetchData while component tree is updating

If testing shows this is unnecessary, the timeout can be reduced or removed. Start conservative, optimize later.
