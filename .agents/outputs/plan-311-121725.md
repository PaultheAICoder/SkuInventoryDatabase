# Implementation Plan
**Generated**: 2025-12-17T19:15:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #311
**Estimated Build Time**: 10-14 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #311
**Priority**: Medium

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="Feedback"` (run feedback-related tests)

### Issue Validation
**Status**: Valid
**Recent Changes**: Multiple enhancements to feedback system in past 60 days (see commits above), but none conflict with this enhancement.

### Current State Assessment
- **Existing components**:
  - `FeedbackDialog.tsx` - 430 lines, functional but uses simple description + clarifying questions flow
  - `feedback.ts` types - Has `clarifyRequestSchema` and `submitFeedbackSchema` with basic fields
  - `clarify/route.ts` - Calls `generateClarifyingQuestions` with just type and description
  - `feedback/route.ts` - Full submission handler with GitHub issue creation
- **Database**: No changes needed - feedback stored in GitHub issues
- **API Routes**: Two routes need enhancement - clarify and submit
- **Types**: New schema fields required for structured data

### Dependencies & Blockers
1. None identified - this enhances existing feature
2. All required UI components exist (`Select`, `Input`, `Textarea`, `Label`)
3. shadcn/ui select component available at `src/components/ui/select.tsx`

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 10-14 hours
**Risk**: Low - enhances existing feature with well-defined patterns

### Patterns Identified
**Primary**: `/home/pbrown/Entertask/laravel/resources/js/Components/FeedbackModal.vue` - Vue implementation to adapt
**Secondary**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx` - Current React implementation

### Ripple Effect Analysis
**Files Identified**: 9 files total

| File | Change Type | Reason |
|------|-------------|--------|
| `src/types/feedback.ts` | MODIFY | Add new schema fields for structured data |
| `src/components/features/FeedbackDialog.tsx` | MAJOR MODIFY | Complete UI redesign with new step flow |
| `src/app/api/feedback/clarify/route.ts` | MODIFY | Accept structured fields, enhanced prompt |
| `src/app/api/feedback/route.ts` | MODIFY | Accept and format new fields in issue body |
| `src/lib/claude.ts` | MODIFY | Update AI prompt with context-aware questions |
| `tests/unit/FeedbackDialog.test.tsx` | MAJOR MODIFY | Update tests for new UI flow |
| `tests/unit/feedback-types.test.ts` | MODIFY | Test new schema validations |
| `tests/unit/feedback-service.test.ts` | NO CHANGE | Service layer unchanged |

---

## Executive Summary
Enhance the feedback submission dialog to collect structured, type-specific information upfront (expected behavior, actual behavior, steps to reproduce for bugs; who benefits, desired action, business value for features). Auto-capture page URL, add a title field, and pass all context to the AI for generating highly customized clarifying questions instead of generic ones.

## Phase 0: Schema and Types Layer

### Subtask 0.1: Define New Structured Feedback Types
**File**: `/home/pbrown/SkuInventory/src/types/feedback.ts`
**Pattern**: Follow existing zod schema patterns in the same file
**Instructions**:
1. Add new fields to `clarifyRequestSchema`:
   ```typescript
   export const clarifyRequestSchema = z.object({
     type: z.enum(['bug', 'feature']),
     pageUrl: z.string().url().optional(),
     title: z.string().min(5).max(255),
     // Bug-specific fields (all optional, validated based on type)
     expectedBehavior: z.string().min(10).max(2000).optional(),
     actualBehavior: z.string().min(10).max(2000).optional(),
     stepsToReproduce: z.string().min(10).max(2000).optional(),
     screenshotUrl: z.string().url().optional().or(z.literal('')),
     // Feature-specific fields
     whoBenefits: z.string().optional(),
     desiredAction: z.string().min(10).max(2000).optional(),
     businessValue: z.string().min(10).max(2000).optional(),
   })
   ```
2. Update `submitFeedbackSchema` to include all new fields:
   ```typescript
   export const submitFeedbackSchema = z.object({
     type: z.enum(['bug', 'feature']),
     pageUrl: z.string().url().optional(),
     title: z.string().min(5).max(255),
     // Bug fields
     expectedBehavior: z.string().optional(),
     actualBehavior: z.string().optional(),
     stepsToReproduce: z.string().optional(),
     screenshotUrl: z.string().optional(),
     // Feature fields
     whoBenefits: z.string().optional(),
     desiredAction: z.string().optional(),
     businessValue: z.string().optional(),
     // AI clarification answers
     answers: z.array(z.string()).min(2).max(3),
   })
   ```
3. Update `FeedbackStep` type to reflect new flow:
   ```typescript
   export type FeedbackStep = 'select-type' | 'structured-fields' | 'clarify' | 'submitting' | 'success' | 'error'
   ```
4. Add `WhoBenefitsOption` type for the dropdown:
   ```typescript
   export const WHO_BENEFITS_OPTIONS = [
     'All Users',
     'Administrators',
     'Data Entry Staff',
     'Analysts',
     'Other'
   ] as const
   export type WhoBenefitsOption = typeof WHO_BENEFITS_OPTIONS[number]
   ```
5. Remove the old `description` field from schemas (replaced by structured fields)

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```
**Completion Criteria**:
- [ ] New zod schemas compile without errors
- [ ] `clarifyRequestSchema` accepts all new fields
- [ ] `submitFeedbackSchema` accepts all new fields
- [ ] `FeedbackStep` updated to new flow

---

## Phase 1: Backend API Updates

### Subtask 1.1: Update Clarify Route to Accept Structured Data
**File**: `/home/pbrown/SkuInventory/src/app/api/feedback/clarify/route.ts`
**Pattern**: Follow existing route structure in same file
**Instructions**:
1. Update the POST handler to use new schema fields:
   ```typescript
   // Parse with updated schema
   const { data, error } = await parseBody(request, clarifyRequestSchema)
   if (error) return error

   // Pass all structured data to AI
   const result = await generateClarifyingQuestions({
     type: data.type,
     pageUrl: data.pageUrl,
     title: data.title,
     // Bug fields
     expectedBehavior: data.expectedBehavior,
     actualBehavior: data.actualBehavior,
     stepsToReproduce: data.stepsToReproduce,
     screenshotUrl: data.screenshotUrl,
     // Feature fields
     whoBenefits: data.whoBenefits,
     desiredAction: data.desiredAction,
     businessValue: data.businessValue,
   })
   ```

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Route accepts new schema fields
- [ ] Passes all fields to `generateClarifyingQuestions`
- [ ] TypeScript compiles without errors

### Subtask 1.2: Update AI Question Generation with Context
**File**: `/home/pbrown/SkuInventory/src/lib/claude.ts`
**Pattern**: Follow existing `generateClarifyingQuestions` function structure
**Instructions**:
1. Update `GenerateQuestionsParams` interface:
   ```typescript
   export interface GenerateQuestionsParams {
     type: 'bug' | 'feature'
     pageUrl?: string
     title: string
     // Bug fields
     expectedBehavior?: string
     actualBehavior?: string
     stepsToReproduce?: string
     screenshotUrl?: string
     // Feature fields
     whoBenefits?: string
     desiredAction?: string
     businessValue?: string
   }
   ```
2. Update `generateClarifyingQuestions` function to use all context:
   - Build context string from all provided fields
   - Update system prompts for bug and feature types
   - Bug prompt should reference: page URL, title, expected behavior, actual behavior, steps to reproduce
   - Feature prompt should reference: page URL, title, who benefits, desired action, business value
3. Update system prompts to generate context-specific questions:
   ```typescript
   // Bug system prompt (example):
   const systemPrompt = `You are helping gather additional information about a software bug report.

   CONTEXT PROVIDED:
   - Page URL: ${params.pageUrl || 'Not specified'}
   - Title: ${params.title}
   - Expected Behavior: ${params.expectedBehavior || 'Not specified'}
   - Actual Behavior: ${params.actualBehavior || 'Not specified'}
   - Steps to Reproduce: ${params.stepsToReproduce || 'Not specified'}

   Based on this context, generate exactly 2-3 highly specific follow-up questions.
   Focus on gaps in the provided information.
   Do NOT ask generic questions - be specific to this bug and page.
   Each question should be under 120 characters.
   Return ONLY the questions, one per line.`
   ```
4. Update fallback questions to be more relevant
5. Change from requiring exactly 3 questions to accepting 2-3

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Interface updated with all new params
- [ ] AI prompts use structured context
- [ ] Questions are context-specific, not generic
- [ ] Accepts 2-3 questions instead of exactly 3

### Subtask 1.3: Update Submit Route to Format New Fields in Issue Body
**File**: `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts`
**Pattern**: Follow existing `enhanceIssueWithClaudeCode` call pattern
**Instructions**:
1. Update to accept new schema fields from `submitFeedbackSchema`
2. Pass all structured data to `enhanceIssueWithClaudeCode`:
   ```typescript
   const { data, error: parseError } = await parseBody(request, submitFeedbackSchema)
   if (parseError) return parseError

   const enhanced = await enhanceIssueWithClaudeCode({
     type: data.type,
     pageUrl: data.pageUrl,
     title: data.title,
     expectedBehavior: data.expectedBehavior,
     actualBehavior: data.actualBehavior,
     stepsToReproduce: data.stepsToReproduce,
     screenshotUrl: data.screenshotUrl,
     whoBenefits: data.whoBenefits,
     desiredAction: data.desiredAction,
     businessValue: data.businessValue,
     answers: data.answers,
   })
   ```
3. Use the title from the request (not from Claude) as the issue title fallback:
   ```typescript
   const title = enhanced.title || data.title
   ```

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Route accepts all new fields
- [ ] Fields passed to enhancement function
- [ ] Title uses user-provided value as fallback

### Subtask 1.4: Update Issue Enhancement with Structured Data
**File**: `/home/pbrown/SkuInventory/src/lib/claude.ts`
**Pattern**: Follow existing `enhanceIssueWithClaudeCode` and `buildUserContext` functions
**Instructions**:
1. Update `EnhanceIssueParams` interface with all new fields
2. Update `buildUserContext` function to format structured fields:
   ```typescript
   function buildUserContext(params: EnhanceIssueParams): string {
     const { type, pageUrl, title, ...fields } = params

     if (type === 'bug') {
       return `Bug Report:
   Page URL: ${pageUrl || 'Not specified'}
   Title: ${title}
   Expected Behavior: ${fields.expectedBehavior || 'Not provided'}
   Actual Behavior: ${fields.actualBehavior || 'Not provided'}
   Steps to Reproduce: ${fields.stepsToReproduce || 'Not provided'}
   Screenshot: ${fields.screenshotUrl || 'None'}

   Follow-up Questions and Answers:
   ${params.answers.map((a, i) => `A${i + 1}: ${a}`).join('\n')}`
     } else {
       return `Feature Request:
   Page URL: ${pageUrl || 'Not specified'}
   Title: ${title}
   Who Benefits: ${fields.whoBenefits || 'Not specified'}
   Desired Action: ${fields.desiredAction || 'Not provided'}
   Business Value: ${fields.businessValue || 'Not provided'}

   Follow-up Questions and Answers:
   ${params.answers.map((a, i) => `A${i + 1}: ${a}`).join('\n')}`
     }
   }
   ```
3. Update `formatFallbackBugBody` and `formatFallbackFeatureBody` to use structured fields
4. Update `buildSystemPrompt` to expect structured input format

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] `EnhanceIssueParams` has all new fields
- [ ] `buildUserContext` formats structured data
- [ ] Fallback formatters use structured data
- [ ] Build passes

---

## Phase 2: Frontend Dialog Redesign

### Subtask 2.1: Capture Page URL on Dialog Open
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Pattern**: Follow existing state management in same file
**Instructions**:
1. Add new state variable for page URL:
   ```typescript
   const [pageUrl, setPageUrl] = useState('')
   ```
2. Capture URL when dialog opens using useEffect:
   ```typescript
   useEffect(() => {
     if (open) {
       setPageUrl(window.location.href)
     }
   }, [open])
   ```
3. Include in reset logic when dialog closes

**Validation Commands**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Page URL captured when dialog opens
- [ ] URL reset when dialog closes
- [ ] State properly managed

### Subtask 2.2: Add Title Field State
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Instructions**:
1. Add title state:
   ```typescript
   const [title, setTitle] = useState('')
   ```
2. Include in reset logic
3. Validate title length (5-255 chars)

**Completion Criteria**:
- [ ] Title state added
- [ ] Title included in reset

### Subtask 2.3: Add Bug-Specific Field States
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Instructions**:
1. Add bug field states:
   ```typescript
   const [expectedBehavior, setExpectedBehavior] = useState('')
   const [actualBehavior, setActualBehavior] = useState('')
   const [stepsToReproduce, setStepsToReproduce] = useState('')
   const [screenshotUrl, setScreenshotUrl] = useState('')
   ```
2. Include all in reset logic

**Completion Criteria**:
- [ ] All bug field states added
- [ ] All included in reset

### Subtask 2.4: Add Feature-Specific Field States
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Instructions**:
1. Add feature field states:
   ```typescript
   const [whoBenefits, setWhoBenefits] = useState('')
   const [desiredAction, setDesiredAction] = useState('')
   const [businessValue, setBusinessValue] = useState('')
   ```
2. Import `WHO_BENEFITS_OPTIONS` from types
3. Include all in reset logic

**Completion Criteria**:
- [ ] All feature field states added
- [ ] Import WHO_BENEFITS_OPTIONS
- [ ] All included in reset

### Subtask 2.5: Update Step Flow from 'describe' to 'structured-fields'
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Instructions**:
1. Update step type usage from `'describe'` to `'structured-fields'`
2. Update `handleTypeSelect` to go to `'structured-fields'`:
   ```typescript
   const handleTypeSelect = (type: FeedbackType) => {
     setFeedbackType(type)
     setStep('structured-fields')
   }
   ```
3. Update `handleBack` function for new flow

**Completion Criteria**:
- [ ] Step transitions updated
- [ ] handleBack works correctly

### Subtask 2.6: Build Structured Fields Step UI - Common Fields
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Pattern**: Follow Entertask FeedbackModal.vue lines 312-337
**Instructions**:
1. Add imports for Select and Input components:
   ```typescript
   import { Input } from '@/components/ui/input'
   import {
     Select,
     SelectContent,
     SelectItem,
     SelectTrigger,
     SelectValue,
   } from '@/components/ui/select'
   ```
2. Create structured fields step JSX (replaces 'describe' step):
   ```tsx
   {step === 'structured-fields' && (
     <>
       <DialogHeader>
         <DialogTitle>
           {feedbackType === 'bug' ? 'Report a Bug' : 'Request a Feature'}
         </DialogTitle>
         <DialogDescription>
           Please provide details about your {feedbackType === 'bug' ? 'issue' : 'request'}.
         </DialogDescription>
       </DialogHeader>

       <div className="grid gap-4 py-4 max-h-[400px] overflow-y-auto">
         {error && (
           <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
             {error}
           </div>
         )}

         {/* Page URL (read-only) */}
         <div className="grid gap-2">
           <Label htmlFor="pageUrl">Page URL</Label>
           <Input
             id="pageUrl"
             value={pageUrl}
             disabled
             className="bg-muted"
           />
           <p className="text-xs text-muted-foreground">
             Auto-captured from current page
           </p>
         </div>

         {/* Title */}
         <div className="grid gap-2">
           <Label htmlFor="title">Title *</Label>
           <Input
             id="title"
             placeholder="Brief summary of your feedback"
             value={title}
             onChange={(e) => setTitle(e.target.value)}
             maxLength={255}
           />
           <p className="text-xs text-muted-foreground">
             {title.length}/255 characters (minimum 5)
           </p>
         </div>

         {/* Type-specific fields render here */}
       </div>
     </>
   )}
   ```

**Completion Criteria**:
- [ ] Imports added
- [ ] Common fields render
- [ ] Page URL displayed read-only

### Subtask 2.7: Build Structured Fields Step UI - Bug Fields
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Pattern**: Follow Entertask FeedbackModal.vue lines 386-430
**Instructions**:
1. Inside the structured-fields step, add bug-specific fields conditionally:
   ```tsx
   {feedbackType === 'bug' && (
     <>
       {/* Expected Behavior */}
       <div className="grid gap-2">
         <Label htmlFor="expectedBehavior">What should happen? *</Label>
         <Textarea
           id="expectedBehavior"
           placeholder="Describe the expected behavior..."
           value={expectedBehavior}
           onChange={(e) => setExpectedBehavior(e.target.value)}
           className="min-h-[80px]"
           maxLength={2000}
         />
         <p className="text-xs text-muted-foreground">
           {expectedBehavior.length}/2000 characters (minimum 10)
         </p>
       </div>

       {/* Actual Behavior */}
       <div className="grid gap-2">
         <Label htmlFor="actualBehavior">What actually happens? *</Label>
         <Textarea
           id="actualBehavior"
           placeholder="Describe what's actually happening..."
           value={actualBehavior}
           onChange={(e) => setActualBehavior(e.target.value)}
           className="min-h-[80px]"
           maxLength={2000}
         />
         <p className="text-xs text-muted-foreground">
           {actualBehavior.length}/2000 characters (minimum 10)
         </p>
       </div>

       {/* Steps to Reproduce */}
       <div className="grid gap-2">
         <Label htmlFor="stepsToReproduce">Steps to reproduce *</Label>
         <Textarea
           id="stepsToReproduce"
           placeholder="1. Go to...
2. Click on...
3. See error..."
           value={stepsToReproduce}
           onChange={(e) => setStepsToReproduce(e.target.value)}
           className="min-h-[100px]"
           maxLength={2000}
         />
         <p className="text-xs text-muted-foreground">
           {stepsToReproduce.length}/2000 characters (minimum 10)
         </p>
       </div>

       {/* Screenshot URL (optional) */}
       <div className="grid gap-2">
         <Label htmlFor="screenshotUrl">Screenshot URL (optional)</Label>
         <Input
           id="screenshotUrl"
           type="url"
           placeholder="https://..."
           value={screenshotUrl}
           onChange={(e) => setScreenshotUrl(e.target.value)}
         />
       </div>
     </>
   )}
   ```

**Completion Criteria**:
- [ ] Bug fields render when type is 'bug'
- [ ] Character counts shown
- [ ] Screenshot URL is optional

### Subtask 2.8: Build Structured Fields Step UI - Feature Fields
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Pattern**: Follow Entertask FeedbackModal.vue lines 340-383
**Instructions**:
1. Inside the structured-fields step, add feature-specific fields conditionally:
   ```tsx
   {feedbackType === 'feature' && (
     <>
       {/* Who Benefits */}
       <div className="grid gap-2">
         <Label htmlFor="whoBenefits">Who would benefit from this? *</Label>
         <Select value={whoBenefits} onValueChange={setWhoBenefits}>
           <SelectTrigger id="whoBenefits">
             <SelectValue placeholder="Select who benefits" />
           </SelectTrigger>
           <SelectContent>
             {WHO_BENEFITS_OPTIONS.map((option) => (
               <SelectItem key={option} value={option}>
                 {option}
               </SelectItem>
             ))}
           </SelectContent>
         </Select>
       </div>

       {/* Desired Action */}
       <div className="grid gap-2">
         <Label htmlFor="desiredAction">What action do you want to be able to do? *</Label>
         <Textarea
           id="desiredAction"
           placeholder="Describe what you'd like to be able to do..."
           value={desiredAction}
           onChange={(e) => setDesiredAction(e.target.value)}
           className="min-h-[100px]"
           maxLength={2000}
         />
         <p className="text-xs text-muted-foreground">
           {desiredAction.length}/2000 characters (minimum 10)
         </p>
       </div>

       {/* Business Value */}
       <div className="grid gap-2">
         <Label htmlFor="businessValue">Why does this matter? *</Label>
         <Textarea
           id="businessValue"
           placeholder="Explain the benefits and why this is important..."
           value={businessValue}
           onChange={(e) => setBusinessValue(e.target.value)}
           className="min-h-[100px]"
           maxLength={2000}
         />
         <p className="text-xs text-muted-foreground">
           {businessValue.length}/2000 characters (minimum 10)
         </p>
       </div>
     </>
   )}
   ```

**Completion Criteria**:
- [ ] Feature fields render when type is 'feature'
- [ ] Select dropdown works for "Who Benefits"
- [ ] Character counts shown

### Subtask 2.9: Add Structured Fields Footer with Validation
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Instructions**:
1. Add validation function for structured fields:
   ```typescript
   const isStructuredFieldsValid = () => {
     if (title.length < 5) return false

     if (feedbackType === 'bug') {
       return expectedBehavior.length >= 10 &&
              actualBehavior.length >= 10 &&
              stepsToReproduce.length >= 10
     } else {
       return whoBenefits !== '' &&
              desiredAction.length >= 10 &&
              businessValue.length >= 10
     }
   }
   ```
2. Add footer to structured-fields step:
   ```tsx
   <DialogFooter>
     <Button type="button" variant="outline" onClick={handleBack}>
       Back
     </Button>
     <Button
       type="button"
       onClick={handleStructuredFieldsSubmit}
       disabled={isLoading || !isStructuredFieldsValid()}
     >
       {isLoading ? (
         <>
           <Loader2 className="mr-2 h-4 w-4 animate-spin" />
           Getting Questions...
         </>
       ) : (
         'Continue'
       )}
     </Button>
   </DialogFooter>
   ```

**Completion Criteria**:
- [ ] Validation function checks all required fields
- [ ] Button disabled until valid
- [ ] Loading state shown

### Subtask 2.10: Update API Call to Clarify Endpoint
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Instructions**:
1. Rename `handleDescriptionSubmit` to `handleStructuredFieldsSubmit`
2. Update API call to send all structured fields:
   ```typescript
   const handleStructuredFieldsSubmit = async () => {
     if (!isStructuredFieldsValid()) {
       setError('Please fill in all required fields')
       return
     }

     setIsLoading(true)
     setError(null)

     try {
       const requestBody = {
         type: feedbackType,
         pageUrl,
         title,
         ...(feedbackType === 'bug' && {
           expectedBehavior,
           actualBehavior,
           stepsToReproduce,
           screenshotUrl: screenshotUrl || undefined,
         }),
         ...(feedbackType === 'feature' && {
           whoBenefits,
           desiredAction,
           businessValue,
         }),
       }

       const res = await fetch('/api/feedback/clarify', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(requestBody),
       })

       // ... rest of handling
     } catch (err) {
       // ... error handling
     } finally {
       setIsLoading(false)
     }
   }
   ```

**Completion Criteria**:
- [ ] Sends all structured fields to API
- [ ] Type-specific fields conditionally included
- [ ] Empty optional fields excluded

### Subtask 2.11: Update Submission to Include Structured Data
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Instructions**:
1. Update `handleSubmit` function to send all structured fields:
   ```typescript
   const handleSubmit = async () => {
     // ... validation

     try {
       const requestBody = {
         type: feedbackType,
         pageUrl,
         title,
         ...(feedbackType === 'bug' && {
           expectedBehavior,
           actualBehavior,
           stepsToReproduce,
           screenshotUrl: screenshotUrl || undefined,
         }),
         ...(feedbackType === 'feature' && {
           whoBenefits,
           desiredAction,
           businessValue,
         }),
         answers,
       }

       const res = await fetch('/api/feedback', {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(requestBody),
       })

       // ... rest of handling
     } catch (err) {
       // ... error handling
     }
   }
   ```

**Completion Criteria**:
- [ ] All structured fields sent to submit endpoint
- [ ] Answers included
- [ ] Type-specific fields conditional

### Subtask 2.12: Update Answers State for Variable Question Count
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Instructions**:
1. Initialize answers based on questions received:
   ```typescript
   // In clarify response handling:
   setQuestions(data.data.questions)
   setAnswers(new Array(data.data.questions.length).fill(''))
   ```
2. Update answer validation to handle 2-3 questions:
   ```typescript
   // In handleSubmit:
   if (answers.some((a) => a.trim().length === 0)) {
     setError('Please answer all questions')
     return
   }
   ```
3. Update reset to handle dynamic answer count:
   ```typescript
   setAnswers([])
   ```

**Completion Criteria**:
- [ ] Answers array sized to match questions
- [ ] Validation works for 2-3 questions
- [ ] Reset clears answers properly

### Subtask 2.13: Remove Old Description Step Code
**File**: `/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`
**Instructions**:
1. Remove the old `{step === 'describe' && (...)}` JSX block
2. Remove `description` state variable
3. Update any remaining references to `description`

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Old describe step removed
- [ ] No references to description state
- [ ] Build passes

---

## Phase 3: Test Updates

### Subtask 3.1: Update Type Schema Tests
**File**: `/home/pbrown/SkuInventory/tests/unit/feedback-types.test.ts`
**Instructions**:
1. Update `clarifyRequestSchema` tests for new fields:
   - Test valid bug request with all fields
   - Test valid feature request with all fields
   - Test validation of title length
   - Test validation of structured field lengths
2. Update `submitFeedbackSchema` tests:
   - Test with 2 answers (should pass)
   - Test with 3 answers (should pass)
   - Test required fields by type

**Validation Commands**:
```bash
npm test -- --filter="feedback-types"
```
**Completion Criteria**:
- [ ] All schema tests updated
- [ ] New field validations tested
- [ ] Tests pass

### Subtask 3.2: Update FeedbackDialog Component Tests
**File**: `/home/pbrown/SkuInventory/tests/unit/FeedbackDialog.test.tsx`
**Instructions**:
1. Update test data for new API payloads
2. Update step transition tests:
   - `'describe'` -> `'structured-fields'`
3. Add tests for new fields:
   - Page URL display (read-only)
   - Title field validation
   - Bug-specific fields
   - Feature-specific fields
   - Who Benefits dropdown
4. Update mock fetch responses to expect new payload structure
5. Update validation tests for new requirements

**Key test cases to add/update**:
- "displays page URL as read-only field"
- "validates title minimum length"
- "shows bug-specific fields when bug type selected"
- "shows feature-specific fields when feature type selected"
- "Who Benefits dropdown shows all options"
- "Continue button disabled until all required fields filled"

**Validation Commands**:
```bash
npm test -- --filter="FeedbackDialog"
```
**Completion Criteria**:
- [ ] All step transition tests updated
- [ ] New field tests added
- [ ] Validation tests updated
- [ ] All tests pass

---

## Phase 4: Final Verification

### Subtask 4.1: Build and Type Check
**Instructions**:
```bash
npx tsc --noEmit
npm run build
npm run lint
```
**Completion Criteria**:
- [ ] No TypeScript errors
- [ ] Build completes successfully
- [ ] No lint errors

### Subtask 4.2: Run Full Test Suite
**Instructions**:
```bash
npm test
```
**Completion Criteria**:
- [ ] All tests pass
- [ ] No regressions

---

## Summary of Deliverables
**Files Created**: 0
**Files Modified**: 7
- `src/types/feedback.ts` - New schema fields
- `src/components/features/FeedbackDialog.tsx` - Complete UI redesign
- `src/app/api/feedback/clarify/route.ts` - Accept structured fields
- `src/app/api/feedback/route.ts` - Format structured data
- `src/lib/claude.ts` - Context-aware AI prompts
- `tests/unit/FeedbackDialog.test.tsx` - Updated tests
- `tests/unit/feedback-types.test.ts` - Schema validation tests

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 0 -> 1 -> 2 -> 3 -> 4)
2. Complete Phase 0 (types) fully before Phase 1 (backend)
3. Complete Phase 1 fully before Phase 2 (frontend)
4. Test completion criteria before next subtask
5. Follow reference patterns exactly
6. Run validation commands after each subtask

## Test Strategy Note
- Use Vitest for unit tests
- Run `npm test -- --filter="feedback"` for targeted tests
- Run full suite before considering complete

## Performance Metrics
| Phase | Estimated Duration |
|-------|----------|
| Phase 0: Types | 1h |
| Phase 1: Backend | 3h |
| Phase 2: Frontend | 5h |
| Phase 3: Tests | 3h |
| Phase 4: Verification | 1h |
| **Total** | **13h** |
