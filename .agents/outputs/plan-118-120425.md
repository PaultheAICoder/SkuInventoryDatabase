# Implementation Plan
**Generated**: 2025-12-04T15:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: issue-118
**Estimated Build Time**: 8-10 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #118
**Priority**: Medium

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="forecast"` or None

### Issue Validation
**Status**: Valid
**Recent Changes**: Issue #116 (Config API) and #117 (Forecast dashboard) both closed. Config API exists at `/api/forecasts/config` with GET/PUT endpoints. Forecast page exists at `/forecasts` with table view.

### Current State Assessment
- Existing components:
  - `src/app/api/forecasts/config/route.ts` - GET/PUT config endpoints (from #116)
  - `src/app/(dashboard)/forecasts/page.tsx` - Forecast dashboard (from #117)
  - `src/components/features/ForecastTable.tsx` - Forecast table component
  - `src/components/features/ForecastStatusBadge.tsx` - Status badge
  - `src/types/forecast.ts` - All forecast types defined
  - `src/services/forecast.ts` - Forecast service with config management
- Database: ForecastConfig model in Prisma schema with lookbackDays, safetyDays, excludedTransactionTypes
- API Routes: GET/PUT /api/forecasts/config already implemented with admin role check
- Types: ForecastConfigResponse, ForecastConfigInput, excludableTransactionTypes all defined

### Dependencies & Blockers
1. Issue #116 (Config API) - CLOSED - API ready
2. Issue #117 (Forecast page) - CLOSED - Page ready for settings button
3. shadcn/ui Dialog component - EXISTS at `src/components/ui/dialog.tsx`
4. Toast (sonner) - EXISTS, used throughout codebase

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 8-10 hours
**Risk**: Low - follows well-established patterns in codebase

### Patterns Identified
**Primary**: `src/components/features/AlertConfigForm.tsx` - Settings form with toggle switches, selects, save/cancel, test buttons, toast notifications
**Secondary**: `src/components/features/AdjustmentDialog.tsx` - Dialog with form, validation, loading states, error handling
**Settings Page Pattern**: `src/app/(dashboard)/settings/alerts/page.tsx` - Role-based access, fetch config, refresh on save

### Ripple Effect Analysis
**Files Identified**: 4 files affected
- `src/app/(dashboard)/forecasts/page.tsx` - Add settings button and pass config state
- `src/components/features/ForecastTable.tsx` - May need to accept callback for refresh
- `src/types/forecast.ts` - Types already defined, no changes needed
- `src/app/api/forecasts/config/route.ts` - API already exists, no changes needed

---

## Executive Summary
This task implements a settings dialog for forecast configuration, allowing admin users to adjust lookback window (7-365 days), safety buffer (0-90 days), and excluded transaction types via a modal dialog launched from the forecasts page. The dialog will persist settings to the database via the existing PUT /api/forecasts/config endpoint and refresh the forecast data after save.

## Phase 1: Create ForecastSettingsDialog Component

### Subtask 1.1: Create ForecastSettingsDialog Component
**File**: `src/components/features/ForecastSettingsDialog.tsx`
**Pattern**: Follow `src/components/features/AdjustmentDialog.tsx` for dialog structure and `src/components/features/AlertConfigForm.tsx` for form patterns
**Instructions**:
1. Create new file with the following structure:
   - Props interface with `open`, `onOpenChange`, `config` (ForecastConfigResponse), `onSaved` callback
   - Internal state for form values: lookbackDays, safetyDays, excludedTransactionTypes
   - Loading state for submit button
   - Error state for validation/API errors
2. Import required components:
   ```typescript
   import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog'
   import { Button } from '@/components/ui/button'
   import { Label } from '@/components/ui/label'
   import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
   import { Input } from '@/components/ui/input'
   import { Checkbox } from '@/components/ui/checkbox'
   import { Loader2, Settings2 } from 'lucide-react'
   import { toast } from 'sonner'
   import type { ForecastConfigResponse } from '@/types/forecast'
   import { excludableTransactionTypes } from '@/types/forecast'
   ```
3. Form fields:
   - Lookback Window: Select dropdown with options [7, 14, 30, 60, 90, 180, 365] days
   - Safety Buffer: Number input with min=0, max=90
   - Excluded Transaction Types: Checkbox group for each of ['initial', 'adjustment', 'receipt', 'transfer']
4. Submit handler:
   - Validate inputs (lookbackDays 7-365, safetyDays 0-90)
   - PUT to /api/forecasts/config with JSON body
   - Handle 403 (forbidden) with toast.error
   - On success: toast.success, call onSaved(), close dialog
   - On error: display error message
5. Reset form values when dialog opens (useEffect on config prop)

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Component compiles without TypeScript errors
- [ ] Dialog opens and closes properly
- [ ] Form displays current config values as defaults
- [ ] Lookback dropdown has all required options
- [ ] Safety buffer input validates 0-90 range
- [ ] Transaction type checkboxes work (multi-select)
- [ ] Save button shows loading state during API call
- [ ] Error message displays on validation failure
- [ ] Toast notification on save success/failure
- [ ] Cancel button closes dialog without saving

### Subtask 1.2: Add Reset to Defaults Button
**File**: `src/components/features/ForecastSettingsDialog.tsx`
**Pattern**: Follow button patterns in AlertConfigForm
**Instructions**:
1. Add "Reset to Defaults" button in DialogFooter (variant="outline")
2. Import DEFAULT_FORECAST_CONFIG from `@/types/forecast`
3. On click, set form values to defaults:
   - lookbackDays: 30
   - safetyDays: 7
   - excludedTransactionTypes: ['initial', 'adjustment']
4. Do NOT automatically save - user must click Save to persist

**Completion Criteria**:
- [ ] Reset button visible in dialog footer
- [ ] Clicking reset populates form with default values
- [ ] Reset does not trigger API call
- [ ] User can still cancel after reset

## Phase 2: Create ForecastQuickSettings Component

### Subtask 2.1: Create ForecastQuickSettings Component
**File**: `src/components/features/ForecastQuickSettings.tsx`
**Pattern**: Follow ForecastTable filter controls for inline control style
**Instructions**:
1. Create new file with props:
   - `config: ForecastConfigResponse | null`
   - `onLookbackChange: (days: number) => void`
   - `onOpenSettings: () => void`
   - `disabled?: boolean`
   - `canEdit?: boolean`
2. Import components:
   ```typescript
   import { Button } from '@/components/ui/button'
   import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
   import { Settings2 } from 'lucide-react'
   ```
3. Render inline controls:
   - Quick lookback selector (Select component, same options as dialog)
   - Settings button (icon button that calls onOpenSettings)
   - Current config summary text (e.g., "Safety: 7 days, Excludes: initial, adjustment")
4. If canEdit is false, disable lookback selector and hide settings button

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Component compiles without TypeScript errors
- [ ] Quick lookback selector changes trigger callback
- [ ] Settings button triggers onOpenSettings callback
- [ ] Config summary displays correctly
- [ ] Controls disabled when canEdit=false

## Phase 3: Update Forecasts Page

### Subtask 3.1: Add Config State and Fetch to Forecasts Page
**File**: `src/app/(dashboard)/forecasts/page.tsx`
**Pattern**: Follow settings/alerts/page.tsx for config fetching pattern
**Instructions**:
1. Add new state:
   ```typescript
   const [config, setConfig] = useState<ForecastConfigResponse | null>(null)
   const [settingsOpen, setSettingsOpen] = useState(false)
   ```
2. Import ForecastConfigResponse from `@/types/forecast`
3. Create fetchConfig function:
   ```typescript
   const fetchConfig = useCallback(async () => {
     try {
       const res = await fetch('/api/forecasts/config')
       if (res.ok) {
         const result = await res.json()
         setConfig(result.data)
       }
     } catch (err) {
       console.error('Failed to fetch forecast config:', err)
     }
   }, [])
   ```
4. Add useEffect to call fetchConfig when session/company changes
5. Add refetch logic when config is saved

**Completion Criteria**:
- [ ] Config is fetched on page load
- [ ] Config refetches when company changes
- [ ] Config state updates after settings save

### Subtask 3.2: Add Settings Button and Dialog to Forecasts Page Header
**File**: `src/app/(dashboard)/forecasts/page.tsx`
**Pattern**: Follow AlertConfigForm usage pattern
**Instructions**:
1. Import new components:
   ```typescript
   import { ForecastSettingsDialog } from '@/components/features/ForecastSettingsDialog'
   import { ForecastQuickSettings } from '@/components/features/ForecastQuickSettings'
   import { Settings2 } from 'lucide-react'
   ```
2. Add role check:
   ```typescript
   const canEdit = session?.user?.role === 'admin'
   ```
3. Update header section to include:
   - ForecastQuickSettings component (inline, below description)
   - Settings button if admin (or as part of QuickSettings)
4. Add ForecastSettingsDialog to component tree:
   ```tsx
   <ForecastSettingsDialog
     open={settingsOpen}
     onOpenChange={setSettingsOpen}
     config={config}
     onSaved={async () => {
       await fetchConfig()
       // Force refetch forecasts by updating queryString
     }}
   />
   ```
5. Handle quick lookback change by updating URL params (existing updateFilters pattern)

**Completion Criteria**:
- [ ] Settings button visible on forecast page header (admin only)
- [ ] Clicking settings button opens ForecastSettingsDialog
- [ ] Quick lookback selector works without opening modal
- [ ] Dialog closes after successful save
- [ ] Forecast data refetches after config change
- [ ] Non-admin users cannot see/access settings button

### Subtask 3.3: Wire Up Forecast Refetch After Config Change
**File**: `src/app/(dashboard)/forecasts/page.tsx`
**Instructions**:
1. Modify fetchForecasts to depend on config.lookbackDays and config.safetyDays
2. Or add a manual refresh mechanism that triggers after settings are saved
3. Option A: Add config to queryString dependency
   ```typescript
   // Add lookbackDays/safetyDays to URL params from config
   if (config?.lookbackDays) params.set('lookbackDays', config.lookbackDays.toString())
   ```
4. Option B: Create a fetchCounter state that increments on config save to force refetch
5. Ensure the forecast list updates with new settings

**Completion Criteria**:
- [ ] Saving settings causes forecast table to refetch
- [ ] Updated config values are reflected in forecast calculations
- [ ] No stale data after config change

## Phase 4: Role-Based Access Control

### Subtask 4.1: Verify Role Checks Throughout
**File**: Multiple files
**Pattern**: Follow alerts/page.tsx role check pattern
**Instructions**:
1. In ForecastSettingsDialog:
   - Dialog should not show if user is not admin (handled by parent)
   - PUT request will return 403 if not admin (handled by API)
2. In ForecastQuickSettings:
   - Accept canEdit prop
   - Disable editing controls when canEdit=false
   - Optionally show read-only config summary for viewers
3. In forecasts/page.tsx:
   - Only show settings button/controls if session.user.role === 'admin'
   - Pass canEdit prop to QuickSettings

**Completion Criteria**:
- [ ] Admin users see full settings controls
- [ ] Non-admin users cannot edit settings
- [ ] API rejects PUT requests from non-admins (already implemented)

## Phase 5: Final Integration and Testing

### Subtask 5.1: Add Help Text and Tooltips
**File**: `src/components/features/ForecastSettingsDialog.tsx`
**Instructions**:
1. Add descriptive help text for each setting:
   - Lookback Window: "Number of days of transaction history to analyze for consumption rate"
   - Safety Buffer: "Extra days of buffer added to reorder recommendations beyond lead time"
   - Excluded Types: "Transaction types to exclude from consumption calculations"
2. Use `text-xs text-muted-foreground` class for help text (follow SettingsForm pattern)

**Completion Criteria**:
- [ ] Each setting has clear help text
- [ ] Help text follows existing style patterns

### Subtask 5.2: Build and Type Check Verification
**File**: Project root
**Instructions**:
1. Run full TypeScript check: `npx tsc --noEmit`
2. Run build: `npm run build`
3. Run lint: `npm run lint`
4. Fix any errors or warnings

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
npm run lint
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` passes with no errors
- [ ] `npm run lint` passes with no errors or warnings

---

## Summary of Deliverables
**Files Created**: 2
- `src/components/features/ForecastSettingsDialog.tsx`
- `src/components/features/ForecastQuickSettings.tsx`

**Files Modified**: 1
- `src/app/(dashboard)/forecasts/page.tsx`

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5)
2. Complete each subtask fully before moving to next
3. Test completion criteria before moving to next subtask
4. Follow reference patterns exactly (AlertConfigForm, AdjustmentDialog, alerts/page.tsx)
5. Use toast from sonner for all notifications
6. Ensure all imports are correct (from @/components/ui/, @/types/, etc.)

## Test Strategy Note
- Manual testing in browser required for:
  - Dialog open/close behavior
  - Form validation
  - API calls and error handling
  - Role-based visibility
  - Forecast data refresh after config change
- Vitest unit tests not required for this issue (UI-focused)

## Performance Metrics
| Phase | Estimated Duration |
|-------|----------|
| Investigation | 45m |
| Validation | 15m |
| Planning | 30m |
| **Total Planning** | **90m** |

---

## Appendix: Reference Code Patterns

### Dialog Component Pattern (from AdjustmentDialog)
```tsx
<Dialog open={open} onOpenChange={onOpenChange}>
  <DialogContent className="sm:max-w-[425px]">
    <form onSubmit={handleSubmit}>
      <DialogHeader>
        <DialogTitle>Title</DialogTitle>
        <DialogDescription>Description</DialogDescription>
      </DialogHeader>
      <div className="grid gap-4 py-4">
        {error && (
          <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
            {error}
          </div>
        )}
        {/* Form fields */}
      </div>
      <DialogFooter>
        <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
          Cancel
        </Button>
        <Button type="submit" disabled={isLoading}>
          {isLoading ? 'Saving...' : 'Save'}
        </Button>
      </DialogFooter>
    </form>
  </DialogContent>
</Dialog>
```

### Multi-Select Checkbox Pattern
```tsx
{excludableTransactionTypes.map((type) => (
  <div key={type} className="flex items-center space-x-2">
    <Checkbox
      id={`exclude-${type}`}
      checked={excludedTypes.includes(type)}
      onCheckedChange={(checked) => {
        if (checked) {
          setExcludedTypes([...excludedTypes, type])
        } else {
          setExcludedTypes(excludedTypes.filter(t => t !== type))
        }
      }}
    />
    <Label htmlFor={`exclude-${type}`} className="font-normal capitalize">
      {type}
    </Label>
  </div>
))}
```

### API Call Pattern (from AlertConfigForm)
```tsx
const handleSave = async () => {
  setIsSaving(true)
  try {
    const res = await fetch('/api/forecasts/config', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        lookbackDays,
        safetyDays,
        excludedTransactionTypes,
      }),
    })

    if (res.status === 403) {
      toast.error('You do not have permission to update settings')
      return
    }

    if (!res.ok) {
      const data = await res.json()
      throw new Error(data.message || 'Failed to save')
    }

    toast.success('Forecast settings saved')
    onSaved()
    onOpenChange(false)
  } catch (err) {
    toast.error(err instanceof Error ? err.message : 'Failed to save settings')
  } finally {
    setIsSaving(false)
  }
}
```
