# Implementation Plan
**Generated**: 2025-12-09T09:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #228
**Estimated Build Time**: 4-6 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Bug Fix
**Source**: GitHub Issue #228 (User-reported)
**Priority**: Medium

### Task Classification
**Category**: BUG_FIX
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="session|auth|company|brand"` or None

### Issue Validation
**Status**: Valid
**Recent Changes**: Recent refactoring to use UserCompany exclusively (#223, #224) did not address session refresh

### Current State Assessment

**Root Cause Identified**:
The `companiesWithBrands` and `companies` arrays are populated in the JWT token ONLY during the `authorize` callback (login time) at `src/lib/auth.ts:114-132`. These arrays are stored in the JWT token and are NEVER refreshed when:

1. A new company is created and the user is assigned to it
2. A new brand is created for a company the user has access to
3. A user is assigned to an existing company

The JWT callback (`jwt`) at lines 143-224 handles:
- Company switching (line 191) - updates `selectedCompanyId`
- Brand list refresh for current company (line 206) - updates `brands`
- Brand switching (line 213) - updates `selectedBrandId`

**Missing**: No handler for refreshing `companies` or `companiesWithBrands` arrays.

**Affected Components**:
- `src/lib/auth.ts` - JWT callback needs new handler
- `src/components/features/CompanyAssignment.tsx` - Should trigger session refresh after assignment
- `src/components/features/BrandForm.tsx` - Should trigger session refresh after brand creation
- `src/app/api/users/[id]/companies/route.ts` - Should return data needed for session refresh

**User Flow Recreated**:
1. Admin creates new brand via Settings > Brands > Create
2. Admin creates new company via Settings > Companies > Create
3. Admin edits user (self) via Settings > Users > Edit to add new company
4. JWT token still has old `companiesWithBrands` from login time
5. CompanyBrandSelector reads from `session.user.companiesWithBrands`
6. New company/brand not visible - requires cache clear/re-login

### Dependencies & Blockers
None - all required infrastructure exists

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 4-6 hours
**Risk**: Low - follows existing patterns for session updates

### Patterns Identified
**Primary**: `src/lib/auth.ts:191-210` - Session update handler pattern for company/brand switching
**Secondary**: `src/components/features/CompanyBrandSelector.tsx:72-78` - Client-side updateSession call pattern

### Ripple Effect Analysis
**Files Identified**: 5 files require changes

| File | Change Type | Reason |
|------|-------------|--------|
| `src/lib/auth.ts` | MODIFY | Add handler for `companiesWithBrands` refresh in JWT callback |
| `src/app/api/session/refresh/route.ts` | CREATE | New API endpoint to fetch fresh company/brand data |
| `src/components/features/CompanyAssignment.tsx` | MODIFY | Call session refresh after company assignment changes |
| `src/components/features/BrandForm.tsx` | MODIFY | Call session refresh after brand creation |
| `src/types/next-auth.d.ts` or `src/lib/auth.ts` | MODIFY | Add `refreshCompanies` trigger type to JWT interface |

---

## Executive Summary

Create a session refresh mechanism that updates the `companies` and `companiesWithBrands` arrays in the JWT token when a user's company assignments or available brands change. This requires:
1. A new API endpoint that fetches the user's current company/brand data from the database
2. A new JWT callback handler for the `refreshCompanies` trigger
3. UI components that call `updateSession` with the refresh data after modifying company/brand assignments

## Phase 1: API Layer - Create Session Refresh Endpoint

### Subtask 1.1: Create Session Refresh API Route
**File**: `src/app/api/session/refresh/route.ts` (CREATE)
**Pattern**: Follow `src/app/api/companies/switch/route.ts` structure
**Instructions**:
1. Create new directory and route file
2. Implement POST handler that:
   - Gets current session
   - Fetches user's current UserCompany records from database
   - Fetches all brands for user's accessible companies
   - Builds `companies` and `companiesWithBrands` arrays (same logic as authorize callback)
   - Returns the data needed for session update
3. Add proper authentication check

```typescript
// src/app/api/session/refresh/route.ts
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { success, unauthorized, serverError } from '@/lib/api-response'

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return unauthorized()
    }

    // Fetch fresh user data with company assignments
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: {
        userCompanies: {
          include: {
            company: { select: { id: true, name: true } }
          }
        }
      }
    })

    if (!user) {
      return unauthorized()
    }

    // Build companies array
    const companies = user.userCompanies.map(uc => ({
      id: uc.company.id,
      name: uc.company.name,
      role: uc.role,
    }))

    // Fetch all brands for accessible companies
    const accessibleCompanyIds = companies.map(c => c.id)
    const allBrands = await prisma.brand.findMany({
      where: {
        companyId: { in: accessibleCompanyIds },
        isActive: true,
      },
      select: { id: true, name: true, companyId: true },
      orderBy: { name: 'asc' },
    })

    // Build companiesWithBrands structure
    const companiesWithBrands = companies.map(company => ({
      id: company.id,
      name: company.name,
      role: company.role,
      brands: allBrands
        .filter(b => b.companyId === company.id)
        .map(b => ({ id: b.id, name: b.name }))
    }))

    return success({
      companies,
      companiesWithBrands,
    })
  } catch (error) {
    console.error('Error refreshing session:', error)
    return serverError()
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Route file created at correct path
- [ ] TypeScript compiles without errors
- [ ] Build passes
- [ ] API returns correct data structure when called

## Phase 2: Auth Layer - Add JWT Callback Handler

### Subtask 2.1: Add Session Refresh Handler to JWT Callback
**File**: `src/lib/auth.ts`
**Pattern**: Follow existing `trigger === 'update'` handlers at lines 191-222
**Instructions**:
1. Add new handler block AFTER line 222 (after brand switch handler)
2. Handle `session?.companies` and `session?.companiesWithBrands` update trigger
3. Validate that the user ID matches before accepting update

Add this code after line 222 (the brand switch handler closing brace):

```typescript
      // Handle companies/companiesWithBrands refresh (after user assignment changes)
      if (trigger === 'update' && session?.companiesWithBrands !== undefined) {
        // Update companies and companiesWithBrands in token
        token.companies = session.companies
        token.companiesWithBrands = session.companiesWithBrands

        // If current selected company is no longer in the list, reset to first company
        const hasAccessToCurrentCompany = (session.companies as Array<{ id: string }>)?.some(
          c => c.id === token.selectedCompanyId
        )
        if (!hasAccessToCurrentCompany && session.companies?.length > 0) {
          const firstCompany = session.companies[0]
          token.selectedCompanyId = firstCompany.id
          token.selectedCompanyName = firstCompany.name
          token.companyId = firstCompany.id
          token.companyName = firstCompany.name
          // Also update brands for the new company
          const firstCompanyWithBrands = (session.companiesWithBrands as Array<{ id: string; brands: Array<{ id: string; name: string }> }>)?.find(
            c => c.id === firstCompany.id
          )
          token.brands = firstCompanyWithBrands?.brands ?? []
          token.selectedBrandId = firstCompanyWithBrands?.brands?.[0]?.id ?? null
          token.selectedBrandName = firstCompanyWithBrands?.brands?.[0]?.name ?? null
        }
      }
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Handler added after line 222
- [ ] TypeScript compiles without errors
- [ ] Build passes
- [ ] Handler follows existing pattern structure

## Phase 3: UI Layer - Trigger Session Refresh

### Subtask 3.1: Update CompanyAssignment Component
**File**: `src/components/features/CompanyAssignment.tsx`
**Pattern**: Follow `src/components/features/CompanyBrandSelector.tsx:72-78` updateSession pattern
**Instructions**:
1. Import `useSession` from `next-auth/react`
2. Get `update: updateSession` from useSession hook
3. After successful company assignment change (line 44), call the session refresh API
4. Update session with the returned data

Modify the component:

```typescript
'use client'

import { useState } from 'react'
import { useSession } from 'next-auth/react'
import { Checkbox } from '@/components/ui/checkbox'
// ... rest of imports

export function CompanyAssignment({
  assignedCompanyIds,
  allCompanies,
  onAssignmentChange,
  disabled,
}: CompanyAssignmentProps) {
  const { update: updateSession } = useSession()
  const [isUpdating, setIsUpdating] = useState<string | null>(null)
  const [error, setError] = useState<string | null>(null)

  const handleToggle = async (companyId: string, checked: boolean) => {
    // ... existing validation code ...

    setError(null)
    setIsUpdating(companyId)
    try {
      await onAssignmentChange(newIds)

      // Refresh the current user's session if they modified their own companies
      try {
        const refreshRes = await fetch('/api/session/refresh', { method: 'POST' })
        if (refreshRes.ok) {
          const refreshData = await refreshRes.json()
          await updateSession({
            companies: refreshData.data.companies,
            companiesWithBrands: refreshData.data.companiesWithBrands,
          })
        }
      } catch (refreshError) {
        // Silent fail - user may need to re-login for changes to take effect
        console.warn('Failed to refresh session:', refreshError)
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update assignment')
    } finally {
      setIsUpdating(null)
    }
  }
  // ... rest of component
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] useSession hook imported
- [ ] updateSession called after successful assignment change
- [ ] TypeScript compiles without errors
- [ ] Build passes

### Subtask 3.2: Update BrandForm Component
**File**: `src/components/features/BrandForm.tsx`
**Pattern**: Follow same pattern as Subtask 3.1
**Instructions**:
1. Import `useSession` from `next-auth/react`
2. Get `update: updateSession` from useSession hook
3. After successful brand creation (not edit), call the session refresh API
4. Update session with the returned data

Modify the component handleSubmit:

```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { useSession } from 'next-auth/react'
// ... rest of imports

export function BrandForm({ brand, onSuccess }: BrandFormProps) {
  const router = useRouter()
  const { update: updateSession } = useSession()
  // ... rest of state

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError(null)

    try {
      // ... existing fetch code ...

      if (!res.ok) {
        const data = await res.json().catch(() => ({}))
        throw new Error(data?.error || 'Failed to save brand')
      }

      // Refresh session after creating a new brand
      if (!isEditing) {
        try {
          const refreshRes = await fetch('/api/session/refresh', { method: 'POST' })
          if (refreshRes.ok) {
            const refreshData = await refreshRes.json()
            await updateSession({
              companies: refreshData.data.companies,
              companiesWithBrands: refreshData.data.companiesWithBrands,
            })
          }
        } catch (refreshError) {
          console.warn('Failed to refresh session:', refreshError)
        }
      }

      if (onSuccess) {
        onSuccess()
      } else {
        router.push('/settings/brands')
        router.refresh()
      }
    } catch (err) {
      // ... error handling
    } finally {
      setIsLoading(false)
    }
  }
  // ... rest of component
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] useSession hook imported
- [ ] updateSession called after successful brand creation
- [ ] Only triggers on create, not edit
- [ ] TypeScript compiles without errors
- [ ] Build passes

### Subtask 3.3: Update CompanyForm Component (Optional Enhancement)
**File**: `src/components/features/CompanyForm.tsx`
**Pattern**: Follow same pattern as Subtasks 3.1 and 3.2
**Instructions**:
This is optional but provides complete coverage. When a company is created, the admin may later assign themselves to it. However, the original issue was specifically about user assignment, so this could be deferred.

If implementing:
1. Import `useSession` from `next-auth/react`
2. After successful company creation, refresh session

**Completion Criteria**:
- [ ] (Optional) Session refresh after company creation

## Phase 4: Testing & Validation

### Subtask 4.1: Manual Testing
**Instructions**:
1. Start test environment: `cd docker && docker compose -f docker-compose.test.yml up -d`
2. Log in as admin user
3. Create a new brand (Settings > Brands > Create Brand)
4. Verify the new brand appears in the CompanyBrandSelector dropdown WITHOUT page refresh or cache clear
5. Create a new company (Settings > Companies > Create Company)
6. Edit own user (Settings > Users > Edit) and add self to new company
7. Verify the new company appears in the CompanyBrandSelector dropdown WITHOUT page refresh or cache clear

**Completion Criteria**:
- [ ] New brands appear immediately in dropdown
- [ ] New companies appear immediately in dropdown after user assignment
- [ ] No browser cache clear required
- [ ] No re-login required

### Subtask 4.2: Verify Build and TypeScript
**Instructions**:
```bash
npx tsc --noEmit
npm run build
npm run lint
```

**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build completes successfully
- [ ] No lint warnings

---

## Summary of Deliverables
**Files Created**: 1
- `src/app/api/session/refresh/route.ts`

**Files Modified**: 3
- `src/lib/auth.ts` (add JWT callback handler)
- `src/components/features/CompanyAssignment.tsx` (trigger session refresh)
- `src/components/features/BrandForm.tsx` (trigger session refresh)

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4)
2. Run TypeScript check after each file modification
3. Run build check after completing each phase
4. Complete Phase 4 manual testing before marking complete

## Test Strategy Note
- Use manual testing for this fix (TARGETED approach)
- No automated tests required for session management
- Focus on verifying the user flow described in the issue

## Alternative Approaches Considered

### Alternative 1: Force Re-login After Changes
**Rejected**: Poor UX - user should not need to re-authenticate for administrative changes

### Alternative 2: Periodic Session Refresh
**Rejected**: Adds complexity and potential race conditions. On-demand refresh is cleaner.

### Alternative 3: Use Next.js Server Actions
**Rejected**: Sticking with existing API route + updateSession pattern for consistency

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 10m |
| **Total** | **30m** |
