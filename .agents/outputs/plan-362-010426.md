# Implementation Plan
**Generated**: 2026-01-04T23:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #362 - [Rec Engine] Threshold configuration and scheduling
**Estimated Build Time**: 8-10 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: Feature Enhancement
**Source**: GitHub Issue #362
**Priority**: P3 (per label)
**Spec Reference**: `specs/001-recommendation-engine/spec.md` - User Story 8 + FR-018-020

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="recommendation|threshold"`

### Issue Validation
**Status**: Valid
**Recent Changes**: Issues #354-361 closed (recommendation engine foundation complete)
**Dependencies Verified**:
- Recommendation types exist in Prisma schema
- `mergeThresholds()` utility exists in `/src/lib/recommendation-utils.ts`
- `generateRecommendations()` already uses thresholds from company.settings
- Amazon sync scheduler pattern exists at `/src/services/amazon-sync/scheduler.ts`
- Cron route pattern exists at `/src/app/api/cron/ads-sync/route.ts`

### Current State Assessment

**Existing Components:**
1. **Thresholds System** - Partially implemented
   - `RecommendationThresholds` type defined in `/src/types/recommendations.ts`
   - `mergeThresholds()` utility in `/src/lib/recommendation-utils.ts`
   - `generator.ts` reads thresholds from `company.settings.recommendationThresholds`
   - **MISSING**: No API endpoint to GET/PUT thresholds
   - **MISSING**: No UI to configure thresholds per brand

2. **Confidence Scoring** - Implemented
   - `calculateConfidence()` in `/src/services/recommendations/confidence-scoring.ts`
   - Confidence badge already displayed in `RecommendationCard.tsx` (line 223-225)
   - Confidence filter already exists in recommendations page (lines 371-387)
   - **NOTE**: Confidence badge and filter are already implemented - verify if issue is stale

3. **Scheduler** - Not implemented for recommendations
   - Amazon sync scheduler pattern available at `/src/services/amazon-sync/scheduler.ts`
   - Cron endpoint pattern at `/src/app/api/cron/ads-sync/route.ts`
   - **MISSING**: `/src/services/recommendations/scheduler.ts`
   - **MISSING**: `/api/cron/recommendations/route.ts`

**Database:**
- Thresholds stored in `Company.settings` JSON field (line 17 in schema)
- No separate `RecommendationThreshold` model needed (settings per company, not per brand)
- **NOTE**: Current implementation uses company-level thresholds, not brand-level
  - Issue requests brand-specific thresholds
  - Need to decide: add to Brand.settings or create new model

### Dependencies & Blockers

1. **Architecture Decision**: Thresholds are currently company-level (via Company.settings), but issue requests brand-specific thresholds
   - **Recommendation**: Use Brand.settings JSON field (like Company.settings pattern)
   - This is consistent with the existing generator code that looks at brand.company.settings

2. **Confidence Badge**: Investigation shows confidence badge is ALREADY implemented
   - `RecommendationCard.tsx` line 223-225 shows confidence badge
   - `recommendations/page.tsx` line 371-387 shows confidence filter
   - **Verify if this task item is complete or if different implementation is needed**

**Can Proceed?**: YES (with brand-level threshold decision)

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 8-10 hours
**Risk**: Low (follows established patterns)

### Patterns Identified

**Primary Pattern - API Route**: `/src/app/api/settings/route.ts`
- GET/PATCH pattern for JSON settings
- Admin-only authorization
- Zod schema validation
- Merge with defaults pattern

**Secondary Pattern - Scheduler**: `/src/services/amazon-sync/scheduler.ts`
- Configuration via environment variables
- Retry logic with exponential backoff
- Staggered execution for multiple entities
- Comprehensive result reporting

**Tertiary Pattern - Cron Route**: `/src/app/api/cron/ads-sync/route.ts`
- CRON_SECRET header authentication
- Dynamic rendering export
- maxDuration export for long-running tasks

**Settings Page Pattern**: `/src/app/(dashboard)/settings/page.tsx`
- Fetch settings on mount
- Form component for editing
- Handle save with API call

### Ripple Effect Analysis

**Files Identified**: 8 files to create/modify

| File | Action | Reason |
|------|--------|--------|
| `src/types/recommendations.ts` | Modify | Add scheduler types, extend threshold types |
| `src/app/api/thresholds/route.ts` | Create | GET/PUT thresholds API |
| `src/app/(dashboard)/settings/thresholds/page.tsx` | Create | Threshold configuration UI |
| `src/components/features/ThresholdSettingsForm.tsx` | Create | Form component for threshold editing |
| `src/services/recommendations/scheduler.ts` | Create | Scheduler service for weekly generation |
| `src/app/api/cron/recommendations/route.ts` | Create | Cron endpoint for scheduler |
| `src/lib/recommendation-utils.ts` | Modify | Support brand-level threshold merging |
| `src/services/recommendations/generator.ts` | Modify | Update to read brand-level thresholds |

**Test Files**: None required for this PR (manual integration test)

---

## Executive Summary

This implementation adds brand-specific threshold configuration, weekly automated recommendation generation via cron, and verifies the confidence badge/filter already exist. The main work involves:
1. Creating API endpoints to GET/PUT brand thresholds
2. Building a settings page for threshold configuration
3. Implementing a scheduler service and cron endpoint for Sunday 11 PM recommendation generation

## Phase 0: Verification

### Subtask 0.1: Verify Confidence Badge Implementation
**Instructions**:
1. Review `/src/components/features/RecommendationCard.tsx` lines 223-225
2. Confirm confidence badge is displaying correctly
3. Review `/src/app/(dashboard)/recommendations/page.tsx` lines 371-387
4. Confirm confidence filter dropdown works

**Completion Criteria**:
- [ ] Confidence badge visible on recommendation cards (HIGH/MEDIUM/LOW)
- [ ] Confidence filter dropdown functional in recommendations page
- [ ] If both work, mark confidence badge task as ALREADY COMPLETE in issue

---

## Phase 1: Types and Utilities

### Subtask 1.1: Extend Threshold Types for Brand-Level Configuration
**File**: `/home/pbrown/SkuInventory/src/types/recommendations.ts`
**Pattern**: Follow existing `RecommendationThresholds` interface (lines 91-118)

**Instructions**:
1. The existing `RecommendationThresholds` interface is already defined and suitable for brand-level use
2. Add scheduler-related types at the end of the file:

```typescript
// ============================================
// Scheduler Types
// ============================================

/**
 * Configuration for recommendation scheduler
 */
export interface SchedulerConfig {
  enabled: boolean
  dayOfWeek: number  // 0=Sunday, 1=Monday, etc.
  hour: number       // 0-23
  minute: number     // 0-59
  timezone: string   // e.g., 'America/New_York'
}

export const schedulerConfigSchema = z.object({
  enabled: z.boolean().default(true),
  dayOfWeek: z.number().int().min(0).max(6).default(0),  // Sunday
  hour: z.number().int().min(0).max(23).default(23),      // 11 PM
  minute: z.number().int().min(0).max(59).default(0),
  timezone: z.string().default('America/New_York'),
})

/**
 * Result of scheduled recommendation generation
 */
export interface ScheduledGenerationResult {
  totalBrands: number
  brandsProcessed: number
  brandsFailed: number
  results: Array<{
    brandId: string
    brandName: string
    generated: number
    skipped: number
    errors: string[]
  }>
  skipped: 'disabled' | 'wrong_day' | null
  duration: number
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] `SchedulerConfig` interface added
- [ ] `schedulerConfigSchema` Zod schema added
- [ ] `ScheduledGenerationResult` interface added
- [ ] TypeScript compiles without errors

### Subtask 1.2: Update Threshold Merge Utility for Brand-Level Settings
**File**: `/home/pbrown/SkuInventory/src/lib/recommendation-utils.ts`
**Pattern**: Follow existing `mergeThresholds()` function (lines 89-115)

**Instructions**:
1. Modify `mergeThresholds` to accept brandSettings as primary, companySettings as fallback:

```typescript
/**
 * Merge brand-specific thresholds with company defaults, then system defaults.
 * Priority: brandSettings > companySettings > DEFAULT_THRESHOLDS
 *
 * @param brandSettings - Threshold overrides from Brand.settings (JSON)
 * @param companySettings - Threshold overrides from Company.settings (JSON)
 * @param defaults - Default thresholds (optional, uses DEFAULT_THRESHOLDS)
 * @returns Complete thresholds object with all values
 */
export function mergeThresholds(
  brandSettings: RecommendationThresholds | undefined | null,
  companySettings?: RecommendationThresholds | undefined | null,
  defaults: RequiredThresholds = DEFAULT_THRESHOLDS
): RequiredThresholds {
  // First merge company with defaults
  const companyMerged = companySettings ? {
    graduation: {
      maxAcos: companySettings.graduation?.maxAcos ?? defaults.graduation.maxAcos,
      minConversions: companySettings.graduation?.minConversions ?? defaults.graduation.minConversions,
      minSpend: companySettings.graduation?.minSpend ?? defaults.graduation.minSpend,
    },
    negative: {
      minSpend: companySettings.negative?.minSpend ?? defaults.negative.minSpend,
      maxOrders: companySettings.negative?.maxOrders ?? defaults.negative.maxOrders,
      minClicks: companySettings.negative?.minClicks ?? defaults.negative.minClicks,
    },
    budget: {
      minRoas: companySettings.budget?.minRoas ?? defaults.budget.minRoas,
      budgetUtilization: companySettings.budget?.budgetUtilization ?? defaults.budget.budgetUtilization,
      maxAcosForIncrease: companySettings.budget?.maxAcosForIncrease ?? defaults.budget.maxAcosForIncrease,
      minAcosForDecrease: companySettings.budget?.minAcosForDecrease ?? defaults.budget.minAcosForDecrease,
    },
  } : defaults

  // If no brand settings, return company merged
  if (!brandSettings) {
    return companyMerged
  }

  // Merge brand settings over company merged
  return {
    graduation: {
      maxAcos: brandSettings.graduation?.maxAcos ?? companyMerged.graduation.maxAcos,
      minConversions: brandSettings.graduation?.minConversions ?? companyMerged.graduation.minConversions,
      minSpend: brandSettings.graduation?.minSpend ?? companyMerged.graduation.minSpend,
    },
    negative: {
      minSpend: brandSettings.negative?.minSpend ?? companyMerged.negative.minSpend,
      maxOrders: brandSettings.negative?.maxOrders ?? companyMerged.negative.maxOrders,
      minClicks: brandSettings.negative?.minClicks ?? companyMerged.negative.minClicks,
    },
    budget: {
      minRoas: brandSettings.budget?.minRoas ?? companyMerged.budget.minRoas,
      budgetUtilization: brandSettings.budget?.budgetUtilization ?? companyMerged.budget.budgetUtilization,
      maxAcosForIncrease: brandSettings.budget?.maxAcosForIncrease ?? companyMerged.budget.maxAcosForIncrease,
      minAcosForDecrease: brandSettings.budget?.minAcosForDecrease ?? companyMerged.budget.minAcosForDecrease,
    },
  }
}
```

2. Update all existing callers to use the new signature (they should still work with single parameter)

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] `mergeThresholds` updated with brand + company fallback chain
- [ ] Backward compatible (single parameter still works)
- [ ] TypeScript compiles without errors
- [ ] Build succeeds

---

## Phase 2: API Endpoints

### Subtask 2.1: Create Thresholds API Route
**File**: `/home/pbrown/SkuInventory/src/app/api/thresholds/route.ts`
**Pattern**: Follow `/src/app/api/settings/route.ts`

**Instructions**:
1. Create the file with GET and PUT handlers
2. GET returns thresholds for selected brand (merged with defaults)
3. PUT updates brand.settings.recommendationThresholds

```typescript
/**
 * GET/PUT /api/thresholds
 *
 * Brand-specific recommendation threshold configuration.
 * Thresholds are stored in Brand.settings JSON field.
 */

import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions, getSelectedCompanyRole } from '@/lib/auth'
import { prisma } from '@/lib/db'
import {
  recommendationThresholdsSchema,
  type RecommendationThresholds,
} from '@/types/recommendations'
import { DEFAULT_THRESHOLDS, mergeThresholds } from '@/lib/recommendation-utils'

// GET /api/thresholds - Get thresholds for selected brand
export async function GET() {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const selectedBrandId = session.user.selectedBrandId
    if (!selectedBrandId) {
      return NextResponse.json(
        { error: 'No brand selected. Please select a brand.' },
        { status: 400 }
      )
    }

    // Fetch brand with company settings
    const brand = await prisma.brand.findUnique({
      where: { id: selectedBrandId },
      include: { company: { select: { settings: true } } },
    })

    if (!brand) {
      return NextResponse.json({ error: 'Brand not found' }, { status: 404 })
    }

    // Extract settings
    const brandSettings = (brand as { settings?: Record<string, unknown> }).settings
    const brandThresholds = brandSettings?.recommendationThresholds as RecommendationThresholds | undefined
    const companySettings = brand.company.settings as Record<string, unknown> | null
    const companyThresholds = companySettings?.recommendationThresholds as RecommendationThresholds | undefined

    // Merge thresholds
    const effectiveThresholds = mergeThresholds(brandThresholds, companyThresholds)

    return NextResponse.json({
      data: {
        brandId: brand.id,
        brandName: brand.name,
        thresholds: effectiveThresholds,
        brandOverrides: brandThresholds || null,
        defaults: DEFAULT_THRESHOLDS,
      },
    })
  } catch (error) {
    console.error('Error fetching thresholds:', error)
    return NextResponse.json({ error: 'Failed to fetch thresholds' }, { status: 500 })
  }
}

// PUT /api/thresholds - Update thresholds for selected brand
export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Admin only
    const companyRole = getSelectedCompanyRole(session)
    if (companyRole !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    const selectedBrandId = session.user.selectedBrandId
    if (!selectedBrandId) {
      return NextResponse.json(
        { error: 'No brand selected. Please select a brand.' },
        { status: 400 }
      )
    }

    const body = await request.json()
    const validation = recommendationThresholdsSchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validation.error.flatten() },
        { status: 400 }
      )
    }

    // Get current brand
    const brand = await prisma.brand.findUnique({
      where: { id: selectedBrandId },
    })

    if (!brand) {
      return NextResponse.json({ error: 'Brand not found' }, { status: 404 })
    }

    // NOTE: Brand model doesn't have settings field by default
    // We need to add it via raw query or use Company.settings
    // For now, store in Company.settings with brand-specific key

    // Alternative approach: Store per-brand thresholds in Company.settings
    // as brandThresholds: { [brandId]: thresholds }
    const company = await prisma.company.findUnique({
      where: { id: brand.companyId },
      select: { settings: true },
    })

    const currentSettings = (company?.settings as Record<string, unknown>) || {}
    const brandThresholds = (currentSettings.brandThresholds as Record<string, unknown>) || {}

    const newSettings = {
      ...currentSettings,
      brandThresholds: {
        ...brandThresholds,
        [selectedBrandId]: validation.data,
      },
    }

    await prisma.company.update({
      where: { id: brand.companyId },
      data: { settings: newSettings },
    })

    return NextResponse.json({
      data: {
        brandId: selectedBrandId,
        thresholds: validation.data,
      },
      message: 'Thresholds updated successfully',
    })
  } catch (error) {
    console.error('Error updating thresholds:', error)
    return NextResponse.json({ error: 'Failed to update thresholds' }, { status: 500 })
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] GET returns merged thresholds for selected brand
- [ ] PUT updates brand-specific thresholds (admin only)
- [ ] Validation using Zod schema
- [ ] TypeScript compiles without errors

### Subtask 2.2: Update Generator to Use Brand-Level Thresholds
**File**: `/home/pbrown/SkuInventory/src/services/recommendations/generator.ts`
**Lines**: 98-100 (current threshold loading)

**Instructions**:
1. Update the threshold loading to check brand-specific settings first:

Replace lines 98-100:
```typescript
// OLD:
const companySettings = brand.company.settings as { recommendationThresholds?: RecommendationThresholds } | null
const thresholds = mergeThresholds(companySettings?.recommendationThresholds)
```

With:
```typescript
// NEW: Check brand-specific thresholds first
const companySettings = brand.company.settings as {
  recommendationThresholds?: RecommendationThresholds
  brandThresholds?: Record<string, RecommendationThresholds>
} | null
const brandThresholds = companySettings?.brandThresholds?.[brandId]
const thresholds = mergeThresholds(brandThresholds, companySettings?.recommendationThresholds)
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Generator uses brand-level thresholds when available
- [ ] Falls back to company thresholds when brand-specific not set
- [ ] TypeScript compiles without errors

---

## Phase 3: Scheduler Service

### Subtask 3.1: Create Recommendation Scheduler Service
**File**: `/home/pbrown/SkuInventory/src/services/recommendations/scheduler.ts`
**Pattern**: Follow `/src/services/amazon-sync/scheduler.ts`

**Instructions**:
1. Create scheduler service with configuration
2. Process all active brands
3. Generate recommendations for each
4. Return comprehensive result

```typescript
/**
 * Recommendation Scheduler
 *
 * Orchestrates weekly recommendation generation for all active brands.
 * Intended to run Sunday 11 PM for Monday morning availability.
 *
 * Configuration (via environment variables):
 * - DISABLE_RECOMMENDATION_SCHEDULER: Set to 'true' to disable
 * - RECOMMENDATION_SCHEDULER_DAY: Day of week (0=Sunday, default 0)
 * - RECOMMENDATION_SCHEDULER_HOUR: Hour to run (default 23)
 */

import { prisma } from '@/lib/db'
import { generateRecommendations } from './generator'
import type { ScheduledGenerationResult } from '@/types/recommendations'

// ============================================
// Configuration
// ============================================

function getConfig() {
  return {
    disabled: process.env.DISABLE_RECOMMENDATION_SCHEDULER === 'true',
    dayOfWeek: parseInt(process.env.RECOMMENDATION_SCHEDULER_DAY || '0', 10), // Sunday
    hour: parseInt(process.env.RECOMMENDATION_SCHEDULER_HOUR || '23', 10),
    timezone: process.env.RECOMMENDATION_SCHEDULER_TZ || 'America/New_York',
    staggerMs: parseInt(process.env.RECOMMENDATION_STAGGER_MS || '2000', 10),
    lookbackDays: parseInt(process.env.RECOMMENDATION_LOOKBACK_DAYS || '30', 10),
  }
}

function getCurrentDayOfWeek(): number {
  return new Date().getDay() // 0 = Sunday
}

// ============================================
// Main Scheduler Function
// ============================================

/**
 * Run scheduled recommendation generation for all active brands.
 * Called by /api/cron/recommendations at configured time (default: Sunday 11 PM).
 *
 * @param force - If true, skip day-of-week check (for manual triggering)
 */
export async function runScheduledRecommendationGeneration(
  force = false
): Promise<ScheduledGenerationResult> {
  const startTime = Date.now()
  const config = getConfig()

  // Check if disabled
  if (config.disabled) {
    console.log('[Recommendation Scheduler] Scheduler is disabled via DISABLE_RECOMMENDATION_SCHEDULER')
    return {
      totalBrands: 0,
      brandsProcessed: 0,
      brandsFailed: 0,
      results: [],
      skipped: 'disabled',
      duration: Date.now() - startTime,
    }
  }

  // Check day of week (unless forced)
  if (!force) {
    const currentDay = getCurrentDayOfWeek()
    if (currentDay !== config.dayOfWeek) {
      console.log(
        `[Recommendation Scheduler] Skipping: current day (${currentDay}) != configured day (${config.dayOfWeek})`
      )
      return {
        totalBrands: 0,
        brandsProcessed: 0,
        brandsFailed: 0,
        results: [],
        skipped: 'wrong_day',
        duration: Date.now() - startTime,
      }
    }
  }

  console.log('[Recommendation Scheduler] Starting scheduled recommendation generation...')

  // Fetch all active brands
  const brands = await prisma.brand.findMany({
    where: { isActive: true },
    select: {
      id: true,
      name: true,
    },
  })

  console.log(`[Recommendation Scheduler] Processing ${brands.length} active brands`)

  const results: ScheduledGenerationResult['results'] = []
  let brandsProcessed = 0
  let brandsFailed = 0

  for (let i = 0; i < brands.length; i++) {
    const brand = brands[i]

    try {
      const result = await generateRecommendations({
        brandId: brand.id,
        lookbackDays: config.lookbackDays,
        dryRun: false,
      })

      results.push({
        brandId: brand.id,
        brandName: brand.name,
        generated: result.generated,
        skipped: result.skipped,
        errors: result.errors,
      })

      if (result.errors.length === 0) {
        brandsProcessed++
      } else {
        // Partial success (some errors but some generated)
        brandsProcessed++
        if (result.generated === 0 && result.errors.length > 0) {
          brandsFailed++
        }
      }

      console.log(
        `[Recommendation Scheduler] Brand ${brand.name}: ${result.generated} generated, ${result.skipped} skipped`
      )
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error'
      console.error(`[Recommendation Scheduler] Error for brand ${brand.name}:`, errorMsg)

      results.push({
        brandId: brand.id,
        brandName: brand.name,
        generated: 0,
        skipped: 0,
        errors: [errorMsg],
      })

      brandsFailed++
    }

    // Stagger between brands
    if (config.staggerMs > 0 && i < brands.length - 1) {
      await new Promise(resolve => setTimeout(resolve, config.staggerMs))
    }
  }

  const duration = Date.now() - startTime
  console.log(
    `[Recommendation Scheduler] Completed: ${brandsProcessed} succeeded, ${brandsFailed} failed. Duration: ${duration}ms`
  )

  return {
    totalBrands: brands.length,
    brandsProcessed,
    brandsFailed,
    results,
    skipped: null,
    duration,
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Scheduler service created
- [ ] Processes all active brands
- [ ] Configurable via environment variables
- [ ] Returns comprehensive result

### Subtask 3.2: Create Cron Route for Recommendation Scheduler
**File**: `/home/pbrown/SkuInventory/src/app/api/cron/recommendations/route.ts`
**Pattern**: Follow `/src/app/api/cron/ads-sync/route.ts`

**Instructions**:
1. Create cron endpoint with CRON_SECRET authentication
2. Call scheduler service
3. Return results

```typescript
/**
 * POST /api/cron/recommendations
 *
 * Scheduled endpoint for weekly recommendation generation.
 * Authenticated via CRON_SECRET header.
 *
 * Intended schedule: Sunday 11 PM (for Monday morning availability)
 *
 * Configuration (via environment variables):
 * - DISABLE_RECOMMENDATION_SCHEDULER: Set to 'true' to disable
 * - RECOMMENDATION_SCHEDULER_DAY: Day of week (0=Sunday, default 0)
 * - RECOMMENDATION_LOOKBACK_DAYS: Days to analyze (default 30)
 */

import { NextRequest, NextResponse } from 'next/server'
import { runScheduledRecommendationGeneration } from '@/services/recommendations/scheduler'

// Force dynamic rendering
export const dynamic = 'force-dynamic'

// Maximum execution time (5 minutes for processing multiple brands)
export const maxDuration = 300

export async function POST(request: NextRequest) {
  try {
    // Verify cron secret
    const cronSecret = process.env.CRON_SECRET
    const providedSecret = request.headers.get('X-Cron-Secret')

    if (!cronSecret || cronSecret.length < 16) {
      console.error('[Recommendation Cron] CRON_SECRET not properly configured')
      return NextResponse.json(
        { error: 'Server configuration error' },
        { status: 500 }
      )
    }

    if (providedSecret !== cronSecret) {
      return NextResponse.json(
        { error: 'Invalid cron secret' },
        { status: 401 }
      )
    }

    // Check for force flag (for manual triggering regardless of day)
    const { searchParams } = new URL(request.url)
    const force = searchParams.get('force') === 'true'

    // Run scheduled generation
    const result = await runScheduledRecommendationGeneration(force)

    // Check if skipped
    if (result.skipped) {
      return NextResponse.json({
        success: true,
        skipped: result.skipped,
        message: result.skipped === 'disabled'
          ? 'Recommendation scheduler is disabled via DISABLE_RECOMMENDATION_SCHEDULER'
          : 'Recommendation scheduler skipped (not configured day of week)',
        duration: result.duration,
      })
    }

    return NextResponse.json({
      success: true,
      totalBrands: result.totalBrands,
      brandsProcessed: result.brandsProcessed,
      brandsFailed: result.brandsFailed,
      results: result.results,
      duration: result.duration,
    })
  } catch (error) {
    console.error('[Recommendation Cron] Error:', error)
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to run recommendation generation',
      },
      { status: 500 }
    )
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Cron route created with CRON_SECRET auth
- [ ] Calls scheduler service
- [ ] Supports ?force=true query param
- [ ] Returns comprehensive results
- [ ] maxDuration set for long-running execution

### Subtask 3.3: Export Scheduler from Index
**File**: `/home/pbrown/SkuInventory/src/services/recommendations/index.ts`

**Instructions**:
Add export at end of file:

```typescript
// Scheduler
export {
  runScheduledRecommendationGeneration,
} from './scheduler'
```

**Completion Criteria**:
- [ ] Scheduler exported from barrel file
- [ ] TypeScript compiles without errors

---

## Phase 4: Settings UI

### Subtask 4.1: Create Threshold Settings Form Component
**File**: `/home/pbrown/SkuInventory/src/components/features/ThresholdSettingsForm.tsx`
**Pattern**: Follow `/src/components/features/SettingsForm.tsx`

**Instructions**:
1. Create form component for threshold editing
2. Show current values with defaults
3. Handle save via API

```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import type { RequiredThresholds } from '@/lib/recommendation-utils'

interface ThresholdSettingsFormProps {
  brandName: string
  thresholds: RequiredThresholds
  defaults: RequiredThresholds
  onSave: (thresholds: Partial<RequiredThresholds>) => Promise<void>
}

export function ThresholdSettingsForm({
  brandName,
  thresholds,
  defaults,
  onSave,
}: ThresholdSettingsFormProps) {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [success, setSuccess] = useState(false)

  const [formData, setFormData] = useState({
    graduation: { ...thresholds.graduation },
    negative: { ...thresholds.negative },
    budget: { ...thresholds.budget },
  })

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError(null)
    setSuccess(false)

    try {
      await onSave(formData)
      setSuccess(true)
      setTimeout(() => setSuccess(false), 3000)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save thresholds')
    } finally {
      setIsLoading(false)
    }
  }

  const handleReset = () => {
    setFormData({
      graduation: { ...defaults.graduation },
      negative: { ...defaults.negative },
      budget: { ...defaults.budget },
    })
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">{error}</div>
      )}

      {success && (
        <div className="rounded-md bg-green-50 border border-green-200 p-3 text-sm text-green-800">
          Thresholds saved successfully
        </div>
      )}

      {/* Brand Info */}
      <Card>
        <CardHeader>
          <CardTitle>Threshold Configuration</CardTitle>
          <CardDescription>
            Configure recommendation thresholds for {brandName}. Leave blank to use defaults.
          </CardDescription>
        </CardHeader>
      </Card>

      {/* Keyword Graduation Thresholds */}
      <Card>
        <CardHeader>
          <CardTitle>Keyword Graduation</CardTitle>
          <CardDescription>
            Thresholds for graduating keywords from Discovery to Accelerate campaigns
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid gap-4 md:grid-cols-3">
            <div className="space-y-2">
              <Label htmlFor="graduation.maxAcos">Max ACOS (%)</Label>
              <Input
                id="graduation.maxAcos"
                type="number"
                min="0"
                max="100"
                step="1"
                value={(formData.graduation.maxAcos * 100).toFixed(0)}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    graduation: {
                      ...prev.graduation,
                      maxAcos: (parseFloat(e.target.value) || 25) / 100,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: {(defaults.graduation.maxAcos * 100).toFixed(0)}%
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="graduation.minConversions">Min Conversions</Label>
              <Input
                id="graduation.minConversions"
                type="number"
                min="0"
                value={formData.graduation.minConversions}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    graduation: {
                      ...prev.graduation,
                      minConversions: parseInt(e.target.value) || 5,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: {defaults.graduation.minConversions}
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="graduation.minSpend">Min Spend ($)</Label>
              <Input
                id="graduation.minSpend"
                type="number"
                min="0"
                step="1"
                value={formData.graduation.minSpend}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    graduation: {
                      ...prev.graduation,
                      minSpend: parseFloat(e.target.value) || 50,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: ${defaults.graduation.minSpend}
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Negative Keyword Thresholds */}
      <Card>
        <CardHeader>
          <CardTitle>Negative Keywords</CardTitle>
          <CardDescription>
            Thresholds for suggesting keywords to add as negatives
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid gap-4 md:grid-cols-3">
            <div className="space-y-2">
              <Label htmlFor="negative.minSpend">Min Spend ($)</Label>
              <Input
                id="negative.minSpend"
                type="number"
                min="0"
                step="1"
                value={formData.negative.minSpend}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    negative: {
                      ...prev.negative,
                      minSpend: parseFloat(e.target.value) || 25,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: ${defaults.negative.minSpend}
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="negative.maxOrders">Max Orders</Label>
              <Input
                id="negative.maxOrders"
                type="number"
                min="0"
                value={formData.negative.maxOrders}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    negative: {
                      ...prev.negative,
                      maxOrders: parseInt(e.target.value) || 0,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: {defaults.negative.maxOrders}
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="negative.minClicks">Min Clicks</Label>
              <Input
                id="negative.minClicks"
                type="number"
                min="0"
                value={formData.negative.minClicks}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    negative: {
                      ...prev.negative,
                      minClicks: parseInt(e.target.value) || 50,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: {defaults.negative.minClicks}
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Budget Strategy Thresholds */}
      <Card>
        <CardHeader>
          <CardTitle>Budget & Bid Strategy</CardTitle>
          <CardDescription>
            Thresholds for budget increase and bid decrease recommendations
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid gap-4 md:grid-cols-2">
            <div className="space-y-2">
              <Label htmlFor="budget.minRoas">Min ROAS for Budget Increase</Label>
              <Input
                id="budget.minRoas"
                type="number"
                min="0"
                step="0.1"
                value={formData.budget.minRoas}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    budget: {
                      ...prev.budget,
                      minRoas: parseFloat(e.target.value) || 1.5,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: {defaults.budget.minRoas}
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="budget.budgetUtilization">Budget Utilization (%)</Label>
              <Input
                id="budget.budgetUtilization"
                type="number"
                min="0"
                max="100"
                step="1"
                value={(formData.budget.budgetUtilization * 100).toFixed(0)}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    budget: {
                      ...prev.budget,
                      budgetUtilization: (parseFloat(e.target.value) || 95) / 100,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: {(defaults.budget.budgetUtilization * 100).toFixed(0)}%
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="budget.maxAcosForIncrease">Max ACOS for Budget Increase (%)</Label>
              <Input
                id="budget.maxAcosForIncrease"
                type="number"
                min="0"
                max="100"
                step="1"
                value={(formData.budget.maxAcosForIncrease * 100).toFixed(0)}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    budget: {
                      ...prev.budget,
                      maxAcosForIncrease: (parseFloat(e.target.value) || 25) / 100,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: {(defaults.budget.maxAcosForIncrease * 100).toFixed(0)}%
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="budget.minAcosForDecrease">Min ACOS for Bid Decrease (%)</Label>
              <Input
                id="budget.minAcosForDecrease"
                type="number"
                min="0"
                max="100"
                step="1"
                value={(formData.budget.minAcosForDecrease * 100).toFixed(0)}
                onChange={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    budget: {
                      ...prev.budget,
                      minAcosForDecrease: (parseFloat(e.target.value) || 35) / 100,
                    },
                  }))
                }
              />
              <p className="text-xs text-muted-foreground">
                Default: {(defaults.budget.minAcosForDecrease * 100).toFixed(0)}%
              </p>
            </div>
          </div>
        </CardContent>
      </Card>

      <div className="flex justify-between">
        <Button type="button" variant="outline" onClick={handleReset}>
          Reset to Defaults
        </Button>
        <Button type="submit" disabled={isLoading}>
          {isLoading ? 'Saving...' : 'Save Thresholds'}
        </Button>
      </div>
    </form>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Form component created
- [ ] All threshold fields included
- [ ] Shows defaults as help text
- [ ] Reset to defaults button
- [ ] TypeScript compiles

### Subtask 4.2: Create Threshold Settings Page
**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/settings/thresholds/page.tsx`
**Pattern**: Follow `/src/app/(dashboard)/settings/page.tsx`

**Instructions**:
1. Create settings page that fetches and saves thresholds
2. Use ThresholdSettingsForm component

```typescript
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useSession } from 'next-auth/react'
import { ThresholdSettingsForm } from '@/components/features/ThresholdSettingsForm'
import type { RequiredThresholds } from '@/lib/recommendation-utils'
import { DEFAULT_THRESHOLDS } from '@/lib/recommendation-utils'

interface ThresholdsResponse {
  brandId: string
  brandName: string
  thresholds: RequiredThresholds
  brandOverrides: Partial<RequiredThresholds> | null
  defaults: RequiredThresholds
}

export default function ThresholdsSettingsPage() {
  const { data: session, status } = useSession()
  const [data, setData] = useState<ThresholdsResponse | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchThresholds = useCallback(async () => {
    try {
      setIsLoading(true)
      const res = await fetch('/api/thresholds')
      if (!res.ok) {
        const errorData = await res.json().catch(() => ({}))
        throw new Error(errorData.error || 'Failed to load thresholds')
      }
      const result = await res.json()
      setData(result.data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred')
    } finally {
      setIsLoading(false)
    }
  }, [])

  useEffect(() => {
    if (status === 'loading') return
    if (session?.user?.selectedBrandId) {
      fetchThresholds()
    } else {
      setIsLoading(false)
    }
  }, [status, session?.user?.selectedBrandId, fetchThresholds])

  const handleSave = async (thresholds: Partial<RequiredThresholds>) => {
    const res = await fetch('/api/thresholds', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(thresholds),
    })

    if (!res.ok) {
      const errorData = await res.json().catch(() => ({}))
      throw new Error(errorData.error || 'Failed to save thresholds')
    }

    await fetchThresholds()
  }

  if (status === 'loading' || isLoading) {
    return (
      <div className="space-y-6">
        <div>
          <h1 className="text-3xl font-bold">Recommendation Thresholds</h1>
          <p className="text-muted-foreground">Configure thresholds for recommendation generation</p>
        </div>
        <div className="py-10 text-center text-muted-foreground">Loading thresholds...</div>
      </div>
    )
  }

  if (!session?.user?.selectedBrandId) {
    return (
      <div className="space-y-6">
        <div>
          <h1 className="text-3xl font-bold">Recommendation Thresholds</h1>
          <p className="text-muted-foreground">Configure thresholds for recommendation generation</p>
        </div>
        <div className="rounded-md bg-yellow-50 border border-yellow-200 p-4 text-yellow-800">
          Please select a brand to configure thresholds.
        </div>
      </div>
    )
  }

  if (error || !data) {
    return (
      <div className="space-y-6">
        <div>
          <h1 className="text-3xl font-bold">Recommendation Thresholds</h1>
          <p className="text-muted-foreground">Configure thresholds for recommendation generation</p>
        </div>
        <div className="rounded-md bg-destructive/10 p-4 text-destructive">
          {error || 'Failed to load thresholds'}
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold">Recommendation Thresholds</h1>
        <p className="text-muted-foreground">
          Configure thresholds for {data.brandName} recommendation generation
        </p>
      </div>

      <div className="max-w-4xl">
        <ThresholdSettingsForm
          brandName={data.brandName}
          thresholds={data.thresholds}
          defaults={data.defaults}
          onSave={handleSave}
        />
      </div>
    </div>
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Page created at `/settings/thresholds`
- [ ] Fetches thresholds on load
- [ ] Handles brand selection requirement
- [ ] Shows form with current values
- [ ] Saves via API

---

## Phase 5: Final Validation

### Subtask 5.1: Full Build and TypeScript Check
**Instructions**:
```bash
npx tsc --noEmit
npm run build
npm run lint
```

**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] No lint errors

### Subtask 5.2: Manual Integration Test
**Instructions**:
1. Start test environment
2. Navigate to `/settings/thresholds`
3. Verify form loads with defaults
4. Change a value and save
5. Refresh and verify value persisted
6. Test cron endpoint with force flag:
   ```bash
   curl -X POST http://172.16.20.50:2345/api/cron/recommendations?force=true \
     -H "X-Cron-Secret: <your_cron_secret>"
   ```
7. Verify recommendations generated

**Completion Criteria**:
- [ ] Thresholds page accessible
- [ ] Form displays and saves correctly
- [ ] Cron endpoint generates recommendations
- [ ] Generated recommendations use brand thresholds

---

## Summary of Deliverables

**Files Created**: 5
- `src/app/api/thresholds/route.ts`
- `src/app/api/cron/recommendations/route.ts`
- `src/services/recommendations/scheduler.ts`
- `src/components/features/ThresholdSettingsForm.tsx`
- `src/app/(dashboard)/settings/thresholds/page.tsx`

**Files Modified**: 3
- `src/types/recommendations.ts` (add scheduler types)
- `src/lib/recommendation-utils.ts` (update mergeThresholds)
- `src/services/recommendations/generator.ts` (use brand thresholds)
- `src/services/recommendations/index.ts` (export scheduler)

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 0 through Phase 5)
2. Complete Phase 0 verification first - confidence badge may already be complete
3. Test completion criteria before moving to next subtask
4. Follow reference patterns exactly
5. Run validation commands after each subtask

## Notes on Issue Tasks

- **Confidence badge and filter**: Investigation shows these are ALREADY IMPLEMENTED in `RecommendationCard.tsx` and `recommendations/page.tsx`. Verify during Phase 0.
- **Brand-level thresholds**: Stored in `Company.settings.brandThresholds[brandId]` rather than separate model to avoid migration complexity.
- **Cron schedule**: Sunday 11 PM configured via environment variables, customizable.

## Environment Variables (to document)

```env
# Recommendation Scheduler (add to .env.example)
DISABLE_RECOMMENDATION_SCHEDULER=false
RECOMMENDATION_SCHEDULER_DAY=0      # 0=Sunday
RECOMMENDATION_SCHEDULER_HOUR=23    # 11 PM
RECOMMENDATION_SCHEDULER_TZ=America/New_York
RECOMMENDATION_STAGGER_MS=2000
RECOMMENDATION_LOOKBACK_DAYS=30
```

## Performance Metrics

| Phase | Estimated Duration |
|-------|----------|
| Investigation | 45m |
| Validation | 15m |
| Planning | 30m |
| **Total** | **90m** |
