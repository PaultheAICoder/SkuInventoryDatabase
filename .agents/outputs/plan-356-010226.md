# Implementation Plan
**Generated**: 2026-01-02 08:45:00 UTC
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #356
**Estimated Build Time**: 8-10 hours
**Complexity**: High

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #356
**Priority**: P1-MVP (priority:p1-mvp label)
**Scope**: Full-Stack (scope:full-stack label)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="recommendation"` or None

### Issue Validation
**Status**: Valid
**Dependencies Met**:
- Issue #354 (CLOSED): Database schema and types setup - COMPLETE
- Issue #355 (CLOSED): Keyword graduation algorithm - COMPLETE
**Recent Changes**:
- `prisma/schema.prisma` - Recommendation, ChangeLogEntry, WatchedKeyword models exist
- `src/types/recommendations.ts` - All types and Zod schemas defined
- `src/services/recommendations/` - Generator and keyword-graduation modules exist

### Current State Assessment
- **Existing services**:
  - `src/services/recommendations/generator.ts` - generateRecommendations() implemented
  - `src/services/recommendations/keyword-graduation.ts` - Classification and threshold logic
  - `src/services/recommendations/confidence-scoring.ts` - Confidence calculation
- **Database**: Recommendation, ChangeLogEntry, WatchedKeyword models ready
- **API Routes**: None exist yet for recommendations
- **Types**: All types defined in `src/types/recommendations.ts`
- **UI Components**: None exist yet

### Dependencies & Blockers
1. All dependencies met - Issues #354 and #355 complete

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: High
**Effort**: 8-10 hours
**Risk**: Medium (new full-stack feature with multiple components)

### Patterns Identified
**Primary API Route**: `src/app/api/components/route.ts` - List/Create pattern with pagination
**Secondary API Route**: `src/app/api/skus/[id]/route.ts` - PATCH with dynamic id
**Dashboard Page**: `src/app/(dashboard)/forecasts/page.tsx` - Client-side page with stats cards
**Card Component**: `src/components/features/DraftTransactionCard.tsx` - Card with action buttons and dialog
**Sidebar Navigation**: `src/app/(dashboard)/layout.tsx` - Main navigation array

### Ripple Effect Analysis
**Files Identified**: 1 (sidebar layout for navigation entry)
- `src/app/(dashboard)/layout.tsx` - Add "Recommendations" to mainNavigation array

---

## Executive Summary
Create the Monday Dashboard for weekly recommendation review workflow. This includes:
1. Four API endpoints for CRUD operations on recommendations
2. Three React components (RecommendationCard, RecommendationList, AcceptRejectModal)
3. Dashboard page at `/recommendations` with stats, filtering, and action workflow

---

## Phase 1: API Routes Layer

### Subtask 1.1: Create GET /api/recommendations route
**File**: `src/app/api/recommendations/route.ts`
**Pattern**: Follow `src/app/api/components/route.ts` (lines 19-124)
**Instructions**:
1. Create directory and file: `src/app/api/recommendations/route.ts`
2. Import from `@/lib/api-response`, `@/lib/auth`, `@/lib/db`
3. Implement GET handler with:
   - Session authentication check
   - Parse query params using `recommendationQuerySchema` from `src/types/recommendations.ts`
   - Brand scoping: Use `session.user.selectedBrandId` (required for recommendations)
   - Prisma query with filters: status, type, confidence, pagination
   - Include relations: brand, keywordMetric, campaign
   - Sort by impact (expectedImpact) or createdAt
   - Return paginated response
4. Handle snoozed recommendations: Only return SNOOZED if snoozedUntil is past

**Code Snippet**:
```typescript
// GET handler structure
export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions)
  if (!session?.user) return unauthorized()

  const selectedBrandId = session.user.selectedBrandId
  if (!selectedBrandId) {
    return error('Please select a brand to view recommendations', 400)
  }

  // Parse query params
  const { searchParams } = new URL(request.url)
  const queryResult = parseQuery(searchParams, recommendationQuerySchema)
  if (queryResult.error) return queryResult.error

  // Build where clause with status filter
  // Handle SNOOZED: include if snoozedUntil <= now
  // ...
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Route returns paginated recommendations
- [ ] Filters work: status, type, confidence
- [ ] Brand scoping enforced
- [ ] TypeScript compiles without errors

### Subtask 1.2: Create POST /api/recommendations route (trigger generation)
**File**: `src/app/api/recommendations/route.ts` (same file)
**Pattern**: Follow `src/app/api/components/route.ts` POST handler (lines 126-232)
**Instructions**:
1. Add POST handler to existing file
2. Accept optional body: `{ dryRun?: boolean, lookbackDays?: number }`
3. Call `generateRecommendations()` from `src/services/recommendations/generator.ts`
4. Return result with generated/skipped counts

**Code Snippet**:
```typescript
// POST handler - trigger generation
export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions)
  if (!session?.user) return unauthorized()

  // Require non-viewer role
  const companyRole = getSelectedCompanyRole(session)
  if (companyRole === 'viewer') {
    return unauthorized('Insufficient permissions')
  }

  const selectedBrandId = session.user.selectedBrandId
  if (!selectedBrandId) {
    return error('Please select a brand to generate recommendations', 400)
  }

  // Parse optional body
  const body = await request.json().catch(() => ({}))

  const result = await generateRecommendations({
    brandId: selectedBrandId,
    lookbackDays: body.lookbackDays,
    dryRun: body.dryRun,
  })

  return success(result)
}
```

**Completion Criteria**:
- [ ] POST triggers recommendation generation
- [ ] Returns generated/skipped counts
- [ ] Non-viewer role enforced

### Subtask 1.3: Create GET /api/recommendations/[id] route
**File**: `src/app/api/recommendations/[id]/route.ts`
**Pattern**: Follow `src/app/api/skus/[id]/route.ts` (lines 24-144)
**Instructions**:
1. Create directory: `src/app/api/recommendations/[id]/`
2. Create `route.ts`
3. Implement GET handler:
   - Fetch recommendation by id
   - Include relations: brand, keywordMetric, campaign, changeLogEntries
   - Verify brand access (recommendation.brandId matches session.selectedBrandId)
4. Return detailed recommendation with all relations

**Code Snippet**:
```typescript
type RouteParams = { params: Promise<{ id: string }> }

export async function GET(request: NextRequest, { params }: RouteParams) {
  const session = await getServerSession(authOptions)
  if (!session?.user) return unauthorized()

  const { id } = await params
  const selectedBrandId = session.user.selectedBrandId

  const recommendation = await prisma.recommendation.findFirst({
    where: {
      id,
      brandId: selectedBrandId,
    },
    include: {
      brand: { select: { id: true, name: true } },
      keywordMetric: { select: { keyword: true, matchType: true } },
      campaign: { select: { id: true, name: true } },
      changeLogEntries: {
        orderBy: { createdAt: 'desc' },
        include: { user: { select: { id: true, name: true } } },
      },
    },
  })

  if (!recommendation) return notFound('Recommendation')

  return success(transformRecommendation(recommendation))
}
```

**Completion Criteria**:
- [ ] Route returns recommendation with relations
- [ ] Brand access verified
- [ ] Change log history included

### Subtask 1.4: Create PATCH /api/recommendations/[id] route (accept/reject/snooze)
**File**: `src/app/api/recommendations/[id]/route.ts` (same file)
**Pattern**: Follow `src/app/api/skus/[id]/route.ts` PATCH handler
**Instructions**:
1. Add PATCH handler to existing file
2. Parse body using `updateRecommendationSchema` from `src/types/recommendations.ts`
3. Implement action logic:
   - **ACCEPTED**: Set status to ACCEPTED, create ChangeLogEntry
   - **REJECTED**: Require reason, set status to REJECTED, create ChangeLogEntry
   - **SNOOZED**: Calculate snoozedUntil, set status to SNOOZED, create ChangeLogEntry
4. Use transaction for atomicity
5. Return updated recommendation

**Code Snippet**:
```typescript
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  const session = await getServerSession(authOptions)
  if (!session?.user) return unauthorized()

  const companyRole = getSelectedCompanyRole(session)
  if (companyRole === 'viewer') {
    return unauthorized('Insufficient permissions')
  }

  const { id } = await params
  const bodyResult = await parseBody(request, updateRecommendationSchema)
  if (bodyResult.error) return bodyResult.error

  const { action, reason, notes, snoozeDays } = bodyResult.data

  // Validate rejection requires reason
  if (action === 'REJECTED' && !reason) {
    return error('Reason is required when rejecting', 400)
  }

  // Use transaction
  const result = await prisma.$transaction(async (tx) => {
    // Get current recommendation
    const recommendation = await tx.recommendation.findFirst({
      where: { id, brandId: session.user.selectedBrandId },
    })

    if (!recommendation) throw new Error('NOT_FOUND')
    if (recommendation.status !== 'PENDING') {
      throw new Error('ALREADY_ACTIONED')
    }

    // Calculate snooze date if needed
    const snoozedUntil = action === 'SNOOZED'
      ? calculateSnoozedUntil(snoozeDays)
      : null

    // Update recommendation
    const updated = await tx.recommendation.update({
      where: { id },
      data: {
        status: action,
        snoozedUntil,
      },
    })

    // Create change log entry
    await tx.changeLogEntry.create({
      data: {
        recommendationId: id,
        action,
        reason,
        notes,
        beforeValues: { status: 'PENDING' },
        afterValues: { status: action, snoozedUntil },
        userId: session.user.id,
      },
    })

    return updated
  })

  return success(result)
}
```

**Completion Criteria**:
- [ ] ACCEPTED updates status, creates log
- [ ] REJECTED requires reason, updates status, creates log
- [ ] SNOOZED calculates date, updates status, creates log
- [ ] Only PENDING recommendations can be actioned
- [ ] Transaction ensures atomicity

---

## Phase 2: Service Layer Enhancements

### Subtask 2.1: Create recommendation service for API helpers
**File**: `src/services/recommendations/api-helpers.ts`
**Pattern**: Follow service function patterns in `src/services/inventory.ts`
**Instructions**:
1. Create new file for API-specific helper functions
2. Implement functions:
   - `getRecommendationsForBrand(brandId, filters, pagination)` - Query with filters
   - `getRecommendationById(id, brandId)` - Single recommendation with relations
   - `actionRecommendation(id, userId, brandId, action, reason?, notes?, snoozeDays?)` - Action handler
   - `getRecommendationSummary(brandId)` - Summary stats for dashboard
3. Include proper typing and error handling

**Code Snippet**:
```typescript
import { prisma } from '@/lib/db'
import { calculateSnoozedUntil } from '@/lib/recommendation-utils'
import type { RecommendationQuery, UpdateRecommendationRequest, RecommendationSummary } from '@/types/recommendations'

export async function getRecommendationSummary(brandId: string): Promise<RecommendationSummary> {
  const [total, pending, accepted, rejected, snoozed, byType, byConfidence] = await Promise.all([
    prisma.recommendation.count({ where: { brandId } }),
    prisma.recommendation.count({ where: { brandId, status: 'PENDING' } }),
    prisma.recommendation.count({ where: { brandId, status: 'ACCEPTED' } }),
    prisma.recommendation.count({ where: { brandId, status: 'REJECTED' } }),
    prisma.recommendation.count({ where: { brandId, status: 'SNOOZED' } }),
    // byType counts...
    // byConfidence counts...
  ])

  return { total, pending, accepted, rejected, snoozed, byType, byConfidence }
}
```

**Completion Criteria**:
- [ ] All helper functions implemented
- [ ] TypeScript types match
- [ ] Error handling for not found cases

### Subtask 2.2: Update barrel export
**File**: `src/services/recommendations/index.ts`
**Instructions**:
1. Add exports for new api-helpers module

**Completion Criteria**:
- [ ] All new functions exported

---

## Phase 3: Frontend Components

### Subtask 3.1: Create RecommendationCard component
**File**: `src/components/features/RecommendationCard.tsx`
**Pattern**: Follow `src/components/features/DraftTransactionCard.tsx`
**Instructions**:
1. Create component with props:
   - recommendation: RecommendationWithRelations
   - onAccept: (id: string, notes?: string) => Promise<void>
   - onReject: (id: string, reason: string) => Promise<void>
   - onSnooze: (id: string, days?: number) => Promise<void>
   - isProcessing?: boolean
2. Implement layout:
   - Header: Type badge + confidence badge
   - Body: Keyword, campaign name, rationale summary
   - Expected impact: current vs projected with percentage
   - Footer: Accept, Reject, Snooze buttons (only if PENDING)
3. Type-specific styling:
   - KEYWORD_GRADUATION: Green/growth theme
   - NEGATIVE_KEYWORD: Red/warning theme
   - etc.

**Code Snippet**:
```tsx
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import {
  TrendingUp,
  TrendingDown,
  Clock,
  CheckCircle,
  XCircle,
  PauseCircle
} from 'lucide-react'
import type { RecommendationWithRelations } from '@/types/recommendations'
import {
  getRecommendationTypeLabel,
  getConfidenceLevelLabel,
  calculateImprovementPercentage
} from '@/lib/recommendation-utils'

interface RecommendationCardProps {
  recommendation: RecommendationWithRelations
  onAccept: (id: string, notes?: string) => Promise<void>
  onReject: (id: string, reason: string) => Promise<void>
  onSnooze: (id: string, days?: number) => Promise<void>
  isProcessing?: boolean
}

const typeConfig = {
  KEYWORD_GRADUATION: { icon: TrendingUp, color: 'bg-green-100 text-green-800' },
  NEGATIVE_KEYWORD: { icon: TrendingDown, color: 'bg-red-100 text-red-800' },
  // ... other types
}

export function RecommendationCard({
  recommendation,
  onAccept,
  onReject,
  onSnooze,
  isProcessing = false,
}: RecommendationCardProps) {
  const [showRejectDialog, setShowRejectDialog] = useState(false)
  const [showSnoozeDialog, setShowSnoozeDialog] = useState(false)

  const config = typeConfig[recommendation.type]
  const isPending = recommendation.status === 'PENDING'
  const improvement = calculateImprovementPercentage(recommendation.expectedImpact)

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <Badge className={config.color}>
            {getRecommendationTypeLabel(recommendation.type)}
          </Badge>
          <Badge variant="outline">
            {getConfidenceLevelLabel(recommendation.confidence)}
          </Badge>
        </div>
        <CardTitle className="text-lg">
          {recommendation.keyword || recommendation.campaign?.name}
        </CardTitle>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Rationale */}
        <p className="text-sm text-muted-foreground">
          {recommendation.rationale}
        </p>

        {/* Expected Impact */}
        <div className="bg-muted p-3 rounded-md">
          <p className="text-sm font-medium">Expected Impact</p>
          <p className="text-lg font-bold">
            {improvement > 0 ? '+' : ''}{improvement.toFixed(1)}% improvement
          </p>
        </div>
      </CardContent>

      {isPending && (
        <CardFooter className="flex justify-end gap-2">
          <Button variant="outline" size="sm" onClick={() => setShowSnoozeDialog(true)}>
            <PauseCircle className="h-4 w-4 mr-1" />
            Snooze
          </Button>
          <Button variant="outline" size="sm" onClick={() => setShowRejectDialog(true)}>
            <XCircle className="h-4 w-4 mr-1" />
            Reject
          </Button>
          <Button size="sm" onClick={() => onAccept(recommendation.id)}>
            <CheckCircle className="h-4 w-4 mr-1" />
            Accept
          </Button>
        </CardFooter>
      )}
    </Card>
  )
}
```

**Completion Criteria**:
- [ ] Card displays recommendation details
- [ ] Action buttons only show for PENDING
- [ ] Type-specific styling applied
- [ ] Expected impact calculated and displayed

### Subtask 3.2: Create AcceptRejectModal component
**File**: `src/components/features/AcceptRejectModal.tsx`
**Pattern**: Follow dialog pattern in `DraftTransactionCard.tsx` (lines 228-264)
**Instructions**:
1. Create modal component for accept/reject actions
2. Accept mode: Optional notes textarea
3. Reject mode: Required reason textarea
4. Snooze mode: Day selector (7, 14, 21, 30 days)
5. Handle loading state
6. Call appropriate callback on confirm

**Code Snippet**:
```tsx
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'

type ModalMode = 'accept' | 'reject' | 'snooze'

interface AcceptRejectModalProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  mode: ModalMode
  keyword?: string
  onConfirm: (data: { notes?: string; reason?: string; snoozeDays?: number }) => Promise<void>
}

export function AcceptRejectModal({
  open,
  onOpenChange,
  mode,
  keyword,
  onConfirm,
}: AcceptRejectModalProps) {
  const [notes, setNotes] = useState('')
  const [reason, setReason] = useState('')
  const [snoozeDays, setSnoozeDays] = useState(7)
  const [isLoading, setIsLoading] = useState(false)

  const handleConfirm = async () => {
    setIsLoading(true)
    try {
      await onConfirm({
        notes: mode === 'accept' ? notes : undefined,
        reason: mode === 'reject' ? reason : undefined,
        snoozeDays: mode === 'snooze' ? snoozeDays : undefined,
      })
      onOpenChange(false)
      setNotes('')
      setReason('')
    } finally {
      setIsLoading(false)
    }
  }

  // Render based on mode...
}
```

**Completion Criteria**:
- [ ] All three modes work (accept, reject, snooze)
- [ ] Reject requires reason
- [ ] Snooze has day selector
- [ ] Loading state handled

### Subtask 3.3: Create RecommendationList component
**File**: `src/components/features/RecommendationList.tsx`
**Pattern**: Follow `src/components/features/ForecastTable.tsx` structure
**Instructions**:
1. Create component that renders list of RecommendationCard components
2. Accept props:
   - recommendations: RecommendationWithRelations[]
   - onAction: (id, action, data) => Promise<void>
   - isLoading: boolean
3. Handle empty state with EmptyState component
4. Handle loading state with skeleton

**Completion Criteria**:
- [ ] Renders list of cards
- [ ] Empty state shown when no recommendations
- [ ] Loading skeleton while fetching

---

## Phase 4: Dashboard Page

### Subtask 4.1: Create Monday Dashboard page
**File**: `src/app/(dashboard)/recommendations/page.tsx`
**Pattern**: Follow `src/app/(dashboard)/forecasts/page.tsx`
**Instructions**:
1. Create directory and page file
2. Implement client-side page with:
   - Session check with status handling
   - Fetch recommendations on mount and brand change
   - Stats cards: Total, Pending, Accepted, Rejected, Snoozed
   - Filter bar: Status, Type, Confidence dropdowns
   - "Generate Recommendations" button (calls POST)
   - RecommendationList component
   - Pagination if >20 items
3. Handle action callbacks (accept/reject/snooze) with optimistic updates

**Code Snippet**:
```tsx
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useSession } from 'next-auth/react'
import { useSearchParams, useRouter } from 'next/navigation'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { RecommendationList } from '@/components/features/RecommendationList'
import {
  Lightbulb,
  CheckCircle,
  XCircle,
  PauseCircle,
  RefreshCw
} from 'lucide-react'
import type { RecommendationWithRelations } from '@/types/recommendations'

export default function RecommendationsPage() {
  const { data: session, status } = useSession()
  const searchParams = useSearchParams()
  const router = useRouter()

  const [recommendations, setRecommendations] = useState<RecommendationWithRelations[]>([])
  const [stats, setStats] = useState({ total: 0, pending: 0, accepted: 0, rejected: 0, snoozed: 0 })
  const [isLoading, setIsLoading] = useState(true)
  const [isGenerating, setIsGenerating] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Fetch recommendations
  const fetchRecommendations = useCallback(async () => {
    // ... implementation
  }, [session?.user?.selectedBrandId])

  // Handle actions
  const handleAction = async (id: string, action: string, data?: unknown) => {
    // ... implementation with optimistic update
  }

  // Generate recommendations
  const handleGenerate = async () => {
    setIsGenerating(true)
    try {
      const res = await fetch('/api/recommendations', { method: 'POST' })
      const result = await res.json()
      // Refresh list
      await fetchRecommendations()
    } finally {
      setIsGenerating(false)
    }
  }

  // Effect for initial load
  useEffect(() => {
    if (status === 'loading') return
    if (session?.user?.selectedBrandId) {
      fetchRecommendations()
    } else {
      setIsLoading(false)
    }
  }, [status, session?.user?.selectedBrandId, fetchRecommendations])

  // Render page with stats cards, filters, and list...
}
```

**Completion Criteria**:
- [ ] Page renders with stats cards
- [ ] Recommendations fetched on load
- [ ] Generate button works
- [ ] Actions update list immediately
- [ ] Loading states handled
- [ ] Brand selection required message shown if no brand

### Subtask 4.2: Add sidebar navigation entry
**File**: `src/app/(dashboard)/layout.tsx`
**Pattern**: Follow existing mainNavigation items (lines 44-55)
**Instructions**:
1. Add "Recommendations" entry to mainNavigation array
2. Position after "Amazon" (last data-related item)
3. Use Lightbulb icon from lucide-react
4. No adminOnly restriction (all users can view)

**Code Change**:
```typescript
// Add after Amazon entry (around line 54)
{ name: 'Recommendations', href: '/recommendations', icon: Lightbulb },
```

**Completion Criteria**:
- [ ] Navigation item visible in sidebar
- [ ] Clicking navigates to /recommendations
- [ ] Active state works correctly

---

## Phase 5: Types and Validation Enhancements

### Subtask 5.1: Add API response types
**File**: `src/types/recommendations.ts`
**Instructions**:
1. Add list response type with pagination meta
2. Add summary response type for stats endpoint

**Code Additions**:
```typescript
// Add to existing file

/**
 * Paginated list response for recommendations API
 */
export interface RecommendationListResponse {
  data: RecommendationWithRelations[]
  meta: {
    total: number
    page: number
    pageSize: number
    totalPages: number
  }
}

/**
 * API request for triggering recommendation generation
 */
export const generateRecommendationsRequestSchema = z.object({
  dryRun: z.boolean().optional(),
  lookbackDays: z.number().int().positive().optional(),
})

export type GenerateRecommendationsRequest = z.infer<typeof generateRecommendationsRequestSchema>
```

**Completion Criteria**:
- [ ] Types added and exported
- [ ] Schemas validate correctly

---

## Summary of Deliverables

**Files Created (7)**:
- `src/app/api/recommendations/route.ts` - GET (list) + POST (generate)
- `src/app/api/recommendations/[id]/route.ts` - GET (detail) + PATCH (action)
- `src/services/recommendations/api-helpers.ts` - API helper functions
- `src/components/features/RecommendationCard.tsx` - Card component
- `src/components/features/AcceptRejectModal.tsx` - Modal for actions
- `src/components/features/RecommendationList.tsx` - List container
- `src/app/(dashboard)/recommendations/page.tsx` - Dashboard page

**Files Modified (3)**:
- `src/services/recommendations/index.ts` - Add api-helpers exports
- `src/types/recommendations.ts` - Add API response types
- `src/app/(dashboard)/layout.tsx` - Add navigation entry

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5)
2. Complete each subtask fully before moving to next
3. Run validation commands after each file change
4. Follow reference patterns exactly - especially authentication and brand scoping
5. Test API routes with curl or API client before building UI

## Test Strategy Note
- Use Vitest for unit tests of service functions
- Manual testing of API routes with curl
- Manual testing of UI in browser
- E2E tests can be added later

## Critical Implementation Notes

1. **Brand Scoping**: All recommendations API endpoints MUST require `session.user.selectedBrandId`. Return error if not set.

2. **Session Status Check**: Dashboard page MUST handle `status === 'loading'` before accessing session data.

3. **Action Validation**: Only PENDING recommendations can be actioned. Return error otherwise.

4. **Rejection Reason**: REJECTED action MUST require a reason string.

5. **Snooze Calculation**: Use `calculateSnoozedUntil()` from `@/lib/recommendation-utils.ts`.

6. **Change Log**: Every action MUST create a ChangeLogEntry with beforeValues/afterValues.

7. **Icons**: Import `Lightbulb` from 'lucide-react' for sidebar navigation.

## Performance Metrics
| Phase | Estimated Duration |
|-------|----------|
| Phase 1: API Routes | 3h |
| Phase 2: Services | 1h |
| Phase 3: Components | 2.5h |
| Phase 4: Dashboard | 1.5h |
| Phase 5: Types | 0.5h |
| **Total** | **8.5h** |
