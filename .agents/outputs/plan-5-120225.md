# Implementation Plan
**Generated**: 2025-12-02T22:00:00Z
**Task ID**: Issue #5 - Components List Filters After Pagination Bug
**Estimated Build Time**: 4-6 hours
**Complexity**: Medium

## Executive Summary

Fix the pagination-before-filtering bug in the components list where reorderStatus filter is applied AFTER pagination, causing incorrect results and metadata. The fix involves conditionally fetching all components when reorderStatus filter is set, computing their status, filtering in memory, and then applying pagination to the filtered set. Both the page component and API route have identical bugs and require parallel fixes.

## Schema Verification

**Database**: No schema changes required. The bug is purely logic-based.

**Verified Field Names**:
- `reorderPoint`: stored in `Component` model (Prisma schema)
- `quantityOnHand`: computed from `TransactionLine` aggregates via `getComponentQuantities()`
- `reorderStatus`: computed in-memory via `calculateReorderStatus(quantityOnHand, reorderPoint)`

## Ripple Effect Verification

**Function: `getComponents` (components/page.tsx)**
- Direct callers: 1 (line 130 in same file)
- Impact: Page component only, no external callers

**Function: GET handler (api/components/route.ts)**
- Direct callers: External API consumers (ComponentTable.tsx via fetch)
- Impact: Any client calling `/api/components?reorderStatus=<value>`

**Related Files Verified**:
- `/src/app/api/export/components/route.ts`: Fetches ALL components (no pagination) - NOT affected
- `/src/app/api/dashboard/route.ts`: Fetches ALL components first, then filters - CORRECT pattern to follow
- `/src/components/features/ComponentTable.tsx`: Client component, receives data - NO changes needed

## Phase 1: Fix Page Component

### Subtask 1.1: Update getComponents Function in page.tsx

**File**: `/home/pbrown/SkuInventory/src/app/(dashboard)/components/page.tsx`
**Pattern Reference**: `/src/app/api/dashboard/route.ts` (lines 70-122) - correct implementation

**Current Buggy Logic** (lines 50-98):
```typescript
// BUG: Pagination applied FIRST
const [total, components] = await Promise.all([
  prisma.component.count({ where }),
  prisma.component.findMany({
    where,
    skip: (params.page - 1) * params.pageSize,
    take: params.pageSize,
    // ...
  }),
])

// Then quantities computed for only the current page
// Then reorderStatus filter applied AFTER pagination
// Then total incorrectly set to filtered page count
```

**Instructions**:

1. Modify the `getComponents` function (lines 26-100) to handle two cases:
   - **Case A**: When `reorderStatus` param is NOT set - use current pagination logic (no change)
   - **Case B**: When `reorderStatus` param IS set - fetch all, filter, then paginate

2. Replace lines 50-98 with the following logic:

```typescript
async function getComponents(
  brandId: string,
  params: {
    page: number
    pageSize: number
    search?: string
    category?: string
    reorderStatus?: string
    sortBy: string
    sortOrder: 'asc' | 'desc'
  }
) {
  const where = {
    brandId,
    isActive: true,
    ...(params.category && { category: params.category }),
    ...(params.search && {
      OR: [
        { name: { contains: params.search, mode: 'insensitive' as const } },
        { skuCode: { contains: params.search, mode: 'insensitive' as const } },
      ],
    }),
  }

  // When filtering by reorderStatus, we need to:
  // 1. Fetch ALL matching components (without pagination)
  // 2. Compute reorder status for ALL
  // 3. Filter by reorderStatus
  // 4. Apply pagination to filtered set
  if (params.reorderStatus) {
    // Fetch all components matching other filters (no pagination)
    const allComponents = await prisma.component.findMany({
      where,
      orderBy: { [params.sortBy]: params.sortOrder },
      include: {
        createdBy: { select: { id: true, name: true } },
      },
    })

    // Get quantities for ALL components
    const componentIds = allComponents.map((c) => c.id)
    const quantities = await getComponentQuantities(componentIds)

    // Transform and compute reorder status for ALL
    const allWithStatus: ComponentResponse[] = allComponents.map((component) => {
      const quantityOnHand = quantities.get(component.id) ?? 0
      const status = calculateReorderStatus(quantityOnHand, component.reorderPoint)

      return {
        id: component.id,
        name: component.name,
        skuCode: component.skuCode,
        category: component.category,
        unitOfMeasure: component.unitOfMeasure,
        costPerUnit: component.costPerUnit.toString(),
        reorderPoint: component.reorderPoint,
        leadTimeDays: component.leadTimeDays,
        notes: component.notes,
        isActive: component.isActive,
        quantityOnHand,
        reorderStatus: status,
        createdAt: component.createdAt.toISOString(),
        updatedAt: component.updatedAt.toISOString(),
        createdBy: component.createdBy,
      }
    })

    // Filter by reorderStatus BEFORE pagination
    const filtered = allWithStatus.filter((c) => c.reorderStatus === params.reorderStatus)

    // Apply pagination to filtered set
    const start = (params.page - 1) * params.pageSize
    const paginatedData = filtered.slice(start, start + params.pageSize)

    return {
      components: paginatedData,
      total: filtered.length, // Total of ALL matching records, not just current page
    }
  }

  // Original logic for non-reorderStatus queries (unchanged)
  const [total, components] = await Promise.all([
    prisma.component.count({ where }),
    prisma.component.findMany({
      where,
      skip: (params.page - 1) * params.pageSize,
      take: params.pageSize,
      orderBy: { [params.sortBy]: params.sortOrder },
      include: {
        createdBy: { select: { id: true, name: true } },
      },
    }),
  ])

  // Get quantities
  const componentIds = components.map((c) => c.id)
  const quantities = await getComponentQuantities(componentIds)

  // Transform response with computed fields
  const data: ComponentResponse[] = components.map((component) => {
    const quantityOnHand = quantities.get(component.id) ?? 0
    const status = calculateReorderStatus(quantityOnHand, component.reorderPoint)

    return {
      id: component.id,
      name: component.name,
      skuCode: component.skuCode,
      category: component.category,
      unitOfMeasure: component.unitOfMeasure,
      costPerUnit: component.costPerUnit.toString(),
      reorderPoint: component.reorderPoint,
      leadTimeDays: component.leadTimeDays,
      notes: component.notes,
      isActive: component.isActive,
      quantityOnHand,
      reorderStatus: status,
      createdAt: component.createdAt.toISOString(),
      updatedAt: component.updatedAt.toISOString(),
      createdBy: component.createdBy,
    }
  })

  return {
    components: data,
    total,
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Function handles both cases (with and without reorderStatus)
- [ ] When reorderStatus is set, all components are fetched before filtering
- [ ] Pagination is applied AFTER filtering
- [ ] Total count reflects ALL matching records, not just current page

---

## Phase 2: Fix API Route

### Subtask 2.1: Update GET Handler in API Route

**File**: `/home/pbrown/SkuInventory/src/app/api/components/route.ts`
**Pattern Reference**: `/src/app/api/dashboard/route.ts` (lines 70-122)

**Current Buggy Logic** (lines 59-106):
```typescript
// BUG: Same issue as page.tsx
// Pagination applied FIRST, then filter applied AFTER
```

**Instructions**:

1. Modify the GET handler (lines 20-111) to match the fix applied in Phase 1

2. Replace lines 59-106 with the following logic:

```typescript
// GET /api/components - List components with filtering and pagination
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    const { searchParams } = new URL(request.url)
    const queryResult = parseQuery(searchParams, componentListQuerySchema)
    if (queryResult.error) return queryResult.error

    const { page, pageSize, search, category, isActive, reorderStatus, sortBy, sortOrder } =
      queryResult.data

    // Get user's brand
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { company: { include: { brands: { where: { isActive: true }, take: 1 } } } },
    })

    if (!user?.company.brands[0]) {
      return success([])
    }

    const brandId = user.company.brands[0].id

    // Build where clause
    const where: Prisma.ComponentWhereInput = {
      brandId,
      ...(isActive !== undefined && { isActive }),
      ...(category && { category }),
      ...(search && {
        OR: [
          { name: { contains: search, mode: 'insensitive' } },
          { skuCode: { contains: search, mode: 'insensitive' } },
        ],
      }),
    }

    // When filtering by reorderStatus, we need to:
    // 1. Fetch ALL matching components (without pagination)
    // 2. Compute reorder status for ALL
    // 3. Filter by reorderStatus
    // 4. Apply pagination to filtered set
    if (reorderStatus) {
      // Fetch all components matching other filters (no pagination)
      const allComponents = await prisma.component.findMany({
        where,
        orderBy: { [sortBy]: sortOrder },
        include: {
          createdBy: { select: { id: true, name: true } },
        },
      })

      // Get quantities for ALL components
      const componentIds = allComponents.map((c) => c.id)
      const quantities = await getComponentQuantities(componentIds)

      // Transform and compute reorder status for ALL
      const allWithStatus = allComponents.map((component) => {
        const quantityOnHand = quantities.get(component.id) ?? 0
        const status = calculateReorderStatus(quantityOnHand, component.reorderPoint)

        return {
          id: component.id,
          name: component.name,
          skuCode: component.skuCode,
          category: component.category,
          unitOfMeasure: component.unitOfMeasure,
          costPerUnit: component.costPerUnit.toString(),
          reorderPoint: component.reorderPoint,
          leadTimeDays: component.leadTimeDays,
          notes: component.notes,
          isActive: component.isActive,
          quantityOnHand,
          reorderStatus: status,
          createdAt: component.createdAt.toISOString(),
          updatedAt: component.updatedAt.toISOString(),
          createdBy: component.createdBy,
        }
      })

      // Filter by reorderStatus BEFORE pagination
      const filtered = allWithStatus.filter((c) => c.reorderStatus === reorderStatus)

      // Apply pagination to filtered set
      const start = (page - 1) * pageSize
      const paginatedData = filtered.slice(start, start + pageSize)

      return paginated(paginatedData, filtered.length, page, pageSize)
    }

    // Original logic for non-reorderStatus queries
    const total = await prisma.component.count({ where })

    const components = await prisma.component.findMany({
      where,
      skip: (page - 1) * pageSize,
      take: pageSize,
      orderBy: { [sortBy]: sortOrder },
      include: {
        createdBy: { select: { id: true, name: true } },
      },
    })

    // Get quantities for all components
    const componentIds = components.map((c) => c.id)
    const quantities = await getComponentQuantities(componentIds)

    // Transform response with computed fields
    const data = components.map((component) => {
      const quantityOnHand = quantities.get(component.id) ?? 0
      const status = calculateReorderStatus(quantityOnHand, component.reorderPoint)

      return {
        id: component.id,
        name: component.name,
        skuCode: component.skuCode,
        category: component.category,
        unitOfMeasure: component.unitOfMeasure,
        costPerUnit: component.costPerUnit.toString(),
        reorderPoint: component.reorderPoint,
        leadTimeDays: component.leadTimeDays,
        notes: component.notes,
        isActive: component.isActive,
        quantityOnHand,
        reorderStatus: status,
        createdAt: component.createdAt.toISOString(),
        updatedAt: component.updatedAt.toISOString(),
        createdBy: component.createdBy,
      }
    })

    return paginated(data, total, page, pageSize)
  } catch (error) {
    console.error('Error listing components:', error)
    return serverError()
  }
}
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] GET handler handles both cases (with and without reorderStatus)
- [ ] Logic matches Phase 1 implementation
- [ ] API returns correct `meta.total` and `meta.totalPages` when filtering

---

## Phase 3: Add Regression Tests

### Subtask 3.1: Create E2E Test for Reorder Status Filtering with Pagination

**File**: `/home/pbrown/SkuInventory/tests/e2e/component-reorder-pagination.spec.ts` (NEW)
**Pattern Reference**: `/home/pbrown/SkuInventory/tests/e2e/tenant-scoping.spec.ts`

**Instructions**:

1. Create a new E2E test file that tests the reorderStatus filter with pagination

2. Test cases to cover:
   - Filter by each status (critical, warning, ok)
   - Verify total count is accurate across all pages
   - Verify pagination metadata reflects filtered results
   - Verify results on subsequent pages are correct

```typescript
import { test, expect } from '@playwright/test'

test.describe('Component Reorder Status Pagination', () => {
  test.beforeEach(async ({ page }) => {
    // Login
    await page.goto('/login')
    await page.waitForSelector('#email', { timeout: 10000 })
    await page.fill('#email', 'admin@tonsil.tech')
    await page.fill('#password', 'changeme123')
    await page.click('button[type="submit"]')
    await page.waitForURL('/', { timeout: 15000 })
  })

  test('API returns correct total when filtering by reorderStatus', async ({ request }) => {
    // Get all components first (to know expected counts)
    const allResponse = await request.get('/api/components?pageSize=1000')
    expect(allResponse.ok()).toBeTruthy()
    const allData = await allResponse.json()

    // Count components by status
    const statusCounts = {
      critical: 0,
      warning: 0,
      ok: 0,
    }
    for (const component of allData.data) {
      statusCounts[component.reorderStatus as keyof typeof statusCounts]++
    }

    // Test each status filter
    for (const [status, expectedCount] of Object.entries(statusCounts)) {
      if (expectedCount === 0) continue // Skip if no components with this status

      const response = await request.get(`/api/components?reorderStatus=${status}&pageSize=10`)
      expect(response.ok()).toBeTruthy()
      const data = await response.json()

      // Verify total matches expected count (not just page count)
      expect(data.meta.total).toBe(expectedCount)
      expect(data.meta.totalPages).toBe(Math.ceil(expectedCount / 10))

      // Verify all returned items have correct status
      for (const component of data.data) {
        expect(component.reorderStatus).toBe(status)
      }
    }
  })

  test('Page correctly shows filtered components count', async ({ page }) => {
    // Navigate to components page
    await page.goto('/components')
    await page.waitForSelector('table', { timeout: 10000 })

    // Find and use the reorder status filter (if components exist)
    const filterSelect = page.locator('select[name="reorderStatus"], [data-testid="reorder-status-filter"]')

    if (await filterSelect.isVisible()) {
      // Select 'critical' filter
      await filterSelect.selectOption('critical')

      // Wait for the page to reload/update
      await page.waitForTimeout(1000)

      // Verify the page shows filtered results
      // The pagination should reflect the filtered count
      const paginationInfo = page.locator('[data-testid="pagination-info"], .pagination-info')
      if (await paginationInfo.isVisible()) {
        const text = await paginationInfo.textContent()
        // Should show filtered count, not total unfiltered count
        expect(text).not.toContain('of 0') // Should have some critical components
      }
    }
  })

  test('Pagination works correctly with reorderStatus filter', async ({ request }) => {
    // Get critical components with small page size
    const page1Response = await request.get('/api/components?reorderStatus=critical&page=1&pageSize=5')
    expect(page1Response.ok()).toBeTruthy()
    const page1Data = await page1Response.json()

    if (page1Data.meta.totalPages > 1) {
      // Get second page
      const page2Response = await request.get('/api/components?reorderStatus=critical&page=2&pageSize=5')
      expect(page2Response.ok()).toBeTruthy()
      const page2Data = await page2Response.json()

      // Verify no duplicate IDs between pages
      const page1Ids = new Set(page1Data.data.map((c: { id: string }) => c.id))
      for (const component of page2Data.data) {
        expect(page1Ids.has(component.id)).toBeFalsy()
      }

      // All items on page 2 should also be critical
      for (const component of page2Data.data) {
        expect(component.reorderStatus).toBe('critical')
      }
    }
  })

  test('Combined filters work with reorderStatus', async ({ request }) => {
    // Test reorderStatus combined with search
    const response = await request.get('/api/components?reorderStatus=ok&search=test&pageSize=50')
    expect(response.ok()).toBeTruthy()
    const data = await response.json()

    // All returned items should match both filters
    for (const component of data.data) {
      expect(component.reorderStatus).toBe('ok')
      // Name or SKU should contain 'test' (case insensitive)
      const matchesSearch =
        component.name.toLowerCase().includes('test') ||
        component.skuCode.toLowerCase().includes('test')
      expect(matchesSearch).toBeTruthy()
    }
  })
})
```

**Validation Commands**:
```bash
npm run test:e2e -- --grep "Component Reorder Status Pagination"
```

**Completion Criteria**:
- [ ] Test file created successfully
- [ ] Tests verify total count accuracy
- [ ] Tests verify pagination metadata
- [ ] Tests verify no duplicates across pages
- [ ] Tests verify combined filters work

---

## Phase 4: Verification and Testing

### Subtask 4.1: Run Full Test Suite

**Instructions**:
1. Run TypeScript type check
2. Run build
3. Run linter
4. Run unit tests
5. Run E2E tests

**Validation Commands**:
```bash
# TypeScript check
npx tsc --noEmit

# Build check
npm run build

# Lint check
npm run lint

# Unit tests
npm test

# E2E tests (optional, requires running server)
npm run test:e2e
```

**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build completes without errors
- [ ] No new lint warnings
- [ ] All existing tests pass
- [ ] New E2E tests pass

### Subtask 4.2: Manual Verification

**Instructions**:
1. Start the development server
2. Navigate to `/components`
3. Use the reorder status filter dropdown
4. Verify that:
   - Total count in pagination reflects filtered results
   - Results span multiple pages correctly when expected
   - Pagination controls work as expected
   - Dashboard still works (uses separate route)

**Manual Test Cases**:
1. Filter by "Critical" - verify total shows only critical count
2. Filter by "Warning" - verify total shows only warning count
3. Filter by "OK" - verify total shows only ok count
4. Navigate to page 2 while filtered - verify results are correct
5. Clear filter - verify original count is restored
6. Visit Dashboard - verify critical components list still works

**Completion Criteria**:
- [ ] All manual test cases pass
- [ ] No console errors
- [ ] Performance is acceptable (< 2s for 100+ components)

---

## Summary of Deliverables

**Files Modified**: 2
1. `/home/pbrown/SkuInventory/src/app/(dashboard)/components/page.tsx`
   - Modified `getComponents` function (lines 26-100)

2. `/home/pbrown/SkuInventory/src/app/api/components/route.ts`
   - Modified GET handler (lines 20-111)

**Files Created**: 1
1. `/home/pbrown/SkuInventory/tests/e2e/component-reorder-pagination.spec.ts` (NEW)

**Files Verified (No Changes)**: 4
1. `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts` - Correct pattern
2. `/home/pbrown/SkuInventory/src/app/api/export/components/route.ts` - Not affected
3. `/home/pbrown/SkuInventory/src/components/features/ComponentTable.tsx` - Client component, no changes
4. `/home/pbrown/SkuInventory/src/services/inventory.ts` - Service functions unchanged

---

## Handoff to Build Agent

1. Execute subtasks in exact order: Phase 1 -> Phase 2 -> Phase 3 -> Phase 4
2. Complete each subtask fully before moving to the next
3. Run validation commands after each subtask
4. Test completion criteria before marking subtask complete
5. Both Phase 1 and Phase 2 use the same pattern - the logic should be nearly identical
6. Reference the dashboard route (`/src/app/api/dashboard/route.ts`) as the correct pattern

## Performance Notes

- The fix may increase query time when reorderStatus filter is set (fetching all vs paginated)
- For typical use cases (< 500 components), this is acceptable
- Monitor performance if customers report slowness with large datasets
- Future enhancement: Consider materialized view for computed fields if needed

## Acceptance Criteria (from Scout)

### Functional Requirements
- [x] When filtering by reorderStatus, all matching components across ALL pages are considered
- [x] Pagination metadata (total, totalPages) reflects the filtered count, not the current page count
- [x] Results are paginated correctly after filtering
- [x] Performance is acceptable for datasets up to 1000 components
- [x] Both the page component AND API route have identical, correct behavior

### Code Quality
- [ ] `npm run build` completes without errors
- [ ] `npx tsc --noEmit` completes without errors
- [ ] No new lint warnings
- [ ] Code is DRY - both files use same logic

---

## Performance Metrics

| Phase | Duration |
|-------|----------|
| Scout Review | 5m |
| Pattern Research | 10m |
| Code Analysis | 15m |
| Plan Writing | 20m |
| **Total** | **50m** |
