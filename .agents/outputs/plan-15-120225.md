# Implementation Plan
**Generated**: 2025-12-02T14:30:00Z
**Task ID**: Issue #15 - Capture defect/quality notes per BOM version and build
**Estimated Build Time**: 6-8 hours
**Complexity**: Medium

## Executive Summary
This feature adds optional defect/quality tracking fields to BOM versions and build transactions. The implementation extends existing `notes` patterns with new fields: `defectNotes` and `qualityMetadata` (JSON) on BOMVersion, and `defectCount`, `defectNotes`, `affectedUnits` on Transaction. All new fields are nullable/optional to maintain backward compatibility.

## Ripple Effect Validation (Verified)
- `createBOMVersion()`: 2 references (definition + 1 caller in `/src/app/api/skus/[id]/bom-versions/route.ts`)
- `createBuildTransaction()`: 2 references (definition + 1 caller in `/src/app/api/transactions/build/route.ts`)
- `BOMVersionResponse`: 6 references (type definition, BOMVersionList, SKU page)
- `TransactionResponse`: 12 references (type definition, routes, pages, components)
- Scout's assessment confirmed: Changes are contained with no unexpected ripple effects.

## Schema Verification (Verified)
**BOMVersion model** (schema lines 196-214):
- Existing fields: `id`, `skuId`, `versionName`, `effectiveStartDate`, `effectiveEndDate`, `isActive`, `notes`, `createdAt`, `updatedAt`, `createdById`
- Adding: `defectNotes` (String?, @db.Text), `qualityMetadata` (Json, default "{}")

**Transaction model** (schema lines 128-154):
- Existing fields: `id`, `companyId`, `type`, `date`, `skuId`, `bomVersionId`, `salesChannel`, `unitsBuild`, `unitBomCost`, `totalBomCost`, `supplier`, `reason`, `notes`, `createdAt`, `createdById`
- Adding: `defectCount` (Int?), `defectNotes` (String?, @db.Text), `affectedUnits` (Int?)

---

## Phase 1: Database & Types Layer

### Subtask 1.1: Update Prisma Schema - BOMVersion Model
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing `notes` field on BOMVersion (line 204)
**Instructions**:
1. After line 204 (`notes String? @db.Text`), add:
```prisma
  defectNotes     String?  @db.Text
  qualityMetadata Json     @default("{}")
```
2. Save the file

**Completion Criteria**:
- [ ] Two new fields added to BOMVersion model
- [ ] `defectNotes` is nullable text
- [ ] `qualityMetadata` is JSON with empty object default

---

### Subtask 1.2: Update Prisma Schema - Transaction Model
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing nullable fields `supplier`, `reason` (lines 142-144)
**Instructions**:
1. After line 144 (`notes String? @db.Text`), add:
```prisma
  defectCount    Int?
  defectNotes    String?  @db.Text
  affectedUnits  Int?
```
2. Save the file

**Completion Criteria**:
- [ ] Three new fields added to Transaction model
- [ ] All fields are nullable (optional)

---

### Subtask 1.3: Run Prisma Migration
**File**: Migration will be auto-generated
**Instructions**:
1. Run:
```bash
cd /home/pbrown/SkuInventory && npx prisma migrate dev --name add_defect_quality_fields
```
2. Verify migration completed successfully
3. Run:
```bash
npx prisma generate
```

**Completion Criteria**:
- [ ] Migration file created in `prisma/migrations/`
- [ ] Migration applied successfully
- [ ] Prisma client regenerated

**Validation Commands**:
```bash
npx prisma db pull --print | grep -E "defectNotes|qualityMetadata|defectCount|affectedUnits"
```

---

### Subtask 1.4: Update BOM Types
**File**: `/home/pbrown/SkuInventory/src/types/bom.ts`
**Pattern**: Follow existing `notes` field in schemas and interfaces

**Instructions**:
1. Update `createBOMVersionSchema` (lines 13-19) to add new fields after `notes`:
```typescript
export const createBOMVersionSchema = z.object({
  versionName: z.string().min(1, 'Version name is required').max(50),
  effectiveStartDate: z.coerce.date(),
  isActive: z.boolean().default(false),
  notes: z.string().optional().nullable(),
  defectNotes: z.string().optional().nullable(),
  qualityMetadata: z.record(z.unknown()).optional().default({}),
  lines: z.array(bomLineSchema).min(1, 'At least one component is required'),
})
```

2. Update `BOMVersionResponse` interface (lines 57-69) to add after `notes`:
```typescript
export interface BOMVersionResponse {
  id: string
  skuId: string
  versionName: string
  effectiveStartDate: string
  effectiveEndDate: string | null
  isActive: boolean
  notes: string | null
  defectNotes: string | null
  qualityMetadata: Record<string, unknown>
  unitCost: string
  lines: BOMLineResponse[]
  createdAt: string
  createdBy?: { id: string; name: string }
}
```

**Completion Criteria**:
- [ ] `createBOMVersionSchema` includes `defectNotes` and `qualityMetadata`
- [ ] `BOMVersionResponse` interface includes new fields
- [ ] TypeScript compiles without errors

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

---

### Subtask 1.5: Update Transaction Types
**File**: `/home/pbrown/SkuInventory/src/types/transaction.ts`
**Pattern**: Follow existing optional fields like `notes`, `supplier`

**Instructions**:
1. Update `createBuildSchema` (lines 40-48) to add defect fields after `notes`:
```typescript
export const createBuildSchema = z.object({
  date: z.coerce.date(),
  skuId: z.string().uuid('Invalid SKU ID'),
  unitsToBuild: z.coerce.number().int().positive('Units must be positive'),
  salesChannel: z.string().optional(),
  notes: z.string().optional().nullable(),
  defectCount: z.coerce.number().int().nonnegative().optional().nullable(),
  defectNotes: z.string().optional().nullable(),
  affectedUnits: z.coerce.number().int().nonnegative().optional().nullable(),
  allowInsufficientInventory: z.boolean().default(false),
})
```

2. Update `TransactionResponse` interface (lines 84-100) to add after `notes`:
```typescript
export interface TransactionResponse {
  id: string
  type: 'receipt' | 'build' | 'adjustment' | 'initial'
  date: string
  sku?: { id: string; name: string } | null
  bomVersion?: { id: string; versionName: string } | null
  salesChannel: string | null
  unitsBuild: number | null
  unitBomCost: string | null
  totalBomCost: string | null
  supplier: string | null
  reason: string | null
  notes: string | null
  defectCount: number | null
  defectNotes: string | null
  affectedUnits: number | null
  createdAt: string
  createdBy: { id: string; name: string }
  lines: TransactionLineResponse[]
}
```

**Completion Criteria**:
- [ ] `createBuildSchema` includes defect fields
- [ ] `TransactionResponse` interface includes defect fields
- [ ] TypeScript compiles without errors

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

---

## Phase 2: Service Layer

### Subtask 2.1: Update BOM Service - createBOMVersion
**File**: `/home/pbrown/SkuInventory/src/services/bom.ts`
**Pattern**: Follow existing `notes` parameter handling (lines 167-180)

**Instructions**:
1. Update function signature (line 167-179) to add new parameters:
```typescript
export async function createBOMVersion(params: {
  skuId: string
  versionName: string
  effectiveStartDate: Date
  isActive: boolean
  notes?: string | null
  defectNotes?: string | null
  qualityMetadata?: Record<string, unknown>
  lines: Array<{
    componentId: string
    quantityPerUnit: number
    notes?: string | null
  }>
  createdById: string
}) {
```

2. Update destructuring (line 180):
```typescript
const { skuId, versionName, effectiveStartDate, isActive, notes, defectNotes, qualityMetadata, lines, createdById } = params
```

3. Update Prisma create data block (lines 198-206) to include new fields:
```typescript
const bomVersion = await tx.bOMVersion.create({
  data: {
    skuId,
    versionName,
    effectiveStartDate,
    isActive,
    notes,
    defectNotes,
    qualityMetadata: qualityMetadata ?? {},
    createdById,
    lines: {
      create: lines.map((line) => ({
        componentId: line.componentId,
        quantityPerUnit: new Prisma.Decimal(line.quantityPerUnit),
        notes: line.notes,
      })),
    },
  },
  // ... include stays the same
})
```

**Completion Criteria**:
- [ ] Function accepts `defectNotes` and `qualityMetadata` parameters
- [ ] Parameters are passed to Prisma create
- [ ] TypeScript compiles without errors

---

### Subtask 2.2: Update Inventory Service - createBuildTransaction
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Follow existing `notes` parameter handling (lines 415-440)

**Instructions**:
1. Update function signature (lines 415-424) to add new parameters:
```typescript
export async function createBuildTransaction(params: {
  companyId: string
  skuId: string
  bomVersionId: string
  unitsToBuild: number
  salesChannel?: string
  date: Date
  notes?: string | null
  defectCount?: number | null
  defectNotes?: string | null
  affectedUnits?: number | null
  createdById: string
  allowInsufficientInventory?: boolean
}): Promise<{
  transaction: BuildTransactionResult
  insufficientItems: InsufficientInventoryItem[]
  warning: boolean
}> {
```

2. Update destructuring (lines 430-440):
```typescript
const {
  companyId,
  skuId,
  bomVersionId,
  unitsToBuild,
  salesChannel,
  date,
  notes,
  defectCount,
  defectNotes,
  affectedUnits,
  createdById,
  allowInsufficientInventory = false,
} = params
```

3. Update Prisma transaction.create data block (lines 477-488) to include new fields:
```typescript
const transaction = await prisma.transaction.create({
  data: {
    companyId,
    type: 'build',
    date,
    skuId,
    bomVersionId,
    salesChannel,
    unitsBuild: unitsToBuild,
    unitBomCost: new Prisma.Decimal(unitBomCost),
    totalBomCost: new Prisma.Decimal(totalBomCost),
    notes,
    defectCount,
    defectNotes,
    affectedUnits,
    createdById,
    lines: {
      // ... lines stay the same
    },
  },
  // ... include stays the same
})
```

4. Update `BuildTransactionResult` interface (lines 390-409) to include new fields:
```typescript
export interface BuildTransactionResult {
  id: string
  type: 'build'
  date: Date
  sku: { id: string; name: string; internalCode: string } | null
  bomVersion: { id: string; versionName: string } | null
  salesChannel: string | null
  unitsBuild: number | null
  unitBomCost: { toString(): string } | null
  totalBomCost: { toString(): string } | null
  notes: string | null
  defectCount: number | null
  defectNotes: string | null
  affectedUnits: number | null
  createdAt: Date
  createdBy: { id: string; name: string }
  lines: Array<{
    id: string
    component: { id: string; name: string; skuCode: string }
    quantityChange: { toString(): string }
    costPerUnit: { toString(): string } | null
  }>
}
```

**Completion Criteria**:
- [ ] Function accepts `defectCount`, `defectNotes`, `affectedUnits` parameters
- [ ] Parameters are passed to Prisma create
- [ ] `BuildTransactionResult` includes new fields
- [ ] TypeScript compiles without errors

---

## Phase 3: API Routes

### Subtask 3.1: Update BOM Version POST Route
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/bom-versions/route.ts`
**Pattern**: Follow existing `notes` handling (line 175)

**Instructions**:
1. Update the `createBOMVersion` call (lines 170-178) to pass new fields:
```typescript
const bomVersion = await createBOMVersion({
  skuId,
  versionName: data.versionName,
  effectiveStartDate: data.effectiveStartDate,
  isActive: data.isActive,
  notes: data.notes,
  defectNotes: data.defectNotes,
  qualityMetadata: data.qualityMetadata,
  lines: data.lines,
  createdById: session.user.id,
})
```

2. Update the response transformation (lines 186-211) to include new fields:
```typescript
return created({
  id: bomVersion.id,
  skuId: bomVersion.skuId,
  versionName: bomVersion.versionName,
  effectiveStartDate: bomVersion.effectiveStartDate.toISOString().split('T')[0],
  effectiveEndDate: bomVersion.effectiveEndDate?.toISOString().split('T')[0] ?? null,
  isActive: bomVersion.isActive,
  notes: bomVersion.notes,
  defectNotes: bomVersion.defectNotes,
  qualityMetadata: bomVersion.qualityMetadata as Record<string, unknown>,
  unitCost: unitCost.toFixed(4),
  lines: bomVersion.lines.map((line) => ({
    // ... existing line mapping
  })),
  createdAt: bomVersion.createdAt.toISOString(),
  createdBy: bomVersion.createdBy,
})
```

3. Update the GET response transformation (lines 84-115) similarly to include new fields in the map function.

**Completion Criteria**:
- [ ] POST accepts and saves `defectNotes` and `qualityMetadata`
- [ ] GET returns `defectNotes` and `qualityMetadata` in response
- [ ] API returns correct structure

**Validation Commands**:
```bash
cd /home/pbrown/SkuInventory && npm run build
```

---

### Subtask 3.2: Update BOM Version Detail Route (GET)
**File**: `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/route.ts`
**Pattern**: Follow existing response transformation (lines 72-98)

**Instructions**:
1. Update the response object (lines 72-98) to include new fields after `notes`:
```typescript
return success({
  id: bomVersion.id,
  skuId: bomVersion.skuId,
  sku: bomVersion.sku,
  versionName: bomVersion.versionName,
  effectiveStartDate: bomVersion.effectiveStartDate.toISOString().split('T')[0],
  effectiveEndDate: bomVersion.effectiveEndDate?.toISOString().split('T')[0] ?? null,
  isActive: bomVersion.isActive,
  notes: bomVersion.notes,
  defectNotes: bomVersion.defectNotes,
  qualityMetadata: bomVersion.qualityMetadata as Record<string, unknown>,
  unitCost: unitCost.toFixed(4),
  // ... rest stays the same
})
```

**Completion Criteria**:
- [ ] GET returns `defectNotes` and `qualityMetadata`
- [ ] TypeScript compiles without errors

---

### Subtask 3.3: Update Build Transaction POST Route
**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
**Pattern**: Follow existing `notes` handling (line 69)

**Instructions**:
1. Update the `createBuildTransaction` call (lines 62-72) to pass new fields:
```typescript
const result = await createBuildTransaction({
  companyId: session.user.companyId,
  skuId: data.skuId,
  bomVersionId: activeBomVersionId,
  unitsToBuild: data.unitsToBuild,
  salesChannel: data.salesChannel,
  date: data.date,
  notes: data.notes,
  defectCount: data.defectCount,
  defectNotes: data.defectNotes,
  affectedUnits: data.affectedUnits,
  createdById: session.user.id,
  allowInsufficientInventory: allowInsufficient,
})
```

2. Update the response object (lines 74-96) to include new fields:
```typescript
return created({
  data: {
    id: result.transaction.id,
    type: result.transaction.type,
    date: result.transaction.date.toISOString().split('T')[0],
    sku: result.transaction.sku,
    bomVersion: result.transaction.bomVersion,
    salesChannel: result.transaction.salesChannel,
    unitsBuild: result.transaction.unitsBuild,
    unitBomCost: result.transaction.unitBomCost?.toString() ?? null,
    totalBomCost: result.transaction.totalBomCost?.toString() ?? null,
    notes: result.transaction.notes,
    defectCount: result.transaction.defectCount,
    defectNotes: result.transaction.defectNotes,
    affectedUnits: result.transaction.affectedUnits,
    createdAt: result.transaction.createdAt.toISOString(),
    createdBy: result.transaction.createdBy,
    lines: result.transaction.lines.map((line) => ({
      // ... existing line mapping
    })),
    warning: result.warning,
    insufficientItems: result.insufficientItems,
  },
})
```

**Completion Criteria**:
- [ ] POST accepts and saves defect fields
- [ ] Response includes defect fields
- [ ] API returns correct structure

---

### Subtask 3.4: Update Transaction List Route (GET)
**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/route.ts`
**Pattern**: Follow existing response transformation (lines 66-87)

**Instructions**:
1. Update the response mapping (lines 66-87) to include defect fields:
```typescript
const data: TransactionResponse[] = transactions.map((tx) => ({
  id: tx.id,
  type: tx.type as TransactionResponse['type'],
  date: tx.date.toISOString().split('T')[0],
  sku: tx.sku,
  bomVersion: tx.bomVersion,
  salesChannel: tx.salesChannel,
  unitsBuild: tx.unitsBuild,
  unitBomCost: tx.unitBomCost?.toString() ?? null,
  totalBomCost: tx.totalBomCost?.toString() ?? null,
  supplier: tx.supplier,
  reason: tx.reason,
  notes: tx.notes,
  defectCount: tx.defectCount,
  defectNotes: tx.defectNotes,
  affectedUnits: tx.affectedUnits,
  createdAt: tx.createdAt.toISOString(),
  createdBy: tx.createdBy,
  lines: tx.lines.map((line) => ({
    // ... existing line mapping
  })),
}))
```

**Completion Criteria**:
- [ ] GET returns defect fields in list response
- [ ] TypeScript compiles without errors

---

### Subtask 3.5: Update Transaction Detail Route (GET)
**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/[id]/route.ts`
**Pattern**: Follow existing response transformation (lines 63-106)

**Instructions**:
1. Update the response object (lines 63-106) to include defect fields after `notes`:
```typescript
return NextResponse.json({
  data: {
    id: transaction.id,
    type: transaction.type,
    date: transaction.date.toISOString().split('T')[0],
    company: transaction.company,
    sku: transaction.sku,
    bomVersion: transaction.bomVersion,
    salesChannel: transaction.salesChannel,
    unitsBuild: transaction.unitsBuild,
    unitBomCost: transaction.unitBomCost?.toString() ?? null,
    totalBomCost: transaction.totalBomCost?.toString() ?? null,
    supplier: transaction.supplier,
    reason: transaction.reason,
    notes: transaction.notes,
    defectCount: transaction.defectCount,
    defectNotes: transaction.defectNotes,
    affectedUnits: transaction.affectedUnits,
    createdAt: transaction.createdAt.toISOString(),
    createdBy: transaction.createdBy,
    lines: transaction.lines.map((line) => ({
      // ... existing line mapping
    })),
    summary: transaction.type === 'build' ? {
      // ... existing summary
    } : null,
  },
})
```

**Completion Criteria**:
- [ ] GET returns defect fields in detail response
- [ ] TypeScript compiles without errors

---

## Phase 4: Frontend Components

### Subtask 4.1: Update BOMVersionForm - Add Defect/Quality Fields
**File**: `/home/pbrown/SkuInventory/src/components/features/BOMVersionForm.tsx`
**Pattern**: Follow existing `notes` textarea (lines 221-229)

**Instructions**:
1. Update formData state (lines 50-55) to include new fields:
```typescript
const [formData, setFormData] = useState({
  versionName: '',
  effectiveStartDate: new Date().toISOString().split('T')[0],
  isActive: false,
  notes: '',
  defectNotes: '',
  qualityMetadata: '{}',
})
```

2. Add new form fields after the Notes textarea (after line 229):
```tsx
<div className="space-y-2">
  <Label htmlFor="defectNotes">Defect Notes</Label>
  <textarea
    id="defectNotes"
    className="flex min-h-[60px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
    value={formData.defectNotes}
    onChange={(e) => setFormData((prev) => ({ ...prev, defectNotes: e.target.value }))}
    placeholder="Document any known defects or quality issues with this BOM version..."
  />
</div>
```

3. Update handleSubmit (lines 130-145) to include new fields in the request body:
```typescript
body: JSON.stringify({
  versionName: formData.versionName,
  effectiveStartDate: formData.effectiveStartDate,
  isActive: formData.isActive,
  notes: formData.notes || null,
  defectNotes: formData.defectNotes || null,
  qualityMetadata: formData.qualityMetadata ? JSON.parse(formData.qualityMetadata) : {},
  lines: lines.map((line) => ({
    componentId: line.componentId,
    quantityPerUnit: parseFloat(line.quantityPerUnit),
    notes: line.notes || null,
  })),
}),
```

**Completion Criteria**:
- [ ] Form includes defect notes field
- [ ] Data is sent to API on submit
- [ ] Form clears correctly on success

---

### Subtask 4.2: Update BOMVersionList - Display Defect/Quality Info
**File**: `/home/pbrown/SkuInventory/src/components/features/BOMVersionList.tsx`
**Pattern**: Follow existing `notes` display (lines 183-185)

**Instructions**:
1. Update the expanded view section (lines 181-229) to display defect info after notes:
```tsx
{expandedVersion === version.id && (
  <div className="border-t p-4">
    {version.notes && (
      <p className="text-sm text-muted-foreground mb-4">{version.notes}</p>
    )}
    {version.defectNotes && (
      <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-md">
        <p className="text-sm font-medium text-yellow-800">Defect Notes</p>
        <p className="text-sm text-yellow-700">{version.defectNotes}</p>
      </div>
    )}
    <Table>
      {/* ... existing table */}
    </Table>
  </div>
)}
```

**Completion Criteria**:
- [ ] Defect notes displayed in expanded BOM version view
- [ ] Styled distinctly (yellow warning style) when present
- [ ] Does not show when defectNotes is null/empty

---

### Subtask 4.3: Update BuildDialog - Add Defect Fields
**File**: `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx`
**Pattern**: Follow existing `notes` input (lines 313-323)

**Instructions**:
1. Update formData state (lines 49-55) to include defect fields:
```typescript
const [formData, setFormData] = useState({
  date: new Date().toISOString().split('T')[0],
  skuId: preselectedSkuId || '',
  unitsToBuild: '',
  salesChannel: '',
  notes: '',
  defectCount: '',
  defectNotes: '',
  affectedUnits: '',
})
```

2. Add new form fields after the Notes input (after line 323). Add a collapsible section for defect info:
```tsx
{/* Defect Tracking (collapsible) */}
<details className="col-span-4">
  <summary className="cursor-pointer text-sm font-medium text-muted-foreground hover:text-foreground">
    Defect Tracking (optional)
  </summary>
  <div className="mt-4 space-y-4 pl-4 border-l-2 border-muted">
    <div className="grid grid-cols-4 items-center gap-4">
      <Label htmlFor="defectCount" className="text-right">
        Defects
      </Label>
      <Input
        id="defectCount"
        type="number"
        min="0"
        step="1"
        className="col-span-3"
        placeholder="Number of defective units"
        value={formData.defectCount}
        onChange={(e) =>
          setFormData((prev) => ({ ...prev, defectCount: e.target.value }))
        }
      />
    </div>

    <div className="grid grid-cols-4 items-center gap-4">
      <Label htmlFor="affectedUnits" className="text-right">
        Affected
      </Label>
      <Input
        id="affectedUnits"
        type="number"
        min="0"
        step="1"
        className="col-span-3"
        placeholder="Number of affected units"
        value={formData.affectedUnits}
        onChange={(e) =>
          setFormData((prev) => ({ ...prev, affectedUnits: e.target.value }))
        }
      />
    </div>

    <div className="grid grid-cols-4 items-center gap-4">
      <Label htmlFor="defectNotes" className="text-right">
        Notes
      </Label>
      <Input
        id="defectNotes"
        className="col-span-3"
        placeholder="Description of defects..."
        value={formData.defectNotes}
        onChange={(e) =>
          setFormData((prev) => ({ ...prev, defectNotes: e.target.value }))
        }
      />
    </div>
  </div>
</details>
```

3. Update handleSubmit request body (lines 113-120) to include defect fields:
```typescript
body: JSON.stringify({
  skuId: formData.skuId,
  date: formData.date,
  unitsToBuild: parseInt(formData.unitsToBuild),
  salesChannel: formData.salesChannel || undefined,
  notes: formData.notes || null,
  defectCount: formData.defectCount ? parseInt(formData.defectCount) : null,
  defectNotes: formData.defectNotes || null,
  affectedUnits: formData.affectedUnits ? parseInt(formData.affectedUnits) : null,
  allowInsufficientInventory: forceSubmit,
}),
```

4. Update form reset (lines 144-150) to include defect fields:
```typescript
setFormData({
  date: new Date().toISOString().split('T')[0],
  skuId: '',
  unitsToBuild: '',
  salesChannel: '',
  notes: '',
  defectCount: '',
  defectNotes: '',
  affectedUnits: '',
})
```

**Completion Criteria**:
- [ ] Build dialog includes defect tracking fields
- [ ] Fields are in collapsible section (not cluttering main UI)
- [ ] Data is sent to API on submit
- [ ] Form resets correctly

---

### Subtask 4.4: Update TransactionDetail - Display Defect Info
**File**: `/home/pbrown/SkuInventory/src/components/features/TransactionDetail.tsx`
**Pattern**: Follow existing notes display (lines 177-182)

**Instructions**:
1. Update the TransactionDetailProps interface (lines 29-53) to include defect fields:
```typescript
interface TransactionDetailProps {
  transaction: {
    // ... existing fields
    notes: string | null
    defectCount: number | null
    defectNotes: string | null
    affectedUnits: number | null
    // ... rest of fields
  }
}
```

2. Add defect info display after notes section (after line 182). Add within the build-specific section:
```tsx
{/* Defect Info (for build transactions with defect data) */}
{transaction.type === 'build' && (transaction.defectCount || transaction.defectNotes || transaction.affectedUnits) && (
  <div className="md:col-span-2 lg:col-span-3 p-3 bg-yellow-50 border border-yellow-200 rounded-md">
    <p className="text-sm font-medium text-yellow-800 mb-2">Defect Information</p>
    <div className="grid gap-2 md:grid-cols-3">
      {transaction.defectCount != null && (
        <div>
          <p className="text-xs text-yellow-700">Defect Count</p>
          <p className="font-medium text-yellow-900">{transaction.defectCount}</p>
        </div>
      )}
      {transaction.affectedUnits != null && (
        <div>
          <p className="text-xs text-yellow-700">Affected Units</p>
          <p className="font-medium text-yellow-900">{transaction.affectedUnits}</p>
        </div>
      )}
      {transaction.defectNotes && (
        <div className="md:col-span-3">
          <p className="text-xs text-yellow-700">Defect Notes</p>
          <p className="text-sm text-yellow-900">{transaction.defectNotes}</p>
        </div>
      )}
    </div>
  </div>
)}
```

**Completion Criteria**:
- [ ] Defect info displayed in transaction detail view
- [ ] Only shows for build transactions with defect data
- [ ] Styled distinctly (yellow warning style)

---

## Phase 5: Export Updates

### Subtask 5.1: Update Export Service Types and Columns
**File**: `/home/pbrown/SkuInventory/src/services/export.ts`
**Pattern**: Follow existing transaction export columns (lines 143-162)

**Instructions**:
1. Update `TransactionExportData` interface (lines 121-141) to add defect fields:
```typescript
export interface TransactionExportData {
  id: string
  type: string
  date: string
  skuName: string | null
  skuCode: string | null
  salesChannel: string | null
  unitsBuild: number | null
  unitBomCost: string | null
  totalBomCost: string | null
  supplier: string | null
  reason: string | null
  notes: string | null
  defectCount: number | null
  defectNotes: string | null
  affectedUnits: number | null
  createdAt: string
  createdByName: string
  // Flattened component lines
  componentName: string
  componentSkuCode: string
  quantityChange: string
  costPerUnit: string | null
}
```

2. Update `transactionExportColumns` (lines 143-162) to add defect columns after Notes:
```typescript
export const transactionExportColumns: CSVColumn<TransactionExportData>[] = [
  { header: 'Transaction ID', accessor: (t) => t.id },
  { header: 'Type', accessor: (t) => t.type },
  { header: 'Date', accessor: (t) => t.date },
  { header: 'Component Name', accessor: (t) => t.componentName },
  { header: 'Component SKU', accessor: (t) => t.componentSkuCode },
  { header: 'Quantity Change', accessor: (t) => t.quantityChange },
  { header: 'Cost Per Unit', accessor: (t) => t.costPerUnit },
  { header: 'SKU Name', accessor: (t) => t.skuName },
  { header: 'SKU Code', accessor: (t) => t.skuCode },
  { header: 'Sales Channel', accessor: (t) => t.salesChannel },
  { header: 'Units Built', accessor: (t) => t.unitsBuild },
  { header: 'Unit BOM Cost', accessor: (t) => t.unitBomCost },
  { header: 'Total BOM Cost', accessor: (t) => t.totalBomCost },
  { header: 'Supplier', accessor: (t) => t.supplier },
  { header: 'Reason', accessor: (t) => t.reason },
  { header: 'Notes', accessor: (t) => t.notes },
  { header: 'Defect Count', accessor: (t) => t.defectCount },
  { header: 'Defect Notes', accessor: (t) => t.defectNotes },
  { header: 'Affected Units', accessor: (t) => t.affectedUnits },
  { header: 'Created At', accessor: (t) => t.createdAt },
  { header: 'Created By', accessor: (t) => t.createdByName },
]
```

**Completion Criteria**:
- [ ] `TransactionExportData` includes defect fields
- [ ] Export columns include defect columns
- [ ] TypeScript compiles without errors

---

### Subtask 5.2: Update Transaction Export Route
**File**: `/home/pbrown/SkuInventory/src/app/api/export/transactions/route.ts`
**Pattern**: Follow existing data mapping (lines 95-141)

**Instructions**:
1. Update the export data mapping (lines 99-141) to include defect fields:
```typescript
for (const tx of transactions) {
  if (tx.lines.length > 0) {
    for (const line of tx.lines) {
      exportData.push({
        id: tx.id,
        type: tx.type,
        date: tx.date.toISOString().split('T')[0],
        skuName: tx.sku?.name ?? null,
        skuCode: tx.sku?.internalCode ?? null,
        salesChannel: tx.salesChannel,
        unitsBuild: tx.unitsBuild,
        unitBomCost: tx.unitBomCost?.toString() ?? null,
        totalBomCost: tx.totalBomCost?.toString() ?? null,
        supplier: tx.supplier,
        reason: tx.reason,
        notes: tx.notes,
        defectCount: tx.defectCount,
        defectNotes: tx.defectNotes,
        affectedUnits: tx.affectedUnits,
        createdAt: tx.createdAt.toISOString(),
        createdByName: tx.createdBy.name,
        componentName: line.component.name,
        componentSkuCode: line.component.skuCode,
        quantityChange: line.quantityChange.toString(),
        costPerUnit: line.costPerUnit?.toString() ?? null,
      })
    }
  } else {
    exportData.push({
      // ... same structure with defect fields
      defectCount: tx.defectCount,
      defectNotes: tx.defectNotes,
      affectedUnits: tx.affectedUnits,
      // ... rest of fields
    })
  }
}
```

**Completion Criteria**:
- [ ] Export includes defect fields in CSV output
- [ ] TypeScript compiles without errors

---

## Phase 6: Final Validation

### Subtask 6.1: Run Full Test Suite
**Instructions**:
1. Run TypeScript check:
```bash
cd /home/pbrown/SkuInventory && npx tsc --noEmit
```

2. Run build:
```bash
cd /home/pbrown/SkuInventory && npm run build
```

3. Run lint:
```bash
cd /home/pbrown/SkuInventory && npm run lint
```

**Completion Criteria**:
- [ ] `npx tsc --noEmit` passes with no errors
- [ ] `npm run build` completes successfully
- [ ] `npm run lint` passes with no errors/warnings

---

## Summary of Deliverables

**Files Modified**: 15 files
| Layer | Files |
|-------|-------|
| Database | `prisma/schema.prisma` |
| Types | `src/types/bom.ts`, `src/types/transaction.ts` |
| Services | `src/services/bom.ts`, `src/services/inventory.ts`, `src/services/export.ts` |
| API Routes | `src/app/api/skus/[id]/bom-versions/route.ts`, `src/app/api/bom-versions/[id]/route.ts`, `src/app/api/transactions/build/route.ts`, `src/app/api/transactions/route.ts`, `src/app/api/transactions/[id]/route.ts`, `src/app/api/export/transactions/route.ts` |
| Frontend | `src/components/features/BOMVersionForm.tsx`, `src/components/features/BOMVersionList.tsx`, `src/components/features/BuildDialog.tsx`, `src/components/features/TransactionDetail.tsx` |

**Files Created**: 1 file
- Migration file (auto-generated by Prisma)

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5 -> Phase 6)
2. Complete each subtask fully before moving to next
3. Run validation commands after each phase
4. Test completion criteria before marking subtask complete
5. Follow reference patterns exactly as shown
6. All new fields are OPTIONAL - do not make them required
7. Use consistent naming: `defectNotes`, `qualityMetadata`, `defectCount`, `affectedUnits`

---

## Acceptance Criteria from Issue #15

- [ ] Users can save defect/quality notes on BOM versions and see them in SKU/BOM views
- [ ] Build transactions can include defect notes/counts; data shows in transaction detail and exports
- [ ] API enforces authZ (viewer cannot modify); validations allow optional fields
- [ ] Tests cover saving and retrieving defect metadata on BOM versions and builds

---

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Scout Review | 5m |
| Pattern Research | 15m |
| Schema Verification | 10m |
| Ripple Effect Validation | 5m |
| Plan Writing | 30m |
| **Total** | **65m** |

---

AGENT_RETURN: plan-15-120225
