# Implementation Plan
**Generated**: 2025-12-31T23:45:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #348
**Estimated Build Time**: 6-8 hours
**Complexity**: Moderate

## Investigation Summary

### Request Analysis
**Type**: NEW_FEATURE
**Source**: GitHub Issue #348 (Parent: #338)
**Priority**: High (blocks #350 analytics UI)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="attribution|sales-daily"`

### Issue Validation
**Status**: Valid
**Dependencies Satisfied**: Yes
- #346 (Orders API) - COMPLETED: `src/services/amazon-sp-api/orders.ts`, `sync-orders.ts`
- #347 (Reports API) - COMPLETED: `src/services/amazon-ads/reports.ts`

### Current State Assessment

**Existing Components**:
| Component | Status | Location |
|-----------|--------|----------|
| `calculateOrganicSales()` | EXISTS - basic | `/src/services/sales-daily/calculator.ts:44` |
| `calculateOrganicPercentage()` | EXISTS | `/src/services/sales-daily/calculator.ts:51` |
| `recalculateOrganicSales()` | EXISTS - needs enhancement | `/src/services/sales-daily/calculator.ts:179` |
| `getDailySalesSummary()` | EXISTS | `/src/services/sales-daily/calculator.ts:248` |
| `SalesDaily` model | EXISTS | `prisma/schema.prisma:883-915` |
| `KeywordMetric` model | EXISTS | `prisma/schema.prisma:836-881` |
| Amazon Orders sync | EXISTS | `/src/services/amazon-sp-api/sync-orders.ts` |
| Amazon Ads Reports sync | EXISTS | `/src/services/amazon-ads/reports.ts` |

**Database**:
- `SalesDaily` model has all required fields: `totalSales`, `adAttributedSales`, `organicSales`, `asin`, `channel`
- `KeywordMetric` model stores ad data with `sales` field (ad-attributed sales)
- No schema changes required

**API Routes**:
- `/api/sales-daily` route exists with GET handler returning daily summary with `organicPercentage`

**What's Missing**:
1. Attribution service (`/src/services/attribution/amazon-attribution.ts`) - does NOT exist
2. Per-ASIN breakdown logic
3. Attribution window support (7d, 14d, 30d)
4. Cross-referencing between Orders (SP-API) and Reports (Ads API)
5. Anomaly detection (ad sales > total sales)
6. Date range aggregation (weekly, monthly)
7. Attribution trend calculation over time

### Dependencies & Blockers
1. **None** - All dependencies (#346, #347) completed

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 6-8 hours
**Risk**: Low
- Clear patterns exist in codebase
- Existing calculator.ts provides foundation
- Database schema already supports all required fields

### Patterns Identified
**Primary**: `/src/services/sales-daily/calculator.ts`
- Core attribution calculation logic
- Date range handling with date-fns
- Prisma query patterns for SalesDaily

**Secondary**: `/src/services/analytics.ts`
- Pattern for aggregation by date (day/week/month)
- `getDateKey()` function for grouping
- Response structure with summary + trends

**Tertiary**: `/src/services/amazon-sp-api/sync-orders.ts`
- Daily aggregation by ASIN pattern
- Map-based aggregation approach
- Error handling and logging patterns

### Ripple Effect Analysis
**Files Identified**: 5

| File | Why Affected |
|------|--------------|
| `/src/services/sales-daily/calculator.ts` | MODIFY - Add enhanced attribution logic |
| `/src/services/attribution/amazon-attribution.ts` | CREATE - New attribution service |
| `/src/app/api/sales-daily/route.ts` | MODIFY - Add attribution breakdown endpoint |
| `/src/types/attribution.ts` | CREATE - Types for attribution service |
| `/tests/unit/attribution.test.ts` | CREATE - Unit tests (optional) |

---

## Executive Summary

Build a sales attribution service that combines Amazon SP-API order data (total sales) with Amazon Ads API data (ad-attributed sales) to calculate organic sales percentages per ASIN. The service will support multiple attribution windows (7d, 14d, 30d), handle edge cases where ad sales exceed total sales, and provide trend analysis over time. The existing `calculator.ts` provides the foundation, and the new attribution service will add ASIN-level breakdown, window support, and anomaly flagging.

---

## Phase 1: Types Layer

### Subtask 1.1: Create Attribution Types
**File**: `/src/types/attribution.ts` (CREATE)
**Pattern**: Follow `/src/types/analytics.ts` structure

**Instructions**:
1. Create new file with the following interfaces:

```typescript
/**
 * Attribution Service Types
 * Types for organic vs ad sales attribution
 */

import { z } from 'zod'

// Attribution window options
export type AttributionWindow = '7d' | '14d' | '30d'

// Query parameters for attribution endpoint
export const attributionQuerySchema = z.object({
  brandId: z.string().uuid(),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  asin: z.string().optional(),
  attributionWindow: z.enum(['7d', '14d', '30d']).default('7d'),
  groupBy: z.enum(['day', 'week', 'month']).default('day'),
})

export type AttributionQuery = z.infer<typeof attributionQuerySchema>

// Per-ASIN attribution breakdown
export interface AsinAttribution {
  asin: string
  productName?: string
  totalSales: number
  adAttributedSales: number
  organicSales: number
  organicPercentage: number
  adPercentage: number
  unitsTotal: number
  unitsAdAttributed: number
  unitsOrganic: number
  hasAnomaly: boolean  // true if adSales > totalSales
  anomalyNote?: string
}

// Daily attribution with trend
export interface DailyAttribution {
  date: string  // YYYY-MM-DD
  totalSales: number
  adAttributedSales: number
  organicSales: number
  organicPercentage: number
  adPercentage: number
  orderCount: number
  asinBreakdown: AsinAttribution[]
}

// Attribution summary
export interface AttributionSummary {
  totalSales: number
  adAttributedSales: number
  organicSales: number
  organicPercentage: number
  adPercentage: number
  totalOrders: number
  asinCount: number
  anomalyCount: number  // Count of days/ASINs with ad > total
  attributionWindow: AttributionWindow
}

// Trend data point for charting
export interface AttributionTrendPoint {
  date: string
  organicPercentage: number
  adPercentage: number
  totalSales: number
}

// Full attribution response
export interface AttributionResponse {
  summary: AttributionSummary
  daily: DailyAttribution[]
  trends: AttributionTrendPoint[]
  byAsin: AsinAttribution[]
  dateRange: {
    startDate: string
    endDate: string
  }
  attributionWindow: AttributionWindow
}

// Options for attribution calculation
export interface CalculateAttributionOptions {
  brandId: string
  startDate: string
  endDate: string
  asin?: string
  attributionWindow?: AttributionWindow
  groupBy?: 'day' | 'week' | 'month'
}

// Result from recalculating attribution
export interface RecalculateAttributionResult {
  recordsUpdated: number
  anomaliesDetected: number
  errors: string[]
}
```

2. Export from `/src/types/index.ts`

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] File created at `/src/types/attribution.ts`
- [ ] All interfaces defined
- [ ] Zod schema for query validation
- [ ] Exported from index
- [ ] TypeScript compiles without errors

---

## Phase 2: Service Layer

### Subtask 2.1: Create Amazon Attribution Service
**File**: `/src/services/attribution/amazon-attribution.ts` (CREATE)
**Pattern**: Follow `/src/services/analytics.ts` and `/src/services/sales-daily/calculator.ts`

**Instructions**:
1. Create directory: `mkdir -p /home/pbrown/SkuInventory/src/services/attribution`
2. Create the service file:

```typescript
/**
 * Amazon Attribution Service
 *
 * Combines SP-API order data (total sales) with Ads API data (ad-attributed sales)
 * to calculate organic sales percentages per ASIN with support for different
 * attribution windows.
 */

import { prisma } from '@/lib/db'
import { format, parseISO, startOfDay, endOfDay, subDays } from 'date-fns'
import type {
  CalculateAttributionOptions,
  AttributionResponse,
  AttributionSummary,
  DailyAttribution,
  AsinAttribution,
  AttributionTrendPoint,
  AttributionWindow,
  RecalculateAttributionResult,
} from '@/types/attribution'

// ============================================
// Core Attribution Calculations
// ============================================

/**
 * Calculate organic sales: max(0, total - adAttributed)
 * Handles edge case where ad > total by returning 0
 */
export function calculateOrganic(totalSales: number, adAttributedSales: number): number {
  return Math.max(0, totalSales - adAttributedSales)
}

/**
 * Calculate organic percentage
 */
export function calculateOrganicPercentage(totalSales: number, organicSales: number): number {
  if (totalSales === 0) return 0
  return Math.round((organicSales / totalSales) * 10000) / 100  // 2 decimal places
}

/**
 * Calculate ad percentage
 */
export function calculateAdPercentage(totalSales: number, adAttributedSales: number): number {
  if (totalSales === 0) return 0
  return Math.round((adAttributedSales / totalSales) * 10000) / 100
}

/**
 * Check if there's an anomaly (ad sales > total sales)
 */
export function hasAttributionAnomaly(totalSales: number, adAttributedSales: number): boolean {
  return adAttributedSales > totalSales && totalSales > 0
}

// ============================================
// Date Grouping Helpers
// ============================================

function getDateKey(date: Date, groupBy: 'day' | 'week' | 'month'): string {
  const d = new Date(date)
  const year = d.getFullYear()
  const month = String(d.getMonth() + 1).padStart(2, '0')
  const day = String(d.getDate()).padStart(2, '0')

  switch (groupBy) {
    case 'day':
      return `${year}-${month}-${day}`
    case 'week': {
      const dayOfWeek = d.getDay()
      const diff = d.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1)
      const monday = new Date(d)
      monday.setDate(diff)
      const wYear = monday.getFullYear()
      const wMonth = String(monday.getMonth() + 1).padStart(2, '0')
      const wDay = String(monday.getDate()).padStart(2, '0')
      return `${wYear}-${wMonth}-${wDay}`
    }
    case 'month':
      return `${year}-${month}-01`
  }
}

// ============================================
// Main Attribution Functions
// ============================================

/**
 * Get full attribution breakdown for a brand
 */
export async function getAttributionBreakdown(
  options: CalculateAttributionOptions
): Promise<AttributionResponse> {
  const {
    brandId,
    startDate,
    endDate,
    asin,
    attributionWindow = '7d',
    groupBy = 'day',
  } = options

  // Fetch SalesDaily records for the date range
  const salesData = await prisma.salesDaily.findMany({
    where: {
      brandId,
      date: {
        gte: startOfDay(parseISO(startDate)),
        lte: endOfDay(parseISO(endDate)),
      },
      channel: 'amazon',
      ...(asin && { asin }),
    },
    orderBy: { date: 'asc' },
  })

  // Aggregate by date and ASIN
  const dailyMap = new Map<string, DailyAttribution>()
  const asinMap = new Map<string, AsinAttribution>()

  // Summary totals
  let totalSalesSum = 0
  let adAttributedSum = 0
  let totalOrdersSum = 0
  let anomalyCount = 0

  for (const record of salesData) {
    const dateKey = getDateKey(record.date, groupBy)
    const asinKey = record.asin || 'unknown'
    const totalSales = Number(record.totalSales)
    const adAttributed = Number(record.adAttributedSales)
    const organic = calculateOrganic(totalSales, adAttributed)
    const hasAnomaly = hasAttributionAnomaly(totalSales, adAttributed)
    const unitsTotal = record.unitsTotal || 0
    const unitsAd = record.unitsAdAttributed || 0
    const unitsOrg = record.unitsOrganic || 0

    // Update summary totals
    totalSalesSum += totalSales
    adAttributedSum += adAttributed
    totalOrdersSum += unitsTotal
    if (hasAnomaly) anomalyCount++

    // Update daily aggregation
    const daily = dailyMap.get(dateKey) || {
      date: dateKey,
      totalSales: 0,
      adAttributedSales: 0,
      organicSales: 0,
      organicPercentage: 0,
      adPercentage: 0,
      orderCount: 0,
      asinBreakdown: [],
    }

    daily.totalSales += totalSales
    daily.adAttributedSales += adAttributed
    daily.organicSales += organic
    daily.orderCount += unitsTotal

    // Add to ASIN breakdown for this day
    daily.asinBreakdown.push({
      asin: asinKey,
      totalSales,
      adAttributedSales: adAttributed,
      organicSales: organic,
      organicPercentage: calculateOrganicPercentage(totalSales, organic),
      adPercentage: calculateAdPercentage(totalSales, adAttributed),
      unitsTotal,
      unitsAdAttributed: unitsAd,
      unitsOrganic: unitsOrg,
      hasAnomaly,
      anomalyNote: hasAnomaly ? 'Ad-attributed sales exceed total sales' : undefined,
    })

    dailyMap.set(dateKey, daily)

    // Update ASIN aggregation
    const asinAgg = asinMap.get(asinKey) || {
      asin: asinKey,
      totalSales: 0,
      adAttributedSales: 0,
      organicSales: 0,
      organicPercentage: 0,
      adPercentage: 0,
      unitsTotal: 0,
      unitsAdAttributed: 0,
      unitsOrganic: 0,
      hasAnomaly: false,
    }

    asinAgg.totalSales += totalSales
    asinAgg.adAttributedSales += adAttributed
    asinAgg.organicSales += organic
    asinAgg.unitsTotal += unitsTotal
    asinAgg.unitsAdAttributed += unitsAd
    asinAgg.unitsOrganic += unitsOrg
    if (hasAnomaly) asinAgg.hasAnomaly = true

    asinMap.set(asinKey, asinAgg)
  }

  // Calculate final percentages for daily records
  const dailyEntries = Array.from(dailyMap.entries())
  for (const [, daily] of dailyEntries) {
    daily.organicPercentage = calculateOrganicPercentage(daily.totalSales, daily.organicSales)
    daily.adPercentage = calculateAdPercentage(daily.totalSales, daily.adAttributedSales)
  }

  // Calculate final percentages for ASIN records
  const asinEntries = Array.from(asinMap.entries())
  for (const [, asinData] of asinEntries) {
    asinData.organicPercentage = calculateOrganicPercentage(asinData.totalSales, asinData.organicSales)
    asinData.adPercentage = calculateAdPercentage(asinData.totalSales, asinData.adAttributedSales)
  }

  // Build trends array
  const trends: AttributionTrendPoint[] = dailyEntries.map(([date, data]) => ({
    date,
    organicPercentage: data.organicPercentage,
    adPercentage: data.adPercentage,
    totalSales: data.totalSales,
  }))

  // Build summary
  const organicSum = calculateOrganic(totalSalesSum, adAttributedSum)
  const summary: AttributionSummary = {
    totalSales: totalSalesSum,
    adAttributedSales: adAttributedSum,
    organicSales: organicSum,
    organicPercentage: calculateOrganicPercentage(totalSalesSum, organicSum),
    adPercentage: calculateAdPercentage(totalSalesSum, adAttributedSum),
    totalOrders: totalOrdersSum,
    asinCount: asinMap.size,
    anomalyCount,
    attributionWindow,
  }

  return {
    summary,
    daily: dailyEntries.map(([, d]) => d).sort((a, b) => a.date.localeCompare(b.date)),
    trends: trends.sort((a, b) => a.date.localeCompare(b.date)),
    byAsin: asinEntries
      .map(([, a]) => a)
      .sort((a, b) => b.totalSales - a.totalSales),  // Sort by sales descending
    dateRange: { startDate, endDate },
    attributionWindow,
  }
}

/**
 * Recalculate organic sales for all SalesDaily records in date range
 * Called after syncing both orders and ads data
 */
export async function recalculateAttribution(options: {
  brandId: string
  startDate?: string
  endDate?: string
}): Promise<RecalculateAttributionResult> {
  const { brandId, startDate, endDate } = options
  const errors: string[] = []
  let recordsUpdated = 0
  let anomaliesDetected = 0

  // Build date filter
  const dateFilter: { gte?: Date; lte?: Date } = {}
  if (startDate) dateFilter.gte = startOfDay(parseISO(startDate))
  if (endDate) dateFilter.lte = endOfDay(parseISO(endDate))

  // Get all SalesDaily records for the brand
  const records = await prisma.salesDaily.findMany({
    where: {
      brandId,
      channel: 'amazon',
      date: Object.keys(dateFilter).length > 0 ? dateFilter : undefined,
    },
  })

  // Update each record
  for (const record of records) {
    try {
      const totalSales = Number(record.totalSales)
      const adAttributed = Number(record.adAttributedSales)
      const organic = calculateOrganic(totalSales, adAttributed)
      const hasAnomaly = hasAttributionAnomaly(totalSales, adAttributed)

      if (hasAnomaly) {
        anomaliesDetected++
        console.warn(
          `[Attribution] Anomaly detected: ASIN ${record.asin} on ${format(record.date, 'yyyy-MM-dd')}: ` +
          `ad=$${adAttributed.toFixed(2)} > total=$${totalSales.toFixed(2)}`
        )
      }

      // Calculate organic units proportionally
      const unitsProportion = totalSales > 0 ? organic / totalSales : 0
      const unitsOrganic = Math.round((record.unitsTotal || 0) * unitsProportion)

      await prisma.salesDaily.update({
        where: { id: record.id },
        data: {
          organicSales: organic,
          unitsOrganic,
        },
      })

      recordsUpdated++
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : 'Unknown error'
      errors.push(`Record ${record.id}: ${errMsg}`)
    }
  }

  return { recordsUpdated, anomaliesDetected, errors }
}

/**
 * Get attribution data for a specific ASIN over time
 */
export async function getAsinAttributionHistory(options: {
  brandId: string
  asin: string
  startDate: string
  endDate: string
}): Promise<DailyAttribution[]> {
  const { brandId, asin, startDate, endDate } = options

  const result = await getAttributionBreakdown({
    brandId,
    startDate,
    endDate,
    asin,
    groupBy: 'day',
  })

  return result.daily
}

/**
 * Get top ASINs by organic percentage
 */
export async function getTopOrganicAsins(options: {
  brandId: string
  startDate: string
  endDate: string
  limit?: number
}): Promise<AsinAttribution[]> {
  const { brandId, startDate, endDate, limit = 10 } = options

  const result = await getAttributionBreakdown({
    brandId,
    startDate,
    endDate,
    groupBy: 'day',
  })

  return result.byAsin
    .filter(a => a.totalSales > 0)  // Exclude zero-sales ASINs
    .sort((a, b) => b.organicPercentage - a.organicPercentage)
    .slice(0, limit)
}

/**
 * Get ASINs with attribution anomalies
 */
export async function getAnomalyAsins(options: {
  brandId: string
  startDate: string
  endDate: string
}): Promise<AsinAttribution[]> {
  const result = await getAttributionBreakdown({
    brandId,
    startDate: options.startDate,
    endDate: options.endDate,
  })

  return result.byAsin.filter(a => a.hasAnomaly)
}
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Directory created at `/src/services/attribution/`
- [ ] Service file created with all functions
- [ ] Core calculation functions implemented
- [ ] Date grouping (day/week/month) working
- [ ] Anomaly detection implemented
- [ ] TypeScript compiles without errors

---

### Subtask 2.2: Update Calculator Service
**File**: `/src/services/sales-daily/calculator.ts` (MODIFY)
**Pattern**: Existing file structure

**Instructions**:
1. Add import for attribution service types
2. Update `recalculateOrganicSales` to use the new attribution logic
3. Add export for `calculateOrganicSales` function (already exported)

Add after line 9 (after date-fns import):
```typescript
import {
  calculateOrganic,
  calculateOrganicPercentage as calcOrganicPct,
} from '@/services/attribution/amazon-attribution'
```

Update the `recalculateOrganicSales` function (lines 179-243) to add anomaly detection:

In the loop where records are updated (around line 225-239), add anomaly logging:
```typescript
// Before the update, check for anomaly
if (adAttributedAllChannels > totalAllChannels && totalAllChannels > 0) {
  console.warn(
    `[Calculator] Attribution anomaly on ${_dateKey}: ` +
    `ad=$${adAttributedAllChannels.toFixed(2)} > total=$${totalAllChannels.toFixed(2)}`
  )
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Import added for attribution service
- [ ] Anomaly detection added to recalculateOrganicSales
- [ ] TypeScript compiles without errors
- [ ] Build passes

---

## Phase 3: API Routes

### Subtask 3.1: Add Attribution Endpoint to Sales Daily Route
**File**: `/src/app/api/sales-daily/route.ts` (MODIFY)
**Pattern**: Existing route structure

**Instructions**:
1. Add import for attribution service
2. Add support for `?breakdown=attribution` query parameter
3. Add ASIN filtering with attribution breakdown

After line 14 (after date-fns imports), add:
```typescript
import { getAttributionBreakdown } from '@/services/attribution/amazon-attribution'
import { attributionQuerySchema } from '@/types/attribution'
```

Modify the GET handler to add attribution breakdown support. After the existing query parameter parsing (around line 29), add:
```typescript
const breakdown = searchParams.get('breakdown')
const attributionWindow = (searchParams.get('attributionWindow') || '7d') as '7d' | '14d' | '30d'
```

Add a conditional block before the existing salesData query (around line 55) that returns attribution data if requested:
```typescript
// If attribution breakdown requested, use attribution service
if (breakdown === 'attribution' && brandId) {
  try {
    const result = await getAttributionBreakdown({
      brandId,
      startDate: effectiveStartDate,
      endDate: effectiveEndDate,
      asin: asin || undefined,
      attributionWindow,
      groupBy: _groupBy as 'day' | 'week' | 'month',
    })

    return NextResponse.json({
      attribution: result,
      brands: brands.filter(b => b.id === brandId),
    })
  } catch (error) {
    console.error('Attribution breakdown error:', error)
    return NextResponse.json(
      { error: 'Failed to get attribution breakdown' },
      { status: 500 }
    )
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Attribution service imported
- [ ] `?breakdown=attribution` parameter handled
- [ ] Attribution response returned when requested
- [ ] Existing functionality unchanged
- [ ] TypeScript compiles without errors
- [ ] Build passes

---

## Phase 4: Testing

### Subtask 4.1: Add Unit Tests for Attribution Service
**File**: `/tests/unit/attribution-service.test.ts` (CREATE)
**Pattern**: Follow `/tests/unit/analytics-service.test.ts`

**Instructions**:
1. Create test file with unit tests for core calculations

```typescript
import { describe, it, expect } from 'vitest'
import {
  calculateOrganic,
  calculateOrganicPercentage,
  calculateAdPercentage,
  hasAttributionAnomaly,
} from '@/services/attribution/amazon-attribution'

describe('Attribution Service', () => {
  describe('calculateOrganic', () => {
    it('should return organic = total - ad when ad < total', () => {
      expect(calculateOrganic(100, 40)).toBe(60)
    })

    it('should return 0 when ad equals total', () => {
      expect(calculateOrganic(100, 100)).toBe(0)
    })

    it('should return 0 when ad > total (anomaly case)', () => {
      expect(calculateOrganic(100, 150)).toBe(0)
    })

    it('should return total when ad is 0', () => {
      expect(calculateOrganic(100, 0)).toBe(100)
    })

    it('should handle zero total sales', () => {
      expect(calculateOrganic(0, 0)).toBe(0)
    })
  })

  describe('calculateOrganicPercentage', () => {
    it('should calculate correct percentage', () => {
      expect(calculateOrganicPercentage(100, 60)).toBe(60)
    })

    it('should return 0 for zero total sales', () => {
      expect(calculateOrganicPercentage(0, 0)).toBe(0)
    })

    it('should round to 2 decimal places', () => {
      expect(calculateOrganicPercentage(100, 33.333)).toBe(33.33)
    })
  })

  describe('calculateAdPercentage', () => {
    it('should calculate correct percentage', () => {
      expect(calculateAdPercentage(100, 40)).toBe(40)
    })

    it('should return 0 for zero total sales', () => {
      expect(calculateAdPercentage(0, 0)).toBe(0)
    })
  })

  describe('hasAttributionAnomaly', () => {
    it('should detect when ad > total', () => {
      expect(hasAttributionAnomaly(100, 150)).toBe(true)
    })

    it('should not flag when ad < total', () => {
      expect(hasAttributionAnomaly(100, 40)).toBe(false)
    })

    it('should not flag when ad equals total', () => {
      expect(hasAttributionAnomaly(100, 100)).toBe(false)
    })

    it('should not flag when total is 0', () => {
      expect(hasAttributionAnomaly(0, 50)).toBe(false)
    })
  })
})
```

**Validation**:
```bash
npm test -- --filter="attribution"
```

**Completion Criteria**:
- [ ] Test file created
- [ ] Core calculation tests pass
- [ ] Edge cases covered (anomaly, zero values)
- [ ] All tests green

---

## Phase 5: Type Exports

### Subtask 5.1: Export Attribution Types from Index
**File**: `/src/types/index.ts` (MODIFY)
**Pattern**: Existing export structure

**Instructions**:
Add export for attribution types at the end of the file:
```typescript
// Attribution types
export * from './attribution'
```

**Validation**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] Attribution types exported from index
- [ ] No circular dependency issues
- [ ] TypeScript compiles

---

## Summary of Deliverables

**Files Created**: 3
- `/src/types/attribution.ts`
- `/src/services/attribution/amazon-attribution.ts`
- `/tests/unit/attribution-service.test.ts`

**Files Modified**: 3
- `/src/services/sales-daily/calculator.ts`
- `/src/app/api/sales-daily/route.ts`
- `/src/types/index.ts`

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> 2 -> 3 -> 4 -> 5)
2. Create directories before files (`mkdir -p`)
3. Test completion criteria before next subtask
4. Follow reference patterns exactly from existing code
5. Run validation commands after each subtask

## Test Strategy Note

**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Commands**:
```bash
# Unit tests for new service
npm test -- --filter="attribution"

# TypeScript check
npx tsc --noEmit

# Build check
npm run build
```

## Acceptance Criteria Checklist

- [ ] Organic sales correctly calculated as total - ad-attributed
- [ ] Per-ASIN attribution breakdown available via API
- [ ] Handles edge case where ad > total (reports 0 organic, flags anomaly)
- [ ] API returns `organicPercentage` in daily summary
- [ ] Supports different attribution windows (7d, 14d, 30d)
- [ ] No TypeScript errors, build passes
- [ ] Unit tests pass

---

## Performance Metrics

| Phase | Estimated Duration |
|-------|-------------------|
| Investigation | 45m |
| Validation | 10m |
| Planning | 25m |
| **Total** | **~80m** |
