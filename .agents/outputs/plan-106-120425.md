# Implementation Plan
**Generated**: 2025-12-04T12:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #106
**Estimated Build Time**: 4-6 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #106
**Priority**: High
**Parent Issue**: #11 (Low-stock alerts)

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--testPathPattern="lowstock|cron|alert"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- `7fe6f83` feat(issue #105): add Slack webhook integration and admin UI
- `11cd0db` feat(issue #104): add database schema and core alert evaluation service

Both dependencies are complete and merged to main.

### Current State Assessment

#### Existing Components (COMPLETE - from #104 and #105):
1. **Database Schema** (`prisma/schema.prisma`):
   - `AlertConfig` model - stores company alert settings (Slack URL, email addresses, enableSlack, enableEmail, alertMode, lastDigestSent)
   - `ComponentAlertState` model - tracks per-component alert state (lastStatus, lastAlertSent)

2. **Service Layer** (`src/services/lowstock-alert.ts`):
   - `evaluateLowStockAlerts(companyId)` - core evaluation function (lines 170-281)
   - `sendSlackAlerts(companyId, alerts, baseUrl)` - Slack delivery (lines 355-410)
   - `getAlertConfig(companyId)` - fetch config (lines 59-80)
   - `areAlertsEnabled(companyId)` - check if alerts enabled (lines 286-290)
   - `updateLastDigestSent(companyId)` - timestamp update (lines 131-136)
   - `updateComponentAlertState()` - internal state tracking (lines 141-158)

3. **Slack Client** (`src/lib/slack.ts`):
   - `sendSlackMessage()` - posts to webhook
   - `formatLowStockAlert()` - single alert format
   - `formatDigestMessage()` - digest format

4. **Types** (`src/types/lowstock-alert.ts`):
   - `AlertConfigResponse`, `ComponentAlertNeeded`, `LowStockAlertEvaluation`

#### What Needs to Be Built (This Issue):
1. **Cron Endpoint**: `src/app/api/cron/alerts/route.ts`
2. **Orchestration Function**: `runAlertEvaluation(companyId, baseUrl)` in lowstock-alert.ts
3. **Multi-Company Runner**: `runAllCompanyAlerts(baseUrl)` in lowstock-alert.ts
4. **Environment Variable**: `CRON_SECRET` for endpoint authentication
5. **Environment Schema Update**: `src/lib/env.ts`

### Dependencies & Blockers
1. **#104 (Core evaluation)** - COMPLETE
2. **#105 (Slack delivery)** - COMPLETE
3. **External cron service** - NOT BLOCKING (endpoint is cron-agnostic)

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 4-6 hours
**Risk**: Low - all foundation code exists, this is orchestration/glue code

### Patterns Identified
**Primary**: `src/app/api/health/route.ts` - Simple public endpoint pattern (no auth, GET handler)
**Secondary**: `src/app/api/settings/alerts/route.ts` - API response patterns, admin-only patterns
**Tertiary**: `src/services/lowstock-alert.ts` - Service function patterns

### Ripple Effect Analysis
**Files Identified**: 4

| File | Reason |
|------|--------|
| `src/app/api/cron/alerts/route.ts` | NEW - cron endpoint |
| `src/services/lowstock-alert.ts` | ADD orchestration functions |
| `src/lib/env.ts` | ADD CRON_SECRET validation |
| `.env.example` | ADD CRON_SECRET documentation |

---

## Executive Summary

This issue implements the scheduled job infrastructure for low-stock alert evaluation. The core pieces (evaluation logic, Slack delivery, database schema) are already complete from issues #104 and #105. This issue creates:
1. A cron-callable API endpoint secured with Bearer token authentication
2. Orchestration functions that tie together evaluation and delivery for single or all companies
3. Proper logging for debugging in serverless environments

---

## Phase 1: Environment Configuration

### Subtask 1.1: Update Environment Schema
**File**: `/home/pbrown/SkuInventory/src/lib/env.ts`
**Pattern**: Follow existing optional env var pattern (line 8-9)
**Instructions**:
1. Add `CRON_SECRET` to envSchema as optional string (min 16 chars when provided)
2. This allows the app to run without cron configured
```typescript
CRON_SECRET: z.string().min(16).optional(),
```
**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] `CRON_SECRET` added to env schema as optional
- [ ] Build passes
- [ ] TypeScript compiles without errors

### Subtask 1.2: Update Environment Example File
**File**: `/home/pbrown/SkuInventory/.env.example`
**Instructions**:
1. Add CRON_SECRET with documentation
```
# Cron Job Secret - Required for /api/cron/alerts endpoint
# Generate with: openssl rand -base64 32
# Used to authenticate scheduled job requests
CRON_SECRET=your-cron-secret-here-min-16-chars
```
**Completion Criteria**:
- [ ] CRON_SECRET documented in .env.example
- [ ] Generation instructions included

---

## Phase 2: Service Layer - Orchestration Functions

### Subtask 2.1: Add runAlertEvaluation Orchestration Function
**File**: `/home/pbrown/SkuInventory/src/services/lowstock-alert.ts`
**Pattern**: Follow existing function structure (lines 355-410)
**Location**: Add after `sendSlackAlerts` function (after line 410)
**Instructions**:
1. Create `runAlertEvaluation(companyId: string, baseUrl: string)` function
2. Function should:
   - Get alert config for company
   - Return early if no alerts enabled
   - Call `evaluateLowStockAlerts(companyId)`
   - If alerts found and Slack enabled, call `sendSlackAlerts()`
   - Log results for debugging
   - Return execution summary
3. Add TypeScript interface for result

```typescript
/**
 * Result of alert evaluation run
 */
export interface AlertEvaluationResult {
  companyId: string
  evaluated: boolean
  componentsEvaluated: number
  alertsTriggered: number
  slackSent: number
  slackErrors: string[]
  emailSent: number
  emailErrors: string[]
  skipped: boolean
  skipReason?: string
}

/**
 * Run alert evaluation for a single company
 * Orchestrates evaluation and delivery
 */
export async function runAlertEvaluation(
  companyId: string,
  baseUrl: string
): Promise<AlertEvaluationResult> {
  const result: AlertEvaluationResult = {
    companyId,
    evaluated: false,
    componentsEvaluated: 0,
    alertsTriggered: 0,
    slackSent: 0,
    slackErrors: [],
    emailSent: 0,
    emailErrors: [],
    skipped: false,
  }

  // Get config
  const config = await getAlertConfig(companyId)
  if (!config) {
    result.skipped = true
    result.skipReason = 'No alert config'
    return result
  }

  if (!config.enableSlack && !config.enableEmail) {
    result.skipped = true
    result.skipReason = 'All channels disabled'
    return result
  }

  // Run evaluation
  const evaluation = await evaluateLowStockAlerts(companyId)
  result.evaluated = true
  result.componentsEvaluated = evaluation.totalComponents
  result.alertsTriggered = evaluation.componentsNeedingAlert.length

  if (evaluation.componentsNeedingAlert.length === 0) {
    console.log(`[Alerts] Company ${companyId}: No alerts needed`)
    return result
  }

  // Send Slack alerts if enabled
  if (config.enableSlack && config.slackWebhookUrl) {
    const slackResult = await sendSlackAlerts(
      companyId,
      evaluation.componentsNeedingAlert,
      baseUrl
    )
    result.slackSent = slackResult.sent
    result.slackErrors = slackResult.errors
  }

  // Email delivery will be added in Issue #107
  // if (config.enableEmail && config.emailAddresses.length > 0) {
  //   const emailResult = await sendEmailAlerts(...)
  //   result.emailSent = emailResult.sent
  //   result.emailErrors = emailResult.errors
  // }

  console.log(`[Alerts] Company ${companyId}: ${result.alertsTriggered} alerts, ${result.slackSent} Slack sent`)

  return result
}
```

**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] `AlertEvaluationResult` interface exported
- [ ] `runAlertEvaluation()` function added
- [ ] Function handles all edge cases (no config, disabled, no alerts)
- [ ] TypeScript compiles without errors

### Subtask 2.2: Add runAllCompanyAlerts Function
**File**: `/home/pbrown/SkuInventory/src/services/lowstock-alert.ts`
**Pattern**: Follow existing Prisma query patterns
**Location**: Add after `runAlertEvaluation` function
**Instructions**:
1. Create `runAllCompanyAlerts(baseUrl: string)` function
2. Query all companies with AlertConfig where alerts are enabled
3. Run evaluation for each company
4. Handle partial failures (continue on individual company errors)
5. Return aggregated results

```typescript
/**
 * Summary of all company alert runs
 */
export interface AlertRunSummary {
  executedAt: string
  companiesProcessed: number
  companiesWithAlerts: number
  totalAlertsTriggered: number
  totalSlackSent: number
  totalEmailSent: number
  errors: Array<{ companyId: string; error: string }>
  results: AlertEvaluationResult[]
}

/**
 * Run alert evaluation for all companies with alerts enabled
 * Called by cron endpoint
 */
export async function runAllCompanyAlerts(
  baseUrl: string
): Promise<AlertRunSummary> {
  const executedAt = new Date().toISOString()
  console.log(`[Alerts] Starting alert run at ${executedAt}`)

  // Find all companies with alerts enabled
  const configs = await prisma.alertConfig.findMany({
    where: {
      OR: [
        { enableSlack: true },
        { enableEmail: true },
      ],
    },
    select: { companyId: true },
  })

  const summary: AlertRunSummary = {
    executedAt,
    companiesProcessed: configs.length,
    companiesWithAlerts: 0,
    totalAlertsTriggered: 0,
    totalSlackSent: 0,
    totalEmailSent: 0,
    errors: [],
    results: [],
  }

  if (configs.length === 0) {
    console.log('[Alerts] No companies with alerts enabled')
    return summary
  }

  // Process each company
  for (const { companyId } of configs) {
    try {
      const result = await runAlertEvaluation(companyId, baseUrl)
      summary.results.push(result)

      if (result.alertsTriggered > 0) {
        summary.companiesWithAlerts++
      }
      summary.totalAlertsTriggered += result.alertsTriggered
      summary.totalSlackSent += result.slackSent
      summary.totalEmailSent += result.emailSent

      if (result.slackErrors.length > 0) {
        summary.errors.push({
          companyId,
          error: `Slack: ${result.slackErrors.join(', ')}`,
        })
      }
    } catch (error) {
      console.error(`[Alerts] Error processing company ${companyId}:`, error)
      summary.errors.push({
        companyId,
        error: error instanceof Error ? error.message : 'Unknown error',
      })
    }
  }

  console.log(`[Alerts] Run complete: ${summary.companiesProcessed} companies, ${summary.totalAlertsTriggered} alerts, ${summary.errors.length} errors`)

  return summary
}
```

**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] `AlertRunSummary` interface exported
- [ ] `runAllCompanyAlerts()` function added
- [ ] Queries companies with enabled alerts
- [ ] Handles partial failures gracefully
- [ ] Returns comprehensive summary
- [ ] TypeScript compiles without errors

---

## Phase 3: API Route - Cron Endpoint

### Subtask 3.1: Create Cron Alerts Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/cron/alerts/route.ts` (NEW)
**Pattern**: Follow `src/app/api/health/route.ts` for simple public endpoint + Bearer auth
**Instructions**:
1. Create directory structure: `src/app/api/cron/alerts/`
2. Create route.ts with GET handler
3. Verify Bearer token against CRON_SECRET
4. Return 401 if missing/invalid
5. Return 503 if CRON_SECRET not configured
6. Call `runAllCompanyAlerts()` and return results
7. Add `force-dynamic` export to prevent static rendering

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { runAllCompanyAlerts } from '@/services/lowstock-alert'

// Force dynamic rendering
export const dynamic = 'force-dynamic'

// Maximum execution time (for Vercel)
export const maxDuration = 60

/**
 * GET /api/cron/alerts - Run alert evaluation for all companies
 * Protected by Bearer token authentication
 *
 * Called by external cron service (Vercel Cron, Railway, crontab, etc.)
 *
 * Headers:
 *   Authorization: Bearer <CRON_SECRET>
 *
 * Query params:
 *   baseUrl: Optional base URL for component links (defaults to request origin)
 */
export async function GET(request: NextRequest) {
  const startTime = Date.now()

  // Check if CRON_SECRET is configured
  const cronSecret = process.env.CRON_SECRET
  if (!cronSecret) {
    console.warn('[Cron] CRON_SECRET not configured')
    return NextResponse.json(
      { error: 'Cron endpoint not configured' },
      { status: 503 }
    )
  }

  // Verify Bearer token
  const authHeader = request.headers.get('authorization')
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return NextResponse.json(
      { error: 'Missing authorization header' },
      { status: 401 }
    )
  }

  const token = authHeader.slice(7) // Remove 'Bearer '
  if (token !== cronSecret) {
    console.warn('[Cron] Invalid cron secret provided')
    return NextResponse.json(
      { error: 'Invalid authorization' },
      { status: 401 }
    )
  }

  // Get base URL for component links
  const searchParams = request.nextUrl.searchParams
  let baseUrl = searchParams.get('baseUrl')
  if (!baseUrl) {
    // Derive from request headers
    const host = request.headers.get('x-forwarded-host') || request.headers.get('host')
    const proto = request.headers.get('x-forwarded-proto') || 'https'
    baseUrl = host ? `${proto}://${host}` : 'http://localhost:4545'
  }

  try {
    console.log(`[Cron] Alert evaluation started, baseUrl: ${baseUrl}`)

    const results = await runAllCompanyAlerts(baseUrl)

    const duration = Date.now() - startTime

    return NextResponse.json({
      success: true,
      duration: `${duration}ms`,
      ...results,
    })
  } catch (error) {
    console.error('[Cron] Alert evaluation failed:', error)
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        duration: `${Date.now() - startTime}ms`,
      },
      { status: 500 }
    )
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Directory `src/app/api/cron/alerts/` created
- [ ] `route.ts` created with GET handler
- [ ] Returns 503 if CRON_SECRET not configured
- [ ] Returns 401 if no/invalid Bearer token
- [ ] Returns 200 with results on success
- [ ] Handles errors gracefully
- [ ] TypeScript compiles
- [ ] Build passes

---

## Phase 4: Testing & Verification

### Subtask 4.1: Manual Testing
**Instructions**:
1. Set CRON_SECRET in local .env:
   ```
   CRON_SECRET=test-secret-for-local-dev-min16
   ```
2. Restart dev server
3. Test unauthorized access:
   ```bash
   curl -i http://localhost:4545/api/cron/alerts
   # Should return 401
   ```
4. Test with wrong token:
   ```bash
   curl -i -H "Authorization: Bearer wrong-token" http://localhost:4545/api/cron/alerts
   # Should return 401
   ```
5. Test with correct token:
   ```bash
   curl -i -H "Authorization: Bearer test-secret-for-local-dev-min16" http://localhost:4545/api/cron/alerts
   # Should return 200 with results
   ```

**Completion Criteria**:
- [ ] Endpoint rejects missing auth
- [ ] Endpoint rejects invalid auth
- [ ] Endpoint accepts valid auth and returns results
- [ ] Logs show execution details

### Subtask 4.2: Build Verification
**Instructions**:
```bash
npm run build && npx tsc --noEmit && npm run lint
```
**Completion Criteria**:
- [ ] Build passes without errors
- [ ] TypeScript compiles without errors
- [ ] Lint passes without errors

---

## Summary of Deliverables

**Files Created**: 1
- `src/app/api/cron/alerts/route.ts` - Cron endpoint

**Files Modified**: 3
- `src/services/lowstock-alert.ts` - Add orchestration functions
- `src/lib/env.ts` - Add CRON_SECRET to schema
- `.env.example` - Document CRON_SECRET

**New Exports from lowstock-alert.ts**:
- `AlertEvaluationResult` (interface)
- `AlertRunSummary` (interface)
- `runAlertEvaluation()` (function)
- `runAllCompanyAlerts()` (function)

---

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 1 -> 2 -> 3 -> 4)
2. Complete each subtask fully before moving to next
3. Test completion criteria before next subtask
4. Follow reference patterns exactly
5. Do NOT add email functionality (that is Issue #107)

## Test Strategy Note
- No automated tests required for this issue
- Manual curl testing sufficient for cron endpoint
- Email-related code is commented placeholder only

## Acceptance Criteria Checklist (from Issue)
- [ ] Cron endpoint at `/api/cron/alerts` protected by secret
- [ ] Runs evaluation for all companies with alerts enabled
- [ ] Daily digest mode batches alerts into single message (via existing sendSlackAlerts)
- [ ] ComponentAlertState updated after successful delivery (via existing evaluateLowStockAlerts)
- [ ] lastDigestSent updated to prevent duplicate digests (via existing sendSlackAlerts)
- [ ] Handles partial failures gracefully
- [ ] Logs execution for debugging
- [ ] Environment variable `CRON_SECRET` documented
- [ ] `npm run build` and `npx tsc --noEmit` pass without errors

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 8m |
| Validation | 2m |
| Planning | 15m |
| **Total** | **25m** |
