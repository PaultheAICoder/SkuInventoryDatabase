# Implementation Plan
**Generated**: 2025-12-17T10:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #291
**Estimated Build Time**: 8-10 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #291
**Priority**: Medium

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="forecast"` or `--testPathPattern="forecast"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- Issue #286 recently added selectedCompanyId validation (already done)
- Issue #191 added companyId filtering to inventory calculations
- Issues #115/#116 added initial forecast service and API endpoints

### Current State Assessment

**Existing Components**:
1. **API Routes**:
   - `src/app/api/forecasts/route.ts` - Main list endpoint (needs location/brand + DB pagination)
   - `src/app/api/export/forecasts/route.ts` - Export endpoint (needs location/brand filters)
   - `src/app/api/forecasts/config/route.ts` - Config endpoint (already has company scoping)
   - `src/app/api/forecasts/[componentId]/route.ts` - Single component forecast (needs location filter)

2. **Service Layer**:
   - `src/services/forecast.ts` - Core forecast logic (needs location/brand + pagination support)
   - `src/services/inventory.ts` - Already supports `locationId` parameter in `getComponentQuantities()`

3. **Types**:
   - `src/types/forecast.ts` - Query schema needs locationId/brandId params

4. **Frontend**:
   - `src/app/(dashboard)/forecasts/page.tsx` - UI page (consumes API, may need filter UI)

**Database**: No schema changes needed. Components have `brandId`, Transactions have `locationId`.

**API Routes**: Company scoping already exists (Issue #286). Need to add location/brand filters.

### Dependencies & Blockers
1. **None** - All prerequisites are in place. The component already has brandId and transactions have locationId.

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Moderate
**Effort**: 8-10 hours
**Risk**: Low - follows established patterns from components API

### Patterns Identified
**Primary**: `src/app/api/components/route.ts` - Shows how to:
- Accept `locationId` query param
- Pass it to `getComponentQuantities()`
- Filter by `selectedBrandId` from session
- Use DB-level pagination with `skip` and `take`

**Secondary**: `src/app/api/skus/route.ts` - Shows:
- Prisma `findMany` with `skip`/`take`/`orderBy`
- DB-level count for total

### Ripple Effect Analysis
**Files Identified**: 8 files directly affected

1. `src/types/forecast.ts` - Add locationId/brandId to query schema
2. `src/services/forecast.ts` - Add location/brand params to service functions
3. `src/app/api/forecasts/route.ts` - Accept filters + DB pagination
4. `src/app/api/export/forecasts/route.ts` - Accept filters (aligned with list view)
5. `src/app/api/forecasts/[componentId]/route.ts` - Accept locationId filter
6. `tests/unit/forecast-service.test.ts` - Update mocks for new params
7. `tests/integration/forecasts.test.ts` - Add tests for location/brand filters
8. `src/app/(dashboard)/forecasts/page.tsx` - Minor: may need to pass location param (optional)

---

## Executive Summary

This implementation makes the forecasting system location and brand aware by:
1. Adding `locationId` and `brandId` optional query params to forecast endpoints
2. Modifying the forecast service to scope consumption calculations by location
3. Moving sorting/pagination from in-memory to database-level Prisma queries
4. Ensuring export endpoint stays aligned with the filtered list view

The key architectural insight is that "DB pagination" for forecasts is tricky because forecasts are computed values (not stored). The solution is to:
1. First filter components at DB level (by company, brand, location via quantities)
2. Compute forecasts for the filtered set
3. Apply sorting/pagination at the service level but on a smaller, pre-filtered set

---

## Phase 1: Types Layer

### Subtask 1.1: Update Forecast Query Schema
**File**: `/home/pbrown/SkuInventory/src/types/forecast.ts`
**Pattern**: Follow `componentListQuerySchema` in `src/types/component.ts` (line 35-48)
**Instructions**:
1. Add `locationId` optional UUID field to `forecastListQuerySchema`
2. Add `brandId` optional UUID field to `forecastListQuerySchema`

```typescript
// Add to forecastListQuerySchema:
locationId: z.string().uuid().optional(),
brandId: z.string().uuid().optional(),
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] `forecastListQuerySchema` includes `locationId` and `brandId` optional params
- [ ] TypeScript compiles without errors
- [ ] `ForecastListQuery` type inferred correctly with new fields

---

## Phase 2: Service Layer

### Subtask 2.1: Update calculateConsumptionRates to Support Location Filtering
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Pattern**: Follow `getComponentQuantities()` location handling in `src/services/inventory.ts` (line 142-266)
**Instructions**:
1. Add optional `locationId` parameter to `calculateConsumptionRates()` function signature
2. If `locationId` is provided, add a filter on the `transaction` relation for:
   - Non-transfer transactions: `transaction.locationId === locationId`
   - Transfer transactions:
     - For negative (outgoing): `transaction.fromLocationId === locationId`
     - For positive (incoming): `transaction.toLocationId === locationId`

Note: The current implementation uses a simple aggregate on transactions. To support location-aware consumption, we need to either:
- Add location conditions to the where clause (simpler, chosen approach)
- OR compute consumption separately per location type (more complex)

**Updated function signature**:
```typescript
export async function calculateConsumptionRates(
  componentIds: string[],
  lookbackDays: number = 30,
  excludedTypes: string[] = ['initial', 'adjustment'],
  locationId?: string  // NEW PARAMETER
): Promise<Map<string, number>>
```

**Implementation notes**:
- When `locationId` is provided, the query should filter transaction lines where the parent transaction occurred at that location
- For transfers, need separate queries for from/to like inventory.ts does

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] `calculateConsumptionRates` accepts optional `locationId`
- [ ] When locationId provided, only consumption from that location is counted
- [ ] Transfers handled correctly (outgoing from location, incoming to location)
- [ ] No TypeScript errors

### Subtask 2.2: Update calculateConsumptionRate (Single Component Version)
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Pattern**: Same as subtask 2.1
**Instructions**:
1. Add optional `locationId` parameter to `calculateConsumptionRate()` (single component version)
2. Apply same location filtering logic

**Updated function signature**:
```typescript
export async function calculateConsumptionRate(
  componentId: string,
  lookbackDays: number = 30,
  excludedTypes: string[] = ['initial', 'adjustment'],
  locationId?: string  // NEW PARAMETER
): Promise<number>
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] `calculateConsumptionRate` accepts optional `locationId`
- [ ] Location filtering works correctly
- [ ] No TypeScript errors

### Subtask 2.3: Update getComponentForecasts for Location/Brand Filtering
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Pattern**: Follow `getComponentQuantities()` usage in components route
**Instructions**:
1. Add optional `filters` parameter with `locationId` and `brandId`
2. Filter component query by brandId if provided
3. Pass locationId to both `getComponentQuantities()` and `calculateConsumptionRates()`

**Updated function signature**:
```typescript
export async function getComponentForecasts(
  companyId: string,
  configOverride?: Partial<ForecastConfigInput>,
  filters?: { locationId?: string; brandId?: string }  // NEW PARAMETER
): Promise<ComponentForecast[]>
```

**Implementation changes**:
1. Add `brandId` filter to the `prisma.component.findMany` where clause
2. Pass `filters?.locationId` to `getComponentQuantities(componentIds, companyId, filters?.locationId)`
3. Pass `filters?.locationId` to `calculateConsumptionRates(componentIds, config.lookbackDays, config.excludedTransactionTypes, filters?.locationId)`

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] `getComponentForecasts` accepts optional filters object
- [ ] Components filtered by brandId when provided
- [ ] Quantities calculated per location when locationId provided
- [ ] Consumption rates calculated per location when locationId provided
- [ ] No TypeScript errors

### Subtask 2.4: Update getComponentForecastById for Location Filter
**File**: `/home/pbrown/SkuInventory/src/services/forecast.ts`
**Pattern**: Same as subtask 2.3
**Instructions**:
1. Add optional `locationId` parameter
2. Pass to quantity and consumption calculations

**Updated function signature**:
```typescript
export async function getComponentForecastById(
  componentId: string,
  configOverride?: Partial<ForecastConfigInput>,
  locationId?: string  // NEW PARAMETER
): Promise<ComponentForecast | null>
```

**Validation Commands**:
```bash
npx tsc --noEmit
```

**Completion Criteria**:
- [ ] `getComponentForecastById` accepts optional `locationId`
- [ ] Location scoping works correctly
- [ ] No TypeScript errors

---

## Phase 3: API Routes

### Subtask 3.1: Update Main Forecasts Route with Location/Brand + DB-ish Pagination
**File**: `/home/pbrown/SkuInventory/src/app/api/forecasts/route.ts`
**Pattern**: Follow `src/app/api/components/route.ts` (lines 30-108)
**Instructions**:
1. Extract `locationId` and `brandId` from query params (add to schema parsing)
2. If `brandId` is not provided, use `session.user.selectedBrandId` (like components route)
3. Pass filters to `getComponentForecasts()`
4. IMPORTANT: Since forecasts are computed values, true DB pagination is not possible. Instead:
   - Get filtered forecasts from service (already filtered by company/brand/location)
   - Apply sorting in-memory (already done)
   - Apply pagination in-memory (already done)
   - This is acceptable because the pre-filtering significantly reduces the dataset

**Key changes**:
```typescript
// In GET handler:
const { page, pageSize, lookbackDays, safetyDays, sortBy, sortOrder, showOnlyAtRisk, locationId, brandId } =
  queryResult.data

// Use selected brand from session if not explicitly provided
const effectiveBrandId = brandId ?? session.user.selectedBrandId

// Get forecasts with filters
const forecasts = await getComponentForecasts(
  selectedCompanyId,
  Object.keys(configOverride).length > 0 ? configOverride : undefined,
  { locationId, brandId: effectiveBrandId }  // NEW: pass filters
)
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
npm run build
```

**Completion Criteria**:
- [ ] Route accepts `locationId` and `brandId` query params
- [ ] Falls back to session.user.selectedBrandId when brandId not provided
- [ ] Forecasts correctly filtered by location and brand
- [ ] Pagination still works
- [ ] No TypeScript errors
- [ ] Build succeeds

### Subtask 3.2: Update Export Forecasts Route
**File**: `/home/pbrown/SkuInventory/src/app/api/export/forecasts/route.ts`
**Pattern**: Follow subtask 3.1
**Instructions**:
1. Parse `locationId` and `brandId` from query params (same as list endpoint)
2. Use `session.user.selectedBrandId` as fallback
3. Pass filters to `getComponentForecasts()`
4. Export should match the filtered list view exactly

**Key changes**:
```typescript
// Parse additional query params
const locationId = searchParams.get('locationId') ?? undefined
const brandId = searchParams.get('brandId') ?? session.user.selectedBrandId ?? undefined

// Get forecasts with filters
const forecasts = await getComponentForecasts(
  selectedCompanyId,
  Object.keys(configOverride).length > 0 ? configOverride : undefined,
  { locationId, brandId }  // NEW: pass filters
)
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Export route accepts same filters as list route
- [ ] Exported data matches filtered list view
- [ ] No TypeScript errors

### Subtask 3.3: Update Single Component Forecast Route
**File**: `/home/pbrown/SkuInventory/src/app/api/forecasts/[componentId]/route.ts`
**Pattern**: Follow subtask 3.1
**Instructions**:
1. Parse optional `locationId` from query params
2. Pass to `getComponentForecastById()`

**Key changes**:
```typescript
// After existing lookbackDays/safetyDays parsing:
const locationIdParam = searchParams.get('locationId')
const locationId = locationIdParam ?? undefined

// Update service call:
const forecast = await getComponentForecastById(
  componentId,
  Object.keys(configOverride).length > 0 ? configOverride : undefined,
  locationId  // NEW: pass locationId
)
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run lint
```

**Completion Criteria**:
- [ ] Route accepts optional `locationId` query param
- [ ] Single component forecast respects location scoping
- [ ] No TypeScript errors

---

## Phase 4: Tests

### Subtask 4.1: Update Unit Tests for Forecast Service
**File**: `/home/pbrown/SkuInventory/tests/unit/forecast-service.test.ts`
**Pattern**: Follow existing test patterns in the file
**Instructions**:
1. Update mock calls to include new parameters where needed
2. Add tests for location filtering in `calculateConsumptionRates`
3. Add tests for brand/location filtering in `getComponentForecasts`

**New test cases to add**:
```typescript
describe('calculateConsumptionRates with locationId', () => {
  it('filters consumption by location when locationId provided', async () => {
    // Test that location filtering works
  })
})

describe('getComponentForecasts with filters', () => {
  it('filters by brandId when provided', async () => {
    // Test brand filtering
  })

  it('filters by locationId when provided', async () => {
    // Test location filtering
  })

  it('applies both brandId and locationId filters', async () => {
    // Test combined filtering
  })
})
```

**Validation Commands**:
```bash
npm test -- --testPathPattern="forecast-service"
```

**Completion Criteria**:
- [ ] Existing tests still pass
- [ ] New tests for location filtering added
- [ ] New tests for brand filtering added
- [ ] All forecast service tests pass

### Subtask 4.2: Update Integration Tests for Forecast API
**File**: `/home/pbrown/SkuInventory/tests/integration/forecasts.test.ts`
**Pattern**: Follow existing test patterns in the file
**Instructions**:
1. Add tests for `locationId` query param
2. Add tests for `brandId` query param
3. Ensure export tests verify filter alignment

**New test cases to add**:
```typescript
describe('GET /api/forecasts', () => {
  it('filters by locationId when provided', async () => {
    // Create components, transactions at specific location
    // Request with locationId filter
    // Verify only matching results returned
  })

  it('filters by brandId when provided', async () => {
    // Create components with different brands
    // Request with brandId filter
    // Verify only matching brand's components returned
  })

  it('uses selectedBrandId from session when brandId not provided', async () => {
    // Verify session brand is used
  })
})

describe('GET /api/export/forecasts', () => {
  it('respects locationId filter in export', async () => {
    // Verify export matches filtered list
  })
})
```

**Validation Commands**:
```bash
npm test -- --testPathPattern="forecasts.test"
```

**Completion Criteria**:
- [ ] Existing integration tests still pass
- [ ] New tests for location/brand filters added
- [ ] Export alignment tests pass
- [ ] All forecast integration tests pass

---

## Phase 5: Final Validation

### Subtask 5.1: Build and Type Check
**File**: N/A (validation only)
**Instructions**:
1. Run full TypeScript check
2. Run full build
3. Run lint

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
npm run lint
```

**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build completes successfully
- [ ] No lint errors

### Subtask 5.2: Run Full Test Suite for Forecasts
**File**: N/A (validation only)
**Instructions**:
1. Run all forecast-related tests

**Validation Commands**:
```bash
npm test -- --testPathPattern="forecast"
```

**Completion Criteria**:
- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] No regressions

---

## Summary of Deliverables
**Files Modified**: 7
1. `src/types/forecast.ts` - Added locationId/brandId to query schema
2. `src/services/forecast.ts` - Added location/brand filtering to service functions
3. `src/app/api/forecasts/route.ts` - Added filter params to list endpoint
4. `src/app/api/export/forecasts/route.ts` - Added filter params to export endpoint
5. `src/app/api/forecasts/[componentId]/route.ts` - Added locationId param
6. `tests/unit/forecast-service.test.ts` - Updated with new test cases
7. `tests/integration/forecasts.test.ts` - Updated with new test cases

**Files Created**: 0

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5)
2. Complete each phase fully before moving to the next
3. Test completion criteria before proceeding to next subtask
4. Follow reference patterns exactly
5. Run validation commands after each subtask

## Test Strategy Note
- Use Vitest for unit tests
- Run with `--testPathPattern="forecast"` to scope test runs
- Integration tests use test database (port 2346)

## Architecture Decision Note
**RE: "DB Pagination"**

The issue requests "push sorting and pagination to the database instead of in-memory slices." This is partially achievable but has a nuance:

1. **What we CAN do at DB level**: Filter components by company/brand, and location-scope quantities
2. **What we CANNOT do at DB level**: Sort by computed forecast values (daysUntilRunout, consumption rate)

Since forecasts are calculated values based on transaction history, true DB-level sorting on `daysUntilRunout` or `averageDailyConsumption` would require:
- Either: A materialized view/table storing forecast snapshots (complex, outside scope)
- Or: In-memory sort after computation (current approach, acceptable for filtered datasets)

The implementation filters the dataset significantly at the DB level (by company, brand, location), making the in-memory sort performant. This is a reasonable trade-off for a medium-complexity enhancement.

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Phase 1 (Types) | 30m |
| Phase 2 (Services) | 3h |
| Phase 3 (API Routes) | 2h |
| Phase 4 (Tests) | 2.5h |
| Phase 5 (Validation) | 30m |
| **Total** | **~8.5h** |

---

**Investigation Duration**: 25 minutes
**Validation Duration**: 5 minutes
**Planning Duration**: 15 minutes
**Total Scout-and-Plan Time**: 45 minutes
