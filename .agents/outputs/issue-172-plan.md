# Implementation Plan: Feedback Loop System
**Generated**: 2025-12-04T22:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #172
**Estimated Build Time**: 16-20 hours (LARGE - should be phased)
**Complexity**: High

## Investigation Summary

### Request Analysis
**Type**: Feature (Multi-phase)
**Source**: GitHub Issue #172
**Priority**: High

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED (per phase)
**Suggested Filter**: None (multiple feature areas)

### Issue Validation
**Status**: Valid
**Recent Changes**: None affecting this area
**Email Configuration**: PENDING (not yet configured - implementation can proceed with stubbed email service)

### Current State Assessment
- **Existing feedback components**: FeedbackButton.tsx, FeedbackDialog.tsx (fully functional)
- **Existing feedback API**: /api/feedback, /api/feedback/clarify (creates GitHub issues)
- **Existing feedback types**: src/types/feedback.ts (FeedbackType, FeedbackStep, schemas)
- **Database**: No Feedback table exists - only in-memory feedback submission
- **Email service**: src/lib/email.ts (Resend-based for low-stock alerts)
- **GitHub integration**: @octokit/rest already installed and configured

### Dependencies & Blockers
1. **Azure AD / Microsoft 365 email account** - PENDING configuration (ai-coder@vital-enterprises.com)
2. **Microsoft Graph SDK for Node.js** - needs to be installed
3. **GitHub webhook endpoint** - needs to be created for issue closed events
4. **Reference implementation**: Entertask app at `/home/pbrown/Entertask` provides patterns for:
   - GraphEmailService.php (sending via Microsoft Graph)
   - GraphEmailReaderService.php (reading inbox via Microsoft Graph)
   - EmailApprovalParsingService.php (parsing reply keywords)

**Can Proceed?**: YES - with email service stubbed for Phase 3

### Complexity Assessment
**Complexity**: High
**Effort**: 16-20 hours total across 3 phases
**Risk**: Medium (external dependencies on Azure AD configuration)

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/services/lowstock-alert.ts` - service layer pattern
**Secondary**: `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts` - API route with Octokit
**Reference**: `/home/pbrown/Entertask/laravel/app/Services/GraphEmailService.php` - Microsoft Graph email pattern

### Ripple Effect Analysis
**Files Identified**: 12+ files across all phases

**Phase 1 (Track Submitter)**:
- `prisma/schema.prisma` - add Feedback model
- `src/types/feedback.ts` - add Feedback types
- `src/services/feedback.ts` - NEW service file
- `src/app/api/feedback/route.ts` - modify to save feedback records
- `src/components/features/FeedbackDialog.tsx` - minor: display tracking info

**Phase 2 (Completion Notification)**:
- `src/app/api/webhooks/github/route.ts` - NEW webhook endpoint
- `src/lib/email.ts` - add feedback notification templates
- `src/services/feedback.ts` - add notification logic

**Phase 3 (Email Reply Processing)**:
- `src/lib/graph-email.ts` - NEW Microsoft Graph email service
- `src/services/feedback.ts` - add reply processing logic
- `src/app/api/cron/email-monitor/route.ts` - NEW polling endpoint

---

## Executive Summary

This feature creates a complete feedback loop from user submission through resolution verification. Phase 1 adds database persistence linking feedback to users and GitHub issues. Phase 2 sends email notifications when issues are closed via GitHub webhooks. Phase 3 processes email replies to either verify fixes or create follow-up issues. Due to pending email configuration, implementation should stub the email service in Phase 3.

---

## Phase 1: Track Submitter (4-6 hours)

### Goal
Add database persistence for feedback submissions, linking them to the submitting user and the created GitHub issue.

### Subtask 1.1: Add Feedback Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow existing model structure (e.g., DefectAlert, SecurityEvent)
**Instructions**:
1. Add the Feedback model after the existing models:
```prisma
// ============================================
// Feedback Tracking
// ============================================

enum FeedbackStatus {
  pending        // Issue created, awaiting resolution
  in_progress    // Developer working on it
  resolved       // Issue closed, awaiting user verification
  verified       // User confirmed fix works
  reopened       // User requested changes, follow-up created
}

model Feedback {
  id                  String         @id @default(uuid())
  userId              String
  user                User           @relation(fields: [userId], references: [id])
  type                String         @db.VarChar(20) // 'bug' | 'feature'
  description         String         @db.Text
  githubIssueNumber   Int
  githubIssueUrl      String         @db.VarChar(500)
  status              FeedbackStatus @default(pending)
  emailMessageId      String?        @db.VarChar(255) // For tracking notification emails
  resolvedAt          DateTime?
  verifiedAt          DateTime?
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt

  replies FeedbackReply[]

  @@index([userId])
  @@index([githubIssueNumber])
  @@index([status])
}

model FeedbackReply {
  id                  String   @id @default(uuid())
  feedbackId          String
  feedback            Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  emailMessageId      String?  @db.VarChar(255) // Email message ID for tracking
  content             String   @db.Text
  action              String   @db.VarChar(20) // 'verified' | 'changes_requested'
  followUpIssueNumber Int?     // If changes requested, the new issue number
  followUpIssueUrl    String?  @db.VarChar(500)
  createdAt           DateTime @default(now())

  @@index([feedbackId])
}
```
2. Add relation to User model (find existing User model):
```prisma
// Add to User model relations section:
feedbacks Feedback[]
```
3. Run `npx prisma migrate dev --name add_feedback_tracking`
4. Run `npx prisma generate`

**Completion Criteria**:
- [ ] Feedback and FeedbackReply models added to schema
- [ ] User relation added
- [ ] Migration runs without errors
- [ ] Prisma client regenerated
- [ ] `npx prisma validate` passes

### Subtask 1.2: Add Feedback TypeScript Types
**File**: `/home/pbrown/SkuInventory/src/types/feedback.ts`
**Pattern**: Follow existing type definitions in same file
**Instructions**:
1. Add these types after the existing feedback types:
```typescript
// Feedback status enum (matches Prisma)
export type FeedbackStatus = 'pending' | 'in_progress' | 'resolved' | 'verified' | 'reopened'

// Feedback reply action enum
export type FeedbackReplyAction = 'verified' | 'changes_requested'

// Feedback record (database entity)
export interface FeedbackRecord {
  id: string
  userId: string
  userName?: string
  userEmail?: string
  type: FeedbackType
  description: string
  githubIssueNumber: number
  githubIssueUrl: string
  status: FeedbackStatus
  emailMessageId: string | null
  resolvedAt: string | null
  verifiedAt: string | null
  createdAt: string
  updatedAt: string
  replies?: FeedbackReplyRecord[]
}

// Feedback reply record
export interface FeedbackReplyRecord {
  id: string
  feedbackId: string
  emailMessageId: string | null
  content: string
  action: FeedbackReplyAction
  followUpIssueNumber: number | null
  followUpIssueUrl: string | null
  createdAt: string
}

// Create feedback input (internal, from API)
export interface CreateFeedbackInput {
  userId: string
  type: FeedbackType
  description: string
  githubIssueNumber: number
  githubIssueUrl: string
}

// Update feedback status input
export interface UpdateFeedbackStatusInput {
  status: FeedbackStatus
  resolvedAt?: Date
  verifiedAt?: Date
  emailMessageId?: string
}
```

**Completion Criteria**:
- [ ] All types added
- [ ] No TypeScript errors
- [ ] `npx tsc --noEmit` passes

### Subtask 1.3: Create Feedback Service
**File**: `/home/pbrown/SkuInventory/src/services/feedback.ts` (NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/services/lowstock-alert.ts` for service structure
**Instructions**:
1. Create new service file with these functions:
```typescript
import { prisma } from '@/lib/db'
import type {
  FeedbackRecord,
  FeedbackReplyRecord,
  CreateFeedbackInput,
  UpdateFeedbackStatusInput,
  FeedbackStatus,
} from '@/types/feedback'

/**
 * Create a new feedback record
 */
export async function createFeedback(input: CreateFeedbackInput): Promise<FeedbackRecord> {
  const feedback = await prisma.feedback.create({
    data: {
      userId: input.userId,
      type: input.type,
      description: input.description,
      githubIssueNumber: input.githubIssueNumber,
      githubIssueUrl: input.githubIssueUrl,
      status: 'pending',
    },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
  })

  return {
    id: feedback.id,
    userId: feedback.userId,
    userName: feedback.user.name,
    userEmail: feedback.user.email,
    type: feedback.type as 'bug' | 'feature',
    description: feedback.description,
    githubIssueNumber: feedback.githubIssueNumber,
    githubIssueUrl: feedback.githubIssueUrl,
    status: feedback.status as FeedbackStatus,
    emailMessageId: feedback.emailMessageId,
    resolvedAt: feedback.resolvedAt?.toISOString() ?? null,
    verifiedAt: feedback.verifiedAt?.toISOString() ?? null,
    createdAt: feedback.createdAt.toISOString(),
    updatedAt: feedback.updatedAt.toISOString(),
  }
}

/**
 * Get feedback by GitHub issue number
 */
export async function getFeedbackByIssueNumber(
  issueNumber: number
): Promise<FeedbackRecord | null> {
  const feedback = await prisma.feedback.findFirst({
    where: { githubIssueNumber: issueNumber },
    include: {
      user: {
        select: { name: true, email: true },
      },
      replies: {
        orderBy: { createdAt: 'desc' },
      },
    },
  })

  if (!feedback) return null

  return {
    id: feedback.id,
    userId: feedback.userId,
    userName: feedback.user.name,
    userEmail: feedback.user.email,
    type: feedback.type as 'bug' | 'feature',
    description: feedback.description,
    githubIssueNumber: feedback.githubIssueNumber,
    githubIssueUrl: feedback.githubIssueUrl,
    status: feedback.status as FeedbackStatus,
    emailMessageId: feedback.emailMessageId,
    resolvedAt: feedback.resolvedAt?.toISOString() ?? null,
    verifiedAt: feedback.verifiedAt?.toISOString() ?? null,
    createdAt: feedback.createdAt.toISOString(),
    updatedAt: feedback.updatedAt.toISOString(),
    replies: feedback.replies.map(r => ({
      id: r.id,
      feedbackId: r.feedbackId,
      emailMessageId: r.emailMessageId,
      content: r.content,
      action: r.action as 'verified' | 'changes_requested',
      followUpIssueNumber: r.followUpIssueNumber,
      followUpIssueUrl: r.followUpIssueUrl,
      createdAt: r.createdAt.toISOString(),
    })),
  }
}

/**
 * Update feedback status
 */
export async function updateFeedbackStatus(
  feedbackId: string,
  input: UpdateFeedbackStatusInput
): Promise<FeedbackRecord> {
  const feedback = await prisma.feedback.update({
    where: { id: feedbackId },
    data: {
      status: input.status,
      ...(input.resolvedAt && { resolvedAt: input.resolvedAt }),
      ...(input.verifiedAt && { verifiedAt: input.verifiedAt }),
      ...(input.emailMessageId && { emailMessageId: input.emailMessageId }),
    },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
  })

  return {
    id: feedback.id,
    userId: feedback.userId,
    userName: feedback.user.name,
    userEmail: feedback.user.email,
    type: feedback.type as 'bug' | 'feature',
    description: feedback.description,
    githubIssueNumber: feedback.githubIssueNumber,
    githubIssueUrl: feedback.githubIssueUrl,
    status: feedback.status as FeedbackStatus,
    emailMessageId: feedback.emailMessageId,
    resolvedAt: feedback.resolvedAt?.toISOString() ?? null,
    verifiedAt: feedback.verifiedAt?.toISOString() ?? null,
    createdAt: feedback.createdAt.toISOString(),
    updatedAt: feedback.updatedAt.toISOString(),
  }
}

/**
 * Get user's feedback history
 */
export async function getUserFeedback(userId: string): Promise<FeedbackRecord[]> {
  const feedbacks = await prisma.feedback.findMany({
    where: { userId },
    include: {
      user: {
        select: { name: true, email: true },
      },
    },
    orderBy: { createdAt: 'desc' },
  })

  return feedbacks.map(f => ({
    id: f.id,
    userId: f.userId,
    userName: f.user.name,
    userEmail: f.user.email,
    type: f.type as 'bug' | 'feature',
    description: f.description,
    githubIssueNumber: f.githubIssueNumber,
    githubIssueUrl: f.githubIssueUrl,
    status: f.status as FeedbackStatus,
    emailMessageId: f.emailMessageId,
    resolvedAt: f.resolvedAt?.toISOString() ?? null,
    verifiedAt: f.verifiedAt?.toISOString() ?? null,
    createdAt: f.createdAt.toISOString(),
    updatedAt: f.updatedAt.toISOString(),
  }))
}
```

**Completion Criteria**:
- [ ] Service file created
- [ ] All functions implemented
- [ ] No TypeScript errors
- [ ] `npx tsc --noEmit` passes

### Subtask 1.4: Update Feedback API Route to Save Records
**File**: `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts`
**Pattern**: Existing route structure
**Instructions**:
1. Import the new service:
```typescript
import { createFeedback } from '@/services/feedback'
```
2. After successful GitHub issue creation (after line ~100), add:
```typescript
// Save feedback record to database
await createFeedback({
  userId: session.user.id,
  type: feedbackType,
  description,
  githubIssueNumber: issueNumber,
  githubIssueUrl: issueUrl,
})
```
3. The response remains unchanged (issueUrl, issueNumber)

**Completion Criteria**:
- [ ] Import added
- [ ] createFeedback called after issue creation
- [ ] No TypeScript errors
- [ ] Existing functionality preserved

### Subtask 1.5: Add Unit Test for Feedback Service
**File**: `/home/pbrown/SkuInventory/tests/unit/feedback-service.test.ts` (NEW)
**Pattern**: Follow existing test patterns
**Instructions**:
Create basic unit tests for the feedback service functions.

**Completion Criteria**:
- [ ] Test file created
- [ ] Tests for createFeedback, getFeedbackByIssueNumber, updateFeedbackStatus
- [ ] Tests pass: `npm test -- --testPathPattern="feedback-service"`

### Phase 1 Validation
```bash
npx prisma validate
npx prisma migrate status
npx tsc --noEmit
npm run build
npm test -- --testPathPattern="feedback"
```

---

## Phase 2: Completion Notification (4-6 hours)

### Goal
When a GitHub issue is closed, send an email notification to the user who submitted the feedback.

### Subtask 2.1: Create GitHub Webhook Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/webhooks/github/route.ts` (NEW directory and file)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/cron/alerts/route.ts` for webhook authentication pattern
**Instructions**:
1. Create directory: `src/app/api/webhooks/github/`
2. Create route.ts with:
```typescript
import { NextRequest } from 'next/server'
import crypto from 'crypto'
import { getFeedbackByIssueNumber, updateFeedbackStatus } from '@/services/feedback'
import { sendFeedbackResolutionEmail } from '@/lib/email'

// Verify GitHub webhook signature
function verifyGitHubSignature(payload: string, signature: string | null): boolean {
  if (!signature) return false

  const secret = process.env.GITHUB_WEBHOOK_SECRET
  if (!secret) {
    console.error('GITHUB_WEBHOOK_SECRET not configured')
    return false
  }

  const hmac = crypto.createHmac('sha256', secret)
  const digest = 'sha256=' + hmac.update(payload).digest('hex')

  try {
    return crypto.timingSafeEqual(Buffer.from(digest), Buffer.from(signature))
  } catch {
    return false
  }
}

/**
 * POST /api/webhooks/github - Handle GitHub webhook events
 *
 * Handles: issues (closed event)
 */
export async function POST(request: NextRequest) {
  try {
    const payload = await request.text()
    const signature = request.headers.get('x-hub-signature-256')

    // Verify signature in production
    if (process.env.NODE_ENV === 'production') {
      if (!verifyGitHubSignature(payload, signature)) {
        console.error('Invalid GitHub webhook signature')
        return new Response('Invalid signature', { status: 401 })
      }
    }

    const event = request.headers.get('x-github-event')
    const body = JSON.parse(payload)

    // Handle issue events
    if (event === 'issues') {
      const action = body.action
      const issueNumber = body.issue?.number

      if (action === 'closed' && issueNumber) {
        console.log(`[Webhook] Issue #${issueNumber} closed`)

        // Find linked feedback
        const feedback = await getFeedbackByIssueNumber(issueNumber)

        if (feedback && feedback.status === 'pending') {
          // Update status to resolved
          await updateFeedbackStatus(feedback.id, {
            status: 'resolved',
            resolvedAt: new Date(),
          })

          // Send notification email
          if (feedback.userEmail) {
            try {
              await sendFeedbackResolutionEmail({
                to: feedback.userEmail,
                userName: feedback.userName ?? 'User',
                feedbackType: feedback.type,
                issueNumber: feedback.githubIssueNumber,
                issueUrl: feedback.githubIssueUrl,
                description: feedback.description,
              })
              console.log(`[Webhook] Notification email sent to ${feedback.userEmail}`)
            } catch (emailError) {
              console.error('[Webhook] Failed to send notification email:', emailError)
              // Don't fail the webhook - email failure shouldn't block
            }
          }
        }
      }
    }

    return new Response('OK', { status: 200 })
  } catch (error) {
    console.error('[Webhook] Error processing GitHub webhook:', error)
    return new Response('Internal error', { status: 500 })
  }
}
```

**Completion Criteria**:
- [ ] Directory and file created
- [ ] Webhook signature verification implemented
- [ ] Issue closed handling implemented
- [ ] No TypeScript errors

### Subtask 2.2: Add Feedback Resolution Email Template
**File**: `/home/pbrown/SkuInventory/src/lib/email.ts`
**Pattern**: Follow existing formatLowStockAlertEmail function
**Instructions**:
1. Add interface and function after existing email functions:
```typescript
// Feedback resolution email data
export interface FeedbackResolutionEmailData {
  to: string
  userName: string
  feedbackType: 'bug' | 'feature'
  issueNumber: number
  issueUrl: string
  description: string
}

/**
 * Send feedback resolution notification email
 */
export async function sendFeedbackResolutionEmail(data: FeedbackResolutionEmailData): Promise<void> {
  const typeLabel = data.feedbackType === 'bug' ? 'Bug Report' : 'Feature Request'

  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background-color: #f4f4f5;">
  <div style="max-width: 600px; margin: 0 auto; background-color: white; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
    <div style="background-color: #10b981; color: white; padding: 20px; text-align: center;">
      <h1 style="margin: 0; font-size: 24px;">Your ${typeLabel} Has Been Resolved!</h1>
    </div>
    <div style="padding: 24px;">
      <p style="margin: 0 0 16px; color: #374151;">Hi ${data.userName},</p>
      <p style="margin: 0 0 16px; color: #374151;">
        Great news! Your ${typeLabel.toLowerCase()} has been addressed and the issue has been closed.
      </p>

      <div style="background-color: #f9fafb; border-radius: 6px; padding: 16px; margin: 16px 0;">
        <p style="margin: 0 0 8px; font-weight: 600; color: #374151;">Issue #${data.issueNumber}</p>
        <p style="margin: 0; color: #6b7280; font-size: 14px;">${data.description.substring(0, 200)}${data.description.length > 200 ? '...' : ''}</p>
      </div>

      <p style="margin: 16px 0; color: #374151;">
        <strong>Please verify the fix works for your use case.</strong> You can reply to this email with:
      </p>

      <ul style="margin: 16px 0; padding-left: 20px; color: #374151;">
        <li><strong>"Verified"</strong> or <strong>"Looks good"</strong> - if the fix works</li>
        <li><strong>"Changes needed"</strong> or describe the issue - if further work is required</li>
      </ul>

      <div style="text-align: center; margin-top: 24px;">
        <a href="${data.issueUrl}" style="display: inline-block; background-color: #2563eb; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: 500;">View Issue on GitHub</a>
      </div>
    </div>
    <div style="background-color: #f9fafb; padding: 16px; text-align: center; font-size: 12px; color: #6b7280;">
      <p style="margin: 0;">Sent by Trevor Inventory Feedback System</p>
    </div>
  </div>
</body>
</html>`

  const text = `Your ${typeLabel} Has Been Resolved!

Hi ${data.userName},

Great news! Your ${typeLabel.toLowerCase()} has been addressed and the issue has been closed.

Issue #${data.issueNumber}
${data.description.substring(0, 200)}${data.description.length > 200 ? '...' : ''}

Please verify the fix works for your use case. Reply to this email with:
- "Verified" or "Looks good" - if the fix works
- "Changes needed" or describe the issue - if further work is required

View Issue: ${data.issueUrl}

Sent by Trevor Inventory Feedback System`

  const message: EmailMessage = {
    to: [data.to],
    subject: \`[Resolved] Your \${typeLabel} #\${data.issueNumber}\`,
    html,
    text,
  }

  await sendEmail(message)
}
```

**Completion Criteria**:
- [ ] Interface added
- [ ] Email template implemented
- [ ] No TypeScript errors

### Subtask 2.3: Add GITHUB_WEBHOOK_SECRET to Environment
**File**: `/home/pbrown/SkuInventory/.env.example`
**Instructions**:
Add after GITHUB_API_TOKEN:
```
# GitHub Webhook Secret for verifying webhook signatures
# Generate with: openssl rand -hex 32
# Configure in GitHub repo Settings > Webhooks
GITHUB_WEBHOOK_SECRET=your-webhook-secret-here
```

**Completion Criteria**:
- [ ] Environment variable documented

### Subtask 2.4: Add Unit Test for Webhook Handler
**File**: `/home/pbrown/SkuInventory/tests/unit/github-webhook.test.ts` (NEW)
**Instructions**:
Create tests for webhook signature verification and issue closed handling.

**Completion Criteria**:
- [ ] Test file created
- [ ] Tests pass

### Phase 2 Validation
```bash
npx tsc --noEmit
npm run build
npm test -- --testPathPattern="webhook\|feedback"
```

---

## Phase 3: Email Reply Processing (6-8 hours)

### Goal
Monitor the feedback email inbox for replies. Parse replies to determine if user verified the fix or needs changes. Create follow-up GitHub issues if changes are needed.

**NOTE**: Email configuration is PENDING. This phase should implement the service layer with a stub that can be enabled once Azure AD is configured.

### Subtask 3.1: Install Microsoft Graph SDK
**Command**: `npm install @microsoft/microsoft-graph-client @azure/identity`
**Instructions**:
```bash
cd /home/pbrown/SkuInventory
npm install @microsoft/microsoft-graph-client @azure/identity
```

**Completion Criteria**:
- [ ] Packages installed
- [ ] package.json updated

### Subtask 3.2: Create Microsoft Graph Email Service
**File**: `/home/pbrown/SkuInventory/src/lib/graph-email.ts` (NEW)
**Pattern**: Follow `/home/pbrown/Entertask/laravel/app/Services/GraphEmailReaderService.php`
**Instructions**:
Create a TypeScript service for Microsoft Graph email operations:
```typescript
import { Client } from '@microsoft/microsoft-graph-client'
import { ClientSecretCredential } from '@azure/identity'
import { TokenCredentialAuthenticationProvider } from '@microsoft/microsoft-graph-client/authProviders/azureTokenCredentials'

// Configuration
const AZURE_TENANT_ID = process.env.AZURE_TENANT_ID
const AZURE_CLIENT_ID = process.env.AZURE_CLIENT_ID
const AZURE_CLIENT_SECRET = process.env.AZURE_CLIENT_SECRET
const FEEDBACK_EMAIL = process.env.FEEDBACK_EMAIL // ai-coder@vital-enterprises.com

export interface EmailMessage {
  id: string
  from: string
  subject: string
  body: string
  receivedAt: string
  inReplyTo: string | null
  references: string | null
}

/**
 * Check if Graph Email service is configured
 */
export function isGraphEmailConfigured(): boolean {
  return !!(AZURE_TENANT_ID && AZURE_CLIENT_ID && AZURE_CLIENT_SECRET && FEEDBACK_EMAIL)
}

/**
 * Get Microsoft Graph client
 */
function getGraphClient(): Client | null {
  if (!isGraphEmailConfigured()) {
    console.warn('Microsoft Graph email not configured')
    return null
  }

  const credential = new ClientSecretCredential(
    AZURE_TENANT_ID!,
    AZURE_CLIENT_ID!,
    AZURE_CLIENT_SECRET!
  )

  const authProvider = new TokenCredentialAuthenticationProvider(credential, {
    scopes: ['https://graph.microsoft.com/.default'],
  })

  return Client.initWithMiddleware({ authProvider })
}

/**
 * Fetch new emails since last check (replies only)
 */
export async function fetchNewReplies(sinceDate: Date): Promise<EmailMessage[]> {
  const client = getGraphClient()
  if (!client) return []

  try {
    const filterDate = sinceDate.toISOString()

    const result = await client
      .api(\`/users/\${FEEDBACK_EMAIL}/messages\`)
      .filter(\`receivedDateTime ge \${filterDate}\`)
      .select('id,from,subject,body,receivedDateTime,internetMessageHeaders')
      .orderby('receivedDateTime')
      .get()

    const emails: EmailMessage[] = []

    for (const message of result.value || []) {
      // Check if this is a reply by looking for In-Reply-To header
      const headers = message.internetMessageHeaders || []
      const inReplyTo = headers.find((h: { name: string }) =>
        h.name.toLowerCase() === 'in-reply-to'
      )?.value
      const references = headers.find((h: { name: string }) =>
        h.name.toLowerCase() === 'references'
      )?.value

      // Skip if not a reply
      if (!inReplyTo && !references) continue

      emails.push({
        id: message.id,
        from: message.from?.emailAddress?.address || '',
        subject: message.subject || '',
        body: message.body?.content || '',
        receivedAt: message.receivedDateTime,
        inReplyTo: inReplyTo || null,
        references: references || null,
      })
    }

    return emails
  } catch (error) {
    console.error('Failed to fetch emails via Graph API:', error)
    return []
  }
}

/**
 * Test Graph API connection
 */
export async function testGraphConnection(): Promise<boolean> {
  const client = getGraphClient()
  if (!client) return false

  try {
    await client
      .api(\`/users/\${FEEDBACK_EMAIL}/messages\`)
      .top(1)
      .select('id')
      .get()
    return true
  } catch (error) {
    console.error('Graph API connection test failed:', error)
    return false
  }
}
```

**Completion Criteria**:
- [ ] Service file created
- [ ] All functions implemented
- [ ] Graceful fallback when not configured

### Subtask 3.3: Create Email Reply Parsing Service
**File**: `/home/pbrown/SkuInventory/src/services/email-parsing.ts` (NEW)
**Pattern**: Follow `/home/pbrown/Entertask/laravel/app/Services/EmailApprovalParsingService.php`
**Instructions**:
```typescript
/**
 * Keywords indicating verification
 */
const VERIFY_KEYWORDS = [
  'verified',
  'looks good',
  'works',
  'fixed',
  'confirmed',
  'approved',
  'great',
  'perfect',
  'thank you',
  'thanks',
]

/**
 * Keywords indicating changes needed
 */
const CHANGE_KEYWORDS = [
  'changes needed',
  'not working',
  'still broken',
  'issue remains',
  'problem persists',
  'needs more work',
  "doesn't work",
  'still not',
  'still having',
]

export interface ParseResult {
  action: 'verified' | 'changes_requested' | null
  keyword: string | null
  cleanedBody: string
}

/**
 * Clean email body by removing quoted text and signatures
 */
function cleanEmailBody(body: string): string {
  // Remove HTML tags if present
  let cleaned = body.replace(/<[^>]*>/g, '')

  const lines = cleaned.split('\n')
  const cleanedLines: string[] = []

  for (const line of lines) {
    const trimmed = line.trim()

    // Skip empty lines
    if (!trimmed) continue

    // Stop at signature delimiters
    if (['--', '---', '____', '===='].includes(trimmed)) break

    // Skip quoted lines
    if (trimmed.startsWith('>')) continue

    // Skip email client headers
    if (/^(On .+ wrote:|From:|Sent:|To:|Subject:)/i.test(trimmed)) break

    // Skip "Sent from" signatures
    if (/^Sent from /i.test(trimmed)) break

    cleanedLines.push(trimmed)

    // Stop after first substantial paragraph
    if (cleanedLines.length >= 10) break
  }

  return cleanedLines.join(' ')
}

/**
 * Find keyword in text
 */
function findKeyword(text: string, keywords: string[]): string | null {
  const textLower = text.toLowerCase()

  for (const keyword of keywords) {
    const pattern = new RegExp(\`\\\\b\${keyword.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b\`, 'i')
    if (pattern.test(textLower)) {
      return keyword
    }
  }

  return null
}

/**
 * Parse email body for verification or change request
 */
export function parseReplyDecision(emailBody: string): ParseResult {
  const cleanedBody = cleanEmailBody(emailBody)

  const verifyKeyword = findKeyword(cleanedBody, VERIFY_KEYWORDS)
  const changeKeyword = findKeyword(cleanedBody, CHANGE_KEYWORDS)

  // Handle ambiguous case
  if (verifyKeyword && changeKeyword) {
    console.warn('Ambiguous email - contains both verify and change keywords')
    return { action: null, keyword: null, cleanedBody }
  }

  if (verifyKeyword) {
    return { action: 'verified', keyword: verifyKeyword, cleanedBody }
  }

  if (changeKeyword) {
    return { action: 'changes_requested', keyword: changeKeyword, cleanedBody }
  }

  return { action: null, keyword: null, cleanedBody }
}
```

**Completion Criteria**:
- [ ] Service file created
- [ ] Keyword parsing implemented
- [ ] Body cleaning implemented

### Subtask 3.4: Add Email Reply Processing to Feedback Service
**File**: `/home/pbrown/SkuInventory/src/services/feedback.ts`
**Instructions**:
Add functions for processing email replies and creating follow-up issues:
```typescript
import { Octokit } from '@octokit/rest'
import { parseReplyDecision } from './email-parsing'

const GITHUB_OWNER = 'PaultheAICoder'
const GITHUB_REPO = 'SkuInventoryDatabase'

/**
 * Create a feedback reply record
 */
export async function createFeedbackReply(
  feedbackId: string,
  input: {
    emailMessageId?: string
    content: string
    action: 'verified' | 'changes_requested'
    followUpIssueNumber?: number
    followUpIssueUrl?: string
  }
): Promise<FeedbackReplyRecord> {
  const reply = await prisma.feedbackReply.create({
    data: {
      feedbackId,
      emailMessageId: input.emailMessageId ?? null,
      content: input.content,
      action: input.action,
      followUpIssueNumber: input.followUpIssueNumber ?? null,
      followUpIssueUrl: input.followUpIssueUrl ?? null,
    },
  })

  return {
    id: reply.id,
    feedbackId: reply.feedbackId,
    emailMessageId: reply.emailMessageId,
    content: reply.content,
    action: reply.action as 'verified' | 'changes_requested',
    followUpIssueNumber: reply.followUpIssueNumber,
    followUpIssueUrl: reply.followUpIssueUrl,
    createdAt: reply.createdAt.toISOString(),
  }
}

/**
 * Process an email reply for feedback
 */
export async function processEmailReply(
  feedback: FeedbackRecord,
  emailBody: string,
  emailMessageId?: string
): Promise<{ action: string; followUpIssue?: { number: number; url: string } }> {
  const { action, cleanedBody } = parseReplyDecision(emailBody)

  if (!action) {
    console.log(\`[Feedback] Could not determine action from reply for feedback \${feedback.id}\`)
    return { action: 'unknown' }
  }

  if (action === 'verified') {
    // Mark as verified
    await updateFeedbackStatus(feedback.id, {
      status: 'verified',
      verifiedAt: new Date(),
    })

    await createFeedbackReply(feedback.id, {
      emailMessageId,
      content: cleanedBody,
      action: 'verified',
    })

    return { action: 'verified' }
  }

  if (action === 'changes_requested') {
    // Create follow-up GitHub issue
    const githubToken = process.env.GITHUB_API_TOKEN
    if (!githubToken) {
      throw new Error('GITHUB_API_TOKEN not configured')
    }

    const octokit = new Octokit({ auth: githubToken })

    const { data: issue } = await octokit.issues.create({
      owner: GITHUB_OWNER,
      repo: GITHUB_REPO,
      title: \`[Follow-up] Re: Issue #\${feedback.githubIssueNumber} - Changes Requested\`,
      body: \`## Follow-up to Issue #\${feedback.githubIssueNumber}

**Original Issue**: \${feedback.githubIssueUrl}
**Submitter**: User requested additional changes

### User Feedback
\${cleanedBody}

### Original Description
\${feedback.description}

---
*This issue was automatically created from an email reply.*\`,
      labels: [feedback.type === 'bug' ? 'bug' : 'enhancement', 'follow-up'],
    })

    // Update feedback status
    await updateFeedbackStatus(feedback.id, {
      status: 'reopened',
    })

    // Record the reply
    await createFeedbackReply(feedback.id, {
      emailMessageId,
      content: cleanedBody,
      action: 'changes_requested',
      followUpIssueNumber: issue.number,
      followUpIssueUrl: issue.html_url,
    })

    return {
      action: 'changes_requested',
      followUpIssue: {
        number: issue.number,
        url: issue.html_url,
      },
    }
  }

  return { action: 'unknown' }
}
```

**Completion Criteria**:
- [ ] Functions added
- [ ] Follow-up issue creation works
- [ ] No TypeScript errors

### Subtask 3.5: Create Email Monitoring Cron Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/cron/email-monitor/route.ts` (NEW)
**Pattern**: Follow `/home/pbrown/SkuInventory/src/app/api/cron/alerts/route.ts`
**Instructions**:
```typescript
import { NextRequest } from 'next/server'
import { fetchNewReplies, isGraphEmailConfigured } from '@/lib/graph-email'
import { getFeedbackByIssueNumber, processEmailReply } from '@/services/feedback'

// Cache for last check time (in production, use Redis or database)
let lastCheckTime = new Date(Date.now() - 15 * 60 * 1000) // Default: 15 minutes ago

/**
 * GET /api/cron/email-monitor - Poll for email replies
 *
 * Should be called by a cron job every 5 minutes
 * Protected by CRON_SECRET
 */
export async function GET(request: NextRequest) {
  // Verify cron secret
  const authHeader = request.headers.get('authorization')
  const cronSecret = process.env.CRON_SECRET

  if (!cronSecret || authHeader !== \`Bearer \${cronSecret}\`) {
    return new Response('Unauthorized', { status: 401 })
  }

  // Check if email is configured
  if (!isGraphEmailConfigured()) {
    return Response.json({
      status: 'skipped',
      reason: 'Email monitoring not configured',
    })
  }

  try {
    const emails = await fetchNewReplies(lastCheckTime)
    lastCheckTime = new Date()

    const results = {
      processed: 0,
      verified: 0,
      changesRequested: 0,
      errors: [] as string[],
    }

    for (const email of emails) {
      try {
        // Extract issue number from subject (format: "[Resolved] Your Bug Report #123")
        const match = email.subject.match(/#(\\d+)/)
        if (!match) continue

        const issueNumber = parseInt(match[1], 10)
        const feedback = await getFeedbackByIssueNumber(issueNumber)

        if (!feedback || feedback.status !== 'resolved') continue

        // Verify sender matches the original submitter
        if (feedback.userEmail?.toLowerCase() !== email.from.toLowerCase()) {
          console.warn(\`Email from \${email.from} doesn't match feedback submitter \${feedback.userEmail}\`)
          continue
        }

        const result = await processEmailReply(feedback, email.body, email.id)
        results.processed++

        if (result.action === 'verified') results.verified++
        if (result.action === 'changes_requested') results.changesRequested++

      } catch (error) {
        results.errors.push(error instanceof Error ? error.message : 'Unknown error')
      }
    }

    return Response.json({
      status: 'success',
      emailsChecked: emails.length,
      ...results,
    })
  } catch (error) {
    console.error('Email monitoring error:', error)
    return Response.json({
      status: 'error',
      message: error instanceof Error ? error.message : 'Unknown error',
    }, { status: 500 })
  }
}
```

**Completion Criteria**:
- [ ] Endpoint created
- [ ] Cron secret verification
- [ ] Graceful handling when email not configured

### Subtask 3.6: Add Azure AD Environment Variables
**File**: `/home/pbrown/SkuInventory/.env.example`
**Instructions**:
Add after email configuration section:
```
# ============================================================================
# MICROSOFT GRAPH API (Email Reply Monitoring)
# ============================================================================
# Azure AD Application credentials for reading feedback inbox
# Email: ai-coder@vital-enterprises.com
# Configuration PENDING - feature is stubbed until configured

# Azure AD Tenant ID
AZURE_TENANT_ID=your-tenant-id

# Azure AD Application (Client) ID
AZURE_CLIENT_ID=your-client-id

# Azure AD Client Secret
AZURE_CLIENT_SECRET=your-client-secret

# Feedback email address to monitor
FEEDBACK_EMAIL=ai-coder@vital-enterprises.com
```

**Completion Criteria**:
- [ ] Environment variables documented

### Phase 3 Validation
```bash
npm install
npx tsc --noEmit
npm run build
npm test
```

---

## Summary of Deliverables

### Files Created
| File | Phase | Purpose |
|------|-------|---------|
| `prisma/schema.prisma` (modified) | 1 | Feedback, FeedbackReply models |
| `src/types/feedback.ts` (modified) | 1 | New types |
| `src/services/feedback.ts` | 1-3 | Feedback service |
| `src/app/api/webhooks/github/route.ts` | 2 | GitHub webhook handler |
| `src/lib/email.ts` (modified) | 2 | Resolution email template |
| `src/lib/graph-email.ts` | 3 | Microsoft Graph service |
| `src/services/email-parsing.ts` | 3 | Reply parsing |
| `src/app/api/cron/email-monitor/route.ts` | 3 | Email polling |
| `.env.example` (modified) | 2-3 | New env vars |
| `tests/unit/feedback-service.test.ts` | 1 | Unit tests |
| `tests/unit/github-webhook.test.ts` | 2 | Webhook tests |

### Files Modified
- `src/app/api/feedback/route.ts` - Save feedback records
- `prisma/schema.prisma` - Add Feedback models

### Environment Variables Required
| Variable | Phase | Status |
|----------|-------|--------|
| `GITHUB_WEBHOOK_SECRET` | 2 | Need to configure |
| `AZURE_TENANT_ID` | 3 | PENDING |
| `AZURE_CLIENT_ID` | 3 | PENDING |
| `AZURE_CLIENT_SECRET` | 3 | PENDING |
| `FEEDBACK_EMAIL` | 3 | PENDING |

---

## Handoff to Build Agent

1. **Execute Phase 1 first** - This is self-contained and can be fully tested
2. **Phase 2 requires GitHub webhook setup** - Create webhook in repo settings after deployment
3. **Phase 3 is STUBBED** - Email configuration is PENDING; implement with graceful fallback

### GitHub Webhook Setup (Phase 2)
After deploying Phase 2:
1. Go to GitHub repo Settings > Webhooks
2. Add webhook:
   - Payload URL: `https://your-domain/api/webhooks/github`
   - Content type: `application/json`
   - Secret: Generate and set in GITHUB_WEBHOOK_SECRET
   - Events: Select "Issues"

### Important Notes
- **Issue #172 should remain OPEN** after implementation until email is configured and tested
- Phase 3 email monitoring can be tested manually once Azure AD is configured
- All email functions gracefully degrade when not configured

---

## Test Strategy Note
- Use Vitest for unit tests
- Unit tests for service functions
- Integration tests for API routes
- Manual E2E test for full feedback loop once email configured

## Performance Metrics
| Phase | Estimated Duration |
|-------|-------------------|
| Phase 1 | 4-6 hours |
| Phase 2 | 4-6 hours |
| Phase 3 | 6-8 hours |
| **Total** | **14-20 hours** |

---

AGENT_RETURN: issue-172-plan
