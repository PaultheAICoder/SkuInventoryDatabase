# Implementation Plan
**Generated**: 2025-12-06T21:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: Issue #201
**Estimated Build Time**: 12-16 hours (1-2 days)
**Complexity**: High

## V2 DEFERRAL RECOMMENDATION

**RECOMMENDATION: DEFER TO V2**

This issue should be deferred to V2 based on:
1. **Explicit V2 label** - Issue is labeled with "v2" and "enhancement"
2. **Issue priority statement**: "Lower priority for V1 - The current approach works correctly, just has performance concerns that will manifest at scale. Can be deferred to V2 if needed."
3. **Parent issue guidance** - Parent issue #195 explicitly places this in "Phase 3: Performance & Simplification (V2)"
4. **Current system works correctly** - The on-the-fly aggregation produces correct results; this is an optimization
5. **Risk assessment** - Refactoring core inventory calculation has high regression risk for a non-blocking issue

If the stakeholder explicitly requests V1 implementation, continue with the plan below.

---

## Investigation Summary

### Request Analysis
**Type**: Enhancement (Performance Refactoring)
**Source**: GitHub Issue #201, child of #195 (Architectural Audit)
**Priority**: Low (V2 candidate)
**Labels**: enhancement, v2

### Task Classification
**Category**: REFACTORING
**Test Strategy**: FULL (architectural change to core inventory calculation)
**Suggested Filter**: None - full test suite required

### Issue Validation
**Status**: Valid but recommended for V2 deferral
**Recent Changes**: Dependencies #198, #199, #200 are all CLOSED (multi-tenancy enforcement complete)

### Current State Assessment

**Inventory Calculation (Problem Area):**
- Location: `/home/pbrown/SkuInventory/src/services/inventory.ts` (lines 46-266)
- `getComponentQuantity`: Single component, ~84 lines, 1-3 DB queries per call
- `getComponentQuantities`: Multiple components, ~124 lines, 1-3 DB queries per call
- `getComponentQuantitiesByLocation`: Calls `getComponentQuantity` N times for N locations

**Performance Profile:**
- Global query: 1 aggregate query
- Location-specific query: 3 aggregate queries (regular + transfer FROM + transfer TO)
- Batch location query: N * 3 queries for N locations

**Transaction Creation Paths (10 functions requiring balance updates):**
1. `createReceiptTransaction` - `/home/pbrown/SkuInventory/src/services/inventory.ts:346`
2. `createAdjustmentTransaction` - `/home/pbrown/SkuInventory/src/services/inventory.ts:512`
3. `createInitialTransaction` - `/home/pbrown/SkuInventory/src/services/inventory.ts:573`
4. `createBuildTransaction` - `/home/pbrown/SkuInventory/src/services/inventory.ts:911`
5. `createTransferTransaction` - `/home/pbrown/SkuInventory/src/services/transfer.ts:35`
6. `adjustFinishedGoods` - `/home/pbrown/SkuInventory/src/services/finished-goods.ts:158`
7. `receiveFinishedGoods` - `/home/pbrown/SkuInventory/src/services/finished-goods.ts:199`
8. `transferFinishedGoods` - `/home/pbrown/SkuInventory/src/services/finished-goods.ts:244`
9. `createOutboundTransaction` - `/home/pbrown/SkuInventory/src/services/finished-goods.ts:328`
10. `approveDraftTransaction` - `/home/pbrown/SkuInventory/src/services/draft-transaction.ts:356`

**Existing Tests:**
- `/home/pbrown/SkuInventory/tests/unit/inventory-quantity.test.ts` (409 lines)
- `/home/pbrown/SkuInventory/tests/unit/transfer-service.test.ts`
- `/home/pbrown/SkuInventory/tests/unit/finished-goods-service.test.ts`
- `/home/pbrown/SkuInventory/tests/integration/lot-consumption.test.ts`

### Dependencies & Blockers

1. **Multi-tenancy issues completed** - #198, #199, #200 are CLOSED
2. **No active blockers** - Dependencies satisfied
3. **Coordination required** - Backfill script needs production data backup

**Can Proceed?**: YES (if V2 deferral is overridden)

### Complexity Assessment
**Complexity**: High
**Effort**: 12-16 hours (1-2 days)
**Risk**: High - Core inventory calculation affects all inventory views, builds, transfers

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/prisma/schema.prisma` LotBalance model (lines 228-236) - snapshot pattern already exists
**Secondary**: `/home/pbrown/SkuInventory/src/services/inventory.ts` createReceiptTransaction lot balance upsert (lines 417-428)

### Ripple Effect Analysis
**Files Identified**: 20+

**Direct consumers of getComponentQuantity/getComponentQuantities:**
- `/home/pbrown/SkuInventory/src/app/api/components/[id]/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/components/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/dashboard/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/export/components/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/skus/[id]/bom-versions/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/clone/route.ts`
- `/home/pbrown/SkuInventory/src/app/api/bom-versions/[id]/activate/route.ts`
- `/home/pbrown/SkuInventory/src/app/(dashboard)/components/page.tsx`
- `/home/pbrown/SkuInventory/src/services/bom.ts`
- `/home/pbrown/SkuInventory/src/services/chatbot-queries.ts`
- `/home/pbrown/SkuInventory/src/services/lowstock-alert.ts`
- `/home/pbrown/SkuInventory/src/services/forecast.ts`
- `/home/pbrown/SkuInventory/src/services/transfer.ts`

**Files requiring balance update integration:**
- `/home/pbrown/SkuInventory/src/services/inventory.ts` (4 functions)
- `/home/pbrown/SkuInventory/src/services/transfer.ts` (1 function)
- `/home/pbrown/SkuInventory/src/services/finished-goods.ts` (4 functions)
- `/home/pbrown/SkuInventory/src/services/draft-transaction.ts` (1 function)

---

## Executive Summary

This plan refactors inventory calculations from O(N) aggregation to O(1) snapshot reads by:
1. Adding a `ComponentBalance` table to store pre-computed balances per component+location
2. Modifying all 10 transaction creation functions to atomically update balances
3. Creating a backfill script to initialize balances from existing transactions
4. Updating query functions to read from the balance table with fallback verification

---

## Phase 0: Pre-flight and Understanding

### Subtask 0.1: Verify Build and Test Baseline
**Instructions**:
1. Run `npm run build` - verify clean completion
2. Run `npx tsc --noEmit` - verify no type errors
3. Run `npm test` - capture baseline test results
4. Document any pre-existing warnings or failures
**Completion Criteria**:
- [ ] Build completes without errors
- [ ] TypeScript compiles without errors
- [ ] Test baseline documented

### Subtask 0.2: Document Current Query Performance
**Instructions**:
1. Add temporary timing logs to `getComponentQuantity` and `getComponentQuantities`
2. Measure query times with 10, 100, 1000 components
3. Document baseline performance metrics
**Completion Criteria**:
- [ ] Baseline performance documented
- [ ] Query count per call type documented

---

## Phase 1: Database Schema Layer

### Subtask 1.1: Add ComponentBalance Model to Prisma Schema
**File**: `/home/pbrown/SkuInventory/prisma/schema.prisma`
**Pattern**: Follow `LotBalance` model structure (lines 228-236)
**Instructions**:
1. Add ComponentBalance model after line 206 (after Component model):
```prisma
model ComponentBalance {
  id          String    @id @default(uuid())
  componentId String
  component   Component @relation(fields: [componentId], references: [id], onDelete: Cascade)
  locationId  String?
  location    Location? @relation(fields: [locationId], references: [id])
  quantity    Decimal   @db.Decimal(10, 4)
  updatedAt   DateTime  @updatedAt

  @@unique([componentId, locationId])
  @@index([componentId])
  @@index([locationId])
}
```
2. Add relation to Component model:
```prisma
  balances         ComponentBalance[]
```
3. Add relation to Location model:
```prisma
  componentBalances ComponentBalance[]
```
**Validation**:
```bash
npx prisma validate
```
**Completion Criteria**:
- [ ] Model added to schema.prisma
- [ ] Relations added to Component and Location models
- [ ] `npx prisma validate` passes

### Subtask 1.2: Create Migration
**Instructions**:
1. Run: `npx prisma migrate dev --name add_component_balance_table`
2. Verify migration creates the table with proper indexes
3. Verify cascade delete is configured
**Validation**:
```bash
npx prisma migrate status
```
**Completion Criteria**:
- [ ] Migration file created in `prisma/migrations/`
- [ ] Migration applies successfully
- [ ] Table created with indexes

### Subtask 1.3: Generate Prisma Client
**Instructions**:
1. Run: `npx prisma generate`
2. Verify types are available in IDE
**Validation**:
```bash
npx prisma generate && npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Client generated
- [ ] TypeScript compiles with new types

---

## Phase 2: TypeScript Types Layer

### Subtask 2.1: Add ComponentBalance Types (Optional)
**File**: `/home/pbrown/SkuInventory/src/types/component.ts` (if exists) or new file
**Instructions**:
1. If custom types are needed beyond Prisma-generated types, add them
2. This may not be necessary if Prisma types suffice
**Completion Criteria**:
- [ ] Types defined if needed
- [ ] TypeScript compiles

---

## Phase 3: Balance Update Integration - Inventory Service

### Subtask 3.1: Create Balance Update Helper Function
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Follow LotBalance upsert pattern (lines 417-428)
**Instructions**:
1. Add helper function after imports:
```typescript
/**
 * Update component balance atomically within a transaction
 * If locationId is null, updates global balance
 */
async function updateComponentBalance(
  tx: Prisma.TransactionClient,
  componentId: string,
  locationId: string | null,
  quantityChange: number
): Promise<void> {
  await tx.componentBalance.upsert({
    where: {
      componentId_locationId: {
        componentId,
        locationId: locationId ?? null,
      },
    },
    create: {
      componentId,
      locationId: locationId ?? null,
      quantity: new Prisma.Decimal(quantityChange),
    },
    update: {
      quantity: { increment: new Prisma.Decimal(quantityChange) },
    },
  })
}
```
**Completion Criteria**:
- [ ] Helper function added
- [ ] TypeScript compiles

### Subtask 3.2: Update createReceiptTransaction
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 346-507 (within $transaction block)
**Instructions**:
1. After creating the transaction (line 492), add balance updates:
```typescript
// Update component balance (location-specific)
await updateComponentBalance(tx, componentId, locationIdToUse, quantity)
// Update global balance (null location)
await updateComponentBalance(tx, componentId, null, quantity)
```
**Completion Criteria**:
- [ ] Balance updates added within transaction
- [ ] Both location-specific and global balances updated
- [ ] TypeScript compiles

### Subtask 3.3: Update createAdjustmentTransaction
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 512-568
**Instructions**:
1. Wrap in $transaction if not already
2. Add balance updates after creating transaction
**Completion Criteria**:
- [ ] Balance updates added
- [ ] TypeScript compiles

### Subtask 3.4: Update createInitialTransaction
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 573-657
**Instructions**:
1. Add balance updates after creating transaction within $transaction block
**Completion Criteria**:
- [ ] Balance updates added
- [ ] TypeScript compiles

### Subtask 3.5: Update createBuildTransaction
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 911-1240
**Instructions**:
1. After creating consumption lines, update balances for each component consumed:
```typescript
// Update balances for consumed components
for (const line of consumptionLines) {
  const qty = line.quantityChange.toNumber()
  await updateComponentBalance(tx, line.componentId, locationIdToUse, qty)
  await updateComponentBalance(tx, line.componentId, null, qty)
}
```
**Completion Criteria**:
- [ ] Balance updates added for all consumed components
- [ ] Both location-specific and global balances updated
- [ ] TypeScript compiles

---

## Phase 4: Balance Update Integration - Transfer Service

### Subtask 4.1: Update createTransferTransaction
**File**: `/home/pbrown/SkuInventory/src/services/transfer.ts`
**Location**: Lines 35-175
**Instructions**:
1. Import updateComponentBalance helper (or inline similar logic)
2. After creating transfer transaction, update balances:
```typescript
// Update source location balance (decrease)
await updateComponentBalance(tx, componentId, fromLocationId, -quantity)
// Update destination location balance (increase)
await updateComponentBalance(tx, componentId, toLocationId, quantity)
// Global balance unchanged (net zero)
```
**Completion Criteria**:
- [ ] Balance updates added for both locations
- [ ] Global balance NOT changed (transfers are net-zero globally)
- [ ] TypeScript compiles

---

## Phase 5: Balance Update Integration - Finished Goods Service

### Subtask 5.1: Export Balance Update Helper
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Instructions**:
1. Export the `updateComponentBalance` function for use by other services
2. OR create a shared utility in `/home/pbrown/SkuInventory/src/lib/balance-utils.ts`
**Completion Criteria**:
- [ ] Helper accessible to finished-goods.ts

### Subtask 5.2: Update adjustFinishedGoods
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Location**: Lines 158-193
**Instructions**:
1. Note: FinishedGoodsLine tracks SKU inventory, not component inventory
2. If a SkuBalance table is needed for FG, create similar pattern
3. If FG inventory is out of scope for this issue, document and skip
**Completion Criteria**:
- [ ] Determine if SKU balance tracking is in scope
- [ ] Update if needed

### Subtask 5.3: Update receiveFinishedGoods
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Location**: Lines 199-239
**Instructions**: Same as 5.2
**Completion Criteria**: Same as 5.2

### Subtask 5.4: Update transferFinishedGoods
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Location**: Lines 244-322
**Instructions**: Same as 5.2
**Completion Criteria**: Same as 5.2

### Subtask 5.5: Update createOutboundTransaction
**File**: `/home/pbrown/SkuInventory/src/services/finished-goods.ts`
**Location**: Lines 328-377
**Instructions**: Same as 5.2
**Completion Criteria**: Same as 5.2

---

## Phase 6: Balance Update Integration - Draft Transaction Service

### Subtask 6.1: Update approveDraftTransaction
**File**: `/home/pbrown/SkuInventory/src/services/draft-transaction.ts`
**Location**: Lines 356-520
**Instructions**:
1. Import balance update helper
2. Add balance updates in the $transaction block after approving:
   - For build: Update component balances for each consumed component
   - For receipt/adjustment/initial: Update component balance
   - For transfer: Update both location balances
**Completion Criteria**:
- [ ] Balance updates added for all draft approval paths
- [ ] TypeScript compiles

---

## Phase 7: Backfill Script

### Subtask 7.1: Create Backfill Script
**File**: `/home/pbrown/SkuInventory/scripts/backfill-component-balances.ts`
**Instructions**:
1. Create script that calculates current balances from TransactionLine:
```typescript
// Pseudo-code
// 1. Truncate ComponentBalance table
// 2. For each component:
//    a. Calculate global balance (sum all approved transaction lines)
//    b. Calculate per-location balances (with transfer logic)
//    c. Insert ComponentBalance records
```
2. Include SQL for direct database backfill:
```sql
-- Global balances
INSERT INTO "ComponentBalance" ("id", "componentId", "locationId", "quantity", "updatedAt")
SELECT
  gen_random_uuid(),
  tl."componentId",
  NULL,
  SUM(tl."quantityChange"),
  NOW()
FROM "TransactionLine" tl
JOIN "Transaction" t ON tl."transactionId" = t.id
WHERE t.status = 'approved'
GROUP BY tl."componentId";

-- Location balances (more complex due to transfer handling)
-- Requires separate queries for regular + transfer transactions
```
**Completion Criteria**:
- [ ] Script created
- [ ] Handles global and per-location balances
- [ ] Handles transfer transaction logic correctly

### Subtask 7.2: Add Verification Function
**Instructions**:
1. Add function to compare snapshot values vs aggregated values
2. Report any discrepancies
**Completion Criteria**:
- [ ] Verification function created
- [ ] Can detect balance mismatches

---

## Phase 8: Update Query Functions

### Subtask 8.1: Update getComponentQuantity to Read from Balance
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 46-130
**Instructions**:
1. Add feature flag or environment variable for gradual rollout
2. Primary path: Read from ComponentBalance table
3. Keep fallback path with original aggregation logic
```typescript
export async function getComponentQuantity(
  componentId: string,
  companyId: string,
  locationId?: string
): Promise<number> {
  // Verify component belongs to company (keep existing check)
  const component = await prisma.component.findFirst({
    where: { id: componentId, companyId },
    select: { id: true }
  })
  if (!component) {
    throw new Error('Component not found or access denied')
  }

  // Try snapshot-based lookup first
  const balance = await prisma.componentBalance.findUnique({
    where: {
      componentId_locationId: {
        componentId,
        locationId: locationId ?? null,
      },
    },
  })

  if (balance) {
    return balance.quantity.toNumber()
  }

  // Fallback to aggregation if no balance record exists
  // (Original logic here for backward compatibility)
  // ...
}
```
**Completion Criteria**:
- [ ] Snapshot lookup implemented
- [ ] Fallback to aggregation preserved
- [ ] TypeScript compiles
- [ ] Unit tests pass

### Subtask 8.2: Update getComponentQuantities to Read from Balance
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 142-266
**Instructions**:
1. Similar pattern: read from ComponentBalance, fallback to aggregation
2. Use batch lookup for efficiency:
```typescript
const balances = await prisma.componentBalance.findMany({
  where: {
    componentId: { in: validIds },
    locationId: locationId ?? null,
  },
})
```
**Completion Criteria**:
- [ ] Batch snapshot lookup implemented
- [ ] Fallback preserved
- [ ] TypeScript compiles
- [ ] Unit tests pass

### Subtask 8.3: Update getComponentQuantitiesByLocation
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Location**: Lines 272-317
**Instructions**:
1. Optimize to query ComponentBalance directly instead of calling getComponentQuantity N times
```typescript
const balances = await prisma.componentBalance.findMany({
  where: {
    componentId,
    locationId: { not: null },
  },
  include: {
    location: { select: { id: true, name: true, type: true } },
  },
})
```
**Completion Criteria**:
- [ ] Single query instead of N queries
- [ ] TypeScript compiles

---

## Phase 9: Testing

### Subtask 9.1: Update Unit Tests for Snapshot-Based Queries
**File**: `/home/pbrown/SkuInventory/tests/unit/inventory-quantity.test.ts`
**Instructions**:
1. Add mocks for ComponentBalance queries
2. Add tests for snapshot lookup path
3. Add tests for fallback to aggregation
4. Add tests for balance update helper
**Completion Criteria**:
- [ ] New tests added for snapshot path
- [ ] Fallback tests preserved
- [ ] All tests pass

### Subtask 9.2: Add Integration Test for Balance Consistency
**File**: `/home/pbrown/SkuInventory/tests/integration/balance-consistency.test.ts`
**Instructions**:
1. Create test that:
   - Creates transactions (receipt, build, transfer)
   - Verifies ComponentBalance matches aggregated calculation
   - Tests concurrent transaction handling
**Completion Criteria**:
- [ ] Integration test created
- [ ] Tests verify balance consistency

### Subtask 9.3: Run Full Test Suite
**Instructions**:
1. Run `npm test`
2. Fix any failures
**Completion Criteria**:
- [ ] All tests pass

---

## Phase 10: Verification and Cleanup

### Subtask 10.1: Run Backfill on Test Database
**Instructions**:
1. Execute backfill script on test environment
2. Run verification to confirm balances match
**Completion Criteria**:
- [ ] Backfill completed
- [ ] Verification passes

### Subtask 10.2: Performance Comparison
**Instructions**:
1. Compare query times before/after
2. Document improvement
**Completion Criteria**:
- [ ] Performance improvement documented
- [ ] < 10ms query time achieved for balance lookups

### Subtask 10.3: Final Build and Type Check
**Instructions**:
```bash
npm run build && npx tsc --noEmit && npm run lint
```
**Completion Criteria**:
- [ ] Build passes
- [ ] No TypeScript errors
- [ ] Lint passes

---

## Summary of Deliverables

**Files Created**: 3
- `prisma/migrations/[timestamp]_add_component_balance_table/migration.sql`
- `scripts/backfill-component-balances.ts`
- `tests/integration/balance-consistency.test.ts`

**Files Modified**: 7
- `prisma/schema.prisma` - Add ComponentBalance model
- `src/services/inventory.ts` - Balance updates + query refactor
- `src/services/transfer.ts` - Balance updates
- `src/services/finished-goods.ts` - Balance updates (if SKU balance in scope)
- `src/services/draft-transaction.ts` - Balance updates
- `tests/unit/inventory-quantity.test.ts` - Updated tests

---

## Handoff to Build Agent

1. **IMPORTANT**: Confirm V2 deferral decision before proceeding
2. If proceeding, execute subtasks in exact order
3. Complete Phase 0 fully before Phase 1
4. Test completion criteria before next subtask
5. Follow reference patterns exactly (LotBalance model for schema, existing upsert pattern for updates)
6. Run `npm run build && npx tsc --noEmit` after each phase

---

## Test Strategy Note

- **Unit Tests**: Vitest with mocked Prisma client
- **Integration Tests**: Real database with test data
- **Performance Tests**: Measure query times before/after

---

## Migration Strategy for Production

1. Deploy schema migration (adds table, no breaking changes)
2. Deploy code with balance updates (writes to new table)
3. Run backfill script during low-traffic window
4. Verify backfill matches aggregation
5. Enable snapshot reads (feature flag)
6. Monitor for discrepancies
7. Remove fallback code after confidence period

---

## Performance Metrics

| Phase | Estimated Duration |
|-------|----------|
| Investigation | 45m |
| Validation | 15m |
| Planning | 30m |
| **Total Scout-Plan** | **90m** |

---

## Risk Mitigation

1. **Data Inconsistency Risk**: Keep fallback aggregation for verification
2. **Migration Risk**: Backfill is additive, not destructive
3. **Concurrency Risk**: Use upsert with increment (atomic operations)
4. **Rollback Plan**: Feature flag allows instant rollback to aggregation

---

AGENT_RETURN: plan-201-120625
