# Implementation Plan
**Generated**: 2025-12-18 00:20:00 UTC
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #323
**Estimated Build Time**: 2 hours
**Complexity**: Low

## Investigation Summary

### Request Analysis
**Type**: Bug Fix
**Source**: GitHub Issue #323
**Priority**: Medium

### Task Classification
**Category**: BUG_FIX
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="reorder-status-filter"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- `e7382dd` (2025-12-17) - Created reorder-status-filter tests using TransactionLine aggregation
- `47e4cfb` (2025-12-17) - Changed inventory queries to use InventoryBalance table (Issue #299)

### Root Cause Analysis

The tests in `tests/integration/reorder-status-filter.test.ts` are failing because of a timing/integration issue between two related changes:

1. **Test Creation (e7382dd)**: The tests were written assuming quantity calculation via `TransactionLine` aggregation. Tests create `Transaction` records directly via Prisma to set up inventory quantities.

2. **Query Change (47e4cfb)**: Later on the same day, Issue #299 changed `getComponentsWithReorderStatus` to use the `InventoryBalance` table for O(1) lookups instead of aggregating `TransactionLine` records.

**The Problem**: Tests create transactions but don't update `InventoryBalance`, so `getComponentsWithReorderStatus` returns `quantityOnHand: 0` for all components.

**Evidence**:
```
AssertionError: expected +0 to be 50 // Object.is equality
- Expected: 50
+ Received: 0
```

The SQL query in `getComponentsWithReorderStatus` (lines 1171-1204 of `src/services/inventory.ts`) uses:
```sql
SELECT SUM(ib.quantity) FROM "InventoryBalance" ib WHERE ib."componentId" = c.id
```

But the tests only create `Transaction` records, not `InventoryBalance` records.

### Current State Assessment
- **Existing components**: `getComponentsWithReorderStatus` function works correctly
- **Database**: InventoryBalance table exists and is correctly populated by service functions
- **API Routes**: Working correctly when data flows through service layer
- **Types**: No issues
- **Issue**: Tests bypass service layer and don't create required InventoryBalance entries

### Dependencies & Blockers
1. **Database Migration Gap**: Test database was missing soft-delete columns for Transaction table. This was FIXED during investigation by manually adding columns.

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Simple (isolated to test file)
**Effort**: 2 hours
**Risk**: Low (only test file changes, no production code changes)

### Patterns Identified
**Primary**: `tests/integration/lot-consumption.test.ts` - Shows correct pattern for creating InventoryBalance entries alongside transactions
**Secondary**: `tests/helpers/integration-context.ts` - Existing test helpers that need updating

### Ripple Effect Analysis
**Files Identified**: 2
- `tests/integration/reorder-status-filter.test.ts` - Primary file to fix
- `tests/helpers/integration-context.ts` - Helper needs `createTestInventoryWithBalance` function

### Pattern Detection (Similar Issues)
Searched for similar patterns that bypass InventoryBalance:
```bash
grep -l "prisma.transaction.create" tests/integration/*.ts
```

Other test files that may have the same issue:
- `tests/integration/import-export.test.ts` - Some tests failing with similar patterns
- `tests/integration/transactions.test.ts` - Some tests failing

These are noted but NOT in scope for this issue. The other failures appear to be related to the Transaction schema sync issue, which was resolved during investigation.

---

## Executive Summary

Fix integration test failures in `reorder-status-filter.test.ts` by updating tests to create `InventoryBalance` entries when setting up component quantities. The tests were written before Issue #299 changed quantity lookups from TransactionLine aggregation to InventoryBalance table queries. The fix requires adding a helper function to create transaction + balance entries atomically, then updating all failing tests to use this helper.

---

## Phase 1: Add Test Helper Function

### Subtask 1.1: Add createTransactionWithBalance Helper Function
**File**: `/home/pbrown/SkuInventory/tests/helpers/integration-context.ts`
**Pattern**: Follow `createLotWithBalance` pattern from `tests/integration/lot-consumption.test.ts` (lines 46-95)
**Instructions**:

1. Add a new helper function after `createTestReceiptInDb` (around line 245):

```typescript
/**
 * Create a transaction AND update InventoryBalance for quantity tracking
 * This mirrors what the service layer does when creating transactions
 * Required because getComponentsWithReorderStatus uses InventoryBalance for O(1) lookups
 */
export async function createTransactionWithBalance(
  companyId: string,
  componentId: string,
  quantity: number,
  options: {
    type?: 'initial' | 'receipt' | 'adjustment'
    locationId?: string
  } = {}
): Promise<{ transactionId: string; quantity: number }> {
  const db = getIntegrationPrisma()
  const { type = 'initial', locationId: providedLocationId } = options

  const admin = await db.user.findFirst({
    where: {
      userCompanies: { some: { companyId } },
      role: 'admin',
    },
  })

  // Get location ID - use provided or get default
  const location = providedLocationId
    ? await db.location.findUnique({ where: { id: providedLocationId } })
    : await db.location.findFirst({ where: { companyId, isDefault: true } })

  if (!location) {
    throw new Error('No location found for transaction')
  }

  // Create transaction with line
  const transaction = await db.transaction.create({
    data: {
      companyId,
      type,
      date: new Date(),
      status: 'approved',
      locationId: location.id,
      createdById: admin?.id ?? companyId,
      lines: {
        create: {
          componentId,
          quantityChange: quantity,
          costPerUnit: 10.0,
        },
      },
    },
  })

  // Update InventoryBalance (this is what the service layer does)
  await db.inventoryBalance.upsert({
    where: {
      componentId_locationId: {
        componentId,
        locationId: location.id,
      },
    },
    create: {
      componentId,
      locationId: location.id,
      quantity,
    },
    update: {
      quantity: {
        increment: quantity,
      },
    },
  })

  return { transactionId: transaction.id, quantity }
}

/**
 * Create multiple transaction lines with a single transaction AND update InventoryBalance
 * Useful for tests that need multiple components with different quantities
 */
export async function createBatchTransactionWithBalances(
  companyId: string,
  lines: Array<{ componentId: string; quantity: number }>,
  options: {
    type?: 'initial' | 'receipt' | 'adjustment'
    locationId?: string
  } = {}
): Promise<{ transactionId: string }> {
  const db = getIntegrationPrisma()
  const { type = 'initial', locationId: providedLocationId } = options

  const admin = await db.user.findFirst({
    where: {
      userCompanies: { some: { companyId } },
      role: 'admin',
    },
  })

  const location = providedLocationId
    ? await db.location.findUnique({ where: { id: providedLocationId } })
    : await db.location.findFirst({ where: { companyId, isDefault: true } })

  if (!location) {
    throw new Error('No location found for transaction')
  }

  // Create transaction with all lines
  const transaction = await db.transaction.create({
    data: {
      companyId,
      type,
      date: new Date(),
      status: 'approved',
      locationId: location.id,
      createdById: admin?.id ?? companyId,
      lines: {
        createMany: {
          data: lines.map(line => ({
            componentId: line.componentId,
            quantityChange: line.quantity,
            costPerUnit: 10.0,
          })),
        },
      },
    },
  })

  // Update InventoryBalance for each component
  for (const line of lines) {
    await db.inventoryBalance.upsert({
      where: {
        componentId_locationId: {
          componentId: line.componentId,
          locationId: location.id,
        },
      },
      create: {
        componentId: line.componentId,
        locationId: location.id,
        quantity: line.quantity,
      },
      update: {
        quantity: {
          increment: line.quantity,
        },
      },
    })
  }

  return { transactionId: transaction.id }
}
```

2. Add the import for Prisma.Decimal if not already present (check line 6):
```typescript
import { Prisma } from '@prisma/client'
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run build
```

**Completion Criteria**:
- [ ] Helper function compiles without TypeScript errors
- [ ] Function creates both Transaction and InventoryBalance entries
- [ ] Export is added to module

---

## Phase 2: Update Failing Tests

### Subtask 2.1: Update reorder-status-filter.test.ts to Use New Helper
**File**: `/home/pbrown/SkuInventory/tests/integration/reorder-status-filter.test.ts`
**Pattern**: Replace direct `prisma.transaction.create()` calls with `createTransactionWithBalance()`
**Instructions**:

1. Add import for new helper at top of file (after line 12):
```typescript
import {
  getIntegrationPrisma,
  cleanupBeforeTest,
  createTestRequest,
  createTestComponentInDb,
  createTransactionWithBalance,
  createBatchTransactionWithBalances,
} from '../helpers/integration-context'
```

2. **Test 1: "returns critical status when quantity <= reorderPoint"** (lines 36-85)
   - Remove lines 49-68 (the location lookup and prisma.transaction.create block)
   - Replace with:
```typescript
      // Add initial transaction with quantity 50 (below reorderPoint)
      await createTransactionWithBalance(companyId, component.id, 50)
```

3. **Test 2: "returns warning status when quantity..."** (lines 87-136)
   - Remove lines 100-119 (location lookup and transaction create)
   - Replace with:
```typescript
      // Add initial transaction with quantity 120 (above 100, below 150 with 1.5x multiplier)
      await createTransactionWithBalance(companyId, component.id, 120)
```

4. **Test 3: "returns ok status when quantity..."** (lines 138-187)
   - Remove lines 151-170 (location lookup and transaction create)
   - Replace with:
```typescript
      // Add initial transaction with quantity 200 (above 150 with 1.5x multiplier)
      await createTransactionWithBalance(companyId, component.id, 200)
```

5. **Test 5: "filters correctly by reorderStatus - excludes non-matching"** (lines 216-304)
   - Remove lines 221-261 (location lookup and transaction create with createMany)
   - Replace with:
```typescript
      // Set quantities: critical=50, warning=120, ok=200
      await createBatchTransactionWithBalances(companyId, [
        { componentId: criticalComp.id, quantity: 50 },
        { componentId: warningComp.id, quantity: 120 },
        { componentId: okComp.id, quantity: 200 },
      ])
```

6. **Test 6: "returns correct total count for pagination"** (lines 306-359)
   - Remove lines 311-344 (location lookup and transaction create)
   - Replace with:
```typescript
      // Set all to critical (quantity 50)
      await createBatchTransactionWithBalances(
        companyId,
        components.map(c => ({ componentId: c.id, quantity: 50 }))
      )
```

7. **Test 7: "respects custom reorderWarningMultiplier"** (lines 361-418)
   - Remove lines 374-393 (location lookup and transaction create)
   - Replace with:
```typescript
      // Add initial transaction with quantity 180
      await createTransactionWithBalance(companyId, component.id, 180)
```

8. **Test 8: "filters by search term"** (lines 420-475)
   - Remove lines 425-459 (location lookup and transaction create)
   - Replace with:
```typescript
      // Set both to critical
      await createBatchTransactionWithBalances(companyId, [
        { componentId: alpha.id, quantity: 50 },
        { componentId: beta.id, quantity: 50 },
      ])
```

9. **Test 9: "uses DB-side filtering for reorderStatus parameter"** (lines 478-533)
   - Remove lines 484-511 (location lookup and transaction create)
   - Replace with:
```typescript
      await createTransactionWithBalance(companyId, component.id, 50)
```

**Validation Commands**:
```bash
npx tsc --noEmit
npm run test:integration 2>&1 | grep -A5 "reorder-status-filter"
```

**Completion Criteria**:
- [ ] All 9 tests in reorder-status-filter.test.ts pass
- [ ] No TypeScript errors
- [ ] Tests complete in under 30 seconds

---

## Phase 3: Verification

### Subtask 3.1: Run Full Integration Test Suite
**Instructions**:
1. Run the full integration test suite to ensure no regressions
2. Verify the specific test file passes

**Validation Commands**:
```bash
# Run specific test file
npm run test:integration 2>&1 | grep -E "(reorder-status-filter|PASS|FAIL)"

# Run full integration suite
npm run test:integration

# Verify build
npm run build
```

**Completion Criteria**:
- [ ] All 9 reorder-status-filter tests pass
- [ ] No new failures introduced in other integration tests
- [ ] Build completes successfully

---

## Summary of Deliverables
**Files Created**: 0
**Files Modified**: 2
- `tests/helpers/integration-context.ts` - Add helper functions
- `tests/integration/reorder-status-filter.test.ts` - Use new helpers

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 1 before Phase 2)
2. Complete helper function before updating tests
3. Test completion criteria after each subtask
4. The database schema issue was already resolved during investigation

## Test Strategy Note
- Use Vitest with integration config: `npm run test:integration`
- Tests use real test database at localhost:2346 (inventory_test)

## Additional Context

### Why This Bug Occurred
Issue #292 (reorder-status filtering) was implemented on 2025-12-17 at 05:57:07 UTC. Later that same day, Issue #299 (O(1) inventory balance lookups) was implemented at 15:17:41 UTC, which changed how `getComponentsWithReorderStatus` calculates quantities. The tests from #292 were never updated to account for the new InventoryBalance-based lookups.

### Pattern for Future Tests
When writing integration tests that need inventory quantities:
1. Always use `createTransactionWithBalance()` instead of direct `prisma.transaction.create()`
2. Or use service functions like `createReceiptTransaction()` that automatically update balances
3. Never create transactions directly if the code under test uses `InventoryBalance` table

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 15m |
| Validation | 5m |
| Planning | 10m |
| **Total** | **30m** |
