# Implementation Plan
**Generated**: 2025-12-04T17:30:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #84
**Estimated Build Time**: 10-14 hours
**Complexity**: High

## Investigation Summary

### Request Analysis
**Type**: Feature
**Source**: GitHub Issue #84 - [Parent #12] Lot consumption with FEFO selection
**Priority**: High

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED (unit tests for lot-selection service, integration tests for build flow)
**Suggested Filter**: `--filter="lot|build|inventory"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- Issue #81 (lot capture on receipts) is CLOSED - schema and receipt lot flow implemented
- Issue #78 (lot tracking schema) is CLOSED - Lot, LotBalance models exist
- Build route and inventory service updated for multi-company scoping, finished goods output

### Current State Assessment
- **Existing Lot Models**: `Lot` and `LotBalance` models exist in Prisma schema (lines 187-215)
- **TransactionLine.lotId**: Already supports optional lotId reference (line 283)
- **Receipt Lot Flow**: Implemented in `createReceiptTransaction` (lines 276-436)
- **Build Transaction**: Exists but does NOT consume from lots - creates negative TransactionLines without lot references (lines 708-932)
- **Database**: Lot, LotBalance tables exist with proper indexes
- **API Routes**: `/api/transactions/build` exists, needs lot override parameter
- **Types**: `TransactionLineResponse` already includes lot info (line 138-145)

### Dependencies & Blockers
1. **Sub-issue #78 (Schema)**: CLOSED - Lot/LotBalance models exist
2. **Sub-issue #81 (Lot Capture)**: CLOSED - Receipts can create lots

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: High
**Effort**: 10-14 hours
**Risk**: Medium - Atomic lot balance updates, multiple lots per component consumption, backward compatibility

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/services/inventory.ts` - `createReceiptTransaction` (lines 276-436) - Shows lot upsert pattern
**Secondary**: `/home/pbrown/SkuInventory/src/services/inventory.ts` - `createBuildTransaction` (lines 708-932) - Current build pattern to extend

### Ripple Effect Analysis
**Files Identified**: 7
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Add lot consumption logic to createBuildTransaction
- `/home/pbrown/SkuInventory/src/services/lot-selection.ts` - NEW FILE - FEFO algorithm
- `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts` - Accept lot override parameter
- `/home/pbrown/SkuInventory/src/types/transaction.ts` - Add lot selection types to build schema
- `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx` - Optional lot selection UI
- `/home/pbrown/SkuInventory/tests/unit/lot-selection.test.ts` - NEW FILE - Unit tests for FEFO
- `/home/pbrown/SkuInventory/tests/integration/lot-consumption.test.ts` - NEW FILE - Integration tests

---

## Executive Summary
Implement lot-aware consumption during build transactions with automatic FEFO (First Expiry First Out) selection. Components with available lots will be consumed from lots with earliest expiry dates first. Users can optionally override lot selection per component. The system will create multiple TransactionLines when consuming from multiple lots for a single component.

## Phase 1: Types Layer

### Subtask 1.1: Add Lot Selection Types to transaction.ts
**File**: `/home/pbrown/SkuInventory/src/types/transaction.ts`
**Pattern**: Follow existing zod schema patterns in the file
**Instructions**:
1. Add `LotSelection` interface after line 84:
```typescript
// Lot selection for build consumption
export interface LotSelection {
  lotId: string
  quantity: number
}

// Per-component lot allocation override
export interface ComponentLotOverride {
  componentId: string
  allocations: LotSelection[]
}
```
2. Update `createBuildSchema` (line 57-73) to add optional lot overrides:
```typescript
export const createBuildSchema = z.object({
  // ... existing fields
  lotOverrides: z.array(z.object({
    componentId: z.string().uuid('Invalid component ID'),
    allocations: z.array(z.object({
      lotId: z.string().uuid('Invalid lot ID'),
      quantity: z.coerce.number().positive('Quantity must be positive'),
    })),
  })).optional(),
})
```

**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] `LotSelection` interface exported
- [ ] `ComponentLotOverride` interface exported
- [ ] `createBuildSchema` includes optional `lotOverrides` array
- [ ] TypeScript compiles without errors

## Phase 2: Service Layer - Lot Selection Algorithm

### Subtask 2.1: Create FEFO Lot Selection Service
**File**: `/home/pbrown/SkuInventory/src/services/lot-selection.ts` (NEW FILE)
**Pattern**: Follow service patterns from `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Instructions**:
1. Create new file with the following structure:
```typescript
import { prisma } from '@/lib/db'
import { Prisma } from '@prisma/client'

/**
 * Lot selection result for consumption
 */
export interface LotSelection {
  lotId: string
  lotNumber: string
  quantity: number
  expiryDate: Date | null
}

/**
 * Result of lot availability check
 */
export interface LotAvailabilityResult {
  componentId: string
  componentName: string
  requiredQuantity: number
  availableQuantity: number
  hasLots: boolean
  selectedLots: LotSelection[]
  isPooled: boolean  // true if component has no lots (lot-less inventory)
  isSufficient: boolean
}

/**
 * Get available lots for a component ordered by FEFO (earliest expiry first)
 * Lots without expiry dates are sorted to the end
 */
export async function getAvailableLotsForComponent(
  componentId: string
): Promise<Array<{
  lotId: string
  lotNumber: string
  availableQuantity: number
  expiryDate: Date | null
}>> {
  // Query LotBalance joined with Lot, ordered by expiryDate ASC (nulls last)
  const lots = await prisma.lot.findMany({
    where: {
      componentId,
      balance: {
        quantity: { gt: 0 },
      },
    },
    include: {
      balance: true,
    },
    orderBy: [
      { expiryDate: 'asc' },  // FEFO: earliest expiry first
      { createdAt: 'asc' },   // Tie-breaker: oldest lot first
    ],
  })

  // Sort nulls to end (Prisma puts nulls first by default in asc)
  const sortedLots = lots.sort((a, b) => {
    if (a.expiryDate === null && b.expiryDate === null) return 0
    if (a.expiryDate === null) return 1  // nulls to end
    if (b.expiryDate === null) return -1
    return a.expiryDate.getTime() - b.expiryDate.getTime()
  })

  return sortedLots.map(lot => ({
    lotId: lot.id,
    lotNumber: lot.lotNumber,
    availableQuantity: lot.balance?.quantity.toNumber() ?? 0,
    expiryDate: lot.expiryDate,
  }))
}

/**
 * Select lots for consumption using FEFO algorithm
 * Returns array of {lotId, lotNumber, quantity, expiryDate} allocations
 * Throws if insufficient quantity across all lots
 */
export async function selectLotsForConsumption(params: {
  componentId: string
  requiredQuantity: number
  allowInsufficient?: boolean
}): Promise<LotSelection[]> {
  const { componentId, requiredQuantity, allowInsufficient = false } = params

  const availableLots = await getAvailableLotsForComponent(componentId)

  const selections: LotSelection[] = []
  let remaining = requiredQuantity

  for (const lot of availableLots) {
    if (remaining <= 0) break

    const toConsume = Math.min(lot.availableQuantity, remaining)
    if (toConsume > 0) {
      selections.push({
        lotId: lot.lotId,
        lotNumber: lot.lotNumber,
        quantity: toConsume,
        expiryDate: lot.expiryDate,
      })
      remaining -= toConsume
    }
  }

  if (remaining > 0 && !allowInsufficient) {
    throw new Error(
      `Insufficient lot quantity for component ${componentId}. ` +
      `Required: ${requiredQuantity}, Available across lots: ${requiredQuantity - remaining}`
    )
  }

  return selections
}

/**
 * Check lot availability for multiple components (used in build pre-check)
 * Returns detailed availability info per component, including pooled (lot-less) components
 */
export async function checkLotAvailabilityForBuild(params: {
  bomLines: Array<{
    componentId: string
    componentName: string
    skuCode: string
    quantityRequired: number
  }>
}): Promise<LotAvailabilityResult[]> {
  const { bomLines } = params
  const results: LotAvailabilityResult[] = []

  for (const line of bomLines) {
    const availableLots = await getAvailableLotsForComponent(line.componentId)
    const totalLotQuantity = availableLots.reduce((sum, lot) => sum + lot.availableQuantity, 0)
    const hasLots = availableLots.length > 0

    if (hasLots) {
      // Component has lots - select using FEFO
      const selectedLots: LotSelection[] = []
      let remaining = line.quantityRequired

      for (const lot of availableLots) {
        if (remaining <= 0) break
        const toConsume = Math.min(lot.availableQuantity, remaining)
        if (toConsume > 0) {
          selectedLots.push({
            lotId: lot.lotId,
            lotNumber: lot.lotNumber,
            quantity: toConsume,
            expiryDate: lot.expiryDate,
          })
          remaining -= toConsume
        }
      }

      results.push({
        componentId: line.componentId,
        componentName: line.componentName,
        requiredQuantity: line.quantityRequired,
        availableQuantity: totalLotQuantity,
        hasLots: true,
        selectedLots,
        isPooled: false,
        isSufficient: totalLotQuantity >= line.quantityRequired,
      })
    } else {
      // Component has no lots - it's pooled inventory (lot-less)
      results.push({
        componentId: line.componentId,
        componentName: line.componentName,
        requiredQuantity: line.quantityRequired,
        availableQuantity: 0,  // Will be filled by caller from pooled inventory check
        hasLots: false,
        selectedLots: [],
        isPooled: true,
        isSufficient: true,  // Will be validated by existing insufficient inventory check
      })
    }
  }

  return results
}

/**
 * Validate manual lot overrides
 * Ensures all specified lots exist, belong to the component, and have sufficient quantity
 */
export async function validateLotOverrides(
  overrides: Array<{
    componentId: string
    allocations: Array<{ lotId: string; quantity: number }>
  }>
): Promise<{ valid: boolean; errors: string[] }> {
  const errors: string[] = []

  for (const override of overrides) {
    for (const alloc of override.allocations) {
      const lot = await prisma.lot.findUnique({
        where: { id: alloc.lotId },
        include: { balance: true },
      })

      if (!lot) {
        errors.push(`Lot ${alloc.lotId} not found`)
        continue
      }

      if (lot.componentId !== override.componentId) {
        errors.push(`Lot ${lot.lotNumber} does not belong to component ${override.componentId}`)
        continue
      }

      const available = lot.balance?.quantity.toNumber() ?? 0
      if (available < alloc.quantity) {
        errors.push(
          `Lot ${lot.lotNumber}: requested ${alloc.quantity}, available ${available}`
        )
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```
**Completion Criteria**:
- [ ] `getAvailableLotsForComponent` function implemented
- [ ] `selectLotsForConsumption` function implements FEFO algorithm
- [ ] `checkLotAvailabilityForBuild` function handles mixed lot/lotless components
- [ ] `validateLotOverrides` function validates manual selections
- [ ] TypeScript compiles without errors

### Subtask 2.2: Extend createBuildTransaction with Lot Consumption
**File**: `/home/pbrown/SkuInventory/src/services/inventory.ts`
**Pattern**: Follow existing `createReceiptTransaction` lot handling pattern (lines 319-382)
**Instructions**:
1. Add imports at top of file:
```typescript
import {
  selectLotsForConsumption,
  checkLotAvailabilityForBuild,
  validateLotOverrides,
  type LotSelection,
} from './lot-selection'
```

2. Update `createBuildTransaction` function signature (around line 708) to accept lot overrides:
```typescript
export async function createBuildTransaction(params: {
  // ... existing params
  lotOverrides?: Array<{
    componentId: string
    allocations: Array<{ lotId: string; quantity: number }>
  }>
}): Promise<{
  transaction: BuildTransactionResult
  insufficientItems: InsufficientInventoryItem[]
  warning: boolean
}>
```

3. Inside the `$transaction` block (around line 790), BEFORE creating transaction lines:
   - For each BOM line, check if component has lots
   - If manual override provided for component, use that
   - Otherwise, use FEFO selection via `selectLotsForConsumption`
   - For pooled (lot-less) components, continue with existing behavior

4. Replace the single TransactionLine creation (lines 827-835) with logic that creates multiple lines when consuming from multiple lots:
```typescript
// Build consumption lines - handle lots
const consumptionLines: Prisma.TransactionLineCreateManyTransactionInput[] = []

for (const bomLine of bomLines) {
  const requiredQty = bomLine.quantityPerUnit.toNumber() * unitsToBuild

  // Check if this component has a manual override
  const override = lotOverrides?.find(o => o.componentId === bomLine.componentId)

  if (override) {
    // Use manual lot allocations
    for (const alloc of override.allocations) {
      consumptionLines.push({
        componentId: bomLine.componentId,
        quantityChange: new Prisma.Decimal(-1 * alloc.quantity),
        costPerUnit: bomLine.component.costPerUnit,
        lotId: alloc.lotId,
      })

      // Deduct from LotBalance
      await tx.lotBalance.update({
        where: { lotId: alloc.lotId },
        data: {
          quantity: { decrement: new Prisma.Decimal(alloc.quantity) },
        },
      })
    }
  } else {
    // Try FEFO lot selection
    const availableLots = await tx.lot.findMany({
      where: {
        componentId: bomLine.componentId,
        balance: { quantity: { gt: 0 } },
      },
      include: { balance: true },
      orderBy: [{ expiryDate: 'asc' }, { createdAt: 'asc' }],
    })

    // Sort nulls to end
    const sortedLots = availableLots.sort((a, b) => {
      if (a.expiryDate === null && b.expiryDate === null) return 0
      if (a.expiryDate === null) return 1
      if (b.expiryDate === null) return -1
      return a.expiryDate.getTime() - b.expiryDate.getTime()
    })

    if (sortedLots.length > 0) {
      // Component has lots - consume using FEFO
      let remaining = requiredQty

      for (const lot of sortedLots) {
        if (remaining <= 0) break
        const available = lot.balance?.quantity.toNumber() ?? 0
        const toConsume = Math.min(available, remaining)

        if (toConsume > 0) {
          consumptionLines.push({
            componentId: bomLine.componentId,
            quantityChange: new Prisma.Decimal(-1 * toConsume),
            costPerUnit: bomLine.component.costPerUnit,
            lotId: lot.id,
          })

          // Deduct from LotBalance atomically
          await tx.lotBalance.update({
            where: { lotId: lot.id },
            data: {
              quantity: { decrement: new Prisma.Decimal(toConsume) },
            },
          })

          remaining -= toConsume
        }
      }

      // If still remaining and allowInsufficientInventory, add pooled consumption
      if (remaining > 0 && allowInsufficientInventory) {
        consumptionLines.push({
          componentId: bomLine.componentId,
          quantityChange: new Prisma.Decimal(-1 * remaining),
          costPerUnit: bomLine.component.costPerUnit,
          lotId: null,
        })
      }
    } else {
      // Component has no lots - use pooled inventory (existing behavior)
      consumptionLines.push({
        componentId: bomLine.componentId,
        quantityChange: new Prisma.Decimal(-1 * requiredQty),
        costPerUnit: bomLine.component.costPerUnit,
        lotId: null,
      })
    }
  }
}

// Create transaction with all consumption lines
const transaction = await tx.transaction.create({
  data: {
    // ... existing transaction data
    lines: {
      createMany: {
        data: consumptionLines,
      },
    },
  },
  include: {
    // ... existing includes
  },
})
```

5. Update the `BuildTransactionResult` interface (around line 674) to include lot info on lines:
```typescript
lines: Array<{
  id: string
  component: { id: string; name: string; skuCode: string }
  quantityChange: { toString(): string }
  costPerUnit: { toString(): string } | null
  lotId: string | null
  lot: { id: string; lotNumber: string; expiryDate: Date | null } | null
}>
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] `createBuildTransaction` accepts optional `lotOverrides` parameter
- [ ] FEFO lot selection is applied when component has lots
- [ ] Multiple TransactionLines created when consuming from multiple lots
- [ ] LotBalance.quantity decremented atomically for each lot consumed
- [ ] Pooled (lot-less) components continue to work as before
- [ ] Manual lot overrides are respected when provided
- [ ] TypeScript compiles without errors
- [ ] Build completes without errors

## Phase 3: API Layer

### Subtask 3.1: Update Build Route to Accept Lot Overrides
**File**: `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts`
**Pattern**: Follow existing route pattern for passing optional parameters
**Instructions**:
1. The schema update from Phase 1 already adds `lotOverrides` to `createBuildSchema`
2. Update the `createBuildTransaction` call (around line 99-116) to pass lot overrides:
```typescript
const result = await createBuildTransaction({
  // ... existing params
  lotOverrides: data.lotOverrides,
})
```

3. Update the response mapping (around line 137-142) to include lot info on lines:
```typescript
lines: result.transaction.lines.map((line) => ({
  id: line.id,
  component: line.component,
  quantityChange: line.quantityChange.toString(),
  costPerUnit: line.costPerUnit?.toString() ?? null,
  lotId: line.lotId ?? null,
  lot: line.lot ? {
    id: line.lot.id,
    lotNumber: line.lot.lotNumber,
    expiryDate: line.lot.expiryDate?.toISOString().split('T')[0] ?? null,
  } : null,
})),
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Route accepts optional `lotOverrides` in request body
- [ ] Lot overrides passed to `createBuildTransaction`
- [ ] Response includes lot info on each line
- [ ] TypeScript compiles without errors
- [ ] Build completes without errors

## Phase 4: Frontend Layer (Optional Lot Selection UI)

### Subtask 4.1: Add Lot Selection Section to BuildDialog
**File**: `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx`
**Pattern**: Follow existing collapsible section pattern (defect tracking details, lines 434-490)
**Instructions**:
1. Add state for lot availability and manual overrides after existing state declarations (around line 61):
```typescript
const [lotAvailability, setLotAvailability] = useState<Array<{
  componentId: string
  componentName: string
  requiredQuantity: number
  availableQuantity: number
  hasLots: boolean
  selectedLots: Array<{
    lotId: string
    lotNumber: string
    quantity: number
    expiryDate: string | null
  }>
}>>([])
const [showLotOverride, setShowLotOverride] = useState(false)
const [lotOverrides, setLotOverrides] = useState<Map<string, Array<{ lotId: string; quantity: string }>>>(new Map())
```

2. Add a function to fetch lot availability when SKU is selected (before handleSubmit):
```typescript
const fetchLotAvailability = async (skuId: string, unitsToBuild: number) => {
  if (!skuId || !unitsToBuild || unitsToBuild <= 0) {
    setLotAvailability([])
    return
  }
  try {
    const res = await fetch(`/api/skus/${skuId}/lot-availability?units=${unitsToBuild}`)
    if (res.ok) {
      const data = await res.json()
      setLotAvailability(data.data || [])
    }
  } catch (err) {
    console.error('Failed to fetch lot availability:', err)
  }
}
```

3. Add effect to fetch lot availability when SKU or units change:
```typescript
useEffect(() => {
  if (formData.skuId && formData.unitsToBuild) {
    fetchLotAvailability(formData.skuId, parseInt(formData.unitsToBuild) || 0)
  }
}, [formData.skuId, formData.unitsToBuild])
```

4. Add collapsible lot selection UI after the Defect Tracking section (around line 490):
```tsx
{/* Lot Selection (collapsible) */}
{lotAvailability.some(la => la.hasLots) && (
  <details className="col-span-4" open={showLotOverride}>
    <summary
      className="cursor-pointer text-sm font-medium text-muted-foreground hover:text-foreground"
      onClick={(e) => {
        e.preventDefault()
        setShowLotOverride(!showLotOverride)
      }}
    >
      Lot Selection (FEFO auto-selected)
    </summary>
    <div className="mt-4 space-y-4 pl-4 border-l-2 border-muted">
      {lotAvailability.filter(la => la.hasLots).map((comp) => (
        <div key={comp.componentId} className="space-y-2">
          <p className="text-sm font-medium">{comp.componentName}</p>
          <p className="text-xs text-muted-foreground">
            Required: {comp.requiredQuantity} | Available across lots: {comp.availableQuantity}
          </p>
          <div className="text-xs space-y-1">
            {comp.selectedLots.map((lot, idx) => (
              <div key={lot.lotId} className="flex items-center gap-2">
                <span className="font-mono">{lot.lotNumber}</span>
                <span className="text-muted-foreground">
                  ({lot.quantity} units)
                </span>
                {lot.expiryDate && (
                  <span className="text-muted-foreground">
                    Expires: {lot.expiryDate}
                  </span>
                )}
              </div>
            ))}
          </div>
        </div>
      ))}
      <p className="text-xs text-muted-foreground italic">
        Lots are automatically selected using FEFO (First Expiry First Out).
        Manual override coming in future update.
      </p>
    </div>
  </details>
)}
```

5. Update handleSubmit to include lot overrides if manually specified (for future use):
```typescript
// In handleSubmit, add to the request body if overrides exist:
lotOverrides: lotOverrides.size > 0
  ? Array.from(lotOverrides.entries()).map(([componentId, allocs]) => ({
      componentId,
      allocations: allocs.filter(a => a.quantity).map(a => ({
        lotId: a.lotId,
        quantity: parseInt(a.quantity) || 0,
      })),
    }))
  : undefined,
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Lot availability displayed when SKU with lots is selected
- [ ] FEFO-selected lots shown per component
- [ ] Collapsible section follows existing UI patterns
- [ ] TypeScript compiles without errors
- [ ] Build completes without errors

### Subtask 4.2: Create Lot Availability API Endpoint
**File**: `/home/pbrown/SkuInventory/src/app/api/skus/[id]/lot-availability/route.ts` (NEW FILE)
**Pattern**: Follow existing SKU API endpoint patterns from `/home/pbrown/SkuInventory/src/app/api/skus/[id]/route.ts`
**Instructions**:
1. Create new route file:
```typescript
import { NextRequest } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { ok, unauthorized, notFound, serverError } from '@/lib/api-response'
import { checkLotAvailabilityForBuild } from '@/services/lot-selection'

// GET /api/skus/[id]/lot-availability?units=N
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user) {
      return unauthorized()
    }

    const { id } = await params
    const { searchParams } = new URL(request.url)
    const units = parseInt(searchParams.get('units') || '0')

    if (units <= 0) {
      return ok([])
    }

    const selectedCompanyId = session.user.selectedCompanyId

    // Get SKU with active BOM
    const sku = await prisma.sKU.findFirst({
      where: {
        id,
        companyId: selectedCompanyId,
      },
      include: {
        bomVersions: {
          where: { isActive: true },
          take: 1,
          include: {
            lines: {
              include: {
                component: {
                  select: { id: true, name: true, skuCode: true },
                },
              },
            },
          },
        },
      },
    })

    if (!sku) {
      return notFound('SKU')
    }

    const activeBom = sku.bomVersions[0]
    if (!activeBom) {
      return ok([])
    }

    // Get lot availability for all BOM components
    const bomLines = activeBom.lines.map(line => ({
      componentId: line.componentId,
      componentName: line.component.name,
      skuCode: line.component.skuCode,
      quantityRequired: line.quantityPerUnit.toNumber() * units,
    }))

    const availability = await checkLotAvailabilityForBuild({ bomLines })

    return ok(availability.map(a => ({
      componentId: a.componentId,
      componentName: a.componentName,
      requiredQuantity: a.requiredQuantity,
      availableQuantity: a.availableQuantity,
      hasLots: a.hasLots,
      selectedLots: a.selectedLots.map(lot => ({
        lotId: lot.lotId,
        lotNumber: lot.lotNumber,
        quantity: lot.quantity,
        expiryDate: lot.expiryDate?.toISOString().split('T')[0] ?? null,
      })),
      isPooled: a.isPooled,
      isSufficient: a.isSufficient,
    })))
  } catch (error) {
    console.error('Error fetching lot availability:', error)
    return serverError()
  }
}
```

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Endpoint returns lot availability for SKU BOM components
- [ ] FEFO selection applied automatically
- [ ] TypeScript compiles without errors
- [ ] Build completes without errors

## Phase 5: Tests

### Subtask 5.1: Add Unit Tests for Lot Selection Service
**File**: `/home/pbrown/SkuInventory/tests/unit/lot-selection.test.ts` (NEW FILE)
**Pattern**: Follow existing test patterns from `/home/pbrown/SkuInventory/tests/unit/inventory-service.test.ts`
**Instructions**:
1. Create test file with the following test cases:
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'

// Mock prisma
vi.mock('@/lib/db', () => ({
  prisma: {
    lot: {
      findMany: vi.fn(),
      findUnique: vi.fn(),
    },
  },
}))

import { prisma } from '@/lib/db'
import {
  getAvailableLotsForComponent,
  selectLotsForConsumption,
  checkLotAvailabilityForBuild,
  validateLotOverrides,
} from '@/services/lot-selection'

describe('lot-selection service', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('getAvailableLotsForComponent', () => {
    it('returns lots ordered by expiry date (FEFO)', async () => {
      // Test FEFO ordering
    })

    it('sorts lots without expiry dates to end', async () => {
      // Test null expiry handling
    })

    it('excludes lots with zero balance', async () => {
      // Test zero balance filtering
    })
  })

  describe('selectLotsForConsumption', () => {
    it('selects lots using FEFO until quantity met', async () => {
      // Test multi-lot selection
    })

    it('throws error when insufficient and not allowed', async () => {
      // Test insufficient inventory error
    })

    it('returns partial selection when allowInsufficient is true', async () => {
      // Test partial consumption
    })
  })

  describe('checkLotAvailabilityForBuild', () => {
    it('identifies components with lots vs pooled', async () => {
      // Test mixed inventory handling
    })

    it('calculates correct availability per component', async () => {
      // Test availability calculation
    })
  })

  describe('validateLotOverrides', () => {
    it('validates lot exists and belongs to component', async () => {
      // Test lot validation
    })

    it('returns errors for insufficient lot quantity', async () => {
      // Test quantity validation
    })
  })
})
```

**Validation**:
```bash
npm test -- --filter="lot-selection"
```
**Completion Criteria**:
- [ ] FEFO ordering tests pass
- [ ] Multi-lot consumption tests pass
- [ ] Mixed inventory (lot + pooled) tests pass
- [ ] Validation tests pass
- [ ] All tests pass

### Subtask 5.2: Add Integration Tests for Lot Consumption
**File**: `/home/pbrown/SkuInventory/tests/integration/lot-consumption.test.ts` (NEW FILE)
**Pattern**: Follow existing integration test patterns from `/home/pbrown/SkuInventory/tests/integration/transactions.test.ts`
**Instructions**:
1. Create integration test file covering end-to-end scenarios:
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest'
import { prisma } from '@/lib/db'

describe('Lot Consumption Integration', () => {
  describe('Build with FEFO lot selection', () => {
    it('consumes from lot with earliest expiry first', async () => {
      // Create component with multiple lots
      // Create build transaction
      // Verify correct lot was consumed
    })

    it('creates multiple transaction lines when consuming from multiple lots', async () => {
      // Create component with lots that together satisfy requirement
      // Create build transaction
      // Verify multiple lines created
    })

    it('decrements LotBalance.quantity correctly', async () => {
      // Create lot with known balance
      // Create build transaction
      // Verify balance decreased
    })
  })

  describe('Build with pooled (lot-less) components', () => {
    it('continues to work for components without lots', async () => {
      // Create component without lots
      // Create build transaction
      // Verify transaction created without lotId on line
    })
  })

  describe('Build with manual lot overrides', () => {
    it('uses specified lots when override provided', async () => {
      // Create component with multiple lots
      // Create build with manual override
      // Verify specified lot was used
    })
  })

  describe('Atomicity', () => {
    it('rolls back all changes on failure', async () => {
      // Create scenario that will fail mid-transaction
      // Verify no partial consumption
    })
  })
})
```

**Validation**:
```bash
npm test -- --filter="lot-consumption"
```
**Completion Criteria**:
- [ ] FEFO selection integration tests pass
- [ ] Multi-lot consumption tests pass
- [ ] Pooled inventory backward compatibility tests pass
- [ ] Manual override tests pass
- [ ] Atomicity tests pass
- [ ] All integration tests pass

## Phase 6: Final Validation

### Subtask 6.1: Full Build and Test Verification
**Instructions**:
1. Run full build:
```bash
npm run build
```
2. Run TypeScript check:
```bash
npx tsc --noEmit
```
3. Run all tests:
```bash
npm test
```
4. Run lint:
```bash
npm run lint
```

**Completion Criteria**:
- [ ] `npm run build` completes without errors
- [ ] `npx tsc --noEmit` completes without errors
- [ ] All tests pass
- [ ] Lint passes

---

## Summary of Deliverables
**Files Created**: 4
- `/home/pbrown/SkuInventory/src/services/lot-selection.ts` - FEFO algorithm and lot selection service
- `/home/pbrown/SkuInventory/src/app/api/skus/[id]/lot-availability/route.ts` - Lot availability endpoint
- `/home/pbrown/SkuInventory/tests/unit/lot-selection.test.ts` - Unit tests
- `/home/pbrown/SkuInventory/tests/integration/lot-consumption.test.ts` - Integration tests

**Files Modified**: 4
- `/home/pbrown/SkuInventory/src/types/transaction.ts` - Add lot selection types
- `/home/pbrown/SkuInventory/src/services/inventory.ts` - Extend createBuildTransaction with lot consumption
- `/home/pbrown/SkuInventory/src/app/api/transactions/build/route.ts` - Accept lot overrides
- `/home/pbrown/SkuInventory/src/components/features/BuildDialog.tsx` - Add lot selection UI

## Handoff to Build Agent
1. Execute subtasks in exact order (Phase 1 through Phase 6)
2. Complete each phase fully before moving to next
3. Test completion criteria before proceeding to next subtask
4. Follow reference patterns exactly
5. Run validation commands after each subtask

## Test Strategy Note
- Use Vitest for unit tests
- Integration tests use real Prisma client against test database
- Focus on: FEFO selection, multi-lot consumption, mixed lot/lotless components, atomicity

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 20m |
| **Total** | **55m** |
