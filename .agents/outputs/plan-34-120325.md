# Implementation Plan
**Generated**: 2025-12-03T20:00:00Z
**Generated By**: Scout-and-Plan Agent (combined workflow)
**Task ID**: GitHub Issue #34
**Estimated Build Time**: 8-12 hours
**Complexity**: Medium

## Investigation Summary

### Request Analysis
**Type**: Enhancement
**Source**: GitHub Issue #34
**Priority**: Medium

**Feature Request**: Use Claude Code headless mode for user-submitted bugs and features. After the user submits their input for a bug or feature request, use Claude headless mode to gather sufficient information and generate a quality GitHub issue - don't just copy and paste the user input into GitHub.

### Task Classification
**Category**: NEW_FEATURE
**Test Strategy**: TARGETED
**Suggested Filter**: `--filter="feedback|claude"`

### Issue Validation
**Status**: Valid
**Recent Changes**:
- `ff1ed35` fix(issue #29): add response validation to prevent FeedbackDialog crashes
- `d5b4a5d` fix: feedback button and agent improvements
- `cc9ceff` feat(issue #1): add user feedback system with AI-powered clarification

### Current State Assessment

#### Existing Feedback System Components:
1. **FeedbackDialog.tsx** (`/home/pbrown/SkuInventory/src/components/features/FeedbackDialog.tsx`)
   - Multi-step dialog: select-type -> describe -> clarify -> submitting -> success/error
   - Calls `/api/feedback/clarify` to get AI-generated clarifying questions
   - Calls `/api/feedback` to submit final feedback and create GitHub issue
   - Collects: type (bug/feature), description, 3 answers to clarifying questions

2. **API Route: /api/feedback/clarify** (`/home/pbrown/SkuInventory/src/app/api/feedback/clarify/route.ts`)
   - Uses Claude API via SDK to generate clarifying questions
   - Falls back to hardcoded questions if API unavailable

3. **API Route: /api/feedback** (`/home/pbrown/SkuInventory/src/app/api/feedback/route.ts`)
   - Creates GitHub issue using Octokit REST API
   - Uses hardcoded template functions: `formatBugBody()` and `formatFeatureBody()`
   - Simple string interpolation with user inputs
   - Rate limiting: 5 requests per hour per user

4. **Claude Library** (`/home/pbrown/SkuInventory/src/lib/claude.ts`)
   - Uses `@anthropic-ai/sdk` for API calls
   - Lazy initialization with ANTHROPIC_API_KEY
   - Only one function: `generateClarifyingQuestions()`

5. **Types** (`/home/pbrown/SkuInventory/src/types/feedback.ts`)
   - `FeedbackType`: 'bug' | 'feature'
   - `FeedbackStep`: dialog states
   - Zod schemas for validation

6. **Slash Commands** (`.claude/commands/bug.md`, `.claude/commands/feature.md`)
   - Templates for bug and feature issue creation
   - Used by Claude Code CLI for `/bug` and `/feature` commands

#### Current Issue Quality Problem:
The current implementation uses simple template strings (`formatBugBody`, `formatFeatureBody`) that:
- Just paste user input into placeholders
- Don't analyze or enhance the content
- Don't follow the detailed templates in `.claude/commands/bug.md` and `.claude/commands/feature.md`
- Result in issues with many "TBD" or placeholder values

### Dependencies & Blockers

1. **Claude Code CLI**: Available at `/home/pbrown/.local/bin/claude` (v2.0.57)
   - Supports `-p` flag for non-interactive mode
   - Supports `--output-format json` for structured output
   - Supports `--dangerously-skip-permissions` for automation
   - Supports `--system-prompt` for custom instructions

2. **Environment Variables**:
   - `ANTHROPIC_API_KEY`: Already configured (for SDK usage)
   - `GITHUB_TOKEN`: Already configured (for Octokit)
   - **NEW**: `CLAUDE_CODE_PATH`: Path to Claude CLI binary (optional, can default to `claude`)

3. **Security Considerations**:
   - Subprocess execution on server requires careful input sanitization
   - Timeouts needed to prevent hanging processes
   - Output size limits to prevent memory issues
   - No user input should be passed as command-line arguments (use stdin/prompts)

**Can Proceed?**: YES

### Complexity Assessment
**Complexity**: Medium
**Effort**: 8-12 hours
**Risk**: Medium (subprocess execution, Claude CLI reliability)

### Patterns Identified
**Primary**: `/home/pbrown/SkuInventory/src/lib/claude.ts` - existing Claude integration pattern
**Secondary**: `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts` - current GitHub issue creation

### Ripple Effect Analysis
**Files Identified**: 6
- `/home/pbrown/SkuInventory/src/lib/claude.ts` - Add new function for headless mode
- `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts` - Use new headless enhancement
- `/home/pbrown/SkuInventory/src/lib/env.ts` - Add CLAUDE_CODE_PATH env var
- `/home/pbrown/SkuInventory/.env.example` - Document new env var
- `/home/pbrown/SkuInventory/src/types/feedback.ts` - Add enhanced response types
- `/home/pbrown/SkuInventory/tests/unit/claude-client.test.ts` - Add tests for new function

---

## Executive Summary

Enhance the feedback submission system to use Claude Code headless mode for generating high-quality GitHub issues. Instead of simple template string interpolation, the server will invoke Claude Code CLI with the `/bug` or `/feature` command prompts to analyze user feedback and generate comprehensive, well-structured GitHub issues with proper investigation notes, reproduction steps, and technical context.

## Phase 0: Environment Verification

### Subtask 0.1: Verify Claude Code CLI Availability
**File**: N/A (verification only)
**Instructions**:
1. Verify Claude Code CLI is installed and accessible:
   ```bash
   which claude
   claude --version
   ```
2. Test headless mode works:
   ```bash
   echo "Test prompt" | claude -p --output-format json "Respond with just 'OK'"
   ```
3. Document any issues found
**Completion Criteria**:
- [ ] Claude CLI found at expected path
- [ ] Version 2.0.57 or higher confirmed
- [ ] Headless mode test succeeds

### Subtask 0.2: Review Bug and Feature Command Templates
**Files**:
- `/home/pbrown/SkuInventory/.claude/commands/bug.md`
- `/home/pbrown/SkuInventory/.claude/commands/feature.md`
**Instructions**:
1. Read both command template files
2. Extract the issue body format from each
3. Identify fields that Claude should populate vs placeholders
**Completion Criteria**:
- [ ] Bug template format documented
- [ ] Feature template format documented
- [ ] Required fields list created

---

## Phase 1: Types and Environment Configuration

### Subtask 1.1: Add CLAUDE_CODE_PATH to Environment Schema
**File**: `/home/pbrown/SkuInventory/src/lib/env.ts`
**Pattern**: Follow existing optional env var pattern (line 8: ANTHROPIC_API_KEY)
**Instructions**:
1. Add new optional environment variable:
   ```typescript
   CLAUDE_CODE_PATH: z.string().optional(),
   ```
2. This allows configuring a custom path to the Claude CLI binary
**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] Schema updated with CLAUDE_CODE_PATH
- [ ] TypeScript compiles without errors

### Subtask 1.2: Document CLAUDE_CODE_PATH in .env.example
**File**: `/home/pbrown/SkuInventory/.env.example`
**Pattern**: Follow existing documentation style
**Instructions**:
1. Add documentation for the new env var:
   ```
   # Claude Code CLI path (optional, defaults to 'claude' in PATH)
   # Set this if claude is installed in a non-standard location
   # CLAUDE_CODE_PATH=/home/user/.local/bin/claude
   ```
**Completion Criteria**:
- [ ] .env.example updated with CLAUDE_CODE_PATH documentation

### Subtask 1.3: Add Enhanced Issue Generation Types
**File**: `/home/pbrown/SkuInventory/src/types/feedback.ts`
**Pattern**: Follow existing type definition patterns
**Instructions**:
1. Add new interface for Claude Code response:
   ```typescript
   // Claude Code headless mode response
   export interface ClaudeCodeResponse {
     success: boolean
     issueTitle: string
     issueBody: string
     error?: string
     duration?: number
   }
   ```
2. Add interface for issue enhancement request:
   ```typescript
   export interface EnhanceIssueRequest {
     type: FeedbackType
     description: string
     answers: string[]
   }
   ```
**Validation**:
```bash
npx tsc --noEmit
```
**Completion Criteria**:
- [ ] ClaudeCodeResponse interface added
- [ ] EnhanceIssueRequest interface added
- [ ] TypeScript compiles without errors

---

## Phase 2: Claude Code Headless Integration

### Subtask 2.1: Create Claude Code Executor Function
**File**: `/home/pbrown/SkuInventory/src/lib/claude.ts`
**Pattern**: Follow existing `generateClarifyingQuestions()` pattern
**Instructions**:
1. Add imports for child process and promisify:
   ```typescript
   import { spawn } from 'child_process'
   ```

2. Add constants for safety limits:
   ```typescript
   const CLAUDE_CODE_TIMEOUT_MS = 60000 // 60 seconds max
   const MAX_OUTPUT_SIZE = 100000 // 100KB max output
   ```

3. Add new function `enhanceIssueWithClaudeCode()`:
   ```typescript
   export interface EnhanceIssueParams {
     type: 'bug' | 'feature'
     description: string
     answers: string[]
   }

   export interface EnhanceIssueResult {
     success: boolean
     title: string
     body: string
     error?: string
   }

   /**
    * Use Claude Code headless mode to generate a high-quality GitHub issue
    * from user feedback. Falls back to simple formatting if Claude Code fails.
    */
   export async function enhanceIssueWithClaudeCode(
     params: EnhanceIssueParams
   ): Promise<EnhanceIssueResult> {
     const { type, description, answers } = params

     const claudePath = process.env.CLAUDE_CODE_PATH || 'claude'

     // Build the prompt with user input
     const userContext = buildUserContext(type, description, answers)
     const systemPrompt = buildSystemPrompt(type)

     try {
       const result = await executeClaudeCode(claudePath, userContext, systemPrompt)
       return parseClaudeCodeOutput(result, type, description)
     } catch (error) {
       console.error('Claude Code execution failed:', error)
       // Fall back to simple formatting
       return {
         success: false,
         title: description.length > 80 ? description.substring(0, 77) + '...' : description,
         body: type === 'bug'
           ? formatFallbackBugBody(description, answers)
           : formatFallbackFeatureBody(description, answers),
         error: error instanceof Error ? error.message : 'Unknown error'
       }
     }
   }
   ```

4. Add helper function for building user context:
   ```typescript
   function buildUserContext(type: 'bug' | 'feature', description: string, answers: string[]): string {
     const label = type === 'bug' ? 'Bug Report' : 'Feature Request'
     return `${label}:

   Description: ${description}

   Clarifying Questions and Answers:
   Q1: ${type === 'bug' ? 'What steps can we follow to reproduce this issue?' : 'What problem would this feature solve for you?'}
   A1: ${answers[0] || 'Not provided'}

   Q2: ${type === 'bug' ? 'What did you expect to happen instead?' : 'How would you ideally use this feature?'}
   A2: ${answers[1] || 'Not provided'}

   Q3: ${type === 'bug' ? 'When did you first notice this problem?' : 'How important is this feature to your workflow?'}
   A3: ${answers[2] || 'Not provided'}`
   }
   ```

5. Add system prompt builder:
   ```typescript
   function buildSystemPrompt(type: 'bug' | 'feature'): string {
     if (type === 'bug') {
       return `You are creating a GitHub issue for a bug report. Based on the user's feedback, generate:
   1. A clear, concise title (max 80 characters)
   2. A comprehensive issue body following this format:

   ## Reported Issue
   **What's broken**: <summarize the issue>
   **Expected behavior**: <from user's answer>
   **Severity**: <Critical/High/Medium/Low based on impact>

   ## Error Details
   **Error Type**: <infer from description>
   **Error Message**: <if provided>
   **Location**: <if mentioned>
   **URL/Route**: <if mentioned>

   ## How to Reproduce
   <Based on user's steps, format as numbered list>

   ## Investigation Notes
   - Error pattern detected: <your analysis>
   - Likely affected components: <your analysis>
   - Related files to check: <your suggestions>

   ## Next Steps
   - Investigate root cause (not just symptom)
   - Add regression test to prevent recurrence
   - Ensure minimal, surgical fix

   Respond with JSON: {"title": "...", "body": "..."}`
     } else {
       return `You are creating a GitHub issue for a feature request. Based on the user's feedback, generate:
   1. A clear, concise title (max 80 characters)
   2. A comprehensive issue body following this format:

   ## Feature Description
   <summarize what the user wants>

   ## User Stories
   ### Primary User Story
   **As a** user
   **I want to** <action from description>
   **So that** <benefit from user's answer>

   ## Requirements
   ### Functional Requirements
   - [ ] <specific capability>
   - [ ] <data handling>
   - [ ] <workflow>

   ### Non-Functional Requirements
   - [ ] Performance: <if applicable>
   - [ ] Privacy: <if applicable>
   - [ ] Reliability: <error handling>

   ## Technical Context
   ### Affected Areas
   - **Database**: <your analysis>
   - **Backend**: <your analysis>
   - **Frontend**: <your analysis>

   ## Acceptance Criteria
   - [ ] Feature works as described
   - [ ] No TypeScript errors
   - [ ] All tests passing

   ## Notes
   - Estimated complexity: <Small/Medium/Large>
   - Priority based on user input: <High/Medium/Low>

   Respond with JSON: {"title": "...", "body": "..."}`
     }
   }
   ```

6. Add Claude Code executor:
   ```typescript
   function executeClaudeCode(
     claudePath: string,
     userContext: string,
     systemPrompt: string
   ): Promise<string> {
     return new Promise((resolve, reject) => {
       const args = [
         '-p',
         '--output-format', 'json',
         '--system-prompt', systemPrompt,
         userContext
       ]

       const child = spawn(claudePath, args, {
         timeout: CLAUDE_CODE_TIMEOUT_MS,
         stdio: ['pipe', 'pipe', 'pipe']
       })

       let stdout = ''
       let stderr = ''

       child.stdout.on('data', (data) => {
         stdout += data.toString()
         if (stdout.length > MAX_OUTPUT_SIZE) {
           child.kill()
           reject(new Error('Output size limit exceeded'))
         }
       })

       child.stderr.on('data', (data) => {
         stderr += data.toString()
       })

       child.on('error', (error) => {
         reject(error)
       })

       child.on('close', (code) => {
         if (code !== 0) {
           reject(new Error(`Claude Code exited with code ${code}: ${stderr}`))
         } else {
           resolve(stdout)
         }
       })

       // Set timeout
       setTimeout(() => {
         child.kill()
         reject(new Error('Claude Code execution timed out'))
       }, CLAUDE_CODE_TIMEOUT_MS)
     })
   }
   ```

7. Add output parser:
   ```typescript
   function parseClaudeCodeOutput(
     output: string,
     type: 'bug' | 'feature',
     originalDescription: string
   ): EnhanceIssueResult {
     try {
       // Parse JSON output from Claude Code
       const parsed = JSON.parse(output)

       if (parsed.result && typeof parsed.result === 'object') {
         // Handle nested result structure
         const result = parsed.result
         if (result.title && result.body) {
           return {
             success: true,
             title: result.title,
             body: result.body
           }
         }
       }

       // Try parsing the text content
       if (parsed.content && Array.isArray(parsed.content)) {
         const textBlock = parsed.content.find((b: {type: string}) => b.type === 'text')
         if (textBlock?.text) {
           const innerParsed = JSON.parse(textBlock.text)
           if (innerParsed.title && innerParsed.body) {
             return {
               success: true,
               title: innerParsed.title,
               body: innerParsed.body
             }
           }
         }
       }

       throw new Error('Could not parse Claude Code output')
     } catch (parseError) {
       console.error('Failed to parse Claude Code output:', parseError)
       // Return fallback
       return {
         success: false,
         title: originalDescription.length > 80
           ? originalDescription.substring(0, 77) + '...'
           : originalDescription,
         body: type === 'bug'
           ? formatFallbackBugBody(originalDescription, [])
           : formatFallbackFeatureBody(originalDescription, []),
         error: 'Failed to parse Claude Code output'
       }
     }
   }
   ```

8. Add fallback formatters (copy existing logic from route.ts):
   ```typescript
   function formatFallbackBugBody(description: string, answers: string[]): string {
     return `## Reported Issue
   **What's broken**: ${description}
   **Expected behavior**: ${answers[1] || 'Not specified'}
   **Severity**: Medium

   ## Error Details
   **Error Type**: User-reported bug
   **Error Message**: See description above
   **Location**: User feedback submission
   **URL/Route**: N/A

   ## Clarifying Questions & Answers
   **Q1**: What steps can we follow to reproduce this issue?
   **A1**: ${answers[0] || 'Not provided'}

   **Q2**: What did you expect to happen instead?
   **A2**: ${answers[1] || 'Not provided'}

   **Q3**: When did you first notice this problem?
   **A3**: ${answers[2] || 'Not provided'}

   ## Next Steps
   - Investigate root cause (not just symptom)
   - Add regression test to prevent recurrence
   - Ensure minimal, surgical fix`
   }

   function formatFallbackFeatureBody(description: string, answers: string[]): string {
     return `## Feature Description
   ${description}

   ## User Stories
   ### Primary User Story
   **As a** user
   **I want to** ${description.toLowerCase()}
   **So that** ${answers[0] || 'it improves my workflow'}

   ## Clarifying Questions & Answers
   **Q1**: What problem would this feature solve for you?
   **A1**: ${answers[0] || 'Not provided'}

   **Q2**: How would you ideally use this feature?
   **A2**: ${answers[1] || 'Not provided'}

   **Q3**: How important is this feature to your workflow?
   **A3**: ${answers[2] || 'Not provided'}

   ## Acceptance Criteria
   - [ ] Feature works as described
   - [ ] No TypeScript errors
   - [ ] All tests passing
   - [ ] Build completes successfully`
   }
   ```

**Validation**:
```bash
npx tsc --noEmit
npm run lint
```
**Completion Criteria**:
- [ ] `enhanceIssueWithClaudeCode()` function added
- [ ] Helper functions added (buildUserContext, buildSystemPrompt, executeClaudeCode, parseClaudeCodeOutput)
- [ ] Fallback formatters added
- [ ] TypeScript compiles without errors
- [ ] Lint passes

---

## Phase 3: API Route Integration

### Subtask 3.1: Update Feedback API Route to Use Claude Code Enhancement
**File**: `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts`
**Pattern**: Follow existing error handling and response patterns
**Instructions**:
1. Import the new function at top:
   ```typescript
   import { enhanceIssueWithClaudeCode } from '@/lib/claude'
   ```

2. Replace the existing issue creation logic in the POST handler (around line 165-176):
   ```typescript
   // OLD CODE (to replace):
   // const issueBody = type === 'bug'
   //   ? formatBugBody(description, answers)
   //   : formatFeatureBody(description, answers)
   // const title = description.length > 80
   //   ? description.substring(0, 77) + '...'
   //   : description

   // NEW CODE:
   // Use Claude Code to enhance the issue
   const enhanced = await enhanceIssueWithClaudeCode({
     type,
     description,
     answers,
   })

   const title = enhanced.title
   const issueBody = enhanced.body

   // Log if enhancement failed (but still create issue with fallback)
   if (!enhanced.success) {
     console.warn('Issue enhancement failed, using fallback:', enhanced.error)
   }
   ```

3. Remove the `formatBugBody` and `formatFeatureBody` functions from this file (they are now in claude.ts as fallbacks)

**Validation**:
```bash
npx tsc --noEmit
npm run build
```
**Completion Criteria**:
- [ ] Import added for `enhanceIssueWithClaudeCode`
- [ ] POST handler updated to use enhancement
- [ ] Old format functions removed
- [ ] TypeScript compiles
- [ ] Build succeeds

---

## Phase 4: Testing

### Subtask 4.1: Add Unit Tests for Claude Code Enhancement
**File**: `/home/pbrown/SkuInventory/tests/unit/claude-enhancement.test.ts` (new file)
**Pattern**: Follow `/home/pbrown/SkuInventory/tests/unit/claude-client.test.ts`
**Instructions**:
1. Create new test file with tests for:
   - `buildUserContext()` - verify correct formatting
   - `buildSystemPrompt()` - verify bug vs feature prompts
   - `parseClaudeCodeOutput()` - verify JSON parsing
   - Fallback behavior when Claude Code fails

2. Mock the `spawn` function to avoid actual CLI execution in tests:
   ```typescript
   import { describe, it, expect, vi, beforeEach } from 'vitest'
   import * as childProcess from 'child_process'

   vi.mock('child_process', () => ({
     spawn: vi.fn()
   }))
   ```

3. Test cases:
   - Happy path: Claude Code returns valid JSON
   - Error handling: Claude Code times out
   - Error handling: Claude Code returns invalid JSON
   - Fallback: Returns formatted body when enhancement fails

**Validation**:
```bash
npm test -- --filter="claude-enhancement"
```
**Completion Criteria**:
- [ ] Test file created
- [ ] All test cases implemented
- [ ] Tests pass

### Subtask 4.2: Update Existing Feedback Tests
**File**: `/home/pbrown/SkuInventory/tests/unit/FeedbackDialog.test.tsx`
**Instructions**:
1. Verify existing tests still pass (they mock fetch, so should be unaffected)
2. Add any necessary mocks if tests fail due to new import

**Validation**:
```bash
npm test -- --filter="FeedbackDialog"
```
**Completion Criteria**:
- [ ] Existing tests still pass
- [ ] No regressions introduced

---

## Phase 5: Documentation and Cleanup

### Subtask 5.1: Update API Documentation Comments
**File**: `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts`
**Instructions**:
1. Update the route comment to document the new behavior:
   ```typescript
   /**
    * POST /api/feedback - Submit feedback and create GitHub issue
    *
    * Uses Claude Code headless mode to enhance user feedback into a
    * comprehensive GitHub issue. Falls back to simple formatting if
    * Claude Code is unavailable or fails.
    *
    * Rate limited to 5 requests per hour per user.
    */
   ```
**Completion Criteria**:
- [ ] Route documentation updated

### Subtask 5.2: Final Build and Lint Verification
**Instructions**:
```bash
npx tsc --noEmit
npm run build
npm run lint
npm test
```
**Completion Criteria**:
- [ ] TypeScript compiles without errors
- [ ] Build succeeds
- [ ] Lint passes
- [ ] All tests pass

---

## Summary of Deliverables

**Files Created**: 1
- `/home/pbrown/SkuInventory/tests/unit/claude-enhancement.test.ts`

**Files Modified**: 5
- `/home/pbrown/SkuInventory/src/lib/env.ts` - Add CLAUDE_CODE_PATH
- `/home/pbrown/SkuInventory/.env.example` - Document CLAUDE_CODE_PATH
- `/home/pbrown/SkuInventory/src/types/feedback.ts` - Add new types
- `/home/pbrown/SkuInventory/src/lib/claude.ts` - Add enhancement function
- `/home/pbrown/SkuInventory/src/app/api/feedback/route.ts` - Use enhancement

## Handoff to Build Agent

1. Execute subtasks in exact order (Phase 0 -> Phase 1 -> Phase 2 -> Phase 3 -> Phase 4 -> Phase 5)
2. Complete Phase 0 fully before Phase 1 to verify Claude CLI is available
3. Test completion criteria before next subtask
4. Follow reference patterns exactly - especially claude.ts for new functions
5. Run validation commands after each subtask

## Test Strategy Note
- Use Vitest for unit tests
- Mock child_process.spawn to avoid actual CLI execution in tests
- Integration testing can be done manually with the dev server

## Security Considerations
1. **Input Sanitization**: User input is passed as prompt content, not CLI arguments
2. **Timeout**: 60 second timeout prevents hanging processes
3. **Output Size**: 100KB limit prevents memory exhaustion
4. **No Shell**: Using spawn() without shell: true prevents injection
5. **Graceful Fallback**: If Claude Code fails, issue is still created with basic formatting

## Performance Metrics
| Phase | Duration |
|-------|----------|
| Investigation | 25m |
| Validation | 10m |
| Planning | 15m |
| **Total** | **50m** |
